<?php
/**
 * Class for reading data from star archives via stream wrapper.
 *
 * @package  star
 * @version  $Id$
 */
/**
 * Class for reading data from star archives via stream wrapper.
 *
 * This class contains code from lang.base.php of the XP-framework,
 * written by Timm Friebe and Alex Kiesel.
 *
 * @package  star
 * @see      http://php.net/stream_wrapper_register
 */
class StarStreamWrapper
{
    /**
     * switch whether class has already been registered as stream wrapper or not
     *
     * @var  bool
     */
    private static $registered = false;
    /**
     * current position in star archive
     *
     * @var  int
     */
    protected $position;
    /**
     * current star archive data
     *
     * @var  array
     */
    protected $archive;
    /**
     * id of the file entry to retrieve
     *
     * @var  string
     */
    protected $id;

    /**
     * registers the class as stream wrapper for the star protocol
     * 
     * @throws  StarException
     */
    public static function register()
    {
        if (true == self::$registered) {
            return;
        }
        
        if (stream_wrapper_register('star', __CLASS__) == false) {
            throw new StarException('A handler has already been registered for the star protocol.');
        }
        
        self::$registered = true;
    }

    /**
     * returns index of requested archive
     *
     * @param   string  $archive  archive to retrieve index for
     * @return  array
     */
    public static function acquire($archive)
    {
        static $archives = array();
        $archive = str_replace('\\', '/', $archive);
        if (isset($archives[$archive]) == true) {
            return $archives[$archive];
        }
        
        $archives[$archive] = array();
        if (file_exists($archive) == false) {
            return array();
        }
            
        $current           =& $archives[$archive];
        $current['handle'] = fopen($archive, 'rb');
        if (str_replace('\\', '/', __FILE__) == $archive && defined('__COMPILER_HALT_OFFSET__') == true) {
            fseek($current['handle'], __COMPILER_HALT_OFFSET__);
        } else {
            fseek($current['handle'], 0);
        }
        
        $header = unpack('a4id/c1version/a8indexsize/a14buildtime/a*reserved', fread($current['handle'], 0x0100));
        if (false === $header) {
            // invalid star file
            return array();
        }
        
        $current['index']  = array();
        $current['header'] = $header;
        if (str_replace('\\', '/', __FILE__) == $archive && defined('__COMPILER_HALT_OFFSET__') == true) {
            $current['header']['totalSize'] = __COMPILER_HALT_OFFSET__ + 0x0100;
        } else {
            $current['header']['totalSize'] = 0x0100;
        }
        
        if (1 === $header['version']) {
            $key = 'a80id/a72filename/a80path/a8size/a8offset/a*reserved';
        } else {
            $key = 'a232id/a8size/a8offset/a*reserved';
        }

        for ($i = 0; $i < $header['indexsize']; $i++) {
            $entry  = unpack($key, fread($current['handle'], 0x0100));
            $current['index'][$entry['id']]  = array('size' => (int) $entry['size'], 'offset' => (int) $entry['offset']);
            $current['header']['totalSize'] += 0x0100 + ((int) $entry['size']);
        }
        
        return $archives[$archive];
    }

    /**
     * returns the metadata of an archive
     *
     * @param   string  $archive  archive to retrieve metadata for
     * @return  array
     */
    public static function getMetaData($archive)
    {
        $current  = self::acquire($archive);
        if (isset($current['index']) == false) {
            throw new StarException('Star file ' . $archive . ' does not exist or is not a valid star file.');
        }
        
        $metaData = array();
        fseek($current['handle'], $current['header']['totalSize']);
        while (feof($current['handle']) == false) {
            $line = trim(fgets($current['handle'], 4096));
            if (empty($line) == true) {
                continue;
            }
            
            $lineData = explode(' => ', $line);
            $metaData[$lineData[0]] = $lineData[1];
        }
        
        return $metaData;
    }

    /**
     * open the stream
     *
     * @param   string  $path         the path to open
     * @param   string  $mode         mode for opening
     * @param   string  $options      options for opening
     * @param   string  $opened_path  full path that was actually opened
     * @return  bool
     */
    public function stream_open($path, $mode, $options, $opened_path)
    {
        $this->parsePath($path);
        $current = self::acquire($this->archive);
        if (isset($current['index'][$this->id]) == false) {
            $this->parsePath(urldecode($path));
            $current = self::acquire($this->archive);
            if (isset($current['index'][$this->id]) == false) {
                return false;
            }
        }
        
        return true;
    }

    /**
     * read the stream up to $count bytes
     *
     * @param   int     $count  amount of bytes to read
     * @return  string
     */
    public function stream_read($count)
    {
        $current = self::acquire($this->archive);
        if (isset($current['index'][$this->id]) == false) {
            return false;
        }
        
        if ($current['index'][$this->id]['size'] == $this->position || 0 == $count) {
            return false;
        }

        fseek($current['handle'], 0x0100 + sizeof($current['index']) * 0x0100 + $current['index'][$this->id]['offset'] + $this->position, SEEK_SET);
        $bytes = fread($current['handle'], min($current['index'][$this->id]['size'] - $this->position, $count));
        $this->position += strlen($bytes);
        return $bytes;
    }

    /**
     * checks whether stream is at end of file
     *
     * @return  bool
     */
    public function stream_eof()
    {
        $current= self::acquire($this->archive);
        return $this->position >= $current['index'][$this->id]['size'];
    }

    /**
     * returns status of stream
     *
     * @return  array
     */
    public function stream_stat()
    {
        $current  = self::acquire($this->archive);
        $fileStat = array('dev'     => 0,
                          'ino'     => 0,
                          'mode'    => 010000 | 0777,
                          'nlink'   => 0,
                          'uid'     => 0,
                          'gid'     => 0,
                          'rdev'    => 0,
                          'size'    => $current['index'][$this->id]['size'],
                          'atime'   => time(),
                          'mtime'   => time(),
                          'ctime'   => time(),
                          'blksize' => -1,
                          'blocks'  => -1
                    );

        return array_merge(array_values($fileStat), $fileStat);
    }

    /**
     * returns status of url
     *
     * @param   string      $path  path of url to return status for
     * @return  array|bool  false if $path does not exist, else 
     */
    public function url_stat($path)
    {
        $this->parsePath($path);
        $current = self::acquire($this->archive);

        if (isset($current['index'][$this->id]) == false) {
            $this->parsePath(urldecode($path));
            $current = self::acquire($this->archive);
            if (isset($current['index'][$this->id]) == false) {
                return false;
            }
        }
        
        $fileStat = array('dev'     => 0,
                          'ino'     => 0,
                          'mode'    => 010000 | 0777,
                          'nlink'   => 0,
                          'uid'     => 0,
                          'gid'     => 0,
                          'rdev'    => 0,
                          'size'    => $current['index'][$this->id]['size'],
                          'atime'   => time(),
                          'mtime'   => time(),
                          'ctime'   => time(),
                          'blksize' => -1,
                          'blocks'  => -1
                    );

        return array_merge(array_values($fileStat), $fileStat);
    }

    /**
     * parses the path into class members
     *
     * @param  string  $path
     */
    protected function parsePath($path)
    {
        list($archive, $id) = sscanf($path, 'star://%[^?]?%[^$]');
        $this->archive      = $archive;
        $this->id           = $id;
    }
}
?><?php
/**
 * Exception to be thrown in case something wents wrong with handlign star files.
 *
 * @package  star
 * @version  $Id$
 */
/**
 * Exception to be thrown in case something wents wrong with handlign star files.
 *
 * @package  star
 */
if (class_exists('StarException') === false) {
    class StarException extends Exception
    {
        // intentionally left empty
    }
}
?><?php
/**
 * Class registry for mapping of classes to star files.
 *
 * @package  star
 * @version  $Id$
 */
/**
 * Class registry for mapping of classes to star files.
 *
 * @package  star
 */
if (class_exists('StarClassRegistry') === false) {
    class StarClassRegistry
    {
        /**
         * switch whether init has been done or not
         *
         * @var  bool
         */
        protected static $initDone  = false;
        /**
         * path to star files
         *
         * @var  string
         */
        protected static $libPathes = array();
        /**
         * list of classes and the file where they are in
         *
         * @var  array<string,string>
         */
        protected static $classes   = array();
        /**
         * list of files and the classes they contain
         *
         * @var  array<string,array<string>>
         */
        protected static $files     = array();
    
        /**
         * set the path to the star files
         *
         * @param  string  $libPath    path to lib files
         * @param  bool    $recursive  optional  recurse into sub directories of lib path
         */
        public static function addLibPath($libPath, $recursive = true)
        {
            self::$libPathes[$libPath] = $recursive;
            self::$initDone            = false;
        }
    
        /**
         * returns the file where the given classes is stored in
         *
         * @param   string  $fqClassName  the full qualified class name
         * @return  string
         */
        public static function getFileForClass($fqClassName)
        {
            if (false === self::$initDone) {
                self::init();
            }
            
            if (isset(self::$classes[$fqClassName]) === true) {
                return self::$classes[$fqClassName];
            }
    
            return null;
        }
    
        /**
         * returns the uri for the given class
         *
         * @param   string  $fqClassName  the full qualified class name
         * @return  string
         */
        public static function getUriForClass($fqClassName)
        {
            if (false === self::$initDone) {
                self::init();
            }
            
            if (isset(self::$classes[$fqClassName]) === true) {
                return 'star://' . self::$classes[$fqClassName] . '?' . $fqClassName;
            }
    
            return null;
        }
    
        /**
         * returns all uris for a given resource
         *
         * @param   string  $fileName  file name of resource
         * @return  array
         */
        public static function getUrisForResource($resource)
        {
            if (false === self::$initDone) {
                self::init();
            }
            
            $uris = array();
            foreach (self::$files as $file => $contents) {
                foreach ($contents as $content) {
                    if ($content === $resource) {
                        $uris[] = 'star://' . $file . '?' . $resource;
                        continue 2;
                    }
                }
            }
    
            return $uris;
        }
    
        /**
         * returns a list of all classes within given file
         *
         * @param   string  $file  name of file
         * @return  array
         */
        public static function getClassNamesFromFile($file)
        {
            if (false === self::$initDone) {
                self::init();
            }
            
            if (isset(self::$files[$file]) === true) {
                return self::$files[$file];
            }
    
            return array();
        }
    
        /**
         * returns a list of all classes
         *
         * @return  string
         */
        public static function getClasses()
        {
            return array_keys(self::$classes);
        }
    
        /**
         * initialize the class registry
         */
        protected static function init()
        {
            if (true === self::$initDone) {
                return;
            }
    
            if (count(self::$libPathes) == 0) {
                self::$libPathes[dirname(__FILE__)] = true;
            }
    
            foreach (self::$libPathes as $libPath => $recursive) {
                if (file_exists($libPath . '/.cache') === true) {
                    $cache = unserialize(file_get_contents($libPath . '/.cache'));
                    self::$files    = array_merge(self::$files, $cache['files']);
                    self::$classes  = array_merge(self::$classes, $cache['classes']);
                    self::$initDone = true;
                    continue;
                }
    
                if (true === $recursive) {
                    $dirIt = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($libPath));
                } else {
                    $dirIt = new DirectoryIterator($libPath);
                }
    
                $cache['files']   = array();
                $cache['classes'] = array();
                foreach ($dirIt as $file) {
                    if ($file->isFile() === false || substr($file->getPathname(), -14) === 'starReader.php' || (substr($file->getPathname(), -5) !== '.star' && substr($file->getPathname(), -4) !== '.php')) {
                        continue;
                    }
    
                    $archiveData = StarStreamWrapper::acquire($file->getPathname());
                    if (empty($archiveData) == true) {
                        continue;
                    }
    
                    $classes = array_keys($archiveData['index']);
                    self::$files[$file->getPathname()]    = $classes;
                    $cache['files'][$file->getPathname()] = $classes;
    
                    foreach (array_keys($archiveData['index']) as $fqClassName) {
                        self::$classes[$fqClassName]    = $file->getPathname();
                        $cache['classes'][$fqClassName] = $file->getPathname();
                    }
                }
    
                $cacheFile = $libPath . '/.cache';
                if (is_writable($libPath) === false && is_writable($cacheFile) === false) {
                    throw new StarException("Unable to write starRegistry cache file to {$cacheFile}.");
                }
                
                file_put_contents($cacheFile, serialize($cache));
                self::$initDone = true;
            }
        }
    }
}
?><?php StarStreamWrapper::register(); ?><?php
/**
 * Class loader for all stubbles classes.
 *
 * @package  stubbles
 * @version  $Id: stubClassLoader.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Interface for class loaders that load classes from foreign namespaces.
 *
 * This interface must reside here because the stubClassLoader uses it as type hint.
 *
 * @package  stubbles
 */
interface stubForeignClassLoader
{
    /**
     * sets the namespace where this classloader is responsible for
     *
     * @param  string  $namespace
     */
    public function setNamespace($namespace);

    /**
     * returns the namespace where this classloader is responsible for
     *
     * @return  string
     */
    public function getNamespace();

    /**
     * loads the given class
     *
     * @param   string  $fqClassName  the full qualified class name of the class to load
     * @throws  stubClassNotFoundException
     */
    public function load($fqClassName);
}
/**
 * Exception thrown if the class loader can not find the desired class.
 *
 * This exception must reside here because the stubClassLoader uses it when a class can not be loaded.
 *
 * @package  stubbles
 */
class stubClassNotFoundException extends Exception
{
    /**
     * full qualified class name of the class that was not found
     *
     * @var  string
     */
    protected $fqClassName;

    /**
     * constructor
     *
     * @param  string  $fqClassName         full qualified class name of the class that was not found
     * @param  bool    $foreignClassLoader  optional  true if thrown in stubForeignClassLoader instance
     */
    public function __construct($fqClassName, $foreignClassLoader = false)
    {
        $this->fqClassName = $fqClassName;
        $caller  = debug_backtrace();
        $file   = ((false == $foreignClassLoader) ? ($caller[1]['file']) : ($caller[2]['file']));
        $line   = ((false == $foreignClassLoader) ? ($caller[1]['line']) : ($caller[2]['line']));
        $message = 'The class ' . $this->fqClassName . ' loaded in ' . $file . ' on line ' . $line . ' was not found.';
        parent::__construct($message);
    }

    /**
     * returns the full qualified class name of the class that was not found
     *
     * @return  string
     */
    public function getNotFoundClassName()
    {
        return $this->fqClassName;
    }

    /**
     * returns a string representation of the class
     *
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * <code>
     * net::stubbles::stubClassNotFoundException {
     *     message(string): The class example::Foo loaded in bar.php on line 6 was not found.
     *     classname(string): example::Foo
     *     file(string): stubClassLoader.php
     *     line(integer): 179
     *     code(integer): 0
     * }
     * </code>
     *
     * @return  string
     */
    public function __toString()
    {
        $string  = "net::stubbles::stubClassNotFoundException {\n";
        $string .= '    message(string): ' . $this->getMessage() . "\n";
        $string .= '    classname(string): ' . $this->fqClassName . "\n";
        $string .= '    file(string): ' . $this->getFile() . "\n";
        $string .= '    line(integer): ' . $this->getLine() . "\n";
        $string .= '    code(integer): ' . $this->getCode() . "\n";
        $string .= "}\n";
        return $string;
    }
}
/**
 * Class loader for all stubbles classes.
 *
 * The class loader takes care that all class files are only loaded once. It
 * allows all classes to include the required files without knowing where they
 * reside or if they have been loaded before.
 *
 * @static
 * @package  stubbles
 */
class stubClassLoader
{
    /**
     * contains a mapping of non qualified class names to their full qualified names
     *
     * @var  array<string,string>
     */
    private static $classNames          = array('net::stubbles::stubClassLoader'            => 'stubClassLoader',
                                                'net::stubbles::stubClassNotFoundException' => 'stubClassNotFoundException',
                                                'net::stubbles::stubForeignClassLoader'     => 'stubForeignClassLoader'
                                          );
    /**
     * list of foreign class loaders
     *
     * @var  array<stubForeignClassLoader>
     */
    private static $foreignClassLoaders = array();
    /**
     * switch whether to use star files or not
     *
     * @var  bool
     */
    private static $useStar             = null;
    /**
     * path to source files
     *
     * @var  string
     */
    private static $sourcePath          = null;

    /**
     * does some initializing
     */
    private static function init()
    {
        self::$useStar    = class_exists('StarClassRegistry', false);
        self::$sourcePath = stubBootstrap::getSourcePath() . DIRECTORY_SEPARATOR . 'php' . DIRECTORY_SEPARATOR;
    }

    /**
     * method to load files from source path
     *
     * Usage: stubblesClassLoader::load('path::to::Classfile');
     * or load more than one at once:
     * stubblesClassLoader::load('path::to::first::Class',
     *                           'path::to::second.Class'
     * );
     * You may name as many files as you like, there is no restriction
     * on the number of arguments.
     *
     * @throws  stubClassNotFoundException
     */
    public static function load()
    {
        $classNames = func_get_args();
        if (count($classNames) === 0) {
            // its ok to call this without any arguments, this won't cause any harm
            return;
        }

        if (null === self::$useStar) {
            self::init();
        }

        foreach ($classNames as $fqClassName) {
            $nqClassName = self::getNonQualifiedClassName($fqClassName);
            if (isset(self::$classNames[$nqClassName]) === true) {
                continue;
            }

            self::$classNames[$nqClassName] = $fqClassName;
            $foreignNamespace = self::getForeignNamespace($fqClassName);
            if (null !== $foreignNamespace) {
                self::$foreignClassLoaders[$foreignNamespace][0]->load($fqClassName);
                return;
            }

            $uri = null;
            if (true === self::$useStar) {
                $uri = StarClassRegistry::getUriForClass($fqClassName);
            }
            if (null === $uri) {
                $uri = self::$sourcePath .  str_replace('::', DIRECTORY_SEPARATOR, $fqClassName) . '.php';
            }

            if ((include_once $uri) === false) {
                throw new stubClassNotFoundException($fqClassName);
            }

            if (method_exists($nqClassName, '__static') === true) {
                call_user_func(array($nqClassName, '__static'));
            }
        }
    }

    /**
     * returns a list of all available classnames within a package
     *
     * @param   string         $packageName  name of the package to retrieve class names for
     * @param   bool           $recursive    optional  true if classes of subpackages should be included
     * @return  array<string>
     */
    public static function getClassNames($packageName, $recursive = false)
    {
        if (null == self::$useStar) {
            self::init();
        }

        $dirName = self::$sourcePath . str_replace('::', DIRECTORY_SEPARATOR, $packageName);
        if (file_exists($dirName) == false) {
            return array();
        }

        if (false === $recursive) {
            $dirIt = new DirectoryIterator($dirName);
        } else {
            $dirIt = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dirName));
        }

        $classes = array();
        foreach ($dirIt as $file) {
            if ($file->isDir() == true || substr($file->getFilename(), -4) != '.php') {
                continue;
            }

            $classes[] = str_replace(DIRECTORY_SEPARATOR, '::', str_replace('.php', '', str_replace(self::$sourcePath, '', $file->getPathname())));
        }

        if (true === self::$useStar) {
            $starClasses = StarClassRegistry::getClasses();
            foreach ($starClasses as $fqClassName) {
                if (substr($fqClassName, 0, strlen($packageName)) !== $packageName) {
                    continue;
                }

                $nqClassName = self::getNonQualifiedClassName($fqClassName);
                if (str_replace($nqClassName, '', $fqClassName) != $packageName && false === $recursive) {
                    continue;
                }

                $classes[] = $fqClassName;
            }
        }

        sort($classes);
        return $classes;
    }

    /**
     * returns the non qualified class name from a full qualified class name
     *
     * @param   string  $fqClassName
     * @return  string
     */
    public static function getNonQualifiedClassName($fqClassName)
    {
        $classNameParts = explode('::', $fqClassName);
        return $classNameParts[count($classNameParts) - 1];
    }

    /**
     * returns the full qualified class name of a non qualified class name
     *
     * @param   string  $nqClassName
     * @return  string
     */
    public static function getFullQualifiedClassName($nqClassName)
    {
        if (isset(self::$classNames[$nqClassName]) == true) {
            return self::$classNames[$nqClassName];
        }

        return null;
    }

    /**
     * returns the package name of a class
     *
     * @param   string  $fqClassName
     * @return  string
     */
    public static function getPackageName($fqClassName)
    {
        $classNameParts = explode('::', $fqClassName);
        unset($classNameParts[count($classNameParts) - 1]);
        return join('::', $classNameParts);
    }

    /**
     * registers a foreign class loader
     *
     * @param  stubForeignClassLoader  $foreignClassLoader
     */
    public static function registerForeignClassLoader(stubForeignClassLoader $foreignClassLoader)
    {
        self::$foreignClassLoaders[$foreignClassLoader->getNamespace()] = array($foreignClassLoader, strlen($foreignClassLoader->getNamespace()));
    }

    /**
     * checks whether a class resides in a foreign namespace
     *
     * @param   string  $fqClassName  the class to check if it is in a foreign namespace
     * @return  string  the foreign namespace, null if class is not in any one
     */
    private static function getForeignNamespace($fqClassName)
    {
        foreach (self::$foreignClassLoaders as $foreignNamespace => $foreignClassLoader) {
            if (strncmp($fqClassName, $foreignNamespace, $foreignClassLoader[1]) === 0) {
                return $foreignNamespace;
            }
        }

        return null;
    }
}
/**
 * set internal, input and output encoding
 */
iconv_set_encoding('internal_encoding', 'UTF-8');
if (($ctype = getenv('LC_CTYPE')) || ($ctype = setlocale(LC_CTYPE, 0))) {
    sscanf($ctype, '%[^.].%s', $language, $charset);
    if (is_numeric($charset) === true) {
        $charset = 'CP' . $charset;
    } elseif (null == $charset) {
        $charset = 'iso-8859-1';
    }
    
    iconv_set_encoding('output_encoding', $charset);
    iconv_set_encoding('input_encoding', $charset);
}
/**
 * make the stubObject class available so there is no need to include it in
 * every other class that should extend it
 */
stubClassLoader::load('net::stubbles::lang::stubObject',
                      'net::stubbles::lang::stubBaseObject',
                      'net::stubbles::lang::exceptions::stubThrowable',
                      'net::stubbles::lang::exceptions::stubException',
                      'net::stubbles::lang::exceptions::stubRuntimeException',
                      'net::stubbles::lang::serialize::stubSerializable',
                      'net::stubbles::lang::serialize::stubSerializableObject',
                      'net::stubbles::lang::serialize::stubSerializedObject'
);
?><?php __halt_compiler();star497     20110112130156                                                                                                                                                                                                                                     net::stubbles::console::ioc::stubConsoleBindingModule                                                                                                                                                                                   1264    27545           net::stubbles::console::stubCommandInputStream                                                                                                                                                                                          2741    28809           net::stubbles::console::stubConsoleCommand                                                                                                                                                                                              423     31550           net::stubbles::console::stubConsoleCommandRunner                                                                                                                                                                                        1818    31973           net::stubbles::console::stubConsoleExecutor                                                                                                                                                                                             3805    33791           net::stubbles::console::stubConsoleInputStream                                                                                                                                                                                          1259    37596           net::stubbles::console::stubConsoleOutputStream                                                                                                                                                                                         2486    38855           net::stubbles::console::stubExecutor                                                                                                                                                                                                    1501    41341           net::stubbles::ioc::annotations::stubImplementedByAnnotation                                                                                                                                                                            1347    42842           net::stubbles::ioc::annotations::stubInjectAnnotation                                                                                                                                                                                   1201    44189           net::stubbles::ioc::annotations::stubNamedAnnotation                                                                                                                                                                                    1065    45390           net::stubbles::ioc::annotations::stubProvidedByAnnotation                                                                                                                                                                               1442    46455           net::stubbles::ioc::annotations::stubSingletonAnnotation                                                                                                                                                                                670     47897           net::stubbles::ioc::module::stubArgumentsBindingModule                                                                                                                                                                                  1003    48567           net::stubbles::ioc::module::stubBindingModule                                                                                                                                                                                           562     49570           net::stubbles::ioc::module::stubModeBindingModule                                                                                                                                                                                       1528    50132           net::stubbles::ioc::module::stubPropertiesBindingModule                                                                                                                                                                                 6209    51660           net::stubbles::ioc::stubApp                                                                                                                                                                                                             5260    57869           net::stubbles::ioc::stubBinder                                                                                                                                                                                                          2326    63129           net::stubbles::ioc::stubBinderRegistry                                                                                                                                                                                                  2501    65455           net::stubbles::ioc::stubBinding                                                                                                                                                                                                         810     67956           net::stubbles::ioc::stubBindingException                                                                                                                                                                                                412     68766           net::stubbles::ioc::stubBindingScope                                                                                                                                                                                                    889     69178           net::stubbles::ioc::stubBindingScopes                                                                                                                                                                                                   2903    70067           net::stubbles::ioc::stubBindingScopeSession                                                                                                                                                                                             2413    72970           net::stubbles::ioc::stubBindingScopeSingleton                                                                                                                                                                                           1182    75383           net::stubbles::ioc::stubClassBinding                                                                                                                                                                                                    7647    76565           net::stubbles::ioc::stubConstantBinding                                                                                                                                                                                                 1629    84212           net::stubbles::ioc::stubDefaultInjectionProvider                                                                                                                                                                                        1724    85841           net::stubbles::ioc::stubInjectionProvider                                                                                                                                                                                               571     87565           net::stubbles::ioc::stubInjector                                                                                                                                                                                                        11641   88136           net::stubbles::ioc::stubValueInjectionProvider                                                                                                                                                                                          949     99777           net::stubbles::ipo::interceptors::stubETagPostInterceptor                                                                                                                                                                               1868    100726          net::stubbles::ipo::interceptors::stubInterceptorInitializer                                                                                                                                                                            1163    102594          net::stubbles::ipo::interceptors::stubPostInterceptor                                                                                                                                                                                   1041    103757          net::stubbles::ipo::interceptors::stubPreInterceptor                                                                                                                                                                                    1009    104798          net::stubbles::ipo::interceptors::stubPropertyBasedInterceptorInitializer                                                                                                                                                               3516    105807          net::stubbles::ipo::interceptors::stubRequestPreInterceptor                                                                                                                                                                             2728    109323          net::stubbles::ipo::ioc::stubIpoBindingModule                                                                                                                                                                                           7566    112051          net::stubbles::ipo::request::broker::annotations::stubAbstractFilterAnnotation                                                                                                                                                          4857    119617          net::stubbles::ipo::request::broker::annotations::stubAbstractStringFilterAnnotation                                                                                                                                                    4719    124474          net::stubbles::ipo::request::broker::annotations::stubBoolFilterAnnotation                                                                                                                                                              915     129193          net::stubbles::ipo::request::broker::annotations::stubDateFilterAnnotation                                                                                                                                                              6152    130108          net::stubbles::ipo::request::broker::annotations::stubFilterAnnotation                                                                                                                                                                  923     136260          net::stubbles::ipo::request::broker::annotations::stubFloatFilterAnnotation                                                                                                                                                             3288    137183          net::stubbles::ipo::request::broker::annotations::stubHTTPURLFilterAnnotation                                                                                                                                                           1372    140471          net::stubbles::ipo::request::broker::annotations::stubIntegerFilterAnnotation                                                                                                                                                           2972    141843          net::stubbles::ipo::request::broker::annotations::stubMailFilterAnnotation                                                                                                                                                              1105    144815          net::stubbles::ipo::request::broker::annotations::stubPasswordFilterAnnotation                                                                                                                                                          2377    145920          net::stubbles::ipo::request::broker::annotations::stubPreselectFilterAnnotation                                                                                                                                                         2757    148297          net::stubbles::ipo::request::broker::annotations::stubStringFilterAnnotation                                                                                                                                                            1946    151054          net::stubbles::ipo::request::broker::annotations::stubTextFilterAnnotation                                                                                                                                                              1326    153000          net::stubbles::ipo::request::broker::stubRequestBroker                                                                                                                                                                                  4727    154326          net::stubbles::ipo::request::broker::stubRequestBrokerException                                                                                                                                                                         477     159053          net::stubbles::ipo::request::broker::stubRequestBrokerMethodPropertyMatcher                                                                                                                                                             2097    159530          net::stubbles::ipo::request::filter::mock::stubMockFilter                                                                                                                                                                               1444    161627          net::stubbles::ipo::request::filter::mock::stubMockFilterFactory                                                                                                                                                                        1139    163071          net::stubbles::ipo::request::filter::stubAbstractFilterDecorator                                                                                                                                                                        2843    164210          net::stubbles::ipo::request::filter::stubBoolFilter                                                                                                                                                                                     988     167053          net::stubbles::ipo::request::filter::stubDateFilter                                                                                                                                                                                     1595    168041          net::stubbles::ipo::request::filter::stubDefaultFilterFactory                                                                                                                                                                           2344    169636          net::stubbles::ipo::request::filter::stubDefaultValueFilterDecorator                                                                                                                                                                    1412    171980          net::stubbles::ipo::request::filter::stubEncodingFilterDecorator                                                                                                                                                                        1979    173392          net::stubbles::ipo::request::filter::stubFilter                                                                                                                                                                                         767     175371          net::stubbles::ipo::request::filter::stubFilterBuilder                                                                                                                                                                                  10576   176138          net::stubbles::ipo::request::filter::stubFilterException                                                                                                                                                                                1092    186714          net::stubbles::ipo::request::filter::stubFilterFactory                                                                                                                                                                                  920     187806          net::stubbles::ipo::request::filter::stubFloatFilter                                                                                                                                                                                    1690    188726          net::stubbles::ipo::request::filter::stubHTTPURLFilter                                                                                                                                                                                  2311    190416          net::stubbles::ipo::request::filter::stubIntegerFilter                                                                                                                                                                                  846     192727          net::stubbles::ipo::request::filter::stubJsonFilter                                                                                                                                                                                     2112    193573          net::stubbles::ipo::request::filter::stubLengthFilterDecorator                                                                                                                                                                          4502    195685          net::stubbles::ipo::request::filter::stubMailFilter                                                                                                                                                                                     3165    200187          net::stubbles::ipo::request::filter::stubPasswordFilter                                                                                                                                                                                 3766    203352          net::stubbles::ipo::request::filter::stubPeriodFilterDecorator                                                                                                                                                                          4599    207118          net::stubbles::ipo::request::filter::stubRangeFilterDecorator                                                                                                                                                                           4488    211717          net::stubbles::ipo::request::filter::stubRegexFilterDecorator                                                                                                                                                                           1626    216205          net::stubbles::ipo::request::filter::stubRequiredFilterDecorator                                                                                                                                                                        2208    217831          net::stubbles::ipo::request::filter::stubStrategyFilterDecorator                                                                                                                                                                        2814    220039          net::stubbles::ipo::request::filter::stubStringFilter                                                                                                                                                                                   998     222853          net::stubbles::ipo::request::filter::stubTextFilter                                                                                                                                                                                     1897    223851          net::stubbles::ipo::request::filter::stubValidatorFilterDecorator                                                                                                                                                                       2449    225748          net::stubbles::ipo::request::stubAbstractRequest                                                                                                                                                                                        11756   228197          net::stubbles::ipo::request::stubDefaultRequestValueErrorCollection                                                                                                                                                                     3426    239953          net::stubbles::ipo::request::stubFilteringRequestValue                                                                                                                                                                                  14338   243379          net::stubbles::ipo::request::stubMockFilteringRequestValue                                                                                                                                                                              2830    257717          net::stubbles::ipo::request::stubModifiableRequest                                                                                                                                                                                      2054    260547          net::stubbles::ipo::request::stubModifiableWebRequest                                                                                                                                                                                   2936    262601          net::stubbles::ipo::request::stubPrefixedRequestValueErrorCollection                                                                                                                                                                    4771    265537          net::stubbles::ipo::request::stubRedirectRequest                                                                                                                                                                                        1077    270308          net::stubbles::ipo::request::stubRequest                                                                                                                                                                                                5853    271385          net::stubbles::ipo::request::stubRequestPrefixDecorator                                                                                                                                                                                 12069   277238          net::stubbles::ipo::request::stubRequestValueError                                                                                                                                                                                      4970    289307          net::stubbles::ipo::request::stubRequestValueErrorCollection                                                                                                                                                                            2289    294277          net::stubbles::ipo::request::stubRequestValueErrorFactory                                                                                                                                                                               806     296566          net::stubbles::ipo::request::stubRequestValueErrorPropertiesFactory                                                                                                                                                                     2483    297372          net::stubbles::ipo::request::stubValidatingRequestValue                                                                                                                                                                                 4144    299855          net::stubbles::ipo::request::stubWebRequest                                                                                                                                                                                             2993    303999          net::stubbles::ipo::request::useragent::stubUserAgent                                                                                                                                                                                   1420    306992          net::stubbles::ipo::request::useragent::stubUserAgentDetector                                                                                                                                                                           1782    308412          net::stubbles::ipo::request::useragent::stubUserAgentFilter                                                                                                                                                                             1227    310194          net::stubbles::ipo::request::useragent::stubUserAgentProvider                                                                                                                                                                           1527    311421          net::stubbles::ipo::request::validator::stubAbstractCompositeValidator                                                                                                                                                                  2153    312948          net::stubbles::ipo::request::validator::stubAndValidator                                                                                                                                                                                1215    315101          net::stubbles::ipo::request::validator::stubCompositeValidator                                                                                                                                                                          705     316316          net::stubbles::ipo::request::validator::stubContainsValidator                                                                                                                                                                           2292    317021          net::stubbles::ipo::request::validator::stubDenyValidator                                                                                                                                                                               944     319313          net::stubbles::ipo::request::validator::stubEqualValidator                                                                                                                                                                              1994    320257          net::stubbles::ipo::request::validator::stubExtFilterValidator                                                                                                                                                                          2025    322251          net::stubbles::ipo::request::validator::stubHTTPURLValidator                                                                                                                                                                            1803    324276          net::stubbles::ipo::request::validator::stubIpValidator                                                                                                                                                                                 1179    326079          net::stubbles::ipo::request::validator::stubMailValidator                                                                                                                                                                               1582    327258          net::stubbles::ipo::request::validator::stubMaxLengthValidator                                                                                                                                                                          1774    328840          net::stubbles::ipo::request::validator::stubMaxNumberValidator                                                                                                                                                                          1764    330614          net::stubbles::ipo::request::validator::stubMinLengthValidator                                                                                                                                                                          1765    332378          net::stubbles::ipo::request::validator::stubMinNumberValidator                                                                                                                                                                          1764    334143          net::stubbles::ipo::request::validator::stubOrValidator                                                                                                                                                                                 1107    335907          net::stubbles::ipo::request::validator::stubPreSelectValidator                                                                                                                                                                          1940    337014          net::stubbles::ipo::request::validator::stubRegexValidator                                                                                                                                                                              2261    338954          net::stubbles::ipo::request::validator::stubValidator                                                                                                                                                                                   862     341215          net::stubbles::ipo::request::validator::stubXorValidator                                                                                                                                                                                1573    342077          net::stubbles::ipo::response::stubBaseResponse                                                                                                                                                                                          12135   343650          net::stubbles::ipo::response::stubCookie                                                                                                                                                                                                5296    355785          net::stubbles::ipo::response::stubResponse                                                                                                                                                                                              4903    361081          net::stubbles::ipo::session::stubAbstractSession                                                                                                                                                                                        10497   365984          net::stubbles::ipo::session::stubFallbackSession                                                                                                                                                                                        5380    376481          net::stubbles::ipo::session::stubNoneDurableSession                                                                                                                                                                                     3362    381861          net::stubbles::ipo::session::stubNoneStoringSession                                                                                                                                                                                     3379    385223          net::stubbles::ipo::session::stubPHPSession                                                                                                                                                                                             3513    388602          net::stubbles::ipo::session::stubSession                                                                                                                                                                                                3472    392115          net::stubbles::lang::errorhandler::stubAbstractExceptionHandler                                                                                                                                                                         4403    395587          net::stubbles::lang::errorhandler::stubCompositeErrorHandler                                                                                                                                                                            4454    399990          net::stubbles::lang::errorhandler::stubDefaultErrorHandler                                                                                                                                                                              1128    404444          net::stubbles::lang::errorhandler::stubDisplayExceptionHandler                                                                                                                                                                          1206    405572          net::stubbles::lang::errorhandler::stubErrorHandler                                                                                                                                                                                     2574    406778          net::stubbles::lang::errorhandler::stubExceptionHandler                                                                                                                                                                                 582     409352          net::stubbles::lang::errorhandler::stubIllegalArgumentErrorHandler                                                                                                                                                                      3379    409934          net::stubbles::lang::errorhandler::stubLogErrorHandler                                                                                                                                                                                  6101    413313          net::stubbles::lang::errorhandler::stubProdModeExceptionHandler                                                                                                                                                                         1075    419414          net::stubbles::lang::exceptions::stubChainedException                                                                                                                                                                                   3501    420489          net::stubbles::lang::exceptions::stubConfigurationException                                                                                                                                                                             561     423990          net::stubbles::lang::exceptions::stubException                                                                                                                                                                                          3183    424551          net::stubbles::lang::exceptions::stubFileNotFoundException                                                                                                                                                                              737     427734          net::stubbles::lang::exceptions::stubIllegalAccessException                                                                                                                                                                             528     428471          net::stubbles::lang::exceptions::stubIllegalArgumentException                                                                                                                                                                           446     428999          net::stubbles::lang::exceptions::stubIllegalStateException                                                                                                                                                                              528     429445          net::stubbles::lang::exceptions::stubIOException                                                                                                                                                                                        400     429973          net::stubbles::lang::exceptions::stubMethodInvocationException                                                                                                                                                                          567     430373          net::stubbles::lang::exceptions::stubMethodNotSupportedException                                                                                                                                                                        633     430940          net::stubbles::lang::exceptions::stubRuntimeException                                                                                                                                                                                   3581    431573          net::stubbles::lang::exceptions::stubThrowable                                                                                                                                                                                          383     435154          net::stubbles::lang::initializer::stubInitializer                                                                                                                                                                                       466     435537          net::stubbles::lang::serialize::stubSerializable                                                                                                                                                                                        522     436003          net::stubbles::lang::serialize::stubSerializableObject                                                                                                                                                                                  3622    436525          net::stubbles::lang::serialize::stubSerializedObject                                                                                                                                                                                    5741    440147          net::stubbles::lang::stubArrayAccessor                                                                                                                                                                                                  4126    445888          net::stubbles::lang::stubBaseObject                                                                                                                                                                                                     6442    450014          net::stubbles::lang::stubClonable                                                                                                                                                                                                       353     456456          net::stubbles::lang::stubDefaultMode                                                                                                                                                                                                    11010   456809          net::stubbles::lang::stubEnum                                                                                                                                                                                                           5777    467819          net::stubbles::lang::stubFactory                                                                                                                                                                                                        1849    473596          net::stubbles::lang::stubMode                                                                                                                                                                                                           2822    475445          net::stubbles::lang::stubObject                                                                                                                                                                                                         1807    478267          net::stubbles::lang::stubPathRegistry                                                                                                                                                                                                   5211    480074          net::stubbles::lang::stubProperties                                                                                                                                                                                                     13120   485285          net::stubbles::lang::types::stubDate                                                                                                                                                                                                    8590    498405          net::stubbles::lang::types::stubTimeZone                                                                                                                                                                                                4151    506995          net::stubbles::peer::http::stubAcceptHeader                                                                                                                                                                                             6570    511146          net::stubbles::peer::http::stubHTTPConnection                                                                                                                                                                                           4917    517716          net::stubbles::peer::http::stubHTTPRequest                                                                                                                                                                                              5718    522633          net::stubbles::peer::http::stubHTTPResponse                                                                                                                                                                                             8888    528351          net::stubbles::peer::http::stubHTTPURL                                                                                                                                                                                                  3090    537239          net::stubbles::peer::http::stubHTTPURLContainer                                                                                                                                                                                         771     540329          net::stubbles::peer::ldap::stubLDAPConnection                                                                                                                                                                                           9541    541100          net::stubbles::peer::ldap::stubLDAPEntry                                                                                                                                                                                                2474    550641          net::stubbles::peer::ldap::stubLDAPSearchResult                                                                                                                                                                                         3819    553115          net::stubbles::peer::ldap::stubLDAPURL                                                                                                                                                                                                  8238    556934          net::stubbles::peer::ldap::stubLDAPURLContainer                                                                                                                                                                                         1262    565172          net::stubbles::peer::stubBSDSocket                                                                                                                                                                                                      11456   566434          net::stubbles::peer::stubConnectionException                                                                                                                                                                                            519     577890          net::stubbles::peer::stubHeaderList                                                                                                                                                                                                     5355    578409          net::stubbles::peer::stubMalformedURLException                                                                                                                                                                                          434     583764          net::stubbles::peer::stubSocket                                                                                                                                                                                                         6664    584198          net::stubbles::peer::stubSocketInputStream                                                                                                                                                                                              1859    590862          net::stubbles::peer::stubSocketOutputStream                                                                                                                                                                                             1419    592721          net::stubbles::peer::stubURL                                                                                                                                                                                                            12738   594140          net::stubbles::peer::stubURLContainer                                                                                                                                                                                                   3282    606878          net::stubbles::php::serializer::stubExceptionReference                                                                                                                                                                                  1576    610160          net::stubbles::php::serializer::stubFormatException                                                                                                                                                                                     460     611736          net::stubbles::php::serializer::stubPHPSerializedData                                                                                                                                                                                   2965    612196          net::stubbles::php::serializer::stubPHPSerializer                                                                                                                                                                                       11714   615161          net::stubbles::php::serializer::stubPHPSerializerMapping                                                                                                                                                                                1855    626875          net::stubbles::php::serializer::stubPHPSerializerObjectMapping                                                                                                                                                                          6521    628730          net::stubbles::php::serializer::stubPHPSerializerSPLSerializableMapping                                                                                                                                                                 3460    635251          net::stubbles::php::serializer::stubUnknownObject                                                                                                                                                                                       2602    638711          net::stubbles::php::string::stubAbstractDecoratedStringEncoder                                                                                                                                                                          1682    641313          net::stubbles::php::string::stubAbstractStringEncoder                                                                                                                                                                                   1468    642995          net::stubbles::php::string::stubBase64Encoder                                                                                                                                                                                           794     644463          net::stubbles::php::string::stubHTMLSpecialCharsEncoder                                                                                                                                                                                 2666    645257          net::stubbles::php::string::stubLocalizedString                                                                                                                                                                                         1211    647923          net::stubbles::php::string::stubMd5Encoder                                                                                                                                                                                              2027    649134          net::stubbles::php::string::stubRecursiveStringEncoder                                                                                                                                                                                  1996    651161          net::stubbles::php::string::stubStringEncoder                                                                                                                                                                                           1511    653157          net::stubbles::php::string::stubURLEncoder                                                                                                                                                                                              776     654668          net::stubbles::php::string::stubUTF8Encoder                                                                                                                                                                                             1170    655444          net::stubbles::rdbms::criteria::stubAbstractCompositeCriterion                                                                                                                                                                          1987    656614          net::stubbles::rdbms::criteria::stubAbstractCriterion                                                                                                                                                                                   1982    658601          net::stubbles::rdbms::criteria::stubAndCriterion                                                                                                                                                                                        812     660583          net::stubbles::rdbms::criteria::stubCompositeCriterion                                                                                                                                                                                  676     661395          net::stubbles::rdbms::criteria::stubCriterion                                                                                                                                                                                           430     662071          net::stubbles::rdbms::criteria::stubEqualCriterion                                                                                                                                                                                      955     662501          net::stubbles::rdbms::criteria::stubGreaterEqualCriterion                                                                                                                                                                               1434    663456          net::stubbles::rdbms::criteria::stubGreaterThanCriterion                                                                                                                                                                                1406    664890          net::stubbles::rdbms::criteria::stubInCriterion                                                                                                                                                                                         1614    666296          net::stubbles::rdbms::criteria::stubLessEqualCriterion                                                                                                                                                                                  1423    667910          net::stubbles::rdbms::criteria::stubLessThanCriterion                                                                                                                                                                                   1395    669333          net::stubbles::rdbms::criteria::stubLikeCriterion                                                                                                                                                                                       1477    670728          net::stubbles::rdbms::criteria::stubNegateCriterion                                                                                                                                                                                     993     672205          net::stubbles::rdbms::criteria::stubOrCriterion                                                                                                                                                                                         806     673198          net::stubbles::rdbms::ioc::stubDatabaseBindingModule                                                                                                                                                                                    3634    674004          net::stubbles::rdbms::ioc::stubDatabaseConnectionProvider                                                                                                                                                                               3828    677638          net::stubbles::rdbms::ioc::stubEntityManagerProvider                                                                                                                                                                                    3567    681466          net::stubbles::rdbms::pdo::stubDatabasePDOConnection                                                                                                                                                                                    10504   685033          net::stubbles::rdbms::pdo::stubDatabasePDOStatement                                                                                                                                                                                     11776   695537          net::stubbles::rdbms::persistence::annotation::stubDBColumnAnnotation                                                                                                                                                                   4330    707313          net::stubbles::rdbms::persistence::annotation::stubDBTableAnnotation                                                                                                                                                                    2469    711643          net::stubbles::rdbms::persistence::annotation::stubEntityAnnotation                                                                                                                                                                     2138    714112          net::stubbles::rdbms::persistence::annotation::stubIdAnnotation                                                                                                                                                                         831     716250          net::stubbles::rdbms::persistence::annotation::stubTransientAnnotation                                                                                                                                                                  859     717081          net::stubbles::rdbms::persistence::creator::stubDatabaseCreator                                                                                                                                                                         1975    717940          net::stubbles::rdbms::persistence::creator::stubDatabaseCreatorException                                                                                                                                                                551     719915          net::stubbles::rdbms::persistence::eraser::stubDatabaseEraser                                                                                                                                                                           4309    720466          net::stubbles::rdbms::persistence::eraser::stubDatabaseEraserException                                                                                                                                                                  545     724775          net::stubbles::rdbms::persistence::finder::stubDatabaseFinder                                                                                                                                                                           9380    725320          net::stubbles::rdbms::persistence::finder::stubDatabaseFinderException                                                                                                                                                                  545     734700          net::stubbles::rdbms::persistence::finder::stubDatabaseFinderResult                                                                                                                                                                     3356    735245          net::stubbles::rdbms::persistence::serializer::stubDatabaseSerializer                                                                                                                                                                   12762   738601          net::stubbles::rdbms::persistence::serializer::stubDatabaseSerializerException                                                                                                                                                          544     751363          net::stubbles::rdbms::persistence::stubDefaultEntityManager                                                                                                                                                                             6570    751907          net::stubbles::rdbms::persistence::stubEntityManager                                                                                                                                                                                    4454    758477          net::stubbles::rdbms::persistence::stubPersistenceException                                                                                                                                                                             438     762931          net::stubbles::rdbms::persistence::stubPersistenceHelper                                                                                                                                                                                7275    763369          net::stubbles::rdbms::persistence::stubSetterMethodHelper                                                                                                                                                                               3847    770644          net::stubbles::rdbms::querybuilder::stubDatabaseMySQLQueryBuilder                                                                                                                                                                       12600   774491          net::stubbles::rdbms::querybuilder::stubDatabaseQueryBuilder                                                                                                                                                                            2210    787091          net::stubbles::rdbms::querybuilder::stubDatabaseQueryBuilderException                                                                                                                                                                   476     789301          net::stubbles::rdbms::querybuilder::stubDatabaseQueryBuilderFactory                                                                                                                                                                     6124    789777          net::stubbles::rdbms::querybuilder::stubDatabaseSelect                                                                                                                                                                                  4511    795901          net::stubbles::rdbms::querybuilder::stubDatabaseTableColumn                                                                                                                                                                             8006    800412          net::stubbles::rdbms::querybuilder::stubDatabaseTableDescription                                                                                                                                                                        5092    808418          net::stubbles::rdbms::querybuilder::stubDatabaseTableJoin                                                                                                                                                                               3539    813510          net::stubbles::rdbms::querybuilder::stubDatabaseTableRow                                                                                                                                                                                2583    817049          net::stubbles::rdbms::stubDatabaseConnection                                                                                                                                                                                            3357    819632          net::stubbles::rdbms::stubDatabaseConnectionData                                                                                                                                                                                        6440    822989          net::stubbles::rdbms::stubDatabaseException                                                                                                                                                                                             461     829429          net::stubbles::rdbms::stubDatabaseInitializer                                                                                                                                                                                           1091    829890          net::stubbles::rdbms::stubDatabaseResult                                                                                                                                                                                                2524    830981          net::stubbles::rdbms::stubDatabaseStatement                                                                                                                                                                                             2741    833505          net::stubbles::rdbms::stubPropertyBasedDatabaseInitializer                                                                                                                                                                              2905    836246          net::stubbles::reflection::annotations::parser::state::stubAnnotationAbstractState                                                                                                                                                      898     839151          net::stubbles::reflection::annotations::parser::state::stubAnnotationAnnotationState                                                                                                                                                    1343    840049          net::stubbles::reflection::annotations::parser::state::stubAnnotationArgumentState                                                                                                                                                      1881    841392          net::stubbles::reflection::annotations::parser::state::stubAnnotationDocblockState                                                                                                                                                      1155    843273          net::stubbles::reflection::annotations::parser::state::stubAnnotationNameState                                                                                                                                                          5381    844428          net::stubbles::reflection::annotations::parser::state::stubAnnotationParamNameState                                                                                                                                                     2734    849809          net::stubbles::reflection::annotations::parser::state::stubAnnotationParamsState                                                                                                                                                        1297    852543          net::stubbles::reflection::annotations::parser::state::stubAnnotationParamValueState                                                                                                                                                    3753    853840          net::stubbles::reflection::annotations::parser::state::stubAnnotationState                                                                                                                                                              1720    857593          net::stubbles::reflection::annotations::parser::state::stubAnnotationTextState                                                                                                                                                          919     859313          net::stubbles::reflection::annotations::parser::state::stubAnnotationTypeState                                                                                                                                                          1798    860232          net::stubbles::reflection::annotations::parser::stubAnnotationParser                                                                                                                                                                    2072    862030          net::stubbles::reflection::annotations::parser::stubAnnotationStateParser                                                                                                                                                               8703    864102          net::stubbles::reflection::annotations::stubAbstractAnnotation                                                                                                                                                                          3213    872805          net::stubbles::reflection::annotations::stubAnnotatable                                                                                                                                                                                 822     876018          net::stubbles::reflection::annotations::stubAnnotation                                                                                                                                                                                  1743    876840          net::stubbles::reflection::annotations::stubAnnotationCache                                                                                                                                                                             6166    878583          net::stubbles::reflection::annotations::stubAnnotationFactory                                                                                                                                                                           8484    884749          net::stubbles::reflection::matcher::stubMethodMatcher                                                                                                                                                                                   802     893233          net::stubbles::reflection::matcher::stubPropertyMatcher                                                                                                                                                                                 836     894035          net::stubbles::reflection::reflection                                                                                                                                                                                                   1291    894871          net::stubbles::reflection::stubBaseReflectionClass                                                                                                                                                                                      3690    896162          net::stubbles::reflection::stubReflectionClass                                                                                                                                                                                          9575    899852          net::stubbles::reflection::stubReflectionExtension                                                                                                                                                                                      2647    909427          net::stubbles::reflection::stubReflectionFunction                                                                                                                                                                                       4967    912074          net::stubbles::reflection::stubReflectionMethod                                                                                                                                                                                         6115    917041          net::stubbles::reflection::stubReflectionObject                                                                                                                                                                                         9897    923156          net::stubbles::reflection::stubReflectionPackage                                                                                                                                                                                        5859    933053          net::stubbles::reflection::stubReflectionParameter                                                                                                                                                                                      7059    938912          net::stubbles::reflection::stubReflectionPrimitive                                                                                                                                                                                      3554    945971          net::stubbles::reflection::stubReflectionProperty                                                                                                                                                                                       4146    949525          net::stubbles::reflection::stubReflectionRoutine                                                                                                                                                                                        3590    953671          net::stubbles::reflection::stubReflectionType                                                                                                                                                                                           985     957261          net::stubbles::service::annotations::stubWebMethodAnnotation                                                                                                                                                                            871     958246          net::stubbles::service::debug::stubFirebugLogger                                                                                                                                                                                        8505    959117          net::stubbles::service::jsonrpc::stubJsonRpcProcessor                                                                                                                                                                                   3389    967622          net::stubbles::service::jsonrpc::stubJsonRpcWriter                                                                                                                                                                                      1800    971011          net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcAbstractGenerateSubProcessor                                                                                                                                                 2146    972811          net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcAbstractInvokingSubProcessor                                                                                                                                                 2995    974957          net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcGenerateProxiesSubProcessor                                                                                                                                                  2403    977952          net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcGenerateSmdSubProcessor                                                                                                                                                      2218    980355          net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcGetSubProcessor                                                                                                                                                              3339    982573          net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcPostSubProcessor                                                                                                                                                             8959    985912          net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcSubProcessor                                                                                                                                                                 1220    994871          net::stubbles::service::jsonrpc::util::stubFirebugEncoder                                                                                                                                                                               1799    996091          net::stubbles::service::jsonrpc::util::stubJsonRpcProxyGenerator                                                                                                                                                                        1829    997890          net::stubbles::service::jsonrpc::util::stubSmdGenerator                                                                                                                                                                                 2198    999719          net::stubbles::service::rest::annotation::stubRestMethodAnnotation                                                                                                                                                                      4703    1001917         net::stubbles::service::rest::format::stubErrorFormatter                                                                                                                                                                                1205    1006620         net::stubbles::service::rest::format::stubFormatContentType                                                                                                                                                                             524     1007825         net::stubbles::service::rest::format::stubFormatter                                                                                                                                                                                     623     1008349         net::stubbles::service::rest::format::stubJsonFormatter                                                                                                                                                                                 2018    1008972         net::stubbles::service::rest::format::stubPlainTextFormatter                                                                                                                                                                            2386    1010990         net::stubbles::service::rest::format::stubVoidFormatter                                                                                                                                                                                 1742    1013376         net::stubbles::service::rest::format::stubXmlFormatter                                                                                                                                                                                  2792    1015118         net::stubbles::service::rest::stubRestHandlerException                                                                                                                                                                                  1640    1017910         net::stubbles::service::rest::stubRestMethodsMatcher                                                                                                                                                                                    1213    1019550         net::stubbles::service::rest::stubRestProcessor                                                                                                                                                                                         15710   1020763         net::stubbles::service::soap::ioc::stubSoapBindingModule                                                                                                                                                                                1676    1036473         net::stubbles::service::soap::native::stubNativeSoapClient                                                                                                                                                                              7474    1038149         net::stubbles::service::soap::stubAbstractSoapClient                                                                                                                                                                                    1720    1045623         net::stubbles::service::soap::stubSoapClient                                                                                                                                                                                            1730    1047343         net::stubbles::service::soap::stubSoapClientConfiguration                                                                                                                                                                               7314    1049073         net::stubbles::service::soap::stubSoapClientGenerator                                                                                                                                                                                   3778    1056387         net::stubbles::service::soap::stubSoapException                                                                                                                                                                                         986     1060165         net::stubbles::service::soap::stubSoapFault                                                                                                                                                                                             1913    1061151         net::stubbles::streams::file::stubFileInputStream                                                                                                                                                                                       3540    1063064         net::stubbles::streams::file::stubFileOutputStream                                                                                                                                                                                      2862    1066604         net::stubbles::streams::file::stubFileStreamFactory                                                                                                                                                                                     2593    1069466         net::stubbles::streams::filter::stubCompositeStreamFilter                                                                                                                                                                               1312    1072059         net::stubbles::streams::filter::stubFilteredInputStream                                                                                                                                                                                 2082    1073371         net::stubbles::streams::filter::stubFilteredOutputStream                                                                                                                                                                                1799    1075453         net::stubbles::streams::filter::stubStreamFilter                                                                                                                                                                                        504     1077252         net::stubbles::streams::memory::stubMemoryInputStream                                                                                                                                                                                   3536    1077756         net::stubbles::streams::memory::stubMemoryOutputStream                                                                                                                                                                                  1314    1081292         net::stubbles::streams::memory::stubMemoryStreamFactory                                                                                                                                                                                 1410    1082606         net::stubbles::streams::memory::stubMemoryStreamWrapper                                                                                                                                                                                 8043    1084016         net::stubbles::streams::stubAbstractDecoratedInputStream                                                                                                                                                                                2392    1092059         net::stubbles::streams::stubAbstractDecoratedOutputStream                                                                                                                                                                               2017    1094451         net::stubbles::streams::stubDecodingInputStream                                                                                                                                                                                         1789    1096468         net::stubbles::streams::stubDecoratedInputStream                                                                                                                                                                                        751     1098257         net::stubbles::streams::stubDecoratedOutputStream                                                                                                                                                                                       766     1099008         net::stubbles::streams::stubEncodingOutputStream                                                                                                                                                                                        1774    1099774         net::stubbles::streams::stubInputStream                                                                                                                                                                                                 1057    1101548         net::stubbles::streams::stubOutputStream                                                                                                                                                                                                768     1102605         net::stubbles::streams::stubPrefixedStreamFactory                                                                                                                                                                                       2019    1103373         net::stubbles::streams::stubResourceInputStream                                                                                                                                                                                         3959    1105392         net::stubbles::streams::stubResourceOutputStream                                                                                                                                                                                        2232    1109351         net::stubbles::streams::stubSeekable                                                                                                                                                                                                    1003    1111583         net::stubbles::streams::stubStreamFactory                                                                                                                                                                                               1150    1112586         net::stubbles::util::Binford                                                                                                                                                                                                            3508    1113736         net::stubbles::util::cache::ioc::stubCacheBindingModule                                                                                                                                                                                 4854    1117244         net::stubbles::util::cache::ioc::stubCacheProvider                                                                                                                                                                                      3089    1122098         net::stubbles::util::cache::stubAbstractCacheContainer                                                                                                                                                                                  4044    1125187         net::stubbles::util::cache::stubCacheContainer                                                                                                                                                                                          2495    1129231         net::stubbles::util::cache::stubCacheStrategy                                                                                                                                                                                           1435    1131726         net::stubbles::util::cache::stubDefaultCacheStrategy                                                                                                                                                                                    4236    1133161         net::stubbles::util::cache::stubFileCacheContainer                                                                                                                                                                                      6796    1137397         net::stubbles::util::datespan::stubDateSpan                                                                                                                                                                                             1496    1144193         net::stubbles::util::datespan::stubDateSpanCustom                                                                                                                                                                                       5502    1145689         net::stubbles::util::datespan::stubDateSpanDay                                                                                                                                                                                          1219    1151191         net::stubbles::util::datespan::stubDateSpanMonth                                                                                                                                                                                        2247    1152410         net::stubbles::util::datespan::stubDateSpanWeek                                                                                                                                                                                         1105    1154657         net::stubbles::util::datespan::stubDateSpanYesterday                                                                                                                                                                                    551     1155762         net::stubbles::util::ext::stubPearClassLoader                                                                                                                                                                                           1515    1156313         net::stubbles::util::ext::stubPhpToolsClassLoader                                                                                                                                                                                       2042    1157828         net::stubbles::util::log::appender::stubFileLogAppender                                                                                                                                                                                 2591    1159870         net::stubbles::util::log::appender::stubLogAppender                                                                                                                                                                                     998     1162461         net::stubbles::util::log::appender::stubMailLogAppender                                                                                                                                                                                 3206    1163459         net::stubbles::util::log::appender::stubMemoryLogAppender                                                                                                                                                                               2560    1166665         net::stubbles::util::log::entryfactory::stubAbstractLogEntryFactory                                                                                                                                                                     838     1169225         net::stubbles::util::log::entryfactory::stubDefaultLogEntryFactory                                                                                                                                                                      1709    1170063         net::stubbles::util::log::entryfactory::stubEmptyLogEntryFactory                                                                                                                                                                        886     1171772         net::stubbles::util::log::entryfactory::stubLogEntryFactory                                                                                                                                                                             1087    1172658         net::stubbles::util::log::ioc::stubBaseLoggerProvider                                                                                                                                                                                   1517    1173745         net::stubbles::util::log::ioc::stubDefaultLoggerProvider                                                                                                                                                                                1657    1175262         net::stubbles::util::log::ioc::stubLogBindingModule                                                                                                                                                                                     3645    1176919         net::stubbles::util::log::stubLogEntry                                                                                                                                                                                                  5216    1180564         net::stubbles::util::log::stubLogger                                                                                                                                                                                                    4774    1185780         net::stubbles::util::log::type::stubExceptionLog                                                                                                                                                                                        2335    1190554         net::stubbles::util::xjconf::stubXJConfAbstractInitializer                                                                                                                                                                              1300    1192889         net::stubbles::util::xjconf::stubXJConfClassLoader                                                                                                                                                                                      2595    1194189         net::stubbles::util::xjconf::stubXJConfException                                                                                                                                                                                        471     1196784         net::stubbles::util::xjconf::stubXJConfFacade                                                                                                                                                                                           1150    1197255         net::stubbles::util::xjconf::stubXJConfInitializer                                                                                                                                                                                      2266    1198405         net::stubbles::util::xjconf::stubXJConfLoader                                                                                                                                                                                           1686    1200671         net::stubbles::util::xjconf::stubXJConfProxy                                                                                                                                                                                            4016    1202357         net::stubbles::util::xjconf::xjconf                                                                                                                                                                                                     541     1206373         net::stubbles::util::xjconf::xjconfReal                                                                                                                                                                                                 368     1206914         net::stubbles::websites::cache::stubAbstractWebsiteCache                                                                                                                                                                                5315    1207282         net::stubbles::websites::cache::stubCachingProcessor                                                                                                                                                                                    2119    1212597         net::stubbles::websites::cache::stubCachingProcessorResolver                                                                                                                                                                            2652    1214716         net::stubbles::websites::cache::stubDefaultWebsiteCache                                                                                                                                                                                 2472    1217368         net::stubbles::websites::cache::stubDummyWebsiteCache                                                                                                                                                                                   2614    1219840         net::stubbles::websites::cache::stubGzipWebsiteCache                                                                                                                                                                                    6523    1222454         net::stubbles::websites::cache::stubWebsiteCache                                                                                                                                                                                        1885    1228977         net::stubbles::websites::ioc::stubProcessorResolverProvider                                                                                                                                                                             1757    1230862         net::stubbles::websites::ioc::stubWebsiteBindingModule                                                                                                                                                                                  12512   1232619         net::stubbles::websites::processors::auth::stubAuthHandler                                                                                                                                                                              1036    1245131         net::stubbles::websites::processors::auth::stubAuthProcessor                                                                                                                                                                            3090    1246167         net::stubbles::websites::processors::auth::stubAuthProcessorResolver                                                                                                                                                                    2513    1249257         net::stubbles::websites::processors::routing::stubAbstractProcessable                                                                                                                                                                   1739    1251770         net::stubbles::websites::processors::routing::stubProcessable                                                                                                                                                                           1948    1253509         net::stubbles::websites::processors::routing::stubPropertyBasedRouter                                                                                                                                                                   3999    1255457         net::stubbles::websites::processors::routing::stubRoute                                                                                                                                                                                 3207    1259456         net::stubbles::websites::processors::routing::stubRouter                                                                                                                                                                                1684    1262663         net::stubbles::websites::processors::stubAbstractProcessor                                                                                                                                                                              2936    1264347         net::stubbles::websites::processors::stubAbstractProcessorDecorator                                                                                                                                                                     2522    1267283         net::stubbles::websites::processors::stubAbstractProcessorResolver                                                                                                                                                                      1983    1269805         net::stubbles::websites::processors::stubDefaultProcessorResolver                                                                                                                                                                       4227    1271788         net::stubbles::websites::processors::stubProcessor                                                                                                                                                                                      2175    1276015         net::stubbles::websites::processors::stubProcessorException                                                                                                                                                                             1108    1278190         net::stubbles::websites::processors::stubProcessorResolver                                                                                                                                                                              1279    1279298         net::stubbles::websites::processors::stubSimpleProcessorResolver                                                                                                                                                                        2298    1280577         net::stubbles::websites::stubFrontController                                                                                                                                                                                            4996    1282875         net::stubbles::websites::variantmanager::stubAbstractVariantFactory                                                                                                                                                                     3312    1287871         net::stubbles::websites::variantmanager::stubVariantConfigurationException                                                                                                                                                              593     1291183         net::stubbles::websites::variantmanager::stubVariantFactory                                                                                                                                                                             2882    1291776         net::stubbles::websites::variantmanager::stubVariantsCookieCreator                                                                                                                                                                      4449    1294658         net::stubbles::websites::variantmanager::stubVariantSettingPreInterceptor                                                                                                                                                               3575    1299107         net::stubbles::websites::variantmanager::stubVariantsMap                                                                                                                                                                                6782    1302682         net::stubbles::websites::variantmanager::stubVariantsPreInterceptor                                                                                                                                                                     3515    1309464         net::stubbles::websites::variantmanager::stubVariantSwitchPreInterceptor                                                                                                                                                                2864    1312979         net::stubbles::websites::variantmanager::stubVariantXJConfFactory                                                                                                                                                                       3020    1315843         net::stubbles::websites::variantmanager::types::stubAbstractVariant                                                                                                                                                                     7698    1318863         net::stubbles::websites::variantmanager::types::stubDummyVariant                                                                                                                                                                        1283    1326561         net::stubbles::websites::variantmanager::types::stubLeadVariant                                                                                                                                                                         1162    1327844         net::stubbles::websites::variantmanager::types::stubRandomVariant                                                                                                                                                                       3650    1329006         net::stubbles::websites::variantmanager::types::stubRequestParamVariant                                                                                                                                                                 2524    1332656         net::stubbles::websites::variantmanager::types::stubRootVariant                                                                                                                                                                         1456    1335180         net::stubbles::websites::variantmanager::types::stubVariant                                                                                                                                                                             3791    1336636         net::stubbles::websites::xml::generator::stubModeXMLGenerator                                                                                                                                                                           2670    1340427         net::stubbles::websites::xml::generator::stubRequestXMLGenerator                                                                                                                                                                        3756    1343097         net::stubbles::websites::xml::generator::stubRouteXMLGenerator                                                                                                                                                                          4593    1346853         net::stubbles::websites::xml::generator::stubSessionXMLGenerator                                                                                                                                                                        3942    1351446         net::stubbles::websites::xml::generator::stubVariantListGenerator                                                                                                                                                                       3924    1355388         net::stubbles::websites::xml::generator::stubXMLGenerator                                                                                                                                                                               1350    1359312         net::stubbles::websites::xml::generator::stubXmlGeneratorFacade                                                                                                                                                                         3237    1360662         net::stubbles::websites::xml::routing::stubAbstractXmlFormProcessable                                                                                                                                                                   2065    1363899         net::stubbles::websites::xml::routing::stubXmlFormProcessable                                                                                                                                                                           601     1365964         net::stubbles::websites::xml::skin::stubCachingSkinGenerator                                                                                                                                                                            2258    1366565         net::stubbles::websites::xml::skin::stubDefaultSkinGenerator                                                                                                                                                                            6065    1368823         net::stubbles::websites::xml::skin::stubSkinGenerator                                                                                                                                                                                   924     1374888         net::stubbles::websites::xml::skin::stubSkinGeneratorProvider                                                                                                                                                                           1689    1375812         net::stubbles::websites::xml::stubShowLastXMLInterceptor                                                                                                                                                                                1338    1377501         net::stubbles::websites::xml::stubXMLProcessor                                                                                                                                                                                          7054    1378839         net::stubbles::websites::xml::stubXmlProcessorTransformer                                                                                                                                                                               4838    1385893         net::stubbles::xml::rss::stubAbstractRSSFeed                                                                                                                                                                                            4809    1390731         net::stubbles::xml::rss::stubRSSFeed                                                                                                                                                                                                    793     1395540         net::stubbles::xml::rss::stubRSSFeedGenerator                                                                                                                                                                                           15232   1396333         net::stubbles::xml::rss::stubRSSFeedItem                                                                                                                                                                                                14769   1411565         net::stubbles::xml::rss::stubRSSFeedItemAnnotation                                                                                                                                                                                      5509    1426334         net::stubbles::xml::rss::stubRSSProcessor                                                                                                                                                                                               3421    1431843         net::stubbles::xml::serializer::annotations::stubXMLAttributeAnnotation                                                                                                                                                                 1955    1435264         net::stubbles::xml::serializer::annotations::stubXMLFragmentAnnotation                                                                                                                                                                  1973    1437219         net::stubbles::xml::serializer::annotations::stubXMLIgnoreAnnotation                                                                                                                                                                    845     1439192         net::stubbles::xml::serializer::annotations::stubXMLMatcherAnnotation                                                                                                                                                                   3107    1440037         net::stubbles::xml::serializer::annotations::stubXMLMethodsAnnotation                                                                                                                                                                   826     1443144         net::stubbles::xml::serializer::annotations::stubXMLPropertiesAnnotation                                                                                                                                                                847     1443970         net::stubbles::xml::serializer::annotations::stubXMLStrategyAnnotation                                                                                                                                                                  1280    1444817         net::stubbles::xml::serializer::annotations::stubXMLTagAnnotation                                                                                                                                                                       1856    1446097         net::stubbles::xml::serializer::matcher::stubXMLSerializerMethodPropertyMatcher                                                                                                                                                         2341    1447953         net::stubbles::xml::serializer::stubXMLSerializer                                                                                                                                                                                       8743    1450294         net::stubbles::xml::serializer::stubXmlSerializerFacade                                                                                                                                                                                 2022    1459037         net::stubbles::xml::serializer::stubXMLSerializerObjectData                                                                                                                                                                             10167   1461059         net::stubbles::xml::stubAbstractXMLStreamWriter                                                                                                                                                                                         2229    1471226         net::stubbles::xml::stubDomXMLStreamWriter                                                                                                                                                                                              11484   1473455         net::stubbles::xml::stubLibXmlXMLStreamWriter                                                                                                                                                                                           4514    1484939         net::stubbles::xml::stubXMLException                                                                                                                                                                                                    393     1489453         net::stubbles::xml::stubXMLStreamWriter                                                                                                                                                                                                 3309    1489846         net::stubbles::xml::stubXmlStreamWriterProvider                                                                                                                                                                                         3363    1493155         net::stubbles::xml::unserializer::stubXMLUnserializer                                                                                                                                                                                   14498   1496518         net::stubbles::xml::unserializer::stubXMLUnserializerOption                                                                                                                                                                             4999    1511016         net::stubbles::xml::xsl::callback::stubXslAbstractCallback                                                                                                                                                                              1768    1516015         net::stubbles::xml::xsl::callback::stubXslCallback                                                                                                                                                                                      4310    1517783         net::stubbles::xml::xsl::callback::stubXslCallbackException                                                                                                                                                                             419     1522093         net::stubbles::xml::xsl::callback::stubXslDateFormatterCallback                                                                                                                                                                         2410    1522512         net::stubbles::xml::xsl::callback::stubXslImageDimensionsCallback                                                                                                                                                                       4409    1524922         net::stubbles::xml::xsl::callback::stubXslMethodAnnotation                                                                                                                                                                              816     1529331         net::stubbles::xml::xsl::callback::stubXslMissingIncludeCallback                                                                                                                                                                        3422    1530147         net::stubbles::xml::xsl::callback::stubXslRequestParamsCallback                                                                                                                                                                         2011    1533569         net::stubbles::xml::xsl::stubXSLProcessor                                                                                                                                                                                               13043   1535580         net::stubbles::xml::xsl::stubXSLProcessorException                                                                                                                                                                                      383     1548623         net::stubbles::xml::xsl::stubXSLProcessorFactory                                                                                                                                                                                        2189    1549006         net::stubbles::xml::xsl::stubXslProcessorProvider                                                                                                                                                                                       2597    1551195         net::stubbles::xml::xsl::util::stubXslImportStreamWrapper                                                                                                                                                                               5115    1553792         net::stubbles::xml::xsl::util::stubXslXIncludeStreamWrapper                                                                                                                                                                             12728   1558907         ipo/request.ini                                                                                                                                                                                                                         8909    1571635         master.xsl                                                                                                                                                                                                                              306     1580544         xjconf/encoder.xml                                                                                                                                                                                                                      685     1580850         xjconf/streams.xml                                                                                                                                                                                                                      1960    1581535         xjconf/validators.xml                                                                                                                                                                                                                   2554    1583495         xjconf/variantmanager.xml                                                                                                                                                                                                               1533    1586049         xsl/copy.xsl                                                                                                                                                                                                                            383     1587582         xsl/ingrid.xsl                                                                                                                                                                                                                          26024   1587965         xsl/master.xsl                                                                                                                                                                                                                          874     1613989         xsl/stub.xsl                                                                                                                                                                                                                            26149   1614863         xsl/variant.xsl                                                                                                                                                                                                                         4074    1641012         <?php
/**
 * Binding module for console classes.
 *
 * @package     stubbles
 * @subpackage  console
 * @version     $Id: stubConsoleBindingModule.php 2250 2009-06-23 12:32:33Z mikey $
 */
stubClassLoader::load('net::stubbles::console::stubConsoleInputStream',
                      'net::stubbles::console::stubConsoleOutputStream',
                      'net::stubbles::ioc::module::stubBindingModule'
);
/**
 * Binding module for console classes.
 *
 * @package     stubbles
 * @subpackage  console
 */
class stubConsoleBindingModule extends stubBaseObject implements stubBindingModule
{
    /**
     * configure the binder
     *
     * @param  stubBinder  $binder
     */
    public function configure(stubBinder $binder)
    {
        $binder->bind('stubInputStream')
               ->named('stdin')
               ->toInstance(stubConsoleInputStream::forIn());
        $binder->bind('stubOutputStream')
               ->named('stdout')
               ->toInstance(stubConsoleOutputStream::forOut());
        $binder->bind('stubOutputStream')
               ->named('stderr')
               ->toInstance(stubConsoleOutputStream::forError());
        $binder->bind('stubExecutor')
               ->to('net::stubbles::console::stubConsoleExecutor');
    }
}
?><?php
/**
 * Input stream to read output of an executed command.
 *
 * @package     stubbles
 * @subpackage  console
 * @version     $Id: stubCommandInputStream.php 2165 2009-04-16 20:42:52Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::lang::exceptions::stubIllegalStateException',
                      'net::stubbles::lang::exceptions::stubIOException',
                      'net::stubbles::lang::exceptions::stubRuntimeException',
                      'net::stubbles::streams::stubResourceInputStream'
);
/**
 * Input stream to read output of an executed command.
 *
 * @package     stubbles
 * @subpackage  console
 */
class stubCommandInputStream extends stubResourceInputStream
{
    /**
     * original command
     *
     * @var  string
     */
    protected $command;

    /**
     * constructor
     *
     * @param   resource  $resource
     * @param   string    $command   optional
     * @throws  stubIllegalArgumentException
     */
    public function __construct($resource, $command = null)
    {
        if (is_resource($resource) === false || get_resource_type($resource) !== 'stream') {
            throw new stubIllegalArgumentException('Resource must be an already opened process resource.');
        }
        
        $this->setHandle($resource);
        $this->command = $command;
    }

    /**
     * destructor
     */
    public function __destruct()
    {
        try {
            $this->close();
        } catch (Exception $e) {
            // ignore exception
        }
    }

    /**
     * reads given amount of bytes
     *
     * @param   int     $length  optional  max amount of bytes to read
     * @return  string
     * @throws  stubIllegalStateException
     * @throws  stubIOException
     */
    public function read($length = 8192)
    {
        if (null === $this->handle) {
            throw new stubIllegalStateException('Can not read from closed input stream.');
        }

        $data = @fgets($this->handle, $length);
        if (false === $data) {
            if (@feof($this->handle) === false) {
                throw new stubIOException('Can not read from input stream.');
            }
            
            return '';
        }

        return $data;
    }

    /**
     * closes the stream
     *
     * @throws  stubRuntimeException
     */
    public function close()
    {
        if (null !== $this->handle) {
            $returnCode   = pclose($this->handle);
            $this->handle = null;
            if (0 != $returnCode) {
                throw new stubRuntimeException('Executing command ' . $this->command . ' failed: #' . $returnCode);
            }
        }
    }
}
?><?php
/**
 * Interface for commands to be executed on the command line.
 *
 * @package     stubbles
 * @subpackage  console
 */
/**
 * Interface for commands to be executed on the command line.
 *
 * @package     stubbles
 * @subpackage  console
 */
interface stubConsoleCommand extends stubObject
{
    /**
     * runs the command and returns an exit code
     *
     * @return  int
     */
    public function run();
}
?><?php
/**
 * Runner for console commands.
 *
 * @package     stubbles
 * @subpackage  console
 * @version     $Id: stubConsoleCommandRunner.php 2240 2009-06-16 21:50:52Z mikey $
 */
stubClassLoader::load('net::stubbles::console::stubConsoleCommand',
                      'net::stubbles::console::stubConsoleOutputStream',
                      'net::stubbles::ioc::stubApp'
);
/**
 * Runner for console commands.
 *
 * @package     stubbles
 * @subpackage  console
 */
class stubConsoleCommandRunner extends stubBaseObject
{
    /**
     * main method
     *
     * @param   string  $projectPath
     * @param   array   $argv
     * @return  int     exit code
     */
    public static function main($projectPath, array $argv)
    {
        return self::run($projectPath, $argv, stubConsoleOutputStream::forError());
    }

    /**
     * running method
     *
     * @param   string            $projectPath
     * @param   array             $argv
     * @param   stubOutputStream  $err
     * @return  int               exit code
     */
    public static function run($projectPath, array $argv, stubOutputStream $err)
    {
        if (isset($argv[2]) === false) {
            $err->writeLine('*** Missing classname of command class to execute');
            return 1;
        }
        
        array_shift($argv); // stubcli
        array_shift($argv); // project
        $commandClass = array_shift($argv);
        try {
            return (int) stubApp::createInstance($commandClass, $projectPath, array_values($argv))
                                ->run();
        } catch (Exception $e) {
            $classname = (($e instanceof stubException) ? ($e->getClassName()) : (get_class($e)));
            $err->writeLine('*** ' . $classname . ': ' . $e->getMessage());
            return 70;
        }
    }
}
?><?php
/**
 * Class to execute commands on the command line.
 *
 * @package     stubbles
 * @subpackage  console
 * @version     $Id: stubConsoleExecutor.php 2572 2010-06-24 11:50:25Z bensch $
 */
stubClassLoader::load('net::stubbles::console::stubCommandInputStream',
                      'net::stubbles::console::stubExecutor',
                      'net::stubbles::lang::exceptions::stubRuntimeException'
);
/**
 * Class to execute commands on the command line.
 *
 * @package     stubbles
 * @subpackage  console
 */
class stubConsoleExecutor extends stubBaseObject implements stubExecutor
{
    /**
     * output stream to write data outputted by executed command to
     *
     * @var  stubOutputStream
     */
    protected $out;
    /**
     * redirect direction
     *
     * @var  string
     */
    protected $redirect = '2>&1';

    /**
     * sets the output stream to write data outputted by executed command to
     *
     * @param   stubOutputStream  $out
     * @return  stubExecutor
     */
    public function streamOutputTo(stubOutputStream $out)
    {
        $this->out = $out;
        return $this;
    }

    /**
     * returns the output stream to write data outputted by executed command to
     *
     * @return  stubOutputStream
     */
    public function getOutputStream()
    {
        return $this->out;
    }

    /**
     * sets the redirect
     *
     * @param   string        $redirect
     * @return  stubExecutor
     */
    public function redirectTo($redirect)
    {
        $this->redirect = $redirect;
        return $this;
    }

    /**
     * executes given command
     *
     * @param   string        $command
     * @return  stubExecutor
     * @throws  stubRuntimeException
     */
    public function execute($command)
    {
        $pd = popen($command . ' ' . $this->redirect, 'r');
        if (false === $pd) {
            throw new stubRuntimeException('Can not execute ' . $command);
        }

        while (feof($pd) === false && false !== ($line = fgets($pd, 4096))) {
            $line = chop($line);
            if (null !== $this->out) {
                $this->out->writeLine($line);
            }
        }

        $returnCode = pclose($pd);
        if (0 != $returnCode) {
            throw new stubRuntimeException('Executing command ' . $command . ' failed: #' . $returnCode);
        }

        return $this;
    }

    /**
     * executes given command asynchronous
     *
     * The method starts the command, and returns an input stream which can be
     * used to read the output of the command manually.
     *
     * @param   string           $command
     * @return  stubInputStream
     * @throws  stubRuntimeException
     */
    public function executeAsync($command)
    {
        $pd = popen($command . ' ' . $this->redirect, 'r');
        if (false === $pd) {
            throw new stubRuntimeException('Can not execute ' . $command);
        }

        return new stubCommandInputStream($pd, $command);
    }

    /**
     * executes command directly and returns output as array (each line as one entry)
     *
     * @param   string         $command
     * @return  array<string>
     * @throws  stubRuntimeException
     */
    public function executeDirect($command)
    {
        $pd = popen($command . ' ' . $this->redirect, 'r');
        if (false === $pd) {
            throw new stubRuntimeException('Can not execute ' . $command);
        }

        $result = array();
        while (feof($pd) === false && false !== ($line = fgets($pd, 4096))) {
            $result[] = chop($line);
        }

        $returnCode = pclose($pd);
        if (0 != $returnCode) {
            throw new stubRuntimeException('Executing command ' . $command . ' failed: #' . $returnCode);
        }

        return $result;
    }
}
?><?php
/**
 * Class for console input streams.
 *
 * @package     stubbles
 * @subpackage  console
 * @version     $Id: stubConsoleInputStream.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubResourceInputStream');
/**
 * Class for console input streams.
 *
 * @package     stubbles
 * @subpackage  console
 */
class stubConsoleInputStream extends stubResourceInputStream
{
    /**
     * holds input stream instance if created
     *
     * @var  stubConsoleInputStream
     */
    protected static $in;

    /**
     * constructor
     */
    protected function __construct()
    {
        $this->setHandle(STDIN);
    }

    /**
     * comfort method for getting a console output stream
     *
     * @return  stubConsoleInputStream
     */
    public static function forIn()
    {
        if (null === self::$in) {
            self::$in      = new self();
            $inputEncoding = iconv_get_encoding('input_encoding');
            if ('UTF-8' !== $inputEncoding) {
                stubClassLoader::load('net::stubbles::streams::stubDecodingInputStream');
                self::$in = new stubDecodingInputStream(self::$in, $inputEncoding);
            }
        }
        
        return self::$in;
    }
}
?><?php
/**
 * Class for console output streams.
 *
 * @package     stubbles
 * @subpackage  console
 * @version     $Id: stubConsoleOutputStream.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubResourceOutputStream');
/**
 * Class for console output streams.
 *
 * @package     stubbles
 * @subpackage  console
 */
class stubConsoleOutputStream extends stubResourceOutputStream
{
    /**
     * holds output stream instance if created
     *
     * @var  stubConsoleOutputStream
     */
    protected static $out;
    /**
     * holds error stream instance if created
     *
     * @var  stubConsoleOutputStream
     */
    protected static $err;

    /**
     * constructor
     *
     * @param  resource  $descriptor
     */
    protected function __construct($descriptor)
    {
        $this->setHandle($descriptor);
    }

    /**
     * comfort method for getting a console output stream
     *
     * @return  stubConsoleOutputStream
     */
    public static function forOut()
    {
        if (null === self::$out) {
            self::$out      = new self(STDOUT);
            $outputEncoding = self::getOutputEncoding();
            if ('UTF-8' !== $outputEncoding) {
                stubClassLoader::load('net::stubbles::streams::stubEncodingOutputStream');
                self::$out = new stubEncodingOutputStream(self::$out, $outputEncoding . '//IGNORE');
            }
        }
        
        return self::$out;
    }

    /**
     * comfort method for getting a console error stream
     *
     * @return  stubConsoleOutputStream
     */
    public static function forError()
    {
        if (null === self::$err) {
            self::$err      = new self(STDERR);
            $outputEncoding = self::getOutputEncoding();
            if ('UTF-8' !== $outputEncoding) {
                stubClassLoader::load('net::stubbles::streams::stubEncodingOutputStream');
                self::$err = new stubEncodingOutputStream(self::$err, $outputEncoding . '//IGNORE');
            }
        }
        
        return self::$err;
    }

    /**
     * helper method to detect correct output encoding
     *
     * @return  string
     */
    protected static function getOutputEncoding()
    {
        $outputEncoding = iconv_get_encoding('output_encoding');
        if ('CP1252' === $outputEncoding && DIRECTORY_SEPARATOR !== '/') {
            $outputEncoding = 'CP850';
        }
        
        return $outputEncoding;
    }
}
?><?php
/**
 * Interface for command executors.
 *
 * @package     stubbles
 * @subpackage  console
 * @version     $Id: stubExecutor.php 2298 2009-08-24 09:25:34Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubOutputStream');
/**
 * Interface for command executors.
 *
 * @package     stubbles
 * @subpackage  console
 */
interface stubExecutor extends stubObject
{
    /**
     * sets the output stream to write data outputted by executed command to
     *
     * @param   stubOutputStream  $out
     * @return  stubExecutor
     */
    public function streamOutputTo(stubOutputStream $out);

    /**
     * returns the output stream to write data outputted by executed command to
     *
     * @return  stubOutputStream
     */
    public function getOutputStream();

    /**
     * executes given command
     *
     * @param   string        $command
     * @return  stubExecutor
     */
    public function execute($command);

    /**
     * executes given command asynchronous
     *
     * The method starts the command, and returns an input stream which can be
     * used to read the output of the command manually.
     *
     * @param   string           $command
     * @return  stubInputStream
     */
    public function executeAsync($command);

    /**
     * executes command directly and returns output as array (each line as one entry)
     *
     * @param   string         $command
     * @return  array<string>
     */
    public function executeDirect($command);
}
?><?php
/**
 * Annotation to mark the default implementation of an interface.
 *
 * @package     stubbles
 * @subpackage  ioc_annotations
 * @version     $Id: stubImplementedByAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAbstractAnnotation',
                      'net::stubbles::reflection::stubReflectionClass'
);
/**
 * Annotation to mark the default implementation of an interface.
 *
 * @package     stubbles
 * @subpackage  ioc_annotations
 */
class stubImplementedByAnnotation extends stubAbstractAnnotation
{
    /**
     * default implementation
     *
     * @var  stubReflectionClass
     */
    protected $defaultImplementation;

    /**
     * sets the list of class names to inject
     *
     * @param  stubReflectionClass  $value
     */
    public function setValue(stubReflectionClass $value)
    {
        $this->defaultImplementation = $value;
    }

    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_CLASS;
    }

    /**
     * Get the default implementation
     *
     * @return  stubReflectionClass
     */
    public function getDefaultImplementation()
    {
        return $this->defaultImplementation;
    }
}
?><?php
/**
 * Annotation to mark a method that is used for dependency injection
 *
 * @package     stubbles
 * @subpackage  ioc_annotations
 * @version     $Id: stubInjectAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAbstractAnnotation');
/**
 * Annotation to mark a method that is used for dependency injection
 *
 * @package     stubbles
 * @subpackage  ioc_annotations
 */
class stubInjectAnnotation extends stubAbstractAnnotation
{
    /**
     * whether the injection is optional
     *
     * @var  boolean
     */
    protected $optional = false;

    /**
     * sets, whether the injection is optional
     *
     * @param  boolean  $optional
     */
    public function setOptional($optional)
    {
        $this->optional = $optional;
    }

    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_METHOD;
    }

    /**
     * Checks, whether the injection is optional
     *
     * @return  boolean
     */
    public function isOptional()
    {
        return $this->optional;
    }
}
?><?php
/**
 * Annotation to name an injection
 *
 * @package     stubbles
 * @subpackage  ioc_annotations
 * @version     $Id: stubNamedAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAbstractAnnotation');
/**
 * Annotation to name an injection
 *
 * @package     stubbles
 * @subpackage  ioc_annotations
 */
class stubNamedAnnotation extends stubAbstractAnnotation
{
    /**
     * Name
     *
     * @var  string
     */
    protected $name;

    /**
     * sets the list of class names to inject
     *
     * @param  string  $value
     */
    public function setValue($value)
    {
        $this->name = $value;
    }

    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_METHOD + stubAnnotation::TARGET_PARAM;
    }

    /**
     * Get the name
     *
     * @return  string
     */
    public function getName()
    {
        return $this->name;
    }
}
?><?php
/**
 * Annotation to mark the default provider of a class.
 *
 * @package     stubbles
 * @subpackage  ioc_annotations
 * @version     $Id: stubProvidedByAnnotation.php 2367 2009-10-30 14:08:41Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAbstractAnnotation',
                      'net::stubbles::reflection::stubReflectionClass'
);
/**
 * Annotation to mark the default provider of a class.
 *
 * @package     stubbles
 * @subpackage  ioc_annotations
 */
class stubProvidedByAnnotation extends stubAbstractAnnotation
{
    /**
     * default implementation
     *
     * @var  string
     */
    protected $providerClassName;

    /**
     * sets the list of class names to inject
     *
     * @param  string|stubReflectionClass  $value
     */
    public function setValue($value)
    {
        if ($value instanceof stubBaseReflectionClass) {
            $this->providerClassName = $value->getFullQualifiedClassName();
        } else {
            $this->providerClassName = $value;
        }
    }

    /**
     * returns the class name of the provider class
     *
     * @return  string
     */
    public function getProviderClassName()
    {
        return $this->providerClassName;
    }

    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_CLASS;
    }
}
?><?php
/**
 * Annotation to mark a class as a singleton.
 *
 * @package     stubbles
 * @subpackage  ioc_annotations
 * @version     $Id: stubSingletonAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAbstractAnnotation');
/**
 * Annotation to mark a class as a singleton.
 *
 * @package     stubbles
 * @subpackage  ioc_annotations
 */
class stubSingletonAnnotation extends stubAbstractAnnotation
{
    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_CLASS;
    }
}
?><?php
/**
 * Binding module to configure the binder with arguments.
 *
 * @package     stubbles
 * @subpackage  ioc_module
 */
stubClassLoader::load('net::stubbles::ioc::module::stubBindingModule');
/**
 * Binding module to configure the binder with arguments.
 *
 * @package     stubbles
 * @subpackage  ioc_module
 */
class stubArgumentsBindingModule extends stubBaseObject implements stubBindingModule
{
    /**
     * list of arguments
     *
     * @var  array<string>
     */
    protected $argv;

    /**
     * constructor
     *
     * @param  array<string>  $argv
     */
    public function __construct(array $argv)
    {
        $this->argv = $argv;
    }

    /**
     * configure the binder
     *
     * @param  stubBinder  $binder
     */
    public function configure(stubBinder $binder)
    {
        foreach ($this->argv as $position => $value) {
            $binder->bindConstant()
                   ->named('argv.' . $position)
                   ->to($value);
        }
    }
}
?><?php
/**
 * Interface for modules which configure the binder.
 *
 * @package     stubbles
 * @subpackage  ioc_module
 * @version     $Id: stubBindingModule.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubBinder');
/**
 * Interface for modules which configure the binder.
 *
 * @package     stubbles
 * @subpackage  ioc_module
 */
interface stubBindingModule extends stubObject
{
    /**
     * configure the binder
     *
     * @param  stubBinder  $binder
     */
    public function configure(stubBinder $binder);
}
?><?php
/**
 * Binding module to configure the binder with a runtime mode.
 *
 * @package     stubbles
 * @subpackage  ioc_module
 * @version     $Id: stubModeBindingModule.php 2627 2010-08-13 13:29:19Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubBinder',
                      'net::stubbles::ioc::module::stubBindingModule',
                      'net::stubbles::lang::stubMode'
);
/**
 * Binding module to configure the binder with a runtime mode.
 *
 * @package     stubbles
 * @subpackage  ioc_module
 */
class stubModeBindingModule extends stubBaseObject implements stubBindingModule
{
    /**
     * mode instance to bind
     *
     * @var  stubMode
     */
    protected $mode;

    /**
     * constructor
     *
     * @param  stubMode  $mode  optional
     */
    public function __construct(stubMode $mode = null)
    {
        if (null === $mode) {
            $mode = $this->getFallbackMode();
        }
        
        $mode->registerErrorHandler();
        $mode->registerExceptionHandler();
        $this->mode = $mode;
    }

    /**
     * returns fallback mode
     *
     * @return  stubMode
     */
    protected function getFallbackMode()
    {
        stubClassLoader::load('net::stubbles::lang::stubDefaultMode');
        return stubDefaultMode::prod();
    }

    /**
     * configure the binder
     *
     * @param  stubBinder  $binder
     */
    public function configure(stubBinder $binder)
    {
        $binder->bind('stubMode')
               ->toInstance($this->mode);
    }
}
?><?php
/**
 * Module to read properties from a file and bind them.
 *
 * @package     stubbles
 * @subpackage  ioc_module
 * @version     $Id: stubPropertiesBindingModule.php 2493 2010-01-26 20:38:06Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::module::stubBindingModule');
/**
 * Module to read properties from a file and bind them.
 *
 * @package     stubbles
 * @subpackage  ioc_module
 */
class stubPropertiesBindingModule extends stubBaseObject implements stubBindingModule
{
    /**
     * project path related data
     */
    const PROJECT     = 'project';
    /**
     * common path related data
     */
    const COMMON      = 'common';
    /**
     * list of pathes
     *
     * @var  array<string,array<string,string>>
     */
    protected $pathes = array(self::PROJECT => array(),
                              self::COMMON  => array()
                        );

    /**
     * constructor
     *
     * @param  string  $projectPath        path to project
     * @param  string  $commonProjectPath  optional  path to common project
     */
    public function __construct($projectPath, $commonProjectPath = null)
    {
        $this->setProjectPath($projectPath);
        if (null == $commonProjectPath) {
            $commonProjectPath = realpath($projectPath . '/../common');
            if (false === $commonProjectPath) {
                return;
            }
        }

        $this->setProjectPath($commonProjectPath, self::COMMON);
    }

    /**
     * static constructor
     *
     * @param   string                       $projectPath        path to project
     * @param   string                       $commonProjectPath  optional  path to common project
     * @return  stubPropertiesBindingModule
     */
    public static function create($projectPath, $commonProjectPath = null)
    {
        return new self($projectPath, $commonProjectPath);
    }

    /**
     * sets project path
     *
     * @param   string                       $projectPath
     * @param   string                       $project
     * @return  stubPropertiesBindingModule
     * @since   1.1.0
     */
    public function setProjectPath($projectPath, $project = self::PROJECT)
    {
        if (substr($projectPath, -1) !== DIRECTORY_SEPARATOR) {
            $projectPath .= DIRECTORY_SEPARATOR;
        }

        return $this->setCachePath($projectPath . 'cache', $project)
                    ->setConfigPath($projectPath . 'config', $project)
                    ->setDataPath($projectPath . 'data', $project)
                    ->setDocrootPath($projectPath . 'docroot', $project)
                    ->setLogPath($projectPath . 'log', $project)
                    ->setPagePath($projectPath . 'pages', $project);
    }

    /**
     * sets cache path
     *
     * @param   string                       $cachePath
     * @param   string                       $project    type of project: project or common
     * @return  stubPropertiesBindingModule
     */
    public function setCachePath($cachePath, $project = self::PROJECT)
    {
        $this->pathes[$project]['cache'] = $cachePath;
        return $this;
    }

    /**
     * sets config path
     *
     * @param   string                       $configPath
     * @return  stubPropertiesBindingModule
     */
    public function setConfigPath($configPath, $project = self::PROJECT)
    {
        $this->pathes[$project]['config'] = $configPath;
        return $this;
    }

    /**
     * sets data path
     *
     * @param   string                       $dataPath
     * @return  stubPropertiesBindingModule
     * @since   1.1.0
     */
    public function setDataPath($dataPath, $project = self::PROJECT)
    {
        $this->pathes[$project]['data'] = $dataPath;
        return $this;
    }

    /**
     * sets docroot path
     *
     * @param   string                       $docrootPath
     * @return  stubPropertiesBindingModule
     * @since   1.1.0
     */
    public function setDocrootPath($docrootPath, $project = self::PROJECT)
    {
        $this->pathes[$project]['docroot'] = $docrootPath;
        return $this;
    }

    /**
     * sets log path
     *
     * @param   string                       $logPath
     * @return  stubPropertiesBindingModule
     */
    public function setLogPath($logPath, $project = self::PROJECT)
    {
        $this->pathes[$project]['log'] = $logPath;
        return $this;
    }

    /**
     * sets page path
     *
     * @param   string                       $pagePath
     * @return  stubPropertiesBindingModule
     */
    public function setPagePath($pagePath, $project = self::PROJECT)
    {
        $this->pathes[$project]['page'] = $pagePath;
        return $this;
    }

    /**
     * configure the binder
     *
     * @param  stubBinder  $binder
     */
    public function configure(stubBinder $binder)
    {
        $this->bindPathes($binder, self::PROJECT)
             ->bindPathes($binder, self::COMMON);
        foreach ($this->getProperties() as $key => $value) {
            $binder->bindConstant()
                   ->named($key)
                   ->to($value);
        }
    }

    /**
     * helper method for binding the pathes
     *
     * @param   stubBinder                   $binder
     * @param   string                       $type
     * @return  stubPropertiesBindingModule
     * @since   1.1.0
     */
    protected function bindPathes(stubBinder $binder, $type)
    {
        foreach ($this->pathes[$type] as $key => $value) {
            $name = 'net.stubbles.' . $key . '.path';
            if (self::COMMON === $type) {
                $name .= '.common';
            }

            $binder->bindConstant()
                   ->named($name)
                   ->to($value);
        }

        return $this;
    }

    /**
     * returns list of properties
     *
     * @return  array<string,scalar>
     */
    protected function getProperties()
    {
        if (file_exists($this->pathes[self::PROJECT]['config'] . DIRECTORY_SEPARATOR . 'config.ini') === false) {
            return array();
        }
        
        return parse_ini_file($this->pathes[self::PROJECT]['config'] . DIRECTORY_SEPARATOR . 'config.ini');
    }
}
?><?php
/**
 * Class for starting the application by configuring the IoC container.
 *
 * @package     stubbles
 * @subpackage  ioc
 * @version     $Id: stubApp.php 2669 2010-08-23 18:57:02Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubBinderRegistry',
                      'net::stubbles::ioc::module::stubArgumentsBindingModule',
                      'net::stubbles::ioc::module::stubBindingModule',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException'
);
/**
 * Class for starting the application by configuring the IoC container.
 *
 * @package     stubbles
 * @subpackage  ioc
 */
class stubApp extends stubBaseObject
{
    /**
     * configures the application using the given binding modules and returns
     * injector so that the bootstrap file can request an instance of the entry
     * class
     *
     * @return  stubInjector
     */
    public static function createInjector()
    {
        return self::createInjectorWithBindings(func_get_args());
    }

    /**
     * configures the application using the given binding modules and returns
     * a front controller instance
     *
     * @return  stubFrontController
     */
    public static function createFrontController()
    {
        return self::createInjectorWithBindings(func_get_args())
                   ->getInstance('net::stubbles::websites::stubFrontController');
    }

    /**
     * creates an object via injection
     *
     * If the class to create an instance of contains a static __bindings() method
     * this method will be used to configure the ioc bindings before using the ioc
     * container to create the instance.
     *
     * @param   string         $fqClassName  full qualified class name of class to create an instance of
     * @param   string         $projectPath  path to project
     * @param   array<string>  $argv         optional  list of arguments
     * @return  object
     */
    public static function createInstance($fqClassName, $projectPath, array $argv = null)
    {
        return self::createInjectorWithBindings(self::getBindingsForClass($fqClassName, $projectPath, $argv))
                   ->getInstance($fqClassName);
    }

    /**
     * creates list of bindings from given class
     *
     * @param   string                           $fqClassName  full qualified class name of class to create an instance of
     * @param   string                           $projectPath  path to project
     * @param   array<string>                    $argv         optional  list of arguments
     * @return  array<string|stubBindingModule>
     * @since   1.3.0
     */
    public static function getBindingsForClass($fqClassName, $projectPath, array $argv = null)
    {
        $nqClassName = stubClassLoader::getNonQualifiedClassName($fqClassName);
        if (class_exists($nqClassName, false) === false) {
            stubClassLoader::load($fqClassName);
        }

        $bindings = array();
        if (method_exists($nqClassName, '__bindings') === true) {
            $bindings = call_user_func_array(array($nqClassName, '__bindings'), array($projectPath));
        }

        if (null !== $argv) {
            $bindings[] = new stubArgumentsBindingModule($argv);
        }

        return $bindings;
    }

    /**
     * configures the application using the given binding modules and returns
     * injector so that the bootstrap file can request an instance of the entry
     * class
     *
     * @param   array<string|stubBindingModule>  $bindingModules
     * @return  stubInjector
     */
    public static function createInjectorWithBindings(array $bindingModules)
    {
        return self::createBinderWithBindings($bindingModules)->getInjector();
    }

    /**
     * configures the application using the given binding modules and returns
     * binder so that the bootstrap file can request an instance of the entry
     * class
     *
     * @param   array<string|stubBindingModule>  $bindingModules
     * @return  stubBinder
     * @throws  stubIllegalArgumentException
     * @since   1.3.0
     */
    public static function createBinderWithBindings(array $bindingModules)
    {
        // use the binder registry for backward compatibility
        $binder = stubBinderRegistry::create();
        foreach ($bindingModules as $bindingModule) {
            if (is_string($bindingModule) === true) {
                $nqClassName = stubClassLoader::getNonQualifiedClassName($bindingModule);
                if (class_exists($nqClassName, false) === false) {
                    stubClassLoader::load($bindingModule);
                }

                $bindingModule = new $nqClassName();
            }

            if (($bindingModule instanceof stubBindingModule) === false) {
                throw new stubIllegalArgumentException('Given module class ' . get_class($bindingModule) . ' is not an instance of net::stubbles::ioc::module::stubBindingModule');
            }

            /* @var  $bindingModule  stubBindingModule */
            $bindingModule->configure($binder);
        }

        // make injector itself available for injection
        $binder->bind('stubInjector')
               ->toInstance($binder->getInjector());
        return $binder;
    }
}
?><?php
/**
 * Binder for the IoC functionality.
 *
 * @package     stubbles
 * @subpackage  ioc
 * @version     $Id: stubBinder.php 2882 2011-01-11 20:54:26Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::stubReflectionClass',
                      'net::stubbles::ioc::stubInjector',
                      'net::stubbles::ioc::stubBindingScope',
                      'net::stubbles::ioc::stubBindingScopes',
                      'net::stubbles::ioc::annotations::stubImplementedByAnnotation',
                      'net::stubbles::ioc::annotations::stubInjectAnnotation',
                      'net::stubbles::ioc::annotations::stubNamedAnnotation',
                      'net::stubbles::ioc::annotations::stubProvidedByAnnotation',
                      'net::stubbles::ioc::annotations::stubSingletonAnnotation'
);
/**
 * Binder for the IoC functionality.
 *
 * @package     stubbles
 * @subpackage  ioc
 */
class stubBinder extends stubBaseObject
{
    /**
     * Injector used by this binder
     *
     * @var  stubInjector
     */
    protected $injector;

    /**
     * Create a new binder
     *
     * @param  stubInjector       $injector  optional
     */
    public function __construct(stubInjector $injector = null)
    {
        if (null === $injector) {
            $this->injector = new stubInjector();
        } else {
            $this->injector = $injector;
        }
    }

    /**
     * sets session to be used with the session scope
     *
     * @param   stubSession  $session
     * @return  stubBinder
     * @since   1.5.0
     */
    public function setSessionForSessionScope(stubSession $session)
    {
        $this->injector->setSessionForSessionScope($session);
        return $this;
    }

    /**
     * Bind a new interface to a class
     *
     * @param   string  $interface
     * @return  stubClassBinding
     */
    public function bind($interface)
    {
        return $this->injector->bind($interface);
    }

    /**
     * Bind a new constant
     *
     * @return  stubConstantBinding
     */
    public function bindConstant()
    {
        return $this->injector->bindConstant();
    }

    /**
     * Get an injector for this binder
     *
     * @return  stubInjector
     */
    public function getInjector()
    {
        return $this->injector;
    }
}
?><?php
/**
 * Helper class to retrieve binder instances from a central place.
 *
 * @package     stubbles
 * @subpackage  ioc
 * @version     $Id: stubBinderRegistry.php 2873 2011-01-10 18:14:31Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubBinder',
                      'net::stubbles::lang::exceptions::stubRuntimeException'
);
/**
 * Helper class to retrieve binder instances from a central place.
 *
 * This registry like class is required as there are still places in applications
 * which can not be reached via dependency injection. Such places can be parts
 * where the framework which does not support dependency injection yet or places
 * where PHP does not give any way at hand to enable dependency injection, i.e.
 * in stream wrappers.
 *
 * @package     stubbles
 * @subpackage  ioc
 * @deprecated  not required any more, will be removed with 1.6.0 or 2.0.0
 */
class stubBinderRegistry extends stubBaseObject
{
    /**
     * binder instance
     *
     * @var  stubBinder
     */
    protected static $binder;

    /**
     * checks if a binder is available
     *
     * @return  bool
     */
    public static function hasInstance()
    {
        return (null !== self::$binder);
    }

    /**
     * sets binder instance to be used
     *
     * This should not be used in applications and is meant for unit tests only.
     *
     * @param  stubBinder  $binder
     */
    public static function set(stubBinder $binder)
    {
        self::$binder = $binder;
    }

    /**
     * retrieves binder instance
     *
     * Throws a runtime exception if no binder instance exists.
     *
     * @return  stubBinder
     * @throws  stubRuntimeException
     */
    public static function get()
    {
        if (null === self::$binder) {
            throw new stubRuntimeException('No instance of net::stubbles::ioc::stubBinder created before.');
        }
        
        return self::$binder;
    }

    /**
     * retrieves binder instance or creates one if none is in registry
     *
     * @return  stubBinder
     */
    public static function create()
    {
        if (null === self::$binder) {
            self::$binder = new stubBinder();
        }
        
        return self::$binder;
    }

    /**
     * clears current binder instance
     *
     * This is mainly for unit tests to be able to restore a clean state and
     * should never be used in applications.
     */
    public static function clear()
    {
        self::$binder = null;
    }
}
?><?php
/**
 * Binding to bind an interface to an implementation
 *
 * @package     stubbles
 * @subpackage  ioc
 * @version     $Id: stubBinding.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Binding to bind an interface to an implementation
 *
 * @package     stubbles
 * @subpackage  ioc
 */
interface stubBinding extends stubObject
{
    /**
     * set the name of the injection
     *
     * @param   string       $name
     * @return  stubBinding
     */
    public function named($name);

    /**
     * returns the created instance
     *
     * @param   string  $type
     * @param   string  $name
     * @return  mixed
     */
    public function getInstance($type, $name);

    /**
     * creates a unique key for this binding
     *
     * @return  string
     */
    public function getKey();
}
?><?php
/**
 * Exception to be thrown in case a binding is invalid or missing
 *
 * @package     stubbles
 * @subpackage  ioc
 * @version     $Id: stubBindingException.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Exception to be thrown in case a binding is invalid or missing
 *
 * @package     stubbles
 * @subpackage  ioc
 */
class stubBindingException extends stubException
{
    // intentionally empty
}
?><?php
/**
 * Interface for all scopes
 *
 * @package     stubbles
 * @subpackage  ioc
 * @version     $Id: stubBindingScope.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjectionProvider',
                      'net::stubbles::reflection::stubBaseReflectionClass'
);
/**
 * Interface for all scopes
 *
 * @package     stubbles
 * @subpackage  ioc
 */
interface stubBindingScope extends stubObject
{
    /**
     * returns the provider that has or creates the required instance
     *
     * @param   stubBaseReflectionClass  $type      type of the object
     * @param   stubBaseReflectionClass  $impl      concrete implementation
     * @param   stubInjectionProvider    $provider
     * @return  object
     */
    public function getInstance(stubBaseReflectionClass $type, stubBaseReflectionClass $impl, stubInjectionProvider $provider);
}
?><?php
/**
 * All built-in scopes.
 *
 * @package     stubbles
 * @subpackage  ioc
 * @version     $Id: stubBindingScopes.php 2882 2011-01-11 20:54:26Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubBindingScopeSession',
                      'net::stubbles::ioc::stubBindingScopeSingleton'
);
/**
 * All built-in scopes.
 *
 * @package     stubbles
 * @subpackage  ioc
 */
class stubBindingScopes extends stubBaseObject
{
    /**
     * scope for singleton objects
     *
     * @var  stubBindingScopeSingleton
     * @deprecated  use asSingleton() instead, will be removed with 1.6.0
     */
    public static $SINGLETON;
    /**
     * scope for session resources
     *
     * @var  stubBindingScopeSession
     * @deprecated  use inSession() instead, will be removed with 1.6.0
     */
    public static $SESSION;
    /**
     * scope for singleton objects
     *
     * @var  stubBindingScope
     */
    protected $singletonScope;
    /**
     * scope for session resources
     *
     * @var  stubBindingScopeSession
     */
    protected $sessionScope;

    /**
     * initialize all built-in scopes
     *
     * @deprecated  not required any more, will be removed with 1.6.0
     */
    public static function __static()
    {
        self::$SINGLETON = new stubBindingScopeSingleton();
        self::$SESSION   = new stubBindingScopeSession();
    }

    /**
     * constructor
     *
     * @param  stubBindingScope  $singletonScope  optional
     * @param  stubBindingScope  $sessionScope    optional
     * @since  1.5.0
     */
    public function  __construct(stubBindingScope $singletonScope = null, stubBindingScope $sessionScope = null)
    {
        if (null === $singletonScope) {
            $this->singletonScope = new stubBindingScopeSingleton();
        } else {
            $this->singletonScope = $singletonScope;
        }

        if (null === $sessionScope) {
            $this->sessionScope = new stubBindingScopeSession();
        } else {
            $this->sessionScope = $sessionScope;
        }

        self::$SINGLETON = $this->singletonScope;
        self::$SESSION   = $this->sessionScope;
    }

    /**
     * returns scope for singleton objects
     *
     * @return  stubBindingScope
     * @since   1.5.0
     */
    public function getSingletonScope()
    {
        return $this->singletonScope;
    }

    /**
     * sets session to be used with the session scope
     *
     * @param   stubSession        $session
     * @return  stubBindingScopes
     * @since   1.5.0
     */
    public function setSessionForSessionScope(stubSession $session)
    {
        $this->sessionScope->setSession($session);
        return $this;
    }

    /**
     * returns scope for session resources
     *
     * @return  stubBindingScope
     * @since   1.5.0
     */
    public function getSessionScope()
    {
        return $this->sessionScope;
    }
}
?><?php
/**
 * Scope for session-bounded singletons.
 *
 * @package     stubbles
 * @subpackage  ioc
 * @version     $Id: stubBindingScopeSession.php 2882 2011-01-11 20:54:26Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubBindingScope',
                      'net::stubbles::ipo::session::stubSession'
);
/**
 * Scope for session-bounded singletons.
 *
 * @package     stubbles
 * @subpackage  ioc
 */
class stubBindingScopeSession extends stubBaseObject implements stubBindingScope
{
    /**
     * session prefix key
     */
    const SESSION_KEY    = 'net.stubbles.ioc.sessionScope#';
    /**
     * session instance to store instances in
     *
     * @var  stubSession
     */
    protected $session;
    /**
     * instances in this scope
     *
     * @var  array<string,object>
     */
    protected $instances = array();

    /**
     * sets the session
     *
     * @param  stubSession  $session
     */
    public function setSession(stubSession $session)
    {
        $this->session = $session;
    }

    /**
     * returns the provider that has or creates the required instance
     *
     * @param   stubBaseReflectionClass  $type      type of the object
     * @param   stubBaseReflectionClass  $impl      concrete implementation
     * @param   stubInjectionProvider    $provider
     * @return  object
     * @throws  stubRuntimeException
     */
    public function getInstance(stubBaseReflectionClass $type, stubBaseReflectionClass $impl, stubInjectionProvider $provider)
    {
        if (null === $this->session) {
            throw new stubRuntimeException('No instance of net::stubbles::ipo::session::stubSession available.');
        }
        
        $key = self::SESSION_KEY . $impl->getName();
        if (isset($this->instances[$key]) === true) {
            return $this->instances[$key];
        }
        
        if ($this->session->hasValue($key) === true) {
            $this->instances[$key] = $this->session->getValue($key);
            return $this->instances[$key];
        }
        
        $this->instances[$key] = $provider->get();
        $this->session->putValue($key, $this->instances[$key]);
        return $this->instances[$key];
    }

    /**
     * clears the instance list
     *
     * @deprecated  not required any more, will be removed with 1.6.0
     */
    public function clearInstances()
    {
        $this->instances = array();
    }
}
?><?php
/**
 * Scope for singletons
 *
 * @package     stubbles
 * @subpackage  ioc
 * @version     $Id: stubBindingScopeSingleton.php 2060 2009-01-26 12:57:25Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubBindingScope');
/**
 * Scope for singletons
 *
 * @package     stubbles
 * @subpackage  ioc
 */
class stubBindingScopeSingleton extends stubBaseObject implements stubBindingScope
{
    /**
     * instances in this scope
     *
     * @var  array<string,object>
     */
    protected $instances = array();

    /**
     * returns the provider that has or creates the required instance
     *
     * @param   stubBaseReflectionClass  $type      type of the object
     * @param   stubBaseReflectionClass  $impl      concrete implementation
     * @param   stubInjectionProvider    $provider
     * @return  object
     */
    public function getInstance(stubBaseReflectionClass $type, stubBaseReflectionClass $impl, stubInjectionProvider $provider)
    {
        $key = $impl->getName();
        if (isset($this->instances[$key]) === false) {
            $this->instances[$key] = $provider->get();
        }
        
        return $this->instances[$key];
    }
}
?><?php
/**
 * Binding to bind an interface to an implementation.
 *
 * @package     stubbles
 * @subpackage  ioc
 * @version     $Id: stubClassBinding.php 2882 2011-01-11 20:54:26Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubBinding',
                      'net::stubbles::ioc::stubBindingException',
                      'net::stubbles::ioc::stubBindingScope',
                      'net::stubbles::ioc::stubBindingScopes',
                      'net::stubbles::ioc::stubDefaultInjectionProvider',
                      'net::stubbles::ioc::stubInjectionProvider',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::reflection::stubBaseReflectionClass',
                      'net::stubbles::reflection::stubReflectionClass'
);
/**
 * Binding to bind an interface to an implementation.
 *
 * Please note that you can do a binding to a class or to an instance, or to an
 * injection provider, or to an injection provider class. These options are
 * mutually exclusive and have a predictive order:
 * 1. Instance
 * 2. Provider instance
 * 3. Provider class
 * 4. Concrete implementation class
 * 
 * @package     stubbles
 * @subpackage  ioc
 */
class stubClassBinding extends stubBaseObject implements stubBinding
{
    /**
     * injector used by this binding
     *
     * @var  stubInjector
     */
    protected $injector      = null;
    /**
     * type for this binding
     *
     * @var  string
     */
    protected $type          = null;
    /**
     * class that implements this binding
     *
     * @var  stubReflectionClass
     */
    protected $impl          = null;
    /**
     * Annotated with a name
     *
     * @var  string
     */
    protected $name          = null;
    /**
     * scope of the binding
     *
     * @var  stubBindingScope
     */
    protected $scope         = null;
    /**
     * instance this type is bound to
     *
     * @var  object
     */
    protected $instance      = null;
    /**
     * provider to use for this binding
     *
     * @var  stubInjectionProvider
     */
    protected $provider      = null;
    /**
     * provider class to use for this binding (will be created via injector)
     *
     * @var  string
     */
    protected $providerClass = null;
    /**
     * list of available binding scopes
     *
     * @var  stubBindingScopes
     */
    protected $scopes;

    /**
     * constructor
     *
     * @param  stubInjector       $injector
     * @param  string             $type
     * @param  stubBindingScopes  $scopes
     */
    public function __construct(stubInjector $injector, $type, stubBindingScopes $scopes)
    {
        $this->injector = $injector;
        $this->type     = $type;
        $this->impl     = $type;
        $this->scopes   = $scopes;
    }

    /**
     * set the concrete implementation
     *
     * @param   stubBaseReflectionClass|string  $impl
     * @return  stubClassBinding
     * @throws  stubIllegalArgumentException
     */
    public function to($impl)
    {
        if (is_string($impl) === false && ($impl instanceof stubBaseReflectionClass) === false) {
            throw new stubIllegalArgumentException('$impl must be a string or an instance of net::stubbles::reflection::stubBaseReflectionClass');
        }
        
        $this->impl = $impl;
        return $this;
    }

    /**
     * set the concrete instance
     *
     * This cannot be used in conjuction with the 'toProvider()' or
     * 'toProviderClass()' method.
     *
     * @param   object            $instance
     * @return  stubClassBinding
     * @throws  stubIllegalArgumentException
     */
    public function toInstance($instance)
    {
        if (($instance instanceof $this->type) === false) {
            throw new stubIllegalArgumentException('Instance of ' . $this->type . ' expectected, ' . get_class($instance) . ' given.');
        }
        
        $this->instance = $instance;
        return $this;
    }

    /**
     * set the provider that should be used to create instances for this binding
     *
     * This cannot be used in conjuction with the 'toInstance()' or
     * 'toProviderClass()' method.
     *
     * @param   stubInjectionProvider  $provider
     * @return  stubClassBinding
     */
    public function toProvider(stubInjectionProvider $provider)
    {
        $this->provider = $provider;
        return $this;
    }

    /**
     * set the provider class that should be used to create instances for this binding
     *
     * This cannot be used in conjuction with the 'toInstance()' or
     * 'toProvider()' method.
     *
     * @param   string            $providerClass
     * @return  stubClassBinding
     */
    public function toProviderClass($providerClass)
    {
        $this->providerClass = $providerClass;
        return $this;
    }

    /**
     * binds the class to the singleton scope
     *
     * @return  stubClassBinding
     * @since   1.5.0
     */
    public function asSingleton()
    {
        $this->scope = $this->scopes->getSingletonScope();
        return $this;
    }

    /**
     * binds the class to the session scope
     *
     * @return  stubClassBinding
     * @since   1.5.0
     */
    public function inSession()
    {
        $this->scope = $this->scopes->getSessionScope();
        return $this;
    }

    /**
     * set the scope
     *
     * @param   stubBindingScope  $scope
     * @return  stubClassBinding
     */
    public function in(stubBindingScope $scope)
    {
        $this->scope = $scope;
        return $this;
    }

    /**
     * Set the name of the injection
     *
     * @param   string            $name
     * @return  stubClassBinding
     */
    public function named($name)
    {
        $this->name = $name;
        return $this;
    }

    /**
     * returns the created instance
     *
     * @param   string  $type
     * @param   string  $name
     * @return  mixed
     * @throws  stubBindingException
     */
    public function getInstance($type, $name)
    {
        if (null !== $this->instance) {
            return $this->instance;
        }
        
        if (is_string($this->impl) === true) {
            $this->impl = new stubReflectionClass($this->impl);
        }

        if (null === $this->scope) {
            if ($this->impl->hasAnnotation('Singleton') === true) {
                $this->scope = $this->scopes->getSingletonScope();
            }
        }
        
        if (null === $this->provider) {
            if (null != $this->providerClass) {
                $provider = $this->injector->getInstance($this->providerClass);
                if (($provider instanceof stubInjectionProvider) === false) {
                    throw new stubBindingException('Configured provider class ' . $this->providerClass . ' for type ' . $this->type . ' is not an instance of net::stubbles::ioc::stubInjectionProvider.');
                }
                
                $this->provider = $provider;
            } else {
                $this->provider = new stubDefaultInjectionProvider($this->injector, $this->impl);
            }
        }

        if (null !== $this->scope) {
            return $this->scope->getInstance(new stubReflectionClass($this->type), $this->impl, $this->provider);
        }
        
        return $this->provider->get($name);
    }

    /**
     * creates a unique key for this binding
     *
     * @return  string
     */
    public function getKey()
    {
        if (null === $this->name) {
            return $this->type;
        }
        
        return $this->type . '#' . $this->name;
    }
}
?><?php
/**
 * Binding to bind a property to a constant value.
 *
 * @package     stubbles
 * @subpackage  ioc
 * @version     $Id: stubConstantBinding.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubBinding');
/**
 * Binding to bind a property to a constant value.
 *
 * @package     stubbles
 * @subpackage  ioc
 */
class stubConstantBinding extends stubBaseObject implements stubBinding
{
    /**
     * This string is used when generating the key for a constant binding.
     */
    const TYPE       = '__CONSTANT__';
    /**
     * annotated with a name
     *
     * @var  string
     */
    protected $name  = null;
    /**
     * value to provide
     *
     * @var  mixed
     */
    protected $value;

    /**
     * set the constant value
     *
     * @param   mixed                $value
     * @return  stubConstantBinding
     */
    public function to($value)
    {
        $this->value = $value;
        return $this;
    }

    /**
     * set the name of the injection
     *
     * @param   string               $name
     * @return  stubConstantBinding
     */
    public function named($name)
    {
        $this->name = $name;
        return $this;
    }

    /**
     * creates a unique key for this binding
     *
     * @return  string
     */
    public function getKey()
    {
        return self::TYPE . '#' . $this->name;
    }

    /**
     * returns the value to provide
     *
     * @param   string  $type
     * @param   string  $name
     * @return  mixed
     */
    public function getInstance($type, $name)
    {
        return $this->value;
    }
}
?><?php
/**
 * Default injection provider.
 *
 * @package     stubbles
 * @subpackage  ioc
 * @version     $Id: stubDefaultInjectionProvider.php 2239 2009-06-16 19:25:52Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjectionProvider',
                      'net::stubbles::ioc::stubInjector'
);
/**
 * Default injection provider.
 *
 * Creates objects and injects all dependencies via the default injector.
 *
 * @package     stubbles
 * @subpackage  ioc
 */
class stubDefaultInjectionProvider extends stubBaseObject implements stubInjectionProvider
{
    /**
     * injector to use for dependencies
     *
     * @var  stubInjector
     */
    protected $injector;
    /**
     * concrete implementation to use
     *
     * @var  stubBaseReflectionClass
     */
    protected $impl;

    /**
     * constructor
     *
     * @param  stubInjector             $injector
     * @param  stubBaseReflectionClass  $impl
     */
    public function __construct(stubInjector $injector, stubBaseReflectionClass $impl)
    {
        $this->injector = $injector;
        $this->impl     = $impl;
    }

    /**
     * returns the value to provide
     *
     * @param   string  $name  optional
     * @return  mixed
     */
    public function get($name = null)
    {
        $constructor = $this->impl->getConstructor();
        if (null === $constructor || $constructor->hasAnnotation('Inject') === false) {
            $instance = $this->impl->newInstance();
        } else {
            $instance = $this->impl->newInstanceArgs($this->injector->getInjectionValuesForMethod($constructor, $this->impl));
        }

        $this->injector->handleInjections($instance, $this->impl);
        return $instance;
    }
}
?><?php
/**
 * Interface for providers that create objects that are required by the
 * Inversion of Control features of Stubbles.
 *
 * @package     stubbles
 * @subpackage  ioc
 */
/**
 * Interface for providers that create objects that are required by the
 * Inversion of Control features of Stubbles.
 *
 * @package     stubbles
 * @subpackage  ioc
 */
interface stubInjectionProvider extends stubObject
{
    /**
     * returns the value to provide
     *
     * @param   string  $name  optional
     * @return  mixed
     */
    public function get($name = null);
}
?><?php
/**
 * Injector for the IoC functionality.
 *
 * @package     stubbles
 * @subpackage  ioc
 * @version     $Id: stubInjector.php 2882 2011-01-11 20:54:26Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubBinding',
                      'net::stubbles::ioc::stubBindingException',
                      'net::stubbles::ioc::stubBindingScopes',
                      'net::stubbles::ioc::stubClassBinding',
                      'net::stubbles::ioc::stubConstantBinding',
                      'net::stubbles::reflection::stubReflectionClass',
                      'net::stubbles::reflection::stubReflectionMethod',
                      'net::stubbles::reflection::stubReflectionParameter'
);
/**
 * Injector for the IoC functionality.
 *
 * Used to create the instances.
 *
 * @package     stubbles
 * @subpackage  ioc
 */
class stubInjector extends stubBaseObject implements stubClonable
{
    /**
     * list of available binding scopes
     *
     * @var  stubBindingScopes
     */
    protected $scopes;
    /**
     * bindings used by the injector that are not yet in the index
     *
     * @var  array<stubBinding>
     */
    protected $bindings   = array();
    /**
     * index for faster access to bindings
     *
     * Do not access this array directly, use getIndex() instead. The binding
     * index is a requirement because the key for a binding is not necessarily
     * complete when the binding is added to the injector.
     *
     * @var  array<string,stubBinding>
     * @see  stubInjector::getIndex()
     */
    private $bindingIndex = array();

    /**
     * constructor
     *
     * @param  stubBindingScopes  $scopes  optional
     * @since  1.5.0
     */
    public function __construct(stubBindingScopes $scopes = null)
    {
        if (null === $scopes) {
            $this->scopes = new stubBindingScopes();
        } else {
            $this->scopes = $scopes;
        }
    }

    /**
     * sets session to be used with the session scope
     *
     * @param   stubSession   $session
     * @return  stubInjector
     * @since   1.5.0
     */
    public function setSessionForSessionScope(stubSession $session)
    {
        $this->scopes->setSessionForSessionScope($session);
        return $this;
    }

    /**
     * adds a new binding to the injector
     *
     * @param   stubBinding  $binding
     * @return  stubBinding
     */
    public function addBinding(stubBinding $binding)
    {
        $this->bindings[] = $binding;
        return $binding;
    }

    /**
     * creates and adds a class binding
     *
     * @param   string            $interface
     * @return  stubClassBinding
     * @since   1.5.0
     */
    public function bind($interface)
    {
        return $this->addBinding(new stubClassBinding($this,
                                                      $interface,
                                                      $this->scopes
                                 )
               );
    }

    /**
     * creates and adds a constanct binding
     *
     * @return  stubConstantBinding
     * @since   1.5.0
     */
    public function bindConstant()
    {
        return $this->addBinding(new stubConstantBinding());
    }

    /**
     * check whether a binding for a type is available (explicit and implicit)
     *
     * @param   string   $type
     * @param   string   $name
     * @return  boolean
     */
    public function hasBinding($type, $name = null)
    {
        return ($this->getBinding($type, $name) != null);
    }

    /**
     * check whether an excplicit binding for a type is available
     *
     * Be aware that implicit bindings turn into explicit bindings when
     * hasBinding() or getInstance() are called.
     *
     * @param   string   $type
     * @param   string   $name
     * @return  boolean
     */
    public function hasExplicitBinding($type, $name = null)
    {
        $bindingIndex = $this->getIndex();
        if (null !== $name) {
            if (isset($bindingIndex[$type . '#' . $name]) === true) {
                return true;
            }
        }

        return isset($bindingIndex[$type]);
    }

    /**
     * get an instance
     *
     * @param   string  $type
     * @param   string  $name
     * @return  object
     * @throws  stubBindingException
     */
    public function getInstance($type, $name = null)
    {
        $binding = $this->getBinding($type, $name);
        if (null === $binding) {
            throw new stubBindingException('No binding for ' . $type . ' defined');
        }
        
        return $binding->getInstance($type, $name);
    }

    /**
     * check whether a constant is available
     *
     * There is no need to distinguish between explicit and implicit binding for
     * constant bindings as there are only explicit constant bindings and never
     * implicit ones.
     *
     * @param   string  $name  name of constant to check for
     * @return  bool
     * @since   1.1.0
     */
    public function hasConstant($name)
    {
        return $this->hasBinding(stubConstantBinding::TYPE, $name);
    }

    /**
     * returns constanct value
     *
     * @param   string  $name  name of constant value to retrieve
     * @return  scalar
     * @since   1.1.0
     */
    public function getConstant($name)
    {
        return $this->getInstance(stubConstantBinding::TYPE, $name);
    }

    /**
     * returns the binding for a name and type
     *
     * @param   string       $type
     * @param   string       $name
     * @return  stubBinding
     */
    protected function getBinding($type, $name = null)
    {
        $bindingIndex = $this->getIndex();
        if (null !== $name) {
            if (isset($bindingIndex[$type . '#' . $name]) === true) {
                return $bindingIndex[$type . '#' . $name];
            }
        }
        
        if (isset($bindingIndex[$type]) === true) {
            return $bindingIndex[$type];
        }
        
        // prevent illegal access to reflection class for constant type
        if (stubConstantBinding::TYPE === $type) {
            return null;
        }
        
        // check for default implementation
        $typeClass = new stubReflectionClass($type);
        if ($typeClass->hasAnnotation('ImplementedBy') === true) {
            return $this->bind($type)
                        ->to($typeClass->getAnnotation('ImplementedBy')
                                       ->getDefaultImplementation()
                          );
        } elseif ($typeClass->hasAnnotation('ProvidedBy') === true) {
            return $this->bind($type)
                        ->toProviderClass($typeClass->getAnnotation('ProvidedBy')
                                                    ->getProviderClassName()
                   );
        }

        // try implicit binding
        if ($typeClass->isInterface() === false) {
            return $this->bind($type)
                        ->to($typeClass);
        }
        
        return null;
    }

    /**
     * returns the binding index
     *
     * @return  array<string,stubBinding>
     */
    protected function getIndex()
    {
        if (empty($this->bindings) === true) {
            return $this->bindingIndex;
        }
        
        foreach ($this->bindings as $binding) {
            $this->bindingIndex[$binding->getKey()] = $binding;
        }
        
        $this->bindings = array();
        return $this->bindingIndex;
    }

    /**
     * handle injections for given instance
     *
     * @param   object                   $instance
     * @param   stubBaseReflectionClass  $class     optional
     * @throws  stubBindingException
     */
    public function handleInjections($instance, stubBaseReflectionClass $class = null)
    {
        if (null === $class) {
            $class = new stubReflectionClass(get_class($instance));
        }
        
        foreach ($class->getMethods() as $method) {
            /* @var  $method  stubReflectionMethod */
            if ($method->isPublic() === false || strncmp($method->getName(), '__', 2) === 0 || $method->hasAnnotation('Inject') === false) {
                continue;
            }

            try {
                $paramValues = $this->getInjectionValuesForMethod($method, $class);
            } catch (stubBindingException $be) {
                if ($method->getAnnotation('Inject')->isOptional() === false) {
                    throw $be;
                }
                
                continue;
            }

            $method->invokeArgs($instance, $paramValues);
        }
    }

    /**
     * returns a list of all injection values for given method
     *
     * @param   stubReflectionMethod     $method
     * @param   stubBaseReflectionClass  $class
     * @return  array<mixed>
     * @throws  stubBindingException
     */
    public function getInjectionValuesForMethod(stubReflectionMethod $method, stubBaseReflectionClass $class)
    {
        $paramValues = array();
        $namedMethod = (($method->hasAnnotation('Named') === true) ? ($method->getAnnotation('Named')->getName()) : (null));
        foreach ($method->getParameters() as $param) {
            /* @var  $param  stubReflectionParameter */
            $paramClass = $param->getClass();
            $type       = ((null !== $paramClass) ? ($paramClass->getName()) : (stubConstantBinding::TYPE));
            $name       = (($param->hasAnnotation('Named') === true) ? ($param->getAnnotation('Named')->getName()) : ($namedMethod));
            if ($this->hasExplicitBinding($type, $name) === false && $method->getAnnotation('Inject')->isOptional() === true) {
                // Somewhat hackish... throwing an exception here which is catched and ignored in handleInjections()
                throw new stubBindingException('Could not find explicit binding for optional injection of type ' . $this->createTypeMessage($type, $name) . ' to complete  ' . $this->createCalledMethodMessage($class, $method, $param, $type));
            }
            
            if ($this->hasBinding($type, $name) === false) {
                $typeMsg = $this->createTypeMessage($type, $name);
                throw new stubBindingException('Can not inject into ' . $this->createCalledMethodMessage($class, $method, $param, $type)  . '. No binding for type ' . $typeMsg . ' specified.');
            }
            
            $paramValues[] = $this->getInstance($type, $name);
        }
        
        return $paramValues;
    }

    /**
     * creates the complete type message
     *
     * @param   string  $type  type to create message for
     * @param   string  $name  name of named parameter
     * @return  string
     */
    protected function createTypeMessage($type, $name)
    {
        return ((null !== $name) ? ($type . ' (named "' . $name . '")') : ($type));
    }

    /**
     * creates the called method message
     *
     * @param   stubBaseReflectionClass  $class
     * @param   stubReflectionMethod     $method
     * @param   stubReflectionParameter  $parameter
     * @param   string                   $type
     * @return  string
     */
    protected function createCalledMethodMessage(stubBaseReflectionClass $class, stubReflectionMethod $method, stubReflectionParameter $parameter, $type)
    {
        $message = $class->getFullQualifiedClassName() . '::' . $method->getName() . '(';
        if (stubConstantBinding::TYPE !== $type) {
            $message .= $type . ' ';
        } elseif ($parameter->isArray() === true) {
            $message .= 'array ';
        }
        
        return $message . '$' . $parameter->getName() . ')';
    }
}
?><?php
/**
 * Simple injection provider for a single predefined value.
 *
 * @package     stubbles
 * @subpackage  ioc
 * @version     $Id: stubValueInjectionProvider.php 2060 2009-01-26 12:57:25Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjectionProvider');
/**
 * Simple injection provider for a single predefined value.
 *
 * @package     stubbles
 * @subpackage  ioc
 */
class stubValueInjectionProvider extends stubBaseObject implements stubInjectionProvider
{
    /**
     * value to provide
     *
     * @var  mixed
     */
    protected $value;

    /**
     * constructor
     *
     * @param  mixed  $value  value to provide
     */
    public function __construct($value)
    {
        $this->value = $value;
    }

    /**
     * returns the value to provide
     *
     * @param   string  $name  optional
     * @return  mixed
     */
    public function get($name = null)
    {
        return $this->value;
    }
}
?><?php
/**
 * Post Interceptor which adds an ETag header to the
 * response to avoid dispensable traffic and save download
 * time for the user.
 *
 * @package     stubbles
 * @subpackage  ipo_interceptors
 * @version     $Id: stubETagPostInterceptor.php 2899 2011-01-12 02:06:32Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::interceptors::stubPostInterceptor');
/**
 * Post Interceptor which adds an ETag header to the
 * response to avoid dispensable traffic and save download
 * time for the user.
 *
 * @package     stubbles
 * @subpackage  ipo_interceptors
 * @link        http://www.w3.org/Protocols/rfc2616/rfc2616.html  RFC 2616  Hypertext Transfer Protocol -- HTTP/1.1 (mainly section 14)
 * @link        http://betterexplained.com/articles/how-to-optimize-your-site-with-http-caching/
 */
class stubETagPostInterceptor extends stubBaseObject implements stubPostInterceptor
{
    /**
     * does the postprocessing stuff
     *
     * @param  stubRequest   $request   access to request data
     * @param  stubSession   $session   access to session data
     * @param  stubResponse  $response  access to response data
     */
    public function postProcess(stubRequest $request, stubSession $session, stubResponse $response)
    {
        // the double quotes are part of an ETag
        $etag = '"'.md5(serialize($response->getData())).'"';
        $response->addHeader('ETag', $etag);

        // these headers interfere with the ETag header,
        // therefore they must be overidden
        $response->addHeader('Cache-Control', 'private');  // HTTP 1.1
        $response->addHeader('Pragma', '');                // HTTP 1.0 (for backward compatibility)

        if ($request->validateHeader('HTTP_IF_NONE_MATCH')->isEqualTo($etag) === true) {
            $response->setStatusCode(304);
            $response->clearData();
        }
    }
}
?><?php
/**
 * Interface for initializing the interceptors.
 *
 * @package     stubbles
 * @subpackage  ipo_interceptors
 * @version     $Id: stubInterceptorInitializer.php 2670 2010-08-23 18:58:24Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::interceptors::stubPostInterceptor',
                      'net::stubbles::ipo::interceptors::stubPreInterceptor',
                      'net::stubbles::lang::initializer::stubInitializer'
);
/**
 * Interface for initializing the interceptors.
 *
 * @package     stubbles
 * @subpackage  ipo_interceptors
 */
interface stubInterceptorInitializer extends stubInitializer
{
    /**
     * sets the descriptor that identifies the initializer
     *
     * @param   string                      $descriptor
     * @return  stubInterceptorInitializer
     */
    public function setDescriptor($descriptor);

    /**
     * returns the list of pre interceptors
     *
     * @return  array<stubPreInterceptor>
     */
    public function getPreInterceptors();

    /**
     * returns the list of post interceptors
     *
     * @return  array<stubPostInterceptor>
     */
    public function getPostInterceptors();
}
?><?php
/**
 * interface for postinterceptors
 *
 * @package     stubbles
 * @subpackage  ipo_interceptors
 * @version     $Id: stubPostInterceptor.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::response::stubResponse',
                      'net::stubbles::ipo::session::stubSession'
);
/**
 * interface for postinterceptors
 * 
 * Postinterceptors are called after all data processing is done. They can change
 * the response or add additional data to the response.
 *
 * @package     stubbles
 * @subpackage  ipo_interceptors
 */
interface stubPostInterceptor extends stubObject
{
    /**
     * does the postprocessing stuff
     *
     * @param  stubRequest   $request   access to request data
     * @param  stubSession   $session   access to session data
     * @param  stubResponse  $response  access to response data
     */
    public function postProcess(stubRequest $request, stubSession $session, stubResponse $response);
}
?><?php
/**
 * interface for preinterceptors
 *
 * @package     stubbles
 * @subpackage  ipo_interceptors
 * @version     $Id: stubPreInterceptor.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::response::stubResponse',
                      'net::stubbles::ipo::session::stubSession'
);
/**
 * interface for preinterceptors
 * 
 * Preinterceptors are called after all initializations have been done and
 * before processing of data starts.
 *
 * @package     stubbles
 * @subpackage  ipo_interceptors
 */
interface stubPreInterceptor extends stubObject
{
    /**
     * does the preprocessing stuff
     *
     * @param  stubRequest   $request   access to request data
     * @param  stubSession   $session   access to session data
     * @param  stubResponse  $response  access to response data
     */
    public function preProcess(stubRequest $request, stubSession $session, stubResponse $response);
}
?><?php
/**
 * Class for initializing the interceptors from a property file.
 *
 * @package     stubbles
 * @subpackage  ipo_interceptors
 * @version     $Id: stubPropertyBasedInterceptorInitializer.php 2670 2010-08-23 18:58:24Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjector',
                      'net::stubbles::ipo::interceptors::stubInterceptorInitializer',
                      'net::stubbles::lang::stubProperties'
);
/**
 * Class for initializing the interceptors from a property file.
 *
 * @package     stubbles
 * @subpackage  ipo_interceptors
 * @since       1.1.0
 */
class stubPropertyBasedInterceptorInitializer extends stubBaseObject implements stubInterceptorInitializer
{
    /**
     * descriptor that identifies the initializer
     *
     * @var  string
     */
    protected $descriptor        = 'interceptors';
    /**
     * injector instance to create single interceptors with
     *
     * @var  stubInjector
     */
    protected $injector;
    /**
     * path to config files
     *
     * @var  string
     */
    protected $configPath;
    /**
     * interceptor properties
     *
     * @var  stubProperties
     */
    protected $interceptorConfig;

    /**
     * constructor
     *
     * @param  stubInjector  $injector
     * @param  string        $configPath
     * @Inject
     * @Named{configPath}('net.stubbles.config.path')
     */
    public function  __construct(stubInjector $injector, $configPath)
    {
        $this->injector   = $injector;
        $this->configPath = $configPath;
    }

    /**
     * sets the descriptor that identifies the initializer
     *
     * @param   string                      $descriptor
     * @return  stubInterceptorInitializer
     */
    public function setDescriptor($descriptor)
    {
        $this->descriptor = $descriptor;
        return $this;
    }

    /**
     * initializing method
     *
     * @return  stubInitializer
     */
    public function init()
    {
        $this->interceptorConfig = stubProperties::fromFile($this->configPath . '/' . $this->descriptor . '.ini');
        return $this;
    }

    /**
     * returns the list of pre interceptors
     *
     * @return  array<stubPreInterceptor>
     * @throws  stubIllegalStateException
     */
    public function getPreInterceptors()
    {
        if (null === $this->interceptorConfig) {
            throw new stubIllegalStateException('Uninitialized state, call init() method first.');
        }

        return $this->getInterceptors('preinterceptors');
    }

    /**
     * returns the list of post interceptors
     *
     * @return  array<stubPostInterceptor>
     * @throws  stubIllegalStateException
     */
    public function getPostInterceptors()
    {
        if (null === $this->interceptorConfig) {
            throw new stubIllegalStateException('Uninitialized state, call init() method first.');
        }
        
        return $this->getInterceptors('postinterceptors');
    }

    /**
     * creates list of interceptor instances from list of interceptor class names
     * using the injector
     *
     * @param   string  $section
     * @return  array<stubPreInterceptor|stubPostInterceptor>
     */
    protected function getInterceptors($section)
    {
        $interceptors = array();
        foreach ($this->interceptorConfig->getSection($section) as $interceptorClassName) {
            $interceptors[] = $this->injector->getInstance($interceptorClassName);
        }

        return $interceptors;
    }
}
?><?php
/**
 * Decorator for lazy loading of pre interceptors: load and execute a pre
 * interceptor only if a specific request param is set.
 *
 * @package     stubbles
 * @subpackage  ipo_interceptors
 * @version     $Id: stubRequestPreInterceptor.php 2632 2010-08-13 18:31:42Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::interceptors::stubPreInterceptor');
/**
 * Decorator for lazy loading of pre interceptors: load and execute a pre
 * interceptor only if a specific request param is set.
 *
 * @package     stubbles
 * @subpackage  ipo_interceptors
 */
class stubRequestPreInterceptor extends stubSerializableObject implements stubPreInterceptor
{
    /**
     * class name of the decorated pre interceptor
     *
     * @var  string
     */
    protected $decoratedPreInterceptor;
    /**
     * name of the request param from which the decorated pre interceptor is dependend
     *
     * @var  string
     */
    protected $requestParamName;

    /**
     * constructor
     *
     * @param  string  $decoratedPreInterceptor  class name of the decorated pre interceptor
     * @param  string  $requestParamName         name of the request param from which the decorated pre interceptor is dependend
     */
    public function __construct($decoratedPreInterceptor, $requestParamName)
    {
        $this->decoratedPreInterceptor = $decoratedPreInterceptor;
        $this->requestParamName        = $requestParamName;
        
    }

    /**
     * returns class name of the decorated pre interceptor
     *
     * @return  string
     */
    public function getDecoratedPreInterceptor()
    {
        return $this->decoratedPreInterceptor;
    }

    /**
     * returns name of the request param from which the decorated pre interceptor is dependend
     *
     * @return  string
     */
    public function getRequestParamName()
    {
        return $this->requestParamName;
    }

    /**
     * does the preprocessing stuff
     *
     * @param  stubRequest   $request   access to request data
     * @param  stubSession   $session   access to session data
     * @param  stubResponse  $response  access to response data
     */
    public function preProcess(stubRequest $request, stubSession $session, stubResponse $response)
    {
        if ($request->hasParam($this->requestParamName) === false) {
            return;
        }
        
        $nqClassName = stubClassLoader::getNonQualifiedClassName($this->decoratedPreInterceptor);
        if (class_exists($nqClassName, false) === false) {
            stubClassLoader::load($this->decoratedPreInterceptor);
        }
            
        $interceptor = new $nqClassName();
        $interceptor->preProcess($request, $session, $response);
    }
}
?><?php
/**
 * Module to configure the binder with default instances for request, session and response.
 *
 * @package     stubbles
 * @subpackage  ipo_ioc
 * @version     $Id: stubIpoBindingModule.php 2899 2011-01-12 02:06:32Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::module::stubBindingModule',
                      'net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::response::stubResponse'
);
/**
 * Module to configure the binder with default instances for request, session and response.
 *
 * @package     stubbles
 * @subpackage  ipo_ioc
 */
class stubIpoBindingModule extends stubBaseObject implements stubBindingModule
{
    /**
     * list of filters to provide via filter factory
     *
     * @var  array<string,string>
     */
    protected $typeFilter        = array('int'      => 'net::stubbles::ipo::request::filter::stubIntegerFilter',
                                         'integer'  => 'net::stubbles::ipo::request::filter::stubIntegerFilter',
                                         'double'   => 'net::stubbles::ipo::request::filter::stubFloatFilter',
                                         'float'    => 'net::stubbles::ipo::request::filter::stubFloatFilter',
                                         'string'   => 'net::stubbles::ipo::request::filter::stubStringFilter',
                                         'text'     => 'net::stubbles::ipo::request::filter::stubTextFilter',
                                         'json'     => 'net::stubbles::ipo::request::filter::stubJsonFilter',
                                         'password' => 'net::stubbles::ipo::request::filter::stubPasswordFilter',
                                         'http'     => 'net::stubbles::ipo::request::filter::stubHTTPURLFilter',
                                         'date'     => 'net::stubbles::ipo::request::filter::stubDateFilter',
                                         'mail'     => 'net::stubbles::ipo::request::filter::stubMailFilter'
                                   );
    /**
     * name for the session
     *
     * @var  string
     */
    protected $sessionName;
    /**
     * request class to be used
     *
     * @var  string
     */
    protected $requestClassName  = 'net::stubbles::ipo::request::stubWebRequest';
    /**
     * response class to be used
     *
     * @var  string
     */
    protected $responseClassName = 'net::stubbles::ipo::response::stubBaseResponse';
    /**
     * session class to be used
     *
     * @var  string
     */
    protected $sessionClassName  = 'net::stubbles::ipo::session::stubPHPSession';

    /**
     * constructor
     *
     * @param  string  $sessionName  optional  name for the session
     */
    public function __construct($sessionName = 'PHPSESSID')
    {
        $this->sessionName = $sessionName;
    }

    /**
     * static constructor
     *
     * @param   string                $sessionName  optional  name for the session
     * @return  stubIpoBindingModule
     * @since   1.3.0
     */
    public static function create($sessionName = 'PHPSESSID')
    {
        return new self($sessionName);
    }

    /**
     * sets class name of request class to be used
     *
     * @param   string                $requestClassName  name of request class to bind
     * @return  stubIpoBindingModule
     * @since   1.1.0
     */
    public function setRequestClassName($requestClassName)
    {
        $this->requestClassName = $requestClassName;
        return $this;
    }

    /**
     * sets class name of response class to be used
     *
     * @param   string                $responseClassName  name of request class to bind
     * @return  stubIpoBindingModule
     * @since   1.1.0
     */
    public function setResponseClassName($responseClassName)
    {
        $this->responseClassName = $responseClassName;
        return $this;
    }

    /**
     * sets class name of session class to be used
     *
     * @param   string                $sessionClassName  name of session class to bind
     * @return  stubIpoBindingModule
     * @since   1.1.0
     */
    public function setSessionClassName($sessionClassName)
    {
        $this->sessionClassName = $sessionClassName;
        return $this;
    }

    /**
     * adds a filter class for a given type
     *
     * @param   string                $filterClassName  full qualified class name of filter class
     * @param   string                $type             name of type the filter is added for
     * @return  stubIpoBindingModule
     * @since   1.3.0
     */
    public function addFilterForType($filterClassName, $type)
    {
        $this->typeFilter[$type] = $filterClassName;
        return $this;
    }

    /**
     * configure the binder
     *
     * @param  stubBinder  $binder
     */
    public function configure(stubBinder $binder)
    {
        $binder->bindConstant()
               ->named('net.stubbles.ipo.request.filter.types')
               ->to($this->typeFilter);
        $request     = $this->createRequest($binder->getInjector()->getInstance('stubFilterFactory'));
        $response    = $this->createResponse();
        $httpVersion = $request->readHeader('SERVER_PROTOCOL')->unsecure();
        $minor       = null;
        if (2 != sscanf($httpVersion, 'HTTP/%*[1].%[01]', $minor)) {
            $response->setStatusCode(505);
            $response->write('Unsupported HTTP protocol version "' . $httpVersion . '", expected HTTP/1.0 or HTTP/1.1' . "\n");
            $request->cancel();
        } else {
            $response->setVersion('1.' . $minor);
        }
        
        $session  = $this->createSession($request, $response);
        $binder->setSessionForSessionScope($session);
        $binder->bind('stubRequest')
               ->toInstance($request);
        $binder->bind('stubSession')
               ->toInstance($session);
        $binder->bind('stubResponse')
               ->toInstance($response);
        $binder->bindConstant()
               ->named('net.stubbles.session.name')
               ->to($this->sessionName);
    }

    /**
     * creates request instance
     *
     * @param   stubFilterFactory  $filterFactory
     * @return  stubRequest
     */
    protected function createRequest(stubFilterFactory $filterFactory)
    {
        $nqClassName = stubClassLoader::getNonQualifiedClassName($this->requestClassName);
        if (class_exists($nqClassName, false) === false) {
            stubClassLoader::load($this->requestClassName);
        }
        
        return new $nqClassName($filterFactory);
    }

    /**
     * creates response instance
     *
     * @return  stubResponse
     */
    protected function createResponse()
    {
        $nqClassName = stubClassLoader::getNonQualifiedClassName($this->responseClassName);
        if (class_exists($nqClassName, false) === false) {
            stubClassLoader::load($this->responseClassName);
        }
        
        return new $nqClassName();
    }

    /**
     * creates session instance
     *
     * @param   stubRequest   $request
     * @param   stubResponse  $response
     * @return  stubSession
     */
    protected function createSession(stubRequest $request, stubResponse $response)
    {
        $nqClassName = stubClassLoader::getNonQualifiedClassName($this->sessionClassName);
        if (class_exists($nqClassName, false) === false) {
            stubClassLoader::load($this->sessionClassName);
        }
        
        return new $nqClassName($request, $response, $this->sessionName);
    }
}
?><?php
/**
 * Abstract base class for filter annotations.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 * @version     $Id: stubAbstractFilterAnnotation.php 2676 2010-08-23 20:48:08Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::broker::stubRequestBrokerException',
                      'net::stubbles::ipo::request::broker::annotations::stubFilterAnnotation',
                      'net::stubbles::ipo::request::filter::stubDefaultValueFilterDecorator',
                      'net::stubbles::ipo::request::filter::stubRequiredFilterDecorator',
                      'net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation',
                      'net::stubbles::reflection::stubReflectionClass'
);
/**
 * Abstract base class for filter annotations.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 */
abstract class stubAbstractFilterAnnotation extends stubAbstractAnnotation implements stubFilterAnnotation
{
    /**
     * the name of the request variable
     *
     * @var  string
     */
    protected $fieldName;
    /**
     * reflection instance of request value error factory to use
     * 
     * @var  stubReflectionClass
     */
    protected $rveFactoryClass;
    /**
     * the created rve factory
     *
     * @var  stubRequestValueErrorFactory
     */
    protected $rveFactory      = null;
    /**
     * switch whether the value is required or not
     *
     * @var  bool
     */
    protected $isRequired      = true;
    /**
     * the default value in case given value not set
     *
     * @var  mixed
     */
    protected $defaultValue    = null;

    /**
     * the name of the request variable
     *
     * @param  string  $fieldName
     */
    public function setFieldName($fieldName)
    {
        $this->fieldName = $fieldName;
    }

    /**
     * returns the name of the request variable
     *
     * @return  string
     */
    public function getFieldName()
    {
        return $this->fieldName;
    }

    /**
     * sets the reflection instance of request value error factory to use
     *
     * @param  stubReflectionClass  $rveFactoryClass
     */
    public function setRVEFactoryClass(stubReflectionClass $rveFactoryClass)
    {
        $this->rveFactoryClass = $rveFactoryClass;
    }

    /**
     * sets whether the value is required or not
     *
     * @param  bool  $isRequired
     */
    public function setRequired($isRequired)
    {
        $this->isRequired = $isRequired;
    }

    /**
     * set a default value in case the value to filter is not set
     *
     * @param  mixed  $defaultValue
     */
    public function setDefaultValue($defaultValue)
    {
        $this->defaultValue = $defaultValue;
    }

    /**
     * returns the filter defined by the annotation
     *
     * @return  stubFilter
     * @throws  stubRequestBrokerException
     */
    public function getFilter()
    {
        $filter = $this->doGetFilter();
        if (true === $this->isRequired) {
            $filter = new stubRequiredFilterDecorator($filter, $this->createRVEFactory());
        }
        
        if (null !== $this->defaultValue) {
            $filter = new stubDefaultValueFilterDecorator($filter, $this->defaultValue);
        }
        
        return $filter;
    }

    /**
     * returns the filter defined by the annotation
     *
     * @return  stubFilter
     * @throws  stubException
     */
    protected abstract function doGetFilter();

    /**
     * helper method to create a new instance of the request value error factory to use
     *
     * @return  stubRequestValueErrorFactory
     * @throws  stubRequestBrokerException
     */
    protected function createRVEFactory()
    {
        if (null !== $this->rveFactory) {
            return $this->rveFactory;
        }
        
        if (null != $this->rveFactoryClass) {
            $rveFactory = $this->rveFactoryClass->newInstance();
            if (($rveFactory instanceof stubRequestValueErrorFactory) === false) {
                throw new stubRequestBrokerException('Created request value error factory is not an instance of stubRequestValueErrorFactory');
            }
            
            $this->rveFactory = $rveFactory;
        } else {
            stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueErrorPropertiesFactory');
            $this->rveFactory = new stubRequestValueErrorPropertiesFactory();
        }
        
        return $this->rveFactory;
    }

    /**
     * returns the target of the annotation as bitmap
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_METHOD + stubAnnotation::TARGET_PROPERTY + stubAnnotation::TARGET_PARAM;
    }
}
?><?php
/**
 * Filter annotation for strings.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 * @version     $Id: stubAbstractStringFilterAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubAbstractFilterAnnotation',
                      'net::stubbles::ipo::request::filter::stubEncodingFilterDecorator',
                      'net::stubbles::ipo::request::filter::stubLengthFilterDecorator',
                      'net::stubbles::ipo::request::validator::stubMaxLengthValidator',
                      'net::stubbles::ipo::request::validator::stubMinLengthValidator',
                      'net::stubbles::php::string::stubStringEncoder'
);
/**
 * Filter annotation for strings.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 */
abstract class stubAbstractStringFilterAnnotation extends stubAbstractFilterAnnotation implements stubAnnotation
{
    /**
     * minimum length of the string
     *
     * @var  int
     */
    protected $minLength;
    /**
     * the error id to use in case min length validation fails
     *
     * @var  string
     */
    protected $minLengthErrorId;
    /**
     * maximum length of the string
     *
     * @var  int
     */
    protected $maxLength;
    /**
     * the error id to use in case max length validation fails
     *
     * @var  string
     */
    protected $maxLengthErrorId;
    /**
     * the encoder class to be used
     *
     * @var  stubReflectionClass
     */
    protected $encoderClass = null;
    /**
     * the encoding mode to be applied
     *
     * @var  int
     */
    protected $encoderMode  = stubStringEncoder::MODE_DECODE;

    /**
     * checks if the regex property is set and if the encoder mode is correct
     *
     * @throws  ReflectionException
     */
    public function finish()
    {
        if (null !== $this->encoderClass && in_array($this->encoderMode, array(stubStringEncoder::MODE_DECODE, stubStringEncoder::MODE_ENCODE)) === false) {
            throw new ReflectionException('Can not use ' . $this->getClassName() . ' with wrong encoder mode ' . $this->encoderMode);
        }
    }

    /**
     * sets the minimum length of the string
     *
     * @param  int  $minLength
     */
    public function setMinLength($minLength)
    {
        $this->minLength = $minLength;
    }

    /**
     * sets the error id to use in case min length validation fails
     *
     * @param  string  $minLengthErrorId
     */
    public function setMinLengthErrorId($minLengthErrorId)
    {
        $this->minLengthErrorId = $minLengthErrorId;
    }

    /**
     * sets the maximum length of the string
     *
     * @param  int  $maxLength
     */
    public function setMaxLength($maxLength)
    {
        $this->maxLength = $maxLength;
    }

    /**
     * sets the error id to use in case max length validation fails
     *
     * @param  string  $maxLengthErrorId
     */
    public function setMaxLengthErrorId($maxLengthErrorId)
    {
        $this->maxLengthErrorId = $maxLengthErrorId;
    }

    /**
     * sets the encoder class to be used
     *
     * @param  stubReflectionClass  $encoderClass
     */
    public function setEncoder(stubReflectionClass $encoderClass)
    {
        $this->encoderClass = $encoderClass;
    }

    /**
     * sets the encoder mode to be used
     *
     * @param  int  $mode
     */
    public function setEncoderMode($mode)
    {
        $this->encoderMode = $mode;
    }

    /**
     * returns the filter defined by the annotation
     *
     * @return  stubFilter
     */
    protected function doGetFilter()
    {
        $filter = $this->doDoGetFilter();
        if (null !== $this->minLength || null !== $this->maxLength) {
            $filter = new stubLengthFilterDecorator($filter, $this->createRVEFactory());
            if (null !== $this->minLength) {
                $filter->setMinLengthValidator(new stubMinLengthValidator($this->minLength), $this->minLengthErrorId);
            }
            
            if (null !== $this->maxLength) {
                $filter->setMaxLengthValidator(new stubMaxLengthValidator($this->maxLength), $this->maxLengthErrorId);
            }
        }
        
        if (null !== $this->encoderClass) {
            $filter = new stubEncodingFilterDecorator($filter, $this->encoderClass->newInstance(), $this->encoderMode);
        }
        
        return $filter;
    }

    /**
     * returns the filter defined by the annotation
     *
     * @return  stubFilter
     */
    protected abstract function doDoGetFilter();
}
?><?php
/**
 * Filter annotation for boolean values.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 * @version     $Id: stubBoolFilterAnnotation.php 2506 2010-03-01 14:28:18Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::ipo::request::filter::stubBoolFilter',
                      'net::stubbles::ipo::request::broker::annotations::stubAbstractFilterAnnotation'
);
/**
 * Filter annotation for boolean values.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 * @since       1.2.0
 */
class stubBoolFilterAnnotation extends stubAbstractFilterAnnotation implements stubAnnotation
{
    /**
     * returns the filter defined by the annotation
     *
     * @return  stubBoolFilter
     */
    protected function doGetFilter()
    {
        return new stubBoolFilter();
    }
}
?><?php
/**
 * Filter annotation for dates.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 * @version     $Id: stubDateFilterAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::broker::annotations::stubAbstractFilterAnnotation',
                      'net::stubbles::ipo::request::filter::stubDateFilter',
                      'net::stubbles::ipo::request::filter::stubPeriodFilterDecorator',
                      'net::stubbles::lang::types::stubDate',
                      'net::stubbles::reflection::stubBaseReflectionClass',
                      'net::stubbles::reflection::annotations::stubAnnotation'
);
/**
 * Filter annotation for dates.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 */
class stubDateFilterAnnotation extends stubAbstractFilterAnnotation implements stubAnnotation
{
    /**
     * minimum date
     *
     * @var  stubDate
     */
    protected $minDate;
    /**
     * minimum date provider class
     *
     * @var  stubBaseReflectionClass
     */
    protected $minDateProviderClass;
    /**
     * minimum date provider method
     *
     * @var  string
     */
    protected $minDateProviderMethod = 'getMinDate';
    /**
     * the error id to use in case min date validation fails
     *
     * @var  string
     */
    protected $minDateErrorId;
    /**
     * maximum date
     *
     * @var  stubDate
     */
    protected $maxDate;
    /**
     * maximum date provider class
     *
     * @var  stubBaseReflectionClass
     */
    protected $maxDateProviderClass;
    /**
     * maximum date provider method
     *
     * @var  string
     */
    protected $maxDateProviderMethod = 'getMaxDate';
    /**
     * the error id to use in case max date validation fails
     *
     * @var  string
     */
    protected $maxDateErrorId;
    /**
     * format for dates in error messages
     *
     * @var  string
     */
    protected $dateFormat;

    /**
     * sets the minimum date
     *
     * @param  int|string|stubDate  $minDate
     */
    public function setMinDate($minDate)
    {
        if (($minDate instanceof stubDate) === false) {
            $minDate = new stubDate($minDate);
        }

        $this->minDate = $minDate;
    }

    /**
     * sets the minimum date provider class
     *
     * @param  stubBaseReflectionClass  $minDateProviderClass
     */
    public function setMinDateProviderClass(stubBaseReflectionClass $minDateProviderClass)
    {
        $this->minDateProviderClass = $minDateProviderClass;
    }

    /**
     * sets the minimum date provider method
     *
     * @param  string  $minDateProviderMethod
     */
    public function setMinDateProviderMethod($minDateProviderMethod)
    {
        $this->minDateProviderMethod = $minDateProviderMethod;
    }

    /**
     * sets the error id to use in case min date validation fails
     *
     * @param  string  $minDateErrorId
     */
    public function setMinDateErrorId($minDateErrorId)
    {
        $this->minDateErrorId = $minDateErrorId;
    }

    /**
     * sets the maximum date
     *
     * @param  int|string|stubDate  $maxDate
     */
    public function setMaxDate($maxDate)
    {
        if (($maxDate instanceof stubDate) === false) {
            $maxDate = new stubDate($maxDate);
        }

        $this->maxDate = $maxDate;
    }

    /**
     * sets the maximum date provider class
     *
     * @param  stubBaseReflectionClass  $maxDateProviderClass
     */
    public function setMaxDateProviderClass(stubBaseReflectionClass $maxDateProviderClass)
    {
        $this->maxDateProviderClass = $maxDateProviderClass;
    }

    /**
     * sets the maximum date provider method
     *
     * @param  string  $maxDateProviderMethod
     */
    public function setMaxDateProviderMethod($maxDateProviderMethod)
    {
        $this->maxDateProviderMethod = $maxDateProviderMethod;
    }

    /**
     * sets the error id to use in case max date validation fails
     *
     * @param  string  $maxDateErrorId
     */
    public function setMaxDateErrorId($maxDateErrorId)
    {
        $this->maxDateErrorId = $maxDateErrorId;
    }

    /**
     * sets the format for dates in error messages
     *
     * @param  string  $dateFormat
     */
    public function setDateFormat($dateFormat)
    {
        $this->dateFormat = $dateFormat;
    }

    /**
     * returns the filter defined by the annotation
     *
     * @return  stubFilter
     */
    protected function doGetFilter()
    {
        $filter = new stubDateFilter($this->createRVEFactory());
        if (null == $this->minDate && null !== $this->minDateProviderClass) {
            $this->setMinDate($this->getDateFromProvider($this->minDateProviderClass, $this->minDateProviderMethod));
        }
        if (null == $this->maxDate && null !== $this->maxDateProviderClass) {
            $this->setMaxDate($this->getDateFromProvider($this->maxDateProviderClass, $this->maxDateProviderMethod));
        }

        if (null !== $this->minDate || null !== $this->maxDate) {
            $filter = new stubPeriodFilterDecorator($filter, $this->createRVEFactory());
            if (null !== $this->minDate) {
                $filter->setMinDate($this->minDate, $this->minDateErrorId);
            }

            if (null !== $this->maxDate) {
                $filter->setMaxDate($this->maxDate, $this->maxDateErrorId);
            }

            if (null != $this->dateFormat) {
                $filter->setDateFormat($this->dateFormat);
            }
        }

        return $filter;
    }

    /**
     * retrieves date from provider
     *
     * @param   stubBaseReflectionClass  $providerClass
     * @param   string                   $providerMethod
     * @return  int|string|stubDate
     */
    protected function getDateFromProvider(stubBaseReflectionClass $providerClass, $providerMethod)
    {
        $method = $providerClass->getMethod($providerMethod);
        if ($method->isStatic() === true) {
            return $method->invoke(null);
        }

        return $method->invoke($providerClass->newInstance());
    }
}
?><?php
/**
 * Interface for filter annotations.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 * @version     $Id: stubFilterAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Interface for filter annotations.
 *
 * Use this annotation to define which filter should be used to populate a
 * property or method of a class with a value from the request.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 */
interface stubFilterAnnotation
{
    /**
     * returns the name of the request variable
     *
     * @return  string
     */
    public function getFieldName();

    /**
     * sets whether the value is required or not
     *
     * @param  bool  $isRequired
     */
    public function setRequired($isRequired);

    /**
     * returns the filter defined by the annotation
     *
     * @return  stubFilter
     */
    public function getFilter();
}
?><?php
/**
 * Filter annotation for floats.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 * @version     $Id: stubFloatFilterAnnotation.php 2320 2009-09-14 08:34:11Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubAbstractFilterAnnotation',
                      'net::stubbles::ipo::request::filter::stubFloatFilter',
                      'net::stubbles::ipo::request::filter::stubRangeFilterDecorator',
                      'net::stubbles::ipo::request::validator::stubMaxNumberValidator',
                      'net::stubbles::ipo::request::validator::stubMinNumberValidator'
);
/**
 * Filter annotation for floats.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 */
class stubFloatFilterAnnotation extends stubAbstractFilterAnnotation implements stubAnnotation
{
    /**
     * number of decimals
     *
     * @var  int
     */
    protected $decimals   = null;
    /**
     * minimum value of the float
     *
     * @var  double
     */
    protected $minValue;
    /**
     * the error id to use in case min validation fails
     *
     * @var  string
     */
    protected $minErrorId;
    /**
     * maximum value of the float
     *
     * @var  double
     */
    protected $maxValue;
    /**
     * the error id to use in case max validation fails
     *
     * @var  string
     */
    protected $maxErrorId;

    /**
     * sets number of decimals
     *
     * @param  int  $decimals
     */
    public function setDecimals($decimals)
    {
        $this->decimals = $decimals;
    }

    /**
     * sets the minimum value of the float
     *
     * @param  double  $minValue
     */
    public function setMinValue($minValue)
    {
        $this->minValue = $minValue;
    }

    /**
     * sets the error id to use in case max validation fails
     *
     * @param  string  $minErrorId
     */
    public function setMinErrorId($minErrorId)
    {
        $this->minErrorId = $minErrorId;
    }

    /**
     * sets the maximum value of the float
     *
     * @param  double  $maxValue
     */
    public function setMaxValue($maxValue)
    {
        $this->maxValue = $maxValue;
    }

    /**
     * sets the error id to use in case max validation fails
     *
     * @param  string  $maxErrorId
     */
    public function setMaxErrorId($maxErrorId)
    {
        $this->maxErrorId = $maxErrorId;
    }

    /**
     * returns the filter defined by the annotation
     *
     * @return  stubFilter
     */
    protected function doGetFilter()
    {
        $filter = new stubFloatFilter();
        $filter->setDecimals($this->decimals);
        if (null !== $this->minValue || null !== $this->maxValue) {
            $filter = new stubRangeFilterDecorator($filter, $this->createRVEFactory());
            if (null !== $this->minValue) {
                $filter->setMinValidator(new stubMinNumberValidator($this->minValue), $this->minErrorId);
            }
            
            if (null !== $this->maxValue) {
                $filter->setMaxValidator(new stubMaxNumberValidator($this->maxValue), $this->maxErrorId);
            }
        }
        
        return $filter;
    }
}
?><?php
/**
 * Filter annotation for HTTP URLs.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 * @version     $Id: stubHTTPURLFilterAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::ipo::request::filter::stubHTTPURLFilter',
                      'net::stubbles::ipo::request::broker::annotations::stubAbstractFilterAnnotation'
);
/**
 * Filter annotation for HTTP URLs.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 */
class stubHTTPURLFilterAnnotation extends stubAbstractFilterAnnotation implements stubAnnotation
{
    /**
     * switch whether DNS should be checked or not
     *
     * @var  bool
     */
    protected $checkDNS = false;

    /**
     * switch the dns check on or off
     *
     * @param  bool  $checkDNS
     */
    public function setCheckDNS($checkDNS)
    {
        $this->checkDNS = $checkDNS;
    }

    /**
     * returns the filter defined by the annotation
     *
     * @return  stubHTTPURLFilter
     * @throws  stubRequestBrokerException
     */
    protected function doGetFilter()
    {
        $httpURLFilter = new stubHTTPURLFilter($this->createRVEFactory());
        $httpURLFilter->setCheckDNS($this->checkDNS);
        return $httpURLFilter;
    }
}
?><?php
/**
 * Filter annotation for integers.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 * @version     $Id: stubIntegerFilterAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubAbstractFilterAnnotation',
                      'net::stubbles::ipo::request::filter::stubIntegerFilter',
                      'net::stubbles::ipo::request::filter::stubRangeFilterDecorator',
                      'net::stubbles::ipo::request::validator::stubMaxNumberValidator',
                      'net::stubbles::ipo::request::validator::stubMinNumberValidator'
);
/**
 * Filter annotation for integers.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 */
class stubIntegerFilterAnnotation extends stubAbstractFilterAnnotation implements stubAnnotation
{
    /**
     * minimum value of the integer
     *
     * @var  int
     */
    protected $minValue;
    /**
     * the error id to use in case min validation fails
     *
     * @var  string
     */
    protected $minErrorId;
    /**
     * maximum value of the integer
     *
     * @var  int
     */
    protected $maxValue;
    /**
     * the error id to use in case max validation fails
     *
     * @var  string
     */
    protected $maxErrorId;

    /**
     * sets the minimum value of the integer
     *
     * @param  int  $minValue
     */
    public function setMinValue($minValue)
    {
        $this->minValue = $minValue;
    }

    /**
     * sets the error id to use in case max validation fails
     *
     * @param  string  $minErrorId
     */
    public function setMinErrorId($minErrorId)
    {
        $this->minErrorId = $minErrorId;
    }

    /**
     * sets the maximum value of the integer
     *
     * @param  int  $maxValue
     */
    public function setMaxValue($maxValue)
    {
        $this->maxValue = $maxValue;
    }

    /**
     * sets the error id to use in case max validation fails
     *
     * @param  string  $maxErrorId
     */
    public function setMaxErrorId($maxErrorId)
    {
        $this->maxErrorId = $maxErrorId;
    }

    /**
     * returns the filter defined by the annotation
     *
     * @return  stubFilter
     */
    protected function doGetFilter()
    {
        $filter = new stubIntegerFilter();
        if (null !== $this->minValue || null !== $this->maxValue) {
            $filter = new stubRangeFilterDecorator($filter, $this->createRVEFactory());
            if (null !== $this->minValue) {
                $filter->setMinValidator(new stubMinNumberValidator($this->minValue), $this->minErrorId);
            }
            
            if (null !== $this->maxValue) {
                $filter->setMaxValidator(new stubMaxNumberValidator($this->maxValue), $this->maxErrorId);
            }
        }
        
        return $filter;
    }
}
?><?php
/**
 * Filter annotation for mail addresses.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 * @version     $Id: stubMailFilterAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubAbstractFilterAnnotation',
                      'net::stubbles::ipo::request::filter::stubMailFilter',
                      'net::stubbles::ipo::request::validator::stubMailValidator'
);
/**
 * Filter annotation for mail addresses.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 */
class stubMailFilterAnnotation extends stubAbstractFilterAnnotation implements stubAnnotation
{
    /**
     * returns the filter defined by the annotation
     *
     * @return  stubMailFilter
     * @throws  stubRequestBrokerException
     */
    protected function doGetFilter()
    {
        $mailFilter  = new stubMailFilter($this->createRVEFactory(), new stubMailValidator());
        return $mailFilter;
    }
}
?><?php
/**
 * Filter annotation for passwords.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 * @version     $Id: stubPasswordFilterAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::broker::annotations::stubAbstractFilterAnnotation',
                      'net::stubbles::ipo::request::filter::stubEncodingFilterDecorator',
                      'net::stubbles::ipo::request::filter::stubLengthFilterDecorator',
                      'net::stubbles::ipo::request::filter::stubPasswordFilter',
                      'net::stubbles::ipo::request::validator::stubMinLengthValidator',
                      'net::stubbles::reflection::annotations::stubAnnotation'
);
/**
 * Filter annotation for passwords.
 * 
 * The default minimum length of the password will be 6 characters if the
 * property is not set within the annotation.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 */
class stubPasswordFilterAnnotation extends stubAbstractFilterAnnotation implements stubAnnotation
{
    /**
     * minimum length of the password
     *
     * @var  int
     */
    protected $minLength    = 6;
    /**
     * the encoder class to be used
     *
     * @var  stubReflectionClass
     */
    protected $encoderClass = null;

    /**
     * sets the minimum length of the password
     *
     * @param  int  $minLength
     */
    public function setMinLength($minLength)
    {
        $this->minLength = $minLength;
    }

    /**
     * sets the encoder class to be used
     *
     * @param  stubReflectionClass  $encoderClass
     */
    public function setEncoder(stubReflectionClass $encoderClass)
    {
        $this->encoderClass = $encoderClass;
    }

    /**
     * returns the filter defined by the annotation
     *
     * @return  stubFilter
     */
    protected function doGetFilter()
    {
        $rveFactory = $this->createRVEFactory();
        $filter     = new stubLengthFilterDecorator(new stubPasswordFilter($rveFactory), $rveFactory);
        $filter->setMinLengthValidator(new stubMinLengthValidator($this->minLength));
        if (null !== $this->encoderClass) {
            $filter = new stubEncodingFilterDecorator($filter, $this->encoderClass->newInstance(), stubStringEncoder::MODE_ENCODE);
        }
        
        return $filter;
    }
}
?><?php
/**
 * Filter annotation for a list of preselected values.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 * @version     $Id: stubPreselectFilterAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubAbstractFilterAnnotation',
                      'net::stubbles::ipo::request::filter::stubStringFilter',
                      'net::stubbles::ipo::request::filter::stubValidatorFilterDecorator',
                      'net::stubbles::ipo::request::validator::stubPreSelectValidator',
                      'net::stubbles::reflection::stubReflectionClass'
);
/**
 * Filter annotation for a list of preselected values.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 */
class stubPreselectFilterAnnotation extends stubAbstractFilterAnnotation implements stubAnnotation
{
    /**
     * source data class
     *
     * @var  stubReflectionClass
     */
    protected $sourceDataClass;
    /**
     * source data method
     *
     * @var  string
     */
    protected $sourceDataMethod = 'getData';
    /**
     * the error id to use in case the validation fails
     *
     * @var  string
     */
    protected $errorId          = 'FIELD_WRONG_VALUE';

    /**
     * sets the source data class
     *
     * @param  stubReflectionClass  $sourceDataClass
     */
    public function setSourceDataClass(stubReflectionClass $sourceDataClass)
    {
        $this->sourceDataClass = $sourceDataClass;
    }

    /**
     * sets the source data method
     *
     * @param  string  $sourceDataMethod
     */
    public function setSourceDataMethod($sourceDataMethod)
    {
        $this->sourceDataMethod = $sourceDataMethod;
    }

    /**
     * sets the error id to be used
     *
     * @param  string  $errorId
     */
    public function setErrorId($errorId)
    {
        $this->errorId = $errorId;
    }

    /**
     * returns the filter defined by the annotation
     *
     * @return  stubValidatorFilterDecorator
     */
    protected function doGetFilter()
    {
        $preselectData            = $this->sourceDataClass->getMethod($this->sourceDataMethod)->invoke(null);
        $validatorFilterDecorator =  new stubValidatorFilterDecorator(new stubStringFilter(),
                                                                      $this->createRVEFactory(),
                                                                      new stubPreSelectValidator($preselectData)
                                     );
        $validatorFilterDecorator->setErrorId($this->errorId);
        return $validatorFilterDecorator;
    }
}
?><?php
/**
 * Filter annotation for strings.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 * @version     $Id: stubStringFilterAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::broker::annotations::stubAbstractStringFilterAnnotation',
                      'net::stubbles::ipo::request::filter::stubValidatorFilterDecorator',
                      'net::stubbles::ipo::request::filter::stubStringFilter',
                      'net::stubbles::ipo::request::validator::stubRegexValidator'
);
/**
 * Filter annotation for strings.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 */
class stubStringFilterAnnotation extends stubAbstractStringFilterAnnotation
{
    /**
     * regular expression to filter the string
     *
     * @var  string
     */
    protected $regex   = null;
    /**
     * error if to be used
     *
     * @var  string
     */
    protected $errorId = null;

    /**
     * sets the regular expression to filter the string
     *
     * @param  string  $regex
     */
    public function setRegex($regex)
    {
        $this->regex = $regex;
    }

    /**
     * set error id to be used in case regular expression fails
     *
     * @param  string  $errorId
     */
    public function setRegexErrorId($errorId)
    {
        $this->errorId = $errorId;
    }

    /**
     * returns the filter defined by the annotation
     *
     * @return  stubFilter
     */
    protected function doDoGetFilter()
    {
        $stringFilter  = new stubStringFilter();
        if (null !== $this->regex) {
            $stringFilter = new stubValidatorFilterDecorator($stringFilter, $this->createRVEFactory(), new stubRegexValidator($this->regex));
            if (null !== $this->errorId) {
                $stringFilter->setErrorId($this->errorId);
            }
        }
        
        return $stringFilter;
    }
}
?><?php
/**
 * Filter annotation for texts.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 * @version     $Id: stubTextFilterAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubTextFilter',
                      'net::stubbles::ipo::request::broker::annotations::stubAbstractStringFilterAnnotation'
);
/**
 * Filter annotation for texts.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker_annotations
 */
class stubTextFilterAnnotation extends stubAbstractStringFilterAnnotation
{
    /**
     * list of allowed tags
     *
     * @var  array<string>
     */
    protected $allowedTags = array();

    /**
     * set the list of allowed tags
     *
     * Use this option very careful. It does not protect you against
     * possible XSS attacks!
     *
     * @param  string  $allowedTags
     */
    public function setAllowedTags($allowedTags)
    {
        $this->allowedTags = array_map('trim', explode(',', $allowedTags));
    }

    /**
     * returns the filter defined by the annotation
     *
     * @return  stubFilter
     */
    protected function doDoGetFilter()
    {
        $textFilter = new stubTextFilter();
        $textFilter->setAllowedTags($this->allowedTags);
        return $textFilter;
    }
}
?><?php
/**
 * Broker class to transfer values from the request into an object via annotations.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker
 * @version     $Id: stubRequestBroker.php 2659 2010-08-20 15:45:49Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::request::broker::stubRequestBrokerException',
                      'net::stubbles::ipo::request::broker::stubRequestBrokerMethodPropertyMatcher',
                      'net::stubbles::ipo::request::broker::annotations::stubBoolFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubDateFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubFloatFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubHTTPURLFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubIntegerFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubMailFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubPasswordFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubPreselectFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubStringFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubTextFilterAnnotation',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::reflection::stubReflectionClass'
);
/**
 * Broker class to transfer values from the request into an object via annotations.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker
 */
class stubRequestBroker extends stubBaseObject
{
    /**
     * the matcher to be used for methods and properties
     *
     * @var  stubRequestBrokerMethodPropertyMatcher
     */
    protected static $methodAndPropertyMatcher;

    /**
     * static initializer
     */
    // @codeCoverageIgnoreStart
    public static function __static()
    {
        self::$methodAndPropertyMatcher = new stubRequestBrokerMethodPropertyMatcher();
    }
    // @codeCoverageIgnoreEnd

    /**
     * does the real action
     *
     * @param   stubRequest               $request
     * @param   object                    $object           the object instance to fill with values
     * @param   string                    $prefix           optional  prefix for access to request values
     * @param   array<string,stubFilter>  $overruleFilters  optional  list of filters to overrule annotated filters with
     * @throws  stubIllegalArgumentException
     */
    public function process(stubRequest $request, $object, $prefix = '', array $overruleFilters = array())
    {
        if ($object instanceof stubObject) {
            $refClass = $object->getClass();
        } elseif (is_object($object) === true) {
            $refClass = new stubReflectionClass(get_class($object));
        } else {
            throw new stubIllegalArgumentException('Parameter object must a concrete object instance.');
        }
        
        foreach ($refClass->getPropertiesByMatcher(self::$methodAndPropertyMatcher) as $refProperty) {
            $filterAnnotation = $refProperty->getAnnotation('Filter');
            $fieldName        = $prefix . $filterAnnotation->getFieldName();
            if (isset($overruleFilters[$fieldName]) === true) {
                $filter = $overruleFilters[$fieldName];
            } else {
                $filter = $filterAnnotation->getFilter();
            }
            
            $value = $request->readParam($fieldName)->withFilter($filter);
            if ($request->paramErrors()->existFor($prefix . $filterAnnotation->getFieldName()) === false) {
                $refProperty->setValue($object, $value);
            }
        }
        
        foreach ($refClass->getMethodsByMatcher(self::$methodAndPropertyMatcher) as $refMethod) {
            $filterAnnotation = $refMethod->getAnnotation('Filter');
            $fieldName        = $prefix . $filterAnnotation->getFieldName();
            if (isset($overruleFilters[$fieldName]) === true) {
                $filter = $overruleFilters[$fieldName];
            } else {
                $filter = $filterAnnotation->getFilter();
            }
            
            $value = $request->readParam($fieldName)->withFilter($filter);
            if ($request->paramErrors()->existFor($prefix . $filterAnnotation->getFieldName()) === false) {
                $refMethod->invoke($object, $value);
            }
        }
    }
}
?><?php
/**
 * Exception to be thrown when something goes wrong with the request broker.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_broker
 * @version     $Id: stubRequestBrokerException.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Exception to be thrown when something goes wrong with the request broker.
 *
 * @package     stubbles
 * @subpackage  ipo_request_broker
 */
class stubRequestBrokerException extends stubException
{
    // intentionally empty
}
?><?php
/**
 * Matcher for methods and properties.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_broker
 * @version     $Id: stubRequestBrokerMethodPropertyMatcher.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::matcher::stubMethodMatcher',
                      'net::stubbles::reflection::matcher::stubPropertyMatcher'
);
/**
 * Matcher for methods and properties.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_broker
 */
class stubRequestBrokerMethodPropertyMatcher extends stubBaseObject implements stubMethodMatcher, stubPropertyMatcher
{
    /**
     * checks whether the matcher is satisfied with the given method
     *
     * @param   ReflectionMethod  $method
     * @return  bool
     */
    public function matchesMethod(ReflectionMethod $method)
    {
        if ($method->isPublic() === false || $method->isStatic() === true) {
            return false;
        }
        
        if ($method->isConstructor() === true || $method->isDestructor() === true) {
            return false;
        }

        return true;
    }

    /**
     * checks whether the matcher is satisfied with the given method
     *
     * @param   stubReflectionMethod  $method
     * @return  bool
     */
    public function matchesAnnotatableMethod(stubReflectionMethod $method)
    {
        return $method->hasAnnotation('Filter');
    }

    /**
     * checks whether the matcher is satisfied with the given property
     *
     * @param   ReflectionProperty  $property
     * @return  bool
     */
    public function matchesProperty(ReflectionProperty $property)
    {
        if ($property->isPublic() === false || $property->isStatic() === true) {
            return false;
        }
        
        return true;
    }

    /**
     * checks whether the matcher is satisfied with the given property
     *
     * @param   stubReflectionProperty  $property
     * @return  bool
     */
    public function matchesAnnotatableProperty(stubReflectionProperty $property)
    {
        return $property->hasAnnotation('Filter');
    }
}
?><?php
/**
 * Mocked filter to be used in unit tests.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_filter_mock
 * @version     $Id: stubMockFilter.php 2647 2010-08-18 12:28:00Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilterException');
/**
 * Mocked filter to be used in unit tests.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter_mock
 */
class stubMockFilter extends stubBaseObject implements stubFilter
{
    /**
     * list of called methods
     *
     * @var    array<string,string>
     * @since  1.3.0
     */
    protected $calledMethods = array();

    /**
     * execute the filter
     *
     * @param   mixed                $value  value to filter
     * @return  mixed                filtered value
     * @throws  stubFilterException  in case $value has errors
     */
    public function execute($value)
    {
        return $value;
    }

    /**
     * pass thru any method call
     *
     * @param   string          $method
     * @param   array           $arguments
     * @return  stubMockFilter
     */
    public function __call($method, $arguments)
    {
        $this->calledMethods[$method] = $method;
        return $this;
    }

    /**
     *
     * @param   string  $methodName
     * @return  bool
     * @since   1.3.0
     */
    public function wasMethodCalled($methodName)
    {
        return isset($this->calledMethods[$methodName]);
    }
}
?><?php
/**
 * Mock factory to create mock filters, to be used in unit tests.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter_mock
 * @version     $Id: stubMockFilterFactory.php 2329 2009-09-16 16:00:05Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilterFactory',
                      'net::stubbles::ipo::request::filter::mock::stubMockFilter'
);
/**
 * Mock factory to create mock filters, to be used in unit tests.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter_mock
 */
class stubMockFilterFactory extends stubBaseObject implements stubFilterFactory
{
    /**
     * creates a filter for the given type
     *
     * @param   string             $type  type of filter to create
     * @return  stubFilterBuilder
     */
    public function createForType($type)
    {
        return new stubMockFilter();
    }

    /**
     * create a builder instance for an existing filter
     *
     * @param   stubFilter         $filter
     * @return  stubFilterBuilder
     */
    public function createBuilder(stubFilter $filter)
    {
        return new stubMockFilter();
    }
}
?><?php
/**
 * Base class for filter decorators: delegates everything to the decorated filter.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubAbstractFilterDecorator.php 2327 2009-09-16 14:27:22Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilter',
                      'net::stubbles::lang::exceptions::stubMethodNotSupportedException'
);
/**
 * Base class for filter decorators: delegates everything to the decorated filter.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
abstract class stubAbstractFilterDecorator extends stubBaseObject implements stubFilter
{
    /**
     * decorated filter
     *
     * @var  stubFilter
     */
    protected $decoratedFilter;

    /**
     * setter method
     *
     * @param  stubFilter  $decoratedFilter
     */
    public function setDecoratedFilter($decoratedFilter)
    {
        $this->decoratedFilter = $decoratedFilter;
    }

    /**
     * getter method
     *
     * @return  stubFilter
     */
    public function getDecoratedFilter()
    {
        return $this->decoratedFilter;
    }

    /**
     * execute the filter
     *
     * @param   mixed  $value  value to filter
     * @return  mixed
     */
    public function execute($value)
    {
        return $this->getDecoratedFilter()->execute($value);
    }

    /**
     * interceptor for method calls on filters without direct support
     *
     * @param   string             $method     name of the method to call
     * @param   array              $arguments  list of arguments for the method
     * @return  stubFilterFactory
     * 
     */
    public function __call($method, $arguments)
    {
        $result = $this->callRecursive($this->getDecoratedFilter(), $method, $arguments);
        if (null === $result) {
            return $this;
        }
        
        return $result;
    }

    /**
     * helper method to recurse down to the base filter in order to call a method
     *
     * @param   stubFilter  $filter     filter to try to call the method off
     * @param   string      $method     name of the method to call
     * @param   array       $arguments  list of arguments for the method
     * @return  mixed
     * @throws  stubMethodNotSupportedException
     */
    protected function callRecursive(stubFilter $filter, $method, $arguments)
    {
        if (method_exists($filter, $method) === true) {
            return call_user_func_array(array($filter, $method), $arguments);
        }
        
        if (method_exists($filter, 'getDecoratedFilter') === true) {
            return $this->callRecursive($filter->getDecoratedFilter(), $method, $arguments);
        }
        
        throw new stubMethodNotSupportedException('The method ' . $method . ' is not supported by the current filter.');
    }
}
?><?php
/**
 * Basic class for filters on request variables of type boolean.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubBoolFilter.php 2506 2010-03-01 14:28:18Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilter');
/**
 * Basic class for filters on request variables of type boolean.
 *
 * If given value is 1 (int or string), 'true' (string) or true (boolean) the
 * filter returns boolean true; and boolean false in all other cases.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @since       1.2.0
 */
class stubBoolFilter extends stubBaseObject implements stubFilter
{
    /**
     * checks if given value is an integer
     *
     * @param   mixed  $value  value to filter
     * @return  bool
     */
    function execute($value)
    {
        if (in_array($value, array(1, '1', 'true', true), true) === true) {
            return true;
        }
        
        return false;
    }
}
?><?php
/**
 * Class for filtering dates.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubDateFilter.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueErrorFactory',
                      'net::stubbles::ipo::request::filter::stubFilter',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::lang::types::stubDate'
);
/**
 * Class for filtering dates.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubDateFilter extends stubBaseObject implements stubFilter
{
    /**
     * request value error factory
     *
     * @var  stubRequestValueErrorFactory
     */
    protected $rveFactory;

    /**
     * constructor
     *
     * @param  stubRequestValueErrorFactory  $rveFactory  factory to create stubRequestValueErrors
     */
    public function __construct(stubRequestValueErrorFactory $rveFactory)
    {
        $this->rveFactory = $rveFactory;
    }

    /**
     * try to change the given value into a date instance
     *
     * @param   string               $value
     * @return  stubDate
     * @throws  stubFilterException  when $value has errors
     */
    public function execute($value)
    {
        if (null == $value) {
            return null;
        }
        
        try {
            return new stubDate($value);
        } catch (stubIllegalArgumentException $iae) {
            throw new stubFilterException($this->rveFactory->create('DATE_INVALID'));
        }
    }
}
?><?php
/**
 * Factory to create filters.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubDefaultFilterFactory.php 2328 2009-09-16 15:23:11Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueErrorFactory',
                      'net::stubbles::ipo::request::filter::stubFilterBuilder',
                      'net::stubbles::ipo::request::filter::stubFilterFactory'
);
/**
 * Factory to create filters.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @Singleton
 */
class stubDefaultFilterFactory extends stubBaseObject implements stubFilterFactory
{
    /**
     * list of filters to provide
     *
     * @var  array<string,string>
     */
    protected $typeFilter = array();
    /**
     * the request error value factory to be used by the filter
     *
     * @var  stubRequestErrorValueFactory
     */
    protected $rveFactory;

    /**
     * constructor
     *
     * @param  array<string,string>          $typeFilter  list of filters to provide
     * @param  stubRequestValueErrorFactory  $rveFactory  default rve factory
     * @Inject
     * @Named{typeFilter}('net.stubbles.ipo.request.filter.types')
     */
    public function __construct(array $typeFilter, stubRequestValueErrorFactory $rveFactory)
    {
        $this->typeFilter = $typeFilter;
        $this->rveFactory = $rveFactory;
    }

    /**
     * creates a filter for the given type
     *
     * @param   string             $type  type of filter to create
     * @return  stubFilterBuilder
     * @throws  stubIllegalArgumentException
     */
    public function createForType($type)
    {
        if (isset($this->typeFilter[$type]) === false) {
            throw new stubIllegalArgumentException('No filter known for given type ' . $type);
        }
        
        stubClassLoader::load($this->typeFilter[$type]);
        $classname = stubClassLoader::getNonQualifiedClassName($this->typeFilter[$type]);
        return $this->createBuilder(new $classname($this->rveFactory));
    }

    /**
     * create a builder instance for an existing filter
     *
     * @param   stubFilter         $filter
     * @return  stubFilterBuilder
     */
    public function createBuilder(stubFilter $filter)
    {
        return new stubFilterBuilder($filter, $this->rveFactory);
    }
}
?><?php
/**
 * Filter for returning a default value if given value is null.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubStrategyFilterDecorator');
/**
 * Filter for returning a default value if given value is null.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubDefaultValueFilterDecorator extends stubStrategyFilterDecorator
{
    /**
     * the default value in case given value not set
     *
     * @var  mixed
     */
    protected $defaultValue = null;

    /**
     * constructor
     *
     * @param  stubFilter  $filter        decorated filter
     * @param  mixed       $defaultValue  default value to return if filteres value is empty
     */
    public function __construct(stubFilter $filter, $defaultValue)
    {
        $this->setDecoratedFilter($filter);
        $this->defaultValue = $defaultValue;
    }

    /**
     * returns the default value
     *
     * @return  mixed
     */
    public function getDefaultValue()
    {
        return $this->defaultValue;
    }

    /**
     * execute the filter
     *
     * @param   string  $value
     * @return  string
     * @throws  stubFilterException
     */
    protected function doExecute($value)
    {
        if (null === $value) {
            return $this->defaultValue;
        }
        
        return $value;
    }
}
?><?php
/**
 * Class for decoding/encoding values using a string encoder.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubEncodingFilterDecorator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubStrategyFilterDecorator',
                      'net::stubbles::php::string::stubStringEncoder'
);
/**
 * Class for decoding/encoding values using a string encoder.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubEncodingFilterDecorator extends stubStrategyFilterDecorator
{
    /**
     * the encoder to be applied on the value to filter
     *
     * @var  stubStringEncoder
     */
    protected $encoder     = null;
    /**
     * the encoding mode to be applied on the value to filter
     *
     * @var  int
     */
    protected $encoderMode = stubStringEncoder::MODE_DECODE;

    /**
     * constructor
     *
     * @param  stubFilter         $filter   decorated filter
     * @param  stubStringEncoder  $encoder  encoder to be used
     * @param  int                $mode     optional
     */
    public function __construct(stubFilter $filter, stubStringEncoder $encoder, $mode = stubStringEncoder::MODE_DECODE)
    {
        $this->setDecoratedFilter($filter);
        $this->encoder     = $encoder;
        $this->encoderMode = $mode;
    }

    /**
     * returns the encoder to be used
     *
     * @return  stubStringEncoder
     */
    public function getEncoder()
    {
        return $this->encoder;
    }

    /**
     * returns the encoder mode to be used
     *
     * @return  int
     */
    public function getEncoderMode()
    {
        return $this->encoderMode;
    }

    /**
     * execute the filter
     *
     * @param   string  $value
     * @return  string
     * @throws  stubFilterException
     */
    protected function doExecute($value)
    {
        return $this->encoder->apply($value, $this->encoderMode);
    }
}
?><?php
/**
 * Interface for filters.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubFilter.php 2329 2009-09-16 16:00:05Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilterException');
/**
 * Interface for filter.
 * 
 * Filters can be used to take request values, validate them and change them
 * into any other value.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
interface stubFilter extends stubObject
{
    /**
     * execute the filter
     *
     * @param   mixed                $value  value to filter
     * @return  mixed                filtered value
     * @throws  stubFilterException  in case $value has errors
     */
    public function execute($value);
}
?><?php
/**
 * Builder to create filters.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubFilterBuilder.php 2331 2009-09-16 18:12:47Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueErrorFactory',
                      'net::stubbles::ipo::request::filter::stubAbstractFilterDecorator',
                      'net::stubbles::ipo::request::filter::stubStrategyFilterDecorator',
                      'net::stubbles::lang::types::stubDate'
);
/**
 * Builder to create filters.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubFilterBuilder extends stubAbstractFilterDecorator
{
    /**
     * constructor
     *
     * @param  stubFilter                    $filter
     * @param  stubRequestValueErrorFactory  $rveFactory
     */
    public function __construct(stubFilter $filter, stubRequestValueErrorFactory $rveFactory)
    {
        $this->setDecoratedFilter($filter);
        $this->rveFactory = $rveFactory;
    }

    /**
     * sets the request error value factory to be used by the filter
     *
     * @param   stubRequestValueErrorFactory  $rveFactory
     * @return  stubFilterBuilder
     */
    public function using(stubRequestValueErrorFactory $rveFactory)
    {
        $this->rveFactory = $rveFactory;
        return $this;
    }

    /**
     * returns the request error value factory to be used by the filter
     *
     * @return  stubRequestValueErrorFactory
     */
    public function getRveFactory()
    {
        return $this->rveFactory;
    }

    /**
     * decorates the filter with a range filter
     *
     * To create a lower border only use NULL for $max, to create an upper
     * border only use NULL for $min.
     *
     * @param   numeric            $min
     * @param   numeric            $max
     * @param   string             $minErrorId  optional  error id for failing min validation
     * @param   string             $maxErrorId  optional  error id for failing max validation
     * @param   int                $strategy    optional  strategy to be used: before or after decorated filter
     * @return  stubFilterFactory
     */
    public function inRange($min, $max, $minErrorId = null, $maxErrorId = null, $strategy = stubStrategyFilterDecorator::STRATEGY_AFTER)
    {
        if (null !== $min || null !== $max) {
            stubClassLoader::load('net::stubbles::ipo::request::filter::stubRangeFilterDecorator',
                                  'net::stubbles::ipo::request::validator::stubMinNumberValidator',
                                  'net::stubbles::ipo::request::validator::stubMaxNumberValidator'
            );
            $filter = new stubRangeFilterDecorator($this->getDecoratedFilter(), $this->rveFactory);
            if (null !== $min) {
                $filter->setMinValidator(new stubMinNumberValidator($min), $minErrorId);
            }
            
            if (null !== $max) {
                $filter->setMaxValidator(new stubMaxNumberValidator($max), $maxErrorId);
            }
            
            $filter->setStrategy($strategy);
            $this->setDecoratedFilter($filter);
        }
        
        return $this;
    }

    /**
     * decorates the filter with a length filter
     *
     * To create a lower border only use NULL for $maxLength, to create an upper
     * border only use NULL for $minLength.
     *
     * @param   numeric            $minLength
     * @param   numeric            $maxLength
     * @param   string             $minLengthErrorId  optional  error id for failing min validation
     * @param   string             $maxLengthErrorId  optional  error id for failing max validation
     * @param   int                $strategy          optional  strategy to be used: before or after decorated filter
     * @return  stubFilterFactory
     */
    public function length($minLength, $maxLength, $minLengthErrorId = null, $maxLengthErrorId = null, $strategy = stubStrategyFilterDecorator::STRATEGY_AFTER)
    {
        if (null !== $minLength || null !== $maxLength) {
            stubClassLoader::load('net::stubbles::ipo::request::filter::stubLengthFilterDecorator',
                                  'net::stubbles::ipo::request::validator::stubMinLengthValidator',
                                  'net::stubbles::ipo::request::validator::stubMaxLengthValidator'
            );
            $filter = new stubLengthFilterDecorator($this->getDecoratedFilter(), $this->rveFactory);
            if (null !== $minLength) {
                $filter->setMinLengthValidator(new stubMinLengthValidator($minLength), $minLengthErrorId);
            }
            
            if (null !== $maxLength) {
                $filter->setMaxLengthValidator(new stubMaxLengthValidator($maxLength), $maxLengthErrorId);
            }
            
            $filter->setStrategy($strategy);
            $this->setDecoratedFilter($filter);
        }
        
        return $this;
    }

    /**
     * decorates the filter with a period filter
     *
     * @param   stubDate           $minDate         optional
     * @param   stubDate           $maxDate         optional
     * @param   string             $minDateErrorId  optional  error id for failing min validation
     * @param   string             $maxDateErrorId  optional  error id for failing max validation
     * @param   string             $dateFormat      optional  format of date in error messages
     * @return  stubFilterFactory
     */
    public function inPeriod(stubDate $minDate = null, stubDate $maxDate = null, $minDateErrorId = null, $maxDateErrorId = null, $dateFormat = null)
    {
        if (null !== $minDate || null !== $maxDate) {
            stubClassLoader::load('net::stubbles::ipo::request::filter::stubPeriodFilterDecorator');
            $filter = new stubPeriodFilterDecorator($this->getDecoratedFilter(), $this->rveFactory);
            if (null !== $minDate) {
                $filter->setMinDate($minDate, $minDateErrorId);
            }
            
            if (null !== $maxDate) {
                $filter->setMaxDate($maxDate, $maxDateErrorId);
            }
            
            if (null != $dateFormat) {
                $filter->setDateFormat($dateFormat);
            }
            
            $this->setDecoratedFilter($filter);
        }
        
        return $this;
    }

    /**
     * decorates the filter as required
     *
     * @param   string             $errorId   optional
     * @param   int                $strategy  optional  strategy to be used: before or after decorated filter
     * @return  stubFilterFactory
     */
    public function asRequired($errorId = null, $strategy = stubStrategyFilterDecorator::STRATEGY_BEFORE)
    {
        stubClassLoader::load('net::stubbles::ipo::request::filter::stubRequiredFilterDecorator');
        $filter = new stubRequiredFilterDecorator($this->getDecoratedFilter(), $this->rveFactory);
        if (null != $errorId) {
            $filter->setErrorId($errorId);
        }
        
        $filter->setStrategy($strategy);
        $this->setDecoratedFilter($filter);
        return $this;
    }

    /**
     * decorates the filter with a default value
     *
     * @param   mixed              $defaultValue
     * @param   int                $strategy      optional  strategy to be used: before or after decorated filter
     * @return  stubFilterFactory
     */
    public function defaultsTo($defaultValue, $strategy = stubStrategyFilterDecorator::STRATEGY_AFTER)
    {
        if (null === $defaultValue) {
            return $this;
        }
        
        stubClassLoader::load('net::stubbles::ipo::request::filter::stubDefaultValueFilterDecorator');
        $filter = new stubDefaultValueFilterDecorator($this->getDecoratedFilter(), $defaultValue);
        $filter->setStrategy($strategy);
        $this->setDecoratedFilter($filter);
        return $this;
    }

    /**
     * decorates the filter with a validator
     *
     * @param   stubValidator      $validator
     * @param   string             $errorId    optional
     * @param   int                $strategy   optional  strategy to be used: before or after decorated filter
     * @return  stubFilterFactory
     */
    public function validatedBy(stubValidator $validator, $errorId = null, $strategy = stubStrategyFilterDecorator::STRATEGY_AFTER)
    {
        stubClassLoader::load('net::stubbles::ipo::request::filter::stubValidatorFilterDecorator');
        $filter = new stubValidatorFilterDecorator($this->getDecoratedFilter(), $this->rveFactory, $validator);
        if (null != $errorId) {
            $filter->setErrorId($errorId);
        }
        
        $filter->setStrategy($strategy);
        $this->setDecoratedFilter($filter);
        return $this;
    }

    /**
     * decorates the filter with an encoder
     *
     * @param   stubStringEncoder  $encoder
     * @param   int                $strategy  optional  strategy to be used: before or after decorated filter
     * @return  stubFilterFactory
     */
    public function encodedWith(stubStringEncoder $encoder, $strategy = stubStrategyFilterDecorator::STRATEGY_AFTER)
    {
        $this->codedWith($encoder, stubStringEncoder::MODE_ENCODE, $strategy);
        return $this;
    }

    /**
     * decorates the filter with a decoder
     *
     * @param   stubStringEncoder  $encoder
     * @param   int                $strategy  optional  strategy to be used: before or after decorated filter
     * @return  stubFilterFactory
     */
    public function decodedWith(stubStringEncoder $encoder, $strategy = stubStrategyFilterDecorator::STRATEGY_AFTER)
    {
        $this->codedWith($encoder, stubStringEncoder::MODE_DECODE, $strategy);
        return $this;
    }

    /**
     * decorates the filter with an encoder
     *
     * @param   stubStringEncoder  $encoder
     * @param   int                $encoderMode  optional
     * @param   int                $strategy     optional  strategy to be used: before or after decorated filter
     * @return  stubFilterFactory
     */
    protected function codedWith(stubStringEncoder $encoder, $encoderMode = stubStringEncoder::MODE_DECODE, $strategy = stubStrategyFilterDecorator::STRATEGY_AFTER)
    {
        stubClassLoader::load('net::stubbles::ipo::request::filter::stubEncodingFilterDecorator');
        $filter = new stubEncodingFilterDecorator($this->getDecoratedFilter(), $encoder, $encoderMode);
        $filter->setStrategy($strategy);
        $this->setDecoratedFilter($filter);
    }
}
?><?php
/**
 * Exception to be thrown when a method has been passed an illegal or
 * inappropriate argument.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubFilterException.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Exception to be thrown when a method has been passed an illegal or
 * inappropriate argument.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubFilterException extends stubException
{
    /**
     * error
     *
     * @var  stubRequestValueError
     */
    protected $error;

    /**
     * Constructor for this class.
     *
     * @param  stubRequestValueError  $error  error
     */
    public function __construct(stubRequestValueError $error)
    {
        parent::__construct($error->getMessage('en_EN'));
        $this->error = $error;
    }

    /**
     * returns value that lead to error, but it is safe enough to use
     *
     * @return  stubRequestValueError  value that is safe enough to use, else null
     */
    public function getError()
    {
        return $this->error;
    }
}
?><?php
/**
 * Factory to create filters.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubFilterFactory.php 2328 2009-09-16 15:23:11Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilter');
/**
 * Factory to create filters.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @ImplementedBy(net::stubbles::ipo::request::filter::stubDefaultFilterFactory.class)
 */
interface stubFilterFactory extends stubObject
{
    /**
     * creates a filter for the given type
     *
     * @param   string             $type  type of filter to create
     * @return  stubFilterBuilder
     */
    public function createForType($type);

    /**
     * create a builder instance for an existing filter
     *
     * @param   stubFilter         $filter
     * @return  stubFilterBuilder
     */
    public function createBuilder(stubFilter $filter);
}
?><?php
/**
 * Filters on request variables of type double / float.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubFloatFilter.php 2320 2009-09-14 08:34:11Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilter');
/**
 * Filters on request variables of type double / float.
 * 
 * This filter takes any value and casts it to float. Afterwards its multiplied
 * with 10^$decimals to get an integer value which can be used for mathematical
 * operations for accuracy. If no value for x is given the value to filter is
 * returned as is after the cast.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubFloatFilter extends stubBaseObject implements stubFilter
{
    /**
     * number of decimals
     *
     * @var  int
     */
    protected $decimals = null;

    /**
     * sets number of decimals
     *
     * @param   int              $decimals
     * @return  stubFloatFilter
     */
    public function setDecimals($decimals)
    {
        $this->decimals = $decimals;
        return $this;
    }

    /**
     * returns number of decimals
     *
     * @return  int
     */
    public function getDecimals()
    {
        return $this->decimals;
    }

    /**
     * checks if given value is double
     *
     * @param   mixed      $value  value to filter
     * @return  int|float
     */
    function execute($value)
    {
        if (null === $value) {
            return null;
        }
        
        settype($value, 'float');
        if (null == $this->decimals) {
            return $value;
        }
        
        return (int) ($value * pow(10, $this->decimals));
    }
}
?><?php
/**
 * Class for filtering strings for valid HTTP URLs.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubHTTPURLFilter.php 2330 2009-09-16 17:45:44Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilter',
                      'net::stubbles::peer::http::stubHTTPURL'
);
/**
 * Class for filtering strings for valid HTTP URLs.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubHTTPURLFilter extends stubBaseObject implements stubFilter
{
    /**
     * request value error factory
     *
     * @var  stubRequestValueErrorFactory
     */
    protected $rveFactory;
    /**
     * switch whether DNS should be checked or not
     *
     * @var  bool
     */
    protected $checkDNS  = false;

    /**
     * constructor
     *
     * @param  stubRequestValueErrorFactory  $rveFactory  factory to create stubRequestValueErrors
     */
    public function __construct(stubRequestValueErrorFactory $rveFactory)
    {
        $this->rveFactory = $rveFactory;
    }

    /**
     * switch the dns check on or off
     *
     * @param   bool               $checkDNS
     * @return  stubHTTPURLFilter
     * @deprecated
     */
    public function setCheckDNS($checkDNS)
    {
        $this->checkDNS = $checkDNS;
        return $this;
    }

    /**
     * checks whether DNS check is enabled
     *
     * @return  bool
     */
    public function isDNSCheckEnabled()
    {
        return $this->checkDNS;
    }

    /**
     * check if value is a valid HTTP URL
     *
     * @param   string               $value
     * @return  string               valid HTTP URL
     * @throws  stubFilterException  when $value has errors
     */
    public function execute($value)
    {
        try {
            $http = stubHTTPURL::fromString($value);
        } catch (stubMalformedURLException $murle) {
            throw new stubFilterException($this->rveFactory->create('URL_INCORRECT'));
        }
        
        if (null === $http) {
            return null;
        }
        
        if (true === $this->checkDNS && $http->checkDNS() === false) {
            throw new stubFilterException($this->rveFactory->create('URL_NOT_AVAILABLE'));
        }
    
        return $http->get(!$http->hasDefaultPort());
    }
}
?><?php
/**
 * Basic class for filters on request variables of type integer.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubIntegerFilter.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilter');
/**
 * Basic class for filters on request variables of type integer.
 *
 * This filter takes any value and casts it to int.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubIntegerFilter extends stubBaseObject implements stubFilter
{
    /**
     * checks if given value is an integer
     *
     * @param   mixed  $value  value to filter
     * @return  int
     */
    function execute($value)
    {
        if (null !== $value) {
            settype($value, 'integer');
        }
        
        return $value;
    }
}
?><?php
/**
 * Class for decoding JSON with not very sophisticated syntax check.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubJsonFilter.php 2257 2009-06-24 10:11:48Z richi $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilter',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException'
);
/**
 * Class for decoding JSON with not very sophisticated syntax check.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @link        http://www.json.org/
 * @link        http://www.ietf.org/rfc/rfc4627.txt
 */
class stubJsonFilter extends stubBaseObject implements stubFilter
{
    /**
     * Checks if given string is valid JSON.
     *
     * @param   mixed  $value  JSON to filter
     * @return  stdClass|array
     * @throws  stubIllegalArgumentException
     */
    public function execute($value)
    {
        if ($value === null) {
            throw new stubIllegalArgumentException('No proper JSON structure given.');
        }

        if (strlen($value) > 20000) {
            throw new stubIllegalArgumentException('JSON-Input too big - aborted.');
        }

        // JSON can only be an object or an array structure (see JSON spec & RFC)
        if ($value[0] === '{' && $value[strlen($value)-1] !== '}') {
            throw new stubIllegalArgumentException('No proper JSON array/object given.');
        } elseif ($value[0] === '[' && $value[strlen($value)-1] !== ']') {
            throw new stubIllegalArgumentException('No proper JSON array/object given.');
        }

        $decodedJson = json_decode($value);
        if ( (function_exists('json_last_error')
             && json_last_error() !== JSON_ERROR_NONE)
             || $decodedJson === null
             || is_scalar($decodedJson) === true) {

            // JSON can only be an object or an array structure (see JSON spec & RFC)
            // json_decode from php lacks this restriction
            throw new stubIllegalArgumentException('No proper JSON structure given.');
        }

        return $decodedJson;
    }
}
?><?php
/**
 * Base class for filtering strings.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubLengthFilterDecorator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueErrorFactory',
                      'net::stubbles::ipo::request::filter::stubStrategyFilterDecorator',
                      'net::stubbles::ipo::request::validator::stubValidator'
);
/**
 * Base class for filtering strings.
 *
 * This is a base class for string filtering. It provides methods to check the
 * minimum and maximum length of a string using validators, but both are
 * optional checks.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubLengthFilterDecorator extends stubStrategyFilterDecorator
{
    /**
     * request value error factory
     *
     * @var  stubRequestValueErrorFactory
     */
    protected $rveFactory;
    /**
     * validator for minimum length of string
     *
     * @var  stubValidator
     */
    protected $minLength        = null;
    /**
     * the error id to use in case min length validation fails
     *
     * @var  string
     */
    protected $minLengthErrorId = 'STRING_TOO_SHORT';
    /**
     * validator for maximum length of string
     *
     * @var  stubValidator
     */
    protected $maxLength   = null;
    /**
     * the error id to use in case max length validation fails
     *
     * @var  string
     */
    protected $maxLengthErrorId = 'STRING_TOO_LONG';

    /**
     * constructor
     *
     * @param  stubFilter                    $filter      decorated filter
     * @param  stubRequestValueErrorFactory  $rveFactory  factory to create RequestValueErrors
     */
    public function __construct(stubFilter $filter, stubRequestValueErrorFactory $rveFactory)
    {
        $this->setDecoratedFilter($filter);
        $this->rveFactory = $rveFactory;
    }

    /**
     * set a min length validator
     *
     * @param  stubValidator  $minLength
     * @param  string         $minLengthErrorId  optional  error id to use in case validation fails
     */
    public function setMinLengthValidator(stubValidator $minLength, $minLengthErrorId = null)
    {
        $this->minLength        = $minLength;
        if (null !== $minLengthErrorId) {
            $this->minLengthErrorId = $minLengthErrorId;
        }
    }

    /**
     * returns the min length validator
     *
     * @return  stubValidator
     */
    public function getMinLengthValidator()
    {
        return $this->minLength;
    }

    /**
     * returns the error id to use in case validation fails
     *
     * @return  string
     */
    public function getMinLengthErrorId()
    {
        return $this->minLengthErrorId;
    }

    /**
     * set a max length validator
     *
     * @param  stubValidator  $maxLength
     * @param  string         $maxLengthErrorId  optional  error id to use in case validation fails
     */
    public function setMaxLengthValidator(stubValidator $maxLength, $maxLengthErrorId = null)
    {
        $this->maxLength = $maxLength;
        if (null !== $maxLengthErrorId) {
            $this->maxLengthErrorId = $maxLengthErrorId;
        }
    }

    /**
     * returns the max length validator
     *
     * @return  stubValidator
     */
    public function getMaxLengthValidator()
    {
        return $this->maxLength;
    }

    /**
     * returns the error id to use in case validation fails
     *
     * @return  string
     */
    public function getMaxLengthErrorId()
    {
        return $this->maxLengthErrorId;
    }

    /**
     * execute the filter
     *
     * @param   string  $value
     * @return  string
     * @throws  stubFilterException
     */
    protected function doExecute($value)
    {
        if (strlen($value) === 0) {
            return null;
        }
        
        if (null != $this->minLength && $this->minLength->validate($value) === false) {
            // input is shorter than maximal allowed length
            throw new stubFilterException($this->rveFactory->create($this->minLengthErrorId)->setValues($this->minLength->getCriteria()));
        } elseif (null != $this->maxLength && $this->maxLength->validate($value) === false) {
            // input is longer than maximal allowed length
            throw new stubFilterException($this->rveFactory->create($this->maxLengthErrorId)->setValues($this->maxLength->getCriteria()));
        }
        
        return $value;
    }
}
?><?php
/**
 * Class for filtering mail addresses.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubMailFilter.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilter',
                      'net::stubbles::ipo::request::validator::stubMailValidator'
);
/**
 * Class for filtering mail addresses.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubMailFilter extends stubBaseObject implements stubFilter
{
    /**
     * request value error factory
     *
     * @var  stubRequestValueErrorFactory
     */
    protected $rveFactory;
    /**
     * validator to use for checking the mail address
     *
     * @var  stubValidator
     */
    protected $mailValidator;

    /**
     * constructor
     *
     * @param  stubRequestValueErrorFactory  $rveFactory     factory to create stubRequestValueErrors
     */
    public function __construct(stubRequestValueErrorFactory $rveFactory)
    {
        $this->rveFactory = $rveFactory;
    }

    /**
     * use another validator
     *
     * @param  stubValidator    $validator
     * @return  stubMailFilter
     */
    public function usingValidator(stubValidator $validator)
    {
        $this->mailValidator = $validator;
        return $this;
    }

    /**
     * check if entered passwords fulfill password conditions
     *
     * @param   array|string         $value  the mail addressto check
     * @return  string               the checked mail address to check
     * @throws  stubFilterException  in case $value has errors
     */
    public function execute($value)
    {
        if (strlen($value) === 0) {
            return null;
        }
        
        if (null === $this->mailValidator) {
            $this->mailValidator = new stubMailValidator();
        }
        
        if ($this->mailValidator->validate($value) === true) {
            return $value;
        }
        
        //    check for spaces
        if (preg_match('/\s/i', $value) != false) {
            throw new stubFilterException($this->rveFactory->create('MAILADDRESS_CANNOT_CONTAIN_SPACES'));
        }

        //    check for German umlaut
        if (preg_match('/[����]/i', $value) != false) {
            throw new stubFilterException($this->rveFactory->create('MAILADDRESS_CANNOT_CONTAIN_UMLAUTS'));
        }

        //    check for more than one '@'
        if (substr_count($value, '@') != 1) {
            throw new stubFilterException($this->rveFactory->create('MAILADDRESS_MUST_CONTAIN_ONE_AT'));
        }

        //    check for valid chars in email
        if (preg_match('/^[' . preg_quote('abcdefghijklmnopqrstuvwxyz1234567890@.+_-') . ']+$/iD', $value) == false) {
            throw new stubFilterException($this->rveFactory->create('MAILADDRESS_CONTAINS_ILLEGAL_CHARS'));
        }
        
        if (strpos($value, '..') !== false) {
            throw new stubFilterException($this->rveFactory->create('MAILADDRESS_CONTAINS_TWO_FOLLOWING_DOTS'));
        }
        
        throw new stubFilterException($this->rveFactory->create('MAILADDRESS_INCORRECT'));
    }
}
?><?php
/**
 * Class for filtering passwords.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubPasswordFilter.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilter',
                      'net::stubbles::php::string::stubStringEncoder',
                      'net::stubbles::ipo::request::validator::stubValidator'
);
/**
 * Class for filtering passwords.
 *
 * This filter allows to check password inputs and if they comply with the rules
 * for a password. It is possible to check against a list of non-allowed passwords
 * (e.g. the username or the login name).
 * If the value is an array the fields with key 0 and 1 are compared. If they are
 * not equal the password is not allowed (can be used to prevent mistyped
 * passwords in register or password change forms).
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubPasswordFilter extends stubBaseObject implements stubFilter
{
    /**
     * request value error factory
     *
     * @var  stubRequestValueErrorFactory
     */
    protected $rveFactory;
    /**
     * minimum amount of different characters in the password
     *
     * @var  int
     */
    protected $minDiffChars     = 5;
    /**
     * list of values that are not allowed as password
     *
     * @var  array
     */
    protected $nonAllowedValues = array();

    /**
     * constructor
     *
     * @param  stubRequestValueErrorFactory  $rveFactory  factory to create stubRequestValueErrors
     */
    public function __construct(stubRequestValueErrorFactory $rveFactory)
    {
        $this->rveFactory = $rveFactory;
    }

    /**
     * set a list of values that are not allowed as password
     *
     * @param  array  $values  list of values that are not allowed as password
     */
    public function nonAllowedValues(array $values)
    {
        $this->nonAllowedValues = $values;
    }

    /**
     * returns a list of values that are not allowed as password
     *
     * @return  array
     */
    public function getNonAllowedValues()
    {
        return $this->nonAllowedValues;
    }

    /**
     * set minimum amount of different characters within password
     * 
     * Set the value with NULL to disable the check.
     *
     * @param  int  $minDiffChars
     */
    public function minDiffChars($minDiffChars)
    {
        $this->minDiffChars = $minDiffChars;
    }

    /**
     * return the minimum amount of different characters within the password
     *
     * @return  int
     */
    public function getMinDiffChars()
    {
        return $this->minDiffChars;
    }

    /**
     * check if entered passwords fulfill password conditions
     *
     * @param   array|string         $value  two passwords in an array or one password as string
     * @return  string               secured password
     * @throws  stubFilterException  when $value has errors
     */
    public function execute($value)
    {
        if (is_array($value) === true) {
            if ($value[0] !== $value[1]) {
                throw new stubFilterException($this->rveFactory->create('PASSWORDS_NOT_EQUAL'));
            }

            $value = $value[0];
        }

        if (in_array($value, $this->nonAllowedValues) === true) {
            throw new stubFilterException($this->rveFactory->create('PASSWORD_INVALID'));
        }
        
        if (null !== $this->minDiffChars) {
            if (count(count_chars($value, 1)) < $this->minDiffChars) {
                throw new stubFilterException($this->rveFactory->create('PASSWORD_TOO_LESS_DIFF_CHARS'));
            }
        }

        if (strlen($value) > 0) {
            return $value;
        }
        
        return null;
    }
}
?><?php
/**
 * Filter to check if a date is inbetween a certain period.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubPeriodFilterDecorator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueErrorFactory',
                      'net::stubbles::ipo::request::filter::stubStrategyFilterDecorator',
                      'net::stubbles::lang::types::stubDate'
);
/**
 * Filter to check if a date is inbetween a certain period.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubPeriodFilterDecorator extends stubStrategyFilterDecorator
{
    /**
     * request value error factory
     *
     * @var  stubRequestValueErrorFactory
     */
    protected $rveFactory;
    /**
     * smallest allowed date
     *
     * @var  stubDate
     */
    protected $minDate        = null;
    /**
     * the error id to use in case min date validation fails
     *
     * @var  string
     */
    protected $minDateErrorId = 'DATE_TOO_EARLY';
    /**
     * greatest allowed date
     *
     * @var  stubDate
     */
    protected $maxDate        = null;
    /**
     * the error id to use in case max date validation fails
     *
     * @var  string
     */
    protected $maxDateErrorId = 'DATE_TOO_LATE';
    /**
     * format of date in error messages
     *
     * @var  string
     */
    protected $dateFormat     = 'Y-m-d';

    /**
     * constructor
     *
     * @param  stubFilter                    $filter      decorated filter
     * @param  stubRequestValueErrorFactory  $rveFactory  factory to create RequestValueErrors
     */
    public function __construct(stubFilter $filter, stubRequestValueErrorFactory $rveFactory)
    {
        $this->setDecoratedFilter($filter);
        $this->rveFactory = $rveFactory;
    }

    /**
     * set a min length validator
     *
     * @param  stubDate  $minDate
     * @param  string    $minDateErrorId  optional  error id to use in case validation fails
     */
    public function setMinDate(stubDate $minDate, $minDateErrorId = null)
    {
        $this->minDate = $minDate;
        if (null !== $minDateErrorId) {
            $this->minDateErrorId = $minDateErrorId;
        }
    }

    /**
     * returns the min date
     *
     * @return  stubDate
     */
    public function getMinDate()
    {
        return $this->minDate;
    }

    /**
     * returns the error id to use in case validation fails
     *
     * @return  string
     */
    public function getMinDateErrorId()
    {
        return $this->minDateErrorId;
    }

    /**
     * set a max length validator
     *
     * @param  stubDate  $maxDate
     * @param  string    $maxDateErrorId  optional  error id to use in case validation fails
     */
    public function setMaxDate(stubDate $maxDate, $maxDateErrorId = null)
    {
        $this->maxDate = $maxDate;
        if (null !== $maxDateErrorId) {
            $this->maxDateErrorId = $maxDateErrorId;
        }
    }

    /**
     * returns the max date
     *
     * @return  stubDate
     */
    public function getMaxDate()
    {
        return $this->maxDate;
    }

    /**
     * returns the error id to use in case validation fails
     *
     * @return  string
     */
    public function getMaxDateErrorId()
    {
        return $this->maxDateErrorId;
    }

    /**
     * sets the way the date will be formatted in error messages
     *
     * @param  string  $dateFormat
     */
    public function setDateFormat($dateFormat)
    {
        $this->dateFormat = $dateFormat;
    }

    /**
     * returns format of date in error messages
     *
     * @return  string
     */
    public function getDateFormat()
    {
        return $this->dateFormat;
    }

    /**
     * execute the filter
     *
     * @param   string  $value
     * @return  string
     * @throws  stubFilterException
     */
    protected function doExecute($value)
    {
        if (($value instanceof stubDate) === false) {
            return null;
        }

        if (null != $this->minDate && $this->minDate->isAfter($value) === true) {
            throw new stubFilterException($this->rveFactory->create($this->minDateErrorId)->setValues(array('earliestDate' => $this->minDate->format($this->dateFormat))));
        } elseif (null != $this->maxDate && $this->maxDate->isBefore($value) === true) {
            throw new stubFilterException($this->rveFactory->create($this->maxDateErrorId)->setValues(array('latestDate' => $this->maxDate->format($this->dateFormat))));
        }

        return $value;
    }
}
?><?php
/**
 * Basic class for filters on variables of type number.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubRangeFilterDecorator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueErrorFactory',
                      'net::stubbles::ipo::request::filter::stubStrategyFilterDecorator',
                      'net::stubbles::ipo::request::validator::stubValidator'
);
/**
 * Basic class for filters on variables of type number.
 *
 * This filter takes any value, casts it to float and checks if it complies
 * with the min and/or the max validator.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubRangeFilterDecorator extends stubStrategyFilterDecorator
{
    /**
     * request value error factory
     *
     * @var  stubRequestValueErrorFactory
     */
    protected $rveFactory;
    /**
     * validator for minimum values
     *
     * @var  stubValidator
     */
    protected $minValidator = null;
    /**
     * the error id to use in case min validation fails
     *
     * @var  string
     */
    protected $minErrorId   = 'VALUE_TOO_SMALL';
    /**
     * validator for maximum values
     *
     * @var  stubValidator
     */
    protected $maxValidator = null;
    /**
     * the error id to use in case max validation fails
     *
     * @var  string
     */
    protected $maxErrorId   = 'VALUE_TOO_GREAT';

    /**
     * constructor
     *
     * @param  stubFilter                    $filter      decorated filter
     * @param  stubRequestValueErrorFactory  $rveFactory  factory to create RequestValueErrors
     */
    public function __construct(stubFilter $filter, stubRequestValueErrorFactory $rveFactory)
    {
        $this->setDecoratedFilter($filter);
        $this->rveFactory   = $rveFactory;
    }

    /**
     * sets the validator for minimum values
     *
     * @param  stubValidator  $minValidator
     * @param  string         $minErrorId    optional  error id to use in case validation fails
     */
    public function setMinValidator(stubValidator $minValidator, $minErrorId = null)
    {
        $this->minValidator = $minValidator;
        if (null !== $minErrorId) {
            $this->minErrorId   = $minErrorId;
        }
    }

    /**
     * returns the validator for minimum values
     *
     * @return  stubValidator
     */
    public function getMinValidator()
    {
        return $this->minValidator;
    }

    /**
     * returns the error id to use in case validation fails
     *
     * @return  string
     */
    public function getMinErrorId()
    {
        return $this->minErrorId;
    }

    /**
     * sets the validator for maximum values
     *
     * @param  stubValidator  $maxValidator
     * @param  string         $maxErrorId    optional  error id to use in case validation fails
     */
    public function setMaxValidator(stubValidator $maxValidator, $maxErrorId = null)
    {
        $this->maxValidator = $maxValidator;
        if (null !== $maxErrorId) {
            $this->maxErrorId   = $maxErrorId;
        }
    }

    /**
     * returns the validator for maximum values
     *
     * @return  stubValidator
     */
    public function getMaxValidator()
    {
        return $this->maxValidator;
    }

    /**
     * returns the error id to use in case validation fails
     *
     * @return  string
     */
    public function getMaxErrorId()
    {
        return $this->maxErrorId;
    }

    /**
     * checks if given value exceeds borders
     *
     * @param   numeric              $value  value to filter
     * @return  numeric              filtered value
     * @throws  stubFilterException  in case $value has errors
     */
    protected function doExecute($value)
    {
        if (null !== $value && null !== $this->minValidator && $this->minValidator->validate($value) !== true) {
             // add error message if input is smaller than minimum value
            throw new stubFilterException($this->rveFactory->create($this->minErrorId)->setValues($this->minValidator->getCriteria()));
        } elseif (null !== $value && null !== $this->maxValidator && $this->maxValidator->validate($value) !== true) {
            // add error message if input is greater than maximum value
            throw new stubFilterException($this->rveFactory->create($this->maxErrorId)->setValues($this->maxValidator->getCriteria()));
        }

        return $value;
    }
}
?><?php
/**
 * Class for changing values with a regular expression.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubRegexFilterDecorator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueErrorFactory',
                      'net::stubbles::ipo::request::filter::stubStrategyFilterDecorator'
);
/**
 * Class for changing values with a regular expression.
 *
 * This filter does a check against a regular expression and returns the
 * requested match. If no match is found the returned value will be null.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubRegexFilterDecorator extends stubStrategyFilterDecorator
{
    /**
     * regex
     *
     * @var  string
     */
    protected $regex;

    /**
     * constructor
     *
     * @param  stubFilter  $filter    decorated filter
     * @param  string      $regex     regex to apply
     */
    function __construct(stubFilter $filter, $regex)
    {
        $this->setDecoratedFilter($filter);
        $this->regex = $regex;
    }

    /**
     * execute the filter
     *
     * @param   string  $value
     * @return  string
     * @throws  stubRuntimeException
     */
    protected function doExecute($value)
    {
        $matches = array();
        if (@preg_match($this->regex, $value, $matches) === false) {
            throw new stubRuntimeException('Invalid regular expression ' . $this->regex);
        }
        
        if (isset($matches[0]) === true) {
            return $matches[0];
        }
        
        return null;
    }
}
?><?php
/**
 * Class for filtering if a value is empty or not.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubRequiredFilterDecorator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueErrorFactory',
                      'net::stubbles::ipo::request::filter::stubStrategyFilterDecorator'
);
/**
 * Class for filtering if a value is empty or not.
 *
 * If the value is empty an error will be created.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubRequiredFilterDecorator extends stubStrategyFilterDecorator
{
    /**
     * request value error factory
     *
     * @var  stubRequestValueErrorFactory
     */
    protected $rveFactory;
    /**
     * error id to be used
     *
     * @var  string
     */
    protected $errorId    = 'FIELD_EMPTY';

    /**
     * constructor
     *
     * @param  stubFilter                    $filter      decorated filter
     * @param  stubRequestValueErrorFactory  $rveFactory  factory to create RequestValueErrors
     * @param  int                           $stategy     optional
     */
    public function __construct(stubFilter $filter, stubRequestValueErrorFactory $rveFactory, $stategy = stubStrategyFilterDecorator::STRATEGY_BEFORE)
    {
        $this->rveFactory = $rveFactory;
        $this->setDecoratedFilter($filter);
        $this->setStrategy($stategy);
    }

    /**
     * sets the id of the request value error to be used
     *
     * @param  string  $errorId
     */
    public function setErrorId($errorId)
    {
        $this->errorId = $errorId;
    }

    /**
     * returns the id of the request value error to be used
     *
     * @return  string
     */
    public function getErrorId()
    {
        return $this->errorId;
    }

    /**
     * execute the filter
     *
     * @param   string  $value
     * @return  string
     * @throws  stubFilterException
     */
    protected function doExecute($value)
    {
        if ((null == $value || strlen($value) == 0)) {
            throw new stubFilterException($this->rveFactory->create($this->errorId));
        }
        
        return $value;
    }
}
?><?php
/**
 * Decorator that is able to execute the decorating behaviour before or after
 * the decorated filter.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubStrategyFilterDecorator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubAbstractFilterDecorator',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::lang::exceptions::stubIllegalStateException'
);
/**
 * Decorator that is able to execute the decorating behaviour before or after
 * the decorated filter.
 *
 * Default strategy is to execute the decorating behaviour after the decorated
 * filter was executed.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
abstract class stubStrategyFilterDecorator extends stubAbstractFilterDecorator
{
    /**
     * indicates the decorator behavior:
     * 
     * decorate the filter *before* the actual method call.
     */
    const STRATEGY_BEFORE = -1;
    /**
     * indicates the decorator behavior:
     * 
     * decorate the filter *after* the actual method call.
     */
    const STRATEGY_AFTER  = 1;
    /**
     * decorator Strategy:
     * 
     * <ul>
     *   <li>stubStrategyFilterDecorator::STRATEGY_BEFORE</li>
     *   <li>stubStrategyFilterDecorator::STRATEGY_AFTER</li>
     * </ul>
     *
     * @var  int
     */
    protected $strategy   = self::STRATEGY_AFTER;

    /**
     * sets the strategy to be applied
     *
     * @param   int  $strategy
     * @throws  stubIllegalArgumentException
     */
    public function setStrategy($strategy)
    {
        if (in_array($strategy, array(self::STRATEGY_BEFORE, self::STRATEGY_AFTER)) === false) {
            throw new stubIllegalArgumentException('Invalid strategy type ' . $strategy);
        }
        
        $this->strategy = $strategy;
    }

    /**
     * execute the filter
     *
     * @param   string                     $value
     * @return  string
     * @throws  stubIllegalStateException
     */
    public function execute($value)
    {
        $result = null;
        switch ($this->strategy) {
            case self::STRATEGY_BEFORE:
                $result = $this->getDecoratedFilter()->execute($this->doExecute($value));
                break;

            case self::STRATEGY_AFTER:
                $result = $this->doExecute($this->getDecoratedFilter()->execute($value));
                break;

            default:
                throw new stubIllegalStateException('Invalid strategy type ' . $this->strategy);
        }
        
        return $result;
    }

    /**
     * execute the filter
     *
     * @param   string  $value
     * @return  string
     */
    protected abstract function doExecute($value);
}
?><?php
/**
 * Class for filtering strings (singe line).
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubStringFilter.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilter');
/**
 * Class for filtering strings (singe line).
 *
 * This filter removes all line breaks, slashes and HTML tags.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubStringFilter extends stubBaseObject implements stubFilter
{
    /**
     * filter strings
     *
     * @param   string  $value  value to filter
     * @return  string  filtered value
     */
    public function execute($value)
    {
        if (null != $value) {
            // remove line feeds, HTML and all added slashes from magic_gpc_quote
            $value = str_replace(chr(10), '', str_replace(chr(13), '', stripslashes($value)));
            $value = strip_tags($value);
        }
        
        return $value;
    }
}
?><?php
/**
 * Class for filtering texts (strings containing line feeds).
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubTextFilter.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilter');
/**
 * Class for filtering texts (strings containing line feeds).
 *
 * This filter removes windows line breaks and html tags from the value. Via
 * setAllowedTags() a list of allowed tags that will not be removed can be
 * specified. Use the allowed tags option very careful. It does not protect
 * you against possible XSS attacks!
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubTextFilter extends stubBaseObject implements stubFilter
{
    /**
     * list of allowed tags
     *
     * @var  array<string>
     */
    protected $allowedTags = array();

    /**
     * set the list of allowed tags
     *
     * Use this option very careful. It does not protect you against
     * possible XSS attacks!
     *
     * @param  array<string>  $allowedTags
     */
    public function setAllowedTags(array $allowedTags)
    {
        $this->allowedTags = $allowedTags;
    }

    /**
     * returns the list of allowed tags
     *
     * @return  array<string>
     */
    public function getAllowedTags()
    {
        return $this->allowedTags;
    }

    /**
     * filter strings
     *
     * @param   string  $value  value to filter
     * @return  string  filtered value
     */
    public function execute($value)
    {
        if (null != $value) {
            // remove carriage return and all added slashes from magic_gpc_quote
            $value = str_replace(chr(13), '', stripslashes($value));
            $value = strip_tags($value, ((count($this->allowedTags) > 0) ? ('<' . join('><', $this->allowedTags) . '>') : ('')));
        }

        return $value;
    }
}
?><?php
/**
 * Class for checking values against any validator.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     $Id: stubValidatorFilterDecorator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueErrorFactory',
                      'net::stubbles::ipo::request::filter::stubStrategyFilterDecorator',
                      'net::stubbles::ipo::request::validator::stubValidator'
);
/**
 * Class for checking values against any validator.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 */
class stubValidatorFilterDecorator extends stubStrategyFilterDecorator
{
    /**
     * validator to use for the check
     *
     * @var  stubValidator
     */
    protected $validator;
    /**
     * the error id to use in case the validation fails
     *
     * @var  string
     */
    protected $errorId   = 'FIELD_WRONG_VALUE';

    /**
     * constructor
     *
     * @param  stubFilter                    $filter      decorated filter
     * @param  stubRequestValueErrorFactory  $rveFactory  factory to create RequestValueErrors
     * @param  stubValidator                 $validator   validator to use for the check
     */
    public function __construct(stubFilter $filter, stubRequestValueErrorFactory $rveFactory, stubValidator $validator)
    {
        $this->setDecoratedFilter($filter);
        $this->rveFactory = $rveFactory;
        $this->validator  = $validator;
    }

    /**
     * returns the validator
     *
     * @return  stubValidator
     */
    public function getValidator()
    {
        return $this->validator;
    }

    /**
     * sets the error id to be used
     *
     * @param  string  $errorId
     */
    public function setErrorId($errorId)
    {
        $this->errorId = $errorId;
    }

    /**
     * returns the error id to be used
     *
     * @return  string
     */
    public function getErrorId()
    {
        return $this->errorId;
    }

    /**
     * execute the filter
     *
     * @param   string  $value
     * @return  string
     * @throws  stubFilterException
     */
    protected function doExecute($value)
    {
        if (strlen($value) === 0) {
            return null;
        }
        
        if ($this->validator->validate($value) === false) {
            throw new stubFilterException($this->rveFactory->create($this->errorId));
        }

        return $value;
    }
}
?><?php
/**
 * Class for access to request data.
 * 
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubAbstractRequest.php 2683 2010-08-24 19:33:16Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::request::stubDefaultRequestValueErrorCollection'
);
/**
 * Class for access to request data.
 * 
 * This class offers a basic implementation for the stubRequest interface
 * from which any specialized request classes can be inherited.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 */
abstract class stubAbstractRequest extends stubBaseObject implements stubRequest
{
    /**
     * filter factory to create filters with
     *
     * @var  stubFilterFactory
     */
    protected $filterFactory;
    /**
     * list of unfiltered request variables
     *
     * @var  array<string,string>
     */
    protected $unsecureParams  = array();
    /**
     * list of unfiltered header data
     *
     * @var  array<string,string>
     */
    protected $unsecureHeaders = array();
    /**
     * list of unfiltered cookie data
     *
     * @var  array<string,string>
     */
    protected $unsecureCookies = array();
    /**
     * list of errors that occurred while applying a filter on a param value
     * 
     * @var  stubRequestValueErrorCollection
     */
    private $paramErrors       = null;
    /**
     * list of errors that occurred while applying a filter on a header value
     * 
     * @var  stubRequestValueErrorCollection
     */
    private $headerErrors      = null;
    /**
     * list of errors that occurred while applying a filter on a cookie value
     * 
     * @var  stubRequestValueErrorCollection
     */
    private $cookieErrors      = null;
    /**
     * list of errors that occurred while applying a filter on the request body
     *
     * @var  stubRequestValueErrorCollection
     */
    private $bodyErrors        = null;
    /**
     * switch whether request has been cancelled or not
     *
     * @var  bool
     */
    protected $isCancelled     = false;

    /**
     * constructor
     *
     * @param  stubFilterFactory  $filterFactory  filter factory to create filters with
     */
    public final function __construct(stubFilterFactory $filterFactory)
    {
        $this->filterFactory = $filterFactory;
        $this->doConstuct();
    }

    /**
     * template method for child classes to do the real construction
     */
    protected abstract function doConstuct();

    /**
     * cloning is forbidden
     *
     * @throws  stubRuntimeException
     */
    public final function __clone()
    {
        throw new stubRuntimeException('Cloning of request is not allowed!');
    }

    /**
     * checks if requestor accepts cookies
     *
     * Warning! Detection is based on the amount of cookie values returned by
     * the user agent. If the user agent did not send any cookies this does not
     * necessarily mean that the user agent will not accept cookies.
     *
     * @return  bool
     */
    public function acceptsCookies()
    {
        return (count($this->unsecureCookies) > 0);
    }

    /**
     * checks whether a request param is set
     *
     * @param   string  $paramName
     * @return  bool
     * @since   1.3.0
     */
    public function hasParam($paramName)
    {
        return isset($this->unsecureParams[$paramName]);
    }

    /**
     * checks whether a request header is set
     *
     * @param   string  $paramName
     * @return  bool
     * @since   1.3.0
     */
    public function hasHeader($headerName)
    {
        return isset($this->unsecureHeaders[$headerName]);
    }

    /**
     * checks whether a request cookie is set
     *
     * @param   string  $paramName
     * @return  bool
     * @since   1.3.0
     */
    public function hasCookie($cookieName)
    {
        return isset($this->unsecureCookies[$cookieName]);
    }

    /**
     * returns error collection for request parameters
     *
     * @return  stubRequestValueErrorCollection
     * @since   1.3.0
     */
    public function paramErrors()
    {
        if (null === $this->paramErrors) {
            $this->paramErrors = new stubDefaultRequestValueErrorCollection();
        }

        return $this->paramErrors;
    }

    /**
     * returns error collection for request headers
     *
     * @return  stubRequestValueErrorCollection
     * @since   1.3.0
     */
    public function headerErrors()
    {
        if (null === $this->headerErrors) {
            $this->headerErrors = new stubDefaultRequestValueErrorCollection();
        }

        return $this->headerErrors;
    }

    /**
     * returns error collection for request cookies
     *
     * @return  stubRequestValueErrorCollection
     * @since   1.3.0
     */
    public function cookieErrors()
    {
        if (null === $this->cookieErrors) {
            $this->cookieErrors = new stubDefaultRequestValueErrorCollection();
        }

        return $this->cookieErrors;
    }

    /**
     * returns error collection for request body
     *
     * @return  stubRequestValueErrorCollection
     * @since   1.3.0
     */
    public function bodyErrors()
    {
        if (null === $this->bodyErrors) {
            $this->bodyErrors = new stubDefaultRequestValueErrorCollection();
        }

        return $this->bodyErrors;
    }

    /**
     * cancels the request, e.g. if it was detected that it is invalid
     */
    public function cancel()
    {
        $this->isCancelled = true;
    }

    /**
     * checks whether the request has been cancelled or not
     *
     * @return  bool
     */
    public function isCancelled()
    {
        return $this->isCancelled;
    }

    /**
     * checks whether a request value from parameters is valid or not
     *
     * @param   string                      $paramName  name of request value
     * @return  stubValidatingRequestValue
     * @since   1.3.0
     */
    public function validateParam($paramName)
    {
        return new stubValidatingRequestValue($paramName,
                                              $this->getValue($paramName, stubRequest::SOURCE_PARAM)
               );
    }

    /**
     * checks whether a request value from headers is valid or not
     *
     * @param   string                      $headerName  name of header
     * @return  stubValidatingRequestValue
     * @since   1.3.0
     */
    public function validateHeader($headerName)
    {
        return new stubValidatingRequestValue($headerName,
                                              $this->getValue($headerName, stubRequest::SOURCE_HEADER)
               );
    }

    /**
     * checks whether a request value from cookie is valid or not
     *
     * @param   string                      $cookieName  name of cookie
     * @return  stubValidatingRequestValue
     * @since   1.3.0
     */
    public function validateCookie($cookieName)
    {
        return new stubValidatingRequestValue($cookieName,
                                              $this->getValue($cookieName, stubRequest::SOURCE_COOKIE)
               );
    }

    /**
     * checks whether a request body is valid or not
     *
     * @return  stubValidatingRequestValue
     * @since   1.3.0
     */
    public function validateBody()
    {
        return new stubValidatingRequestValue('body',
                                              $this->getRawData()
               );
    }

    /**
     * returns request value from params for filtering or validation
     *
     * @param   string                     $paramName  name of request value
     * @return  stubFilteringRequestValue
     * @since   1.3.0
     */
    public function readParam($paramName)
    {
        return new stubFilteringRequestValue($this->paramErrors(),
                                             $this->filterFactory,
                                             $paramName,
                                             $this->getValue($paramName, stubRequest::SOURCE_PARAM)
               );
    }

    /**
     * returns request value from headers for filtering or validation
     *
     * @param   string                     $headerName  name of header
     * @return  stubFilteringRequestValue
     * @since   1.3.0
     */
    public function readHeader($headerName)
    {
        return new stubFilteringRequestValue($this->headerErrors(),
                                             $this->filterFactory,
                                             $headerName,
                                             $this->getValue($headerName, stubRequest::SOURCE_HEADER)
               );
    }

    /**
     * returns request value from cookies for filtering or validation
     *
     * @param   string                     $cookieName  name of cookie
     * @return  stubFilteringRequestValue
     * @since   1.3.0
     */
    public function readCookie($cookieName)
    {
        return new stubFilteringRequestValue($this->cookieErrors(),
                                             $this->filterFactory,
                                             $cookieName,
                                             $this->getValue($cookieName, stubRequest::SOURCE_COOKIE)
               );
    }

    /**
     * returns request body for filtering or validation
     *
     * @return  stubFilteringRequestValue
     * @since   1.3.0
     */
    public function readBody()
    {
        return new stubFilteringRequestValue($this->bodyErrors(),
                                             $this->filterFactory,
                                             'body',
                                             $this->getRawData()
               );
    }

    /**
     * return an array of all param names registered in this request
     *
     * @return  array<string>
     * @since   1.3.0
     */
    public function getParamNames()
    {
        return array_keys($this->unsecureParams);
    }

    /**
     * return an array of all header names registered in this request
     *
     * @return  array<string>
     * @since   1.3.0
     */
    public function getHeaderNames()
    {
        return array_keys($this->unsecureHeaders);
    }

    /**
     * return an array of all cookie names registered in this request
     *
     * @return  array<string>
     * @since   1.3.0
     */
    public function getCookieNames()
    {
        return array_keys($this->unsecureCookies);
    }

    /**
     * returns the raw data
     *
     * @return  string
     */
    protected abstract function getRawData();

    /**
     * returns single value with given name from requested source
     *
     * If the given value name does not exist the return value will be null.
     *
     * @param   string  $valueName
     * @param   int     $source
     * @return  string
     * @since   1.3.0
     */
    protected function getValue($valueName, $source)
    {
        $data = $this->getValues($source);
        if (isset($data[$valueName]) === false) {
            return null;
        }

        return $data[$valueName];
    }

    /**
     * returns the array with data from requested source
     *
     * @param   int  $source  source type: cookie, header, param
     * @return  array<string,string>
     */
    protected function getValues($source)
    {
        switch ($source) {
            case stubRequest::SOURCE_PARAM:
                return $this->unsecureParams;
                
            case stubRequest::SOURCE_COOKIE:
                return $this->unsecureCookies;
                
            case stubRequest::SOURCE_HEADER:
                return $this->unsecureHeaders;
            
            default:
                return $this->unsecureParams;
        }
    }
}
?><?php
/**
 * Default implementation of a value error list.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubDefaultRequestValueErrorCollection.php 2637 2010-08-14 18:25:37Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueErrorCollection');
/**
 * Default implementation of a value error list.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @since       1.3.0
 */
class stubDefaultRequestValueErrorCollection extends stubBaseObject implements stubRequestValueErrorCollection
{
    /**
     * list of errors that occurred while applying a filter on a request value
     *
     * @var  array<string,array<string,stubRequestValueError>>
     */
    protected $errors = array();

    /**
     * add a value error to the collection
     *
     * Return value is the added $valueError instance.
     *
     * @param   stubRequestValueError  $valueError
     * @param   string                 $valueName
     * @return  stubRequestValueError
     */
    public function add(stubRequestValueError $valueError, $valueName)
    {
        if (isset($this->errors[$valueName]) === false) {
            $this->errors[$valueName] = array($valueError->getId() => $valueError);
        } else {
            $this->errors[$valueName][$valueError->getId()] = $valueError;
        }

        return $valueError;
    }

    /**
     * returns number of collected errors
     *
     * @return  int
     */
    public function count()
    {
        return count($this->errors);
    }

    /**
     * checks whether there are any errors at all
     *
     * @return  bool
     */
    public function exist()
    {
        return ($this->count() > 0);
    }

    /**
     * checks whether a request value has any error
     *
     * @param   string  $valueName  name of request value
     * @return  bool
     */
    public function existFor($valueName)
    {
        return isset($this->errors[$valueName]);
    }

    /**
     * checks whether a request value has a specific error
     *
     * @param   string  $valueName  name of request value
     * @param   string  $errorId    id of error
     * @return  bool
     */
    public function existForWithId($valueName, $errorId)
    {
        return (isset($this->errors[$valueName]) && isset($this->errors[$valueName][$errorId]));
    }

    /**
     * returns list of all errors for all request values
     *
     * @return  array<string,array<string,stubRequestValueError>>
     */
    public function get()
    {
        return $this->errors;
    }

    /**
     * returns a list of errors for given request value
     *
     * @param   string                               $valueName
     * @return  array<string,stubRequestValueError>
     */
    public function getFor($valueName)
    {
        if (isset($this->errors[$valueName]) === true) {
            return $this->errors[$valueName];
        }

        return array();
    }

    /**
     * returns a list of errors for given request value
     *
     * @param   string                 $valueName
     * @param   string                 $errorId    id of error
     * @return  stubRequestValueError
     */
    public function getForWithId($valueName, $errorId)
    {
        if (isset($this->errors[$valueName]) && isset($this->errors[$valueName][$errorId])) {
            return $this->errors[$valueName][$errorId];
        }

        return null;
    }
}
?><?php
/**
 * Value object for request values to filter them or retrieve them after validation.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubFilteringRequestValue.php 2688 2010-08-24 22:48:36Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueErrorCollection',
                      'net::stubbles::ipo::request::filter::stubFilter',
                      'net::stubbles::ipo::request::filter::stubFilterFactory'
);
/**
 * Value object for request values to filter them or retrieve them after validation.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @since       1.3.0
 */
class stubFilteringRequestValue extends stubBaseObject
{
    /**
     * request instance the value inherits from
     *
     * @var  stubRequestValueErrorCollection
     */
    protected $requestValueErrorCollection;
    /**
     * filter factory to create filters with
     *
     * @var  stubFilterFactory
     */
    protected $filterFactory;
    /**
     * original value
     *
     * @var  string
     */
    protected $value;
    /**
     * name of value
     *
     * @var  string
     */
    protected $name;

    /**
     * constructor
     *
     * @param  stubRequestValueErrorCollection  $requestValueErrorCollection  request instance the value inherits from
     * @param  stubFilterFactory                $filterFactory                filter factory to create filters with
     * @param  string                           $name                         name of value
     * @param  string                           $value                        original value
     */
    public function __construct(stubRequestValueErrorCollection $requestValueErrorCollection, stubFilterFactory $filterFactory, $name, $value)
    {
        $this->requestValueErrorCollection = $requestValueErrorCollection;
        $this->filterFactory               = $filterFactory;
        $this->name                        = $name;
        $this->value                       = $value;
    }

    /**
     * read as integer value
     *
     * @param   int    $min       optional  minimum allowed value
     * @param   int    $max       optional  maximum allowed value
     * @param   int    $default   optional  default value to fall back to
     * @param   bool   $required  optional  if a value is required, defaults to false
     * @return  int
     */
    public function asInt($min = null, $max = null, $default = null, $required = false)
    {
        $filter = $this->filterFactory->createForType('int')
                                      ->inRange($min, $max)
                                      ->defaultsTo($default);
        if (true === $required) {
            $filter->asRequired();
        }
        
        return $this->withFilter($filter);
    }

    /**
     * read as float value
     *
     * @param   int    $min       optional  minimum allowed value
     * @param   int    $max       optional  maximum allowed value
     * @param   float  $default   optional  default value to fall back to
     * @param   bool   $required  optional  if a value is required, defaults to false
     * @param   int    $decimals  optional  number of decimals
     * @return  float
     */
    public function asFloat($min = null, $max = null, $default = null, $required = false, $decimals = null)
    {
        $filter = $this->filterFactory->createForType('float')
                                      ->setDecimals($decimals)
                                      ->inRange($min, $max)
                                      ->defaultsTo($default);
        if (true === $required) {
            $filter->asRequired();
        }

        return $this->withFilter($filter);
    }

    /**
     * read as string value
     *
     * @param   int     $minLength  optional  minimum length of string
     * @param   int     $maxLength  optional  maximum length of string
     * @param   string  $default    optional  default value to fall back to
     * @param   bool    $required   optional  if a value is required, defaults to false
     * @return  string
     */
    public function asString($minLength = null, $maxLength = null, $default = null, $required = false)
    {
        $filter = $this->filterFactory->createForType('string')
                                      ->length($minLength, $maxLength)
                                      ->defaultsTo($default);
        if (true === $required) {
            $filter->asRequired();
        }

        return $this->withFilter($filter);
    }

    /**
     * read as text value
     *
     * @param   int     $minLength  optional  minimum length of string
     * @param   int     $maxLength  optional  maximum length of string
     * @param   string  $default    optional  default value to fall back to
     * @param   bool    $required   optional  if a value is required, defaults to false
     * @return  string
     */
    public function asText($minLength = null, $maxLength = null, $default = null, $required = false)
    {
        $filter = $this->filterFactory->createForType('text')
                                      ->length($minLength, $maxLength)
                                      ->defaultsTo($default);
        if (true === $required) {
            $filter->asRequired();
        }

        return $this->withFilter($filter);
    }

    /**
     * read as json value
     *
     * @param   string  $default   optional  default value to fall back to
     * @param   bool    $required  optional  if a value is required, defaults to false
     * @return  string
     */
    public function asJson($default = null, $required = false)
    {
        $filter = $this->filterFactory->createForType('json')
                                      ->defaultsTo($default);
        if (true === $required) {
            $filter->asRequired();
        }

        return $this->withFilter($filter);
    }

    /**
     * read as password value
     *
     * @param   int            $minDiffChars      optional  minimum amount of different characters within password
     * @param   array<string>  $nonAllowedValues  optional  list of values that are not allowed as password
     * @param   bool           $required          optional  if a value is required, defaults to false
     * @return  string
     */
    public function asPassword($minDiffChars = 5, array $nonAllowedValues = array(), $required = false)
    {
        $filter = $this->filterFactory->createForType('password')
                                      ->minDiffChars($minDiffChars)
                                      ->nonAllowedValues($nonAllowedValues);
        if (true === $required) {
            $filter->asRequired();
        }

        return $this->withFilter($filter);
    }

    /**
     * read as http url
     *
     * @param   bool                  $checkDns   optional  whether url should be checked via DNS
     * @param   stubHTTPURLContainer  $default    optional  default value to fall back to
     * @param   bool                  $required   optional  if a value is required, defaults to false
     * @return  stubHTTPURL
     */
    public function asHttpUrl($checkDns = false, stubHTTPURLContainer $default = null, $required = false)
    {
        $filter = $this->filterFactory->createForType('http')
                                      ->setCheckDNS($checkDns)
                                      ->defaultsTo($default);
        if (true === $required) {
            $filter->asRequired();
        }

        return $this->withFilter($filter);
    }

    /**
     * read as mail address
     *
     * @param   bool    $required  optional  if a value is required, defaults to false
     * @return  string
     */
    public function asMailAddress($required = false)
    {
        $filter = $this->filterFactory->createForType('mail');
        if (true === $required) {
            $filter->asRequired();
        }

        return $this->withFilter($filter);
    }

    /**
     * read as date value
     *
     * @param   stubDate  $minDate    optional  smallest allowed date
     * @param   stubDate  $maxDate    optional  greatest allowed date
     * @param   stubDate  $default    optional  default value to fall back to
     * @param   bool      $required   optional  if a value is required, defaults to false
     * @return  stubDate

     */
    public function asDate(stubDate $minDate = null, stubDate $maxDate = null, stubDate $default = null, $required = false)
    {
        $filter = $this->filterFactory->createForType('date')
                                      ->inPeriod($minDate, $maxDate)
                                      ->defaultsTo($default);
        if (true === $required) {
            $filter->asRequired();
        }

        return $this->withFilter($filter);
    }

    /**
     * read a value of given type
     *
     * @param   string  $type  type of variable to read
     * @return  mixed
     */
    public function asType($type)
    {
        return $this->withFilter($this->filterFactory->createForType($type));
    }

    /**
     * filters value with given filter
     *
     * If value does not satisfy given filter return value will be null.
     *
     * @param   stubFilter  $filter
     * @return  mixed
     */
    public function withFilter(stubFilter $filter)
    {
        try {
            $value = $filter->execute($this->value);
        } catch (stubFilterException $fe) {
            $this->requestValueErrorCollection->add($fe->getError(), $this->name);
            $value = null;
        }

        return $value;
    }

    /**
     * returns value if it contains given string, and null otherwise
     *
     * @param   string  $contained  byte sequence the value must contain
     * @param   string  $default    optional  default value to fall back to
     * @return  string
     */
    public function ifContains($contained, $default = null)
    {
        stubClassLoader::load('net::stubbles::ipo::request::validator::stubContainsValidator');
        return $this->withValidator(new stubContainsValidator($contained), $default);
    }

    /**
     * returns value if it eqals an expected value, and null otherwise
     *
     * @param   string  $expected  byte sequence the value must be equal to
     * @param   string  $default   optional  default value to fall back to
     * @return  bool
     */
    public function ifIsEqualTo($expected, $default = null)
    {
        stubClassLoader::load('net::stubbles::ipo::request::validator::stubEqualValidator');
        return $this->withValidator(new stubEqualValidator($expected), $default);
    }

    /**
     * returns value if it is an http url, and null otherwise
     *
     * @param   bool    $checkDns  optional  whether to verify url via DNS
     * @param   string  $default   optional  default value to fall back to
     * @return  string
     */
    public function ifIsHttpUrl($checkDns = false, $default = null)
    {
        stubClassLoader::load('net::stubbles::ipo::request::validator::stubHTTPURLValidator');
        return $this->withValidator(new stubHTTPURLValidator($checkDns), $default);
    }

    /**
     * returns value if it is an ip address, and null otherwise
     *
     * @param   string  $default  optional  default value to fall back to
     * @return  string
     */
    public function ifIsIpAddress($default = null)
    {
        stubClassLoader::load('net::stubbles::ipo::request::validator::stubIpValidator');
        return $this->withValidator(new stubIpValidator(), $default);
    }

    /**
     * returns value if it is a mail address, and null otherwise
     *
     * @param   string  $default  optional  default value to fall back to
     * @return  string
     */
    public function ifIsMailAddress($default = null)
    {
        stubClassLoader::load('net::stubbles::ipo::request::validator::stubMailValidator');
        return $this->withValidator(new stubMailValidator(), $default);
    }

    /**
     * returns value if it is an allowed value according to list of allowed values, and null otherwise
     *
     * @param   array<string>  $allowedValues  list of allowed values
     * @param   string         $default        optional  default value to fall back to
     * @return  string
     */
    public function ifIsOneOf(array $allowedValues, $default = null)
    {
        stubClassLoader::load('net::stubbles::ipo::request::validator::stubPreSelectValidator');
        return $this->withValidator(new stubPreselectValidator($allowedValues), $default);
    }

    /**
     * returns value if it complies to a given regular expression, and null otherwise
     *
     * @param   string  $regex    regular expression to apply
     * @param   string  $default  optional  default value to fall back to
     * @return  string
     */
    public function ifSatisfiesRegex($regex, $default = null)
    {
        stubClassLoader::load('net::stubbles::ipo::request::validator::stubRegexValidator');
        return $this->withValidator(new stubRegexValidator($regex), $default);
    }

    /**
     * checks value with given validator
     *
     * If value does not satisfy the validator return value will be null.
     *
     * @param   stubValidator  $validator  validator to use
     * @param   string         $default    optional  default value to fall back to
     * @return  string
     */
    public function withValidator(stubValidator $validator, $default = null)
    {
        if ($validator->validate($this->value) === true) {
            return $this->value;
        }

        return $default;
    }

    /**
     * returns value unvalidated
     *
     * This should be used with greatest care.
     *
     * @return  string
     */
    public function unsecure()
    {
        return $this->value;
    }

    /**
     * returns name of value
     *
     * @return  string
     */
    public function getName()
    {
        return $this->name;
    }
}
?><?php
/**
 * Simplified filtering request value instance.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubMockFilteringRequestValue.php 2686 2010-08-24 20:15:24Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubDefaultRequestValueErrorCollection',
                      'net::stubbles::ipo::request::stubFilteringRequestValue',
                      'net::stubbles::ipo::request::stubRequestValueErrorPropertiesFactory',
                      'net::stubbles::ipo::request::filter::stubDefaultFilterFactory'
);
/**
 * Simplified filtering request value instance.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @since       1.3.0
 */
class stubMockFilteringRequestValue extends stubFilteringRequestValue
{
    /**
     * constructor
     *
     * @param  string  $name   name of value
     * @param  string  $value  original value
     */
    public function __construct($name, $value)
    {
        parent::__construct(new stubDefaultRequestValueErrorCollection(),
                            new stubDefaultFilterFactory(array('int'      => 'net::stubbles::ipo::request::filter::stubIntegerFilter',
                                                               'integer'  => 'net::stubbles::ipo::request::filter::stubIntegerFilter',
                                                               'double'   => 'net::stubbles::ipo::request::filter::stubFloatFilter',
                                                               'float'    => 'net::stubbles::ipo::request::filter::stubFloatFilter',
                                                               'string'   => 'net::stubbles::ipo::request::filter::stubStringFilter',
                                                               'text'     => 'net::stubbles::ipo::request::filter::stubTextFilter',
                                                               'json'     => 'net::stubbles::ipo::request::filter::stubJsonFilter',
                                                               'password' => 'net::stubbles::ipo::request::filter::stubPasswordFilter',
                                                               'http'     => 'net::stubbles::ipo::request::filter::stubHTTPURLFilter',
                                                               'date'     => 'net::stubbles::ipo::request::filter::stubDateFilter',
                                                               'mail'     => 'net::stubbles::ipo::request::filter::stubMailFilter'
                                                         ),
                                                         new stubRequestValueErrorPropertiesFactory()
                            ),
                            $name,
                            $value
        );
    }
}
?><?php
/**
 * Permits modifiying request values.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubModifiableRequest.php 2678 2010-08-23 21:03:57Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest');
/**
 * Permits modifiying request values.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 */
interface stubModifiableRequest extends stubRequest
{
    /**
     * modifies a param value
     *
     * @param   string                 $paramName  name of param to modify
     * @param   string                 $value      new value for param to modify
     * @return  stubModifiableRequest
     */
    public function setParam($paramName, $value);

    /**
     * removes a param value
     *
     * @param   string                 $paramName  name of param to remove
     * @return  stubModifiableRequest
     */
    public function removeParam($paramName);

    /**
     * modifies a header value
     *
     * @param   string                 $headerName  name of header to modify
     * @param   string                 $value       new value for header to modify
     * @return  stubModifiableRequest
     * @since   1.3.0
     */
    public function setHeader($headerName, $value);

    /**
     * removes a header value
     *
     * @param   string                 $headerName  name of header to remove
     * @return  stubModifiableRequest
     * @since   1.3.0
     */
    public function removeHeader($headerName);

    /**
     * modifies a cookie value
     *
     * @param   string                 $cookieName  name of cookie to modify
     * @param   string                 $value       new value for cookie to modify
     * @return  stubModifiableRequest
     * @since   1.3.0
     */
    public function setCookie($cookieName, $value);

    /**
     * removes a cookie value
     *
     * @param   string                 $cookieName  name of cookie to remove
     * @return  stubModifiableRequest
     * @since   1.3.0
     */
    public function removeCookie($cookieName);
}
?><?php
/**
 * Permits modifiying request values.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubModifiableWebRequest.php 2678 2010-08-23 21:03:57Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubModifiableRequest',
                      'net::stubbles::ipo::request::stubWebRequest'
);
/**
 * Permits modifiying request values.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 */
class stubModifiableWebRequest extends stubWebRequest implements stubModifiableRequest
{
    /**
     * modifies a param value
     *
     * @param   string                 $paramName  name of param to modify
     * @param   string                 $value      new value for param to modify
     * @return  stubModifiableRequest
     */
    public function setParam($paramName, $value)
    {
        $this->unsecureParams[$paramName] = $value;
        return $this;
    }

    /**
     * removes a param value
     *
     * @param   string                 $paramName  name of param to remove
     * @return  stubModifiableRequest
     */
    public function removeParam($paramName)
    {
        if (isset($this->unsecureParams[$paramName]) === true) {
            unset($this->unsecureParams[$paramName]);
        }

        return $this;
    }

    /**
     * modifies a header value
     *
     * @param   string                 $headerName  name of header to modify
     * @param   string                 $value       new value for header to modify
     * @return  stubModifiableRequest
     * @since   1.3.0
     */
    public function setHeader($headerName, $value)
    {
        $this->unsecureHeaders[$headerName] = $value;
        return $this;
    }

    /**
     * removes a header value
     *
     * @param   string                 $headerName  name of header to remove
     * @return  stubModifiableRequest
     * @since   1.3.0
     */
    public function removeHeader($headerName)
    {
        if (isset($this->unsecureHeaders[$headerName]) === true) {
            unset($this->unsecureHeaders[$headerName]);
        }
        
        return $this;
    }

    /**
     * modifies a cookie value
     *
     * @param   string                 $cookieName  name of cookie to modify
     * @param   string                 $value       new value for cookie to modify
     * @return  stubModifiableRequest
     * @since   1.3.0
     */
    public function setCookie($cookieName, $value)
    {
        $this->unsecureCookies[$cookieName] = $value;
        return $this;
    }

    /**
     * removes a cookie value
     *
     * @param   string                 $cookieName  name of cookie to remove
     * @return  stubModifiableRequest
     * @since   1.3.0
     */
    public function removeCookie($cookieName)
    {
        if (isset($this->unsecureCookies[$cookieName]) === true) {
            unset($this->unsecureCookies[$cookieName]);
        }

        return $this;
    }
}
?><?php
/**
 * Value error list which decorates another one allowing access only to prefixed value names.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubPrefixedRequestValueErrorCollection.php 2637 2010-08-14 18:25:37Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueErrorCollection');
/**
 * Value error list which decorates another one allowing access only to prefixed value names.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @since       1.3.0
 */
class stubPrefixedRequestValueErrorCollection extends stubBaseObject implements stubRequestValueErrorCollection
{
    /**
     * decorated instance
     *
     * @var  stubRequestValueErrorCollections
     */
    protected $requestValueErrorCollection;
    /**
     * prefix for request value names
     *
     * @var  string
     */
    protected $prefix;

    /**
     * constructor
     *
     * @param  stubRequestValueErrorCollection  $requestValueErrorCollection
     * @param  string                           $prefix
     */
    public function __construct(stubRequestValueErrorCollection $requestValueErrorCollection, $prefix)
    {
        $this->requestValueErrorCollection = $requestValueErrorCollection;
        $this->prefix                      = $prefix;
    }

    /**
     * helper method to calculate the prefixed value name
     *
     * @param   string  $valueName
     * @return  string
     */
    protected function getPrefixedValueName($valueName)
    {
        return $this->prefix . '_' . $valueName;
    }

    /**
     * add a value error to the collection
     *
     * Return value is the added $valueError instance.
     *
     * @param   stubRequestValueError  $valueError
     * @param   string                 $valueName
     * @return  stubRequestValueError
     */
    public function add(stubRequestValueError $valueError, $valueName)
    {
        return $this->requestValueErrorCollection->add($valueError,
                                                       $this->getPrefixedValueName($valueName)
               );
    }

    /**
     * returns number of collected errors
     *
     * @return  int
     */
    public function count()
    {
        return count($this->get());
    }

    /**
     * checks whether there are any errors at all
     *
     * @return  bool
     */
    public function exist()
    {
        return ($this->count() > 0);
    }

    /**
     * checks whether a request value has any error
     *
     * @param   string  $valueName  name of request value
     * @return  bool
     */
    public function existFor($valueName)
    {
        return $this->requestValueErrorCollection->existFor($this->getPrefixedValueName($valueName));
    }

    /**
     * checks whether a request value has a specific error
     *
     * @param   string  $valueName  name of request value
     * @param   string  $errorId    id of error
     * @return  bool
     */
    public function existForWithId($valueName, $errorId)
    {
        return $this->requestValueErrorCollection->existForWithId($this->getPrefixedValueName($valueName),
                                                                  $errorId
               );
    }

    /**
     * returns list of all errors for all request values
     *
     * @return  array<string,array<string,stubRequestValueError>>
     */
    public function get()
    {
        if ($this->requestValueErrorCollection->exist() === false) {
            return array();
        }

        $returnedErrors = array();
        $checkLength    = strlen($this->prefix) + 1;
        foreach ($this->requestValueErrorCollection->get() as $valueName => $valueErrors) {
            if (substr($valueName, 0, $checkLength) === $this->prefix . '_') {
                $returnedErrors[str_replace($this->prefix . '_', '', $valueName)] = $valueErrors;
            }
        }

        return $returnedErrors;
    }

    /**
     * returns a list of errors for given request value
     *
     * @param   string                               $valueName
     * @return  array<string,stubRequestValueError>
     */
    public function getFor($valueName)
    {
        return $this->requestValueErrorCollection->getFor($this->getPrefixedValueName($valueName));
    }

    /**
     * returns a list of errors for given request value
     *
     * @param   string                 $valueName
     * @param   string                 $errorId    id of error
     * @return  stubRequestValueError
     */
    public function getForWithId($valueName, $errorId)
    {
        return $this->requestValueErrorCollection->getForWithId($this->getPrefixedValueName($valueName),
                                                                $errorId
               );
    }
}
?><?php
/**
 * Request implementation for processing redirected requests.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubRedirectRequest.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubWebRequest');
/**
 * Request implementation for processing redirected requests.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 */
class stubRedirectRequest extends stubWebRequest
{
    /**
     * post initialization of redirect parameters
     *
     * This method initialize parameters, instead of fetching thoose from HTTP
     * GET and POST headers, it access a special HTTP header and fetching from
     * there parameters.
     */
    protected function doConstuct()
    {
        if (isset($_SERVER['REDIRECT_QUERY_STRING']) === true) {
            parse_str($_SERVER['REDIRECT_QUERY_STRING'], $this->unsecureParams);
        } else {
            $this->unsecureParams = $_GET;
        }
        
        $this->unsecureHeaders = $_SERVER;
        $this->unsecureCookies = $_COOKIE;
    }
}
?><?php
/**
 * Interface for handling request variables.
 * 
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubRequest.php 2678 2010-08-23 21:03:57Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubFilteringRequestValue',
                      'net::stubbles::ipo::request::stubRequestValueErrorCollection',
                      'net::stubbles::ipo::request::stubValidatingRequestValue'
);
/**
 * Interface for handling request variables.
 * 
 * The request contains all data send by the user-agent: parameters,
 * headers and cookies. It allows to retrieve this values via validators
 * and filters. Errors that occurred during filtering are collected as well.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @see         http://stubbles.net/wiki/Docs/Validators
 */
interface stubRequest extends stubObject
{
    /**
     * request source: cookies
     */
    const SOURCE_COOKIE      = 1;
    /**
     * request source: header
     */
    const SOURCE_HEADER      = 2;
    /**
     * request source: parameters
     */
    const SOURCE_PARAM       = 4;
    /**
     * request source: body
     *
     * @since  1.3.0
     */
    const SOURCE_BODY        = 8;

    /**
     * checks if requestor accepts cookies
     *
     * @return  bool
     */
    public function acceptsCookies();

    /**
     * checks whether a request param is set
     *
     * @param   string  $paramName
     * @return  bool
     * @since   1.3.0
     */
    public function hasParam($paramName);

    /**
     * checks whether a request header is set
     *
     * @param   string  $paramName
     * @return  bool
     * @since   1.3.0
     */
    public function hasHeader($headerName);

    /**
     * checks whether a request cookie is set
     *
     * @param   string  $paramName
     * @return  bool
     * @since   1.3.0
     */
    public function hasCookie($cookieName);

    /**
     * returns error collection for request parameters
     *
     * @return  stubRequestValueErrorCollection
     * @since   1.3.0
     */
    public function paramErrors();

    /**
     * returns error collection for request headers
     *
     * @return  stubRequestValueErrorCollection
     * @since   1.3.0
     */
    public function headerErrors();

    /**
     * returns error collection for request cookies
     *
     * @return  stubRequestValueErrorCollection
     * @since   1.3.0
     */
    public function cookieErrors();

    /**
     * returns error collection for request body
     *
     * @return  stubRequestValueErrorCollection
     * @since   1.3.0
     */
    public function bodyErrors();

    /**
     * cancels the request, e.g. if it was detected that it is invalid
     */
    public function cancel();

    /**
     * checks whether the request has been cancelled or not
     *
     * @return  bool
     */
    public function isCancelled();

    /**
     * returns the request method
     *
     * @return  string
     */
    public function getMethod();

    /**
     * returns the uri of the request
     * 
     * @return  string
     */
    public function getURI();

    /**
     * returns complete uri including scheme
     *
     * @return  string
     * @since   1.3.0
     */
    public function getCompleteUri();

    /**
     * checks whether a request value from parameters is valid or not
     *
     * @param   string                      $paramName  name of request value
     * @return  stubValidatingRequestValue
     * @since   1.3.0
     */
    public function validateParam($paramName);

    /**
     * checks whether a request value from headers is valid or not
     *
     * @param   string                      $headerName  name of header
     * @return  stubValidatingRequestValue
     * @since   1.3.0
     */
    public function validateHeader($headerName);

    /**
     * checks whether a request value from cookie is valid or not
     *
     * @param   string                      $cookieName  name of cookie
     * @return  stubValidatingRequestValue
     * @since   1.3.0
     */
    public function validateCookie($cookieName);

    /**
     * checks whether a request body is valid or not
     *
     * @return  stubValidatingRequestValue
     * @since   1.3.0
     */
    public function validateBody();

    /**
     * returns request value from params for filtering or validation
     *
     * @param   string                     $paramName  name of request value
     * @return  stubFilteringRequestValue
     * @since   1.3.0
     */
    public function readParam($paramName);

    /**
     * returns request value from headers for filtering or validation
     *
     * @param   string                     $headerName  name of header
     * @return  stubFilteringRequestValue
     * @since   1.3.0
     */
    public function readHeader($headerName);

    /**
     * returns request value from cookies for filtering or validation
     *
     * @param   string                     $cookieName  name of cookie
     * @return  stubFilteringRequestValue
     * @since   1.3.0
     */
    public function readCookie($cookieName);

    /**
     * returns request body for filtering or validation
     *
     * @return  stubFilteringRequestValue
     * @since   1.3.0
     */
    public function readBody();

    /**
     * return an array of all param names registered in this request
     *
     * @return  array<string>
     * @since   1.3.0
     */
    public function getParamNames();

    /**
     * return an array of all header names registered in this request
     *
     * @return  array<string>
     * @since   1.3.0
     */
    public function getHeaderNames();

    /**
     * return an array of all cookie names registered in this request
     *
     * @return  array<string>
     * @since   1.3.0
     */
    public function getCookieNames();
}
?><?php
/**
 * Class for handling request variables with a special prefix.
 * 
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubRequestPrefixDecorator.php 2680 2010-08-23 22:02:52Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::request::stubPrefixedRequestValueErrorCollection'
);
/**
 * Class for handling request variables with a special prefix.
 * 
 * This acts as a decorator around a stubRequest instance and allows to restrict
 * access to request values starting with a prefix. Via param $sources from the
 * constructor it is controlled for which source the prefix should be applied. As
 * it is a bit switch you may not only use the stubRequest::SOURCE_* constansts
 * but any combination of them as well: e.g. stubRequest::SOURCE_COOKIE +
 * stubRequest::SOURCE_PARAM applies prefixes on cookies and parameters, but not
 * on headers.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 */
class stubRequestPrefixDecorator extends stubBaseObject implements stubRequest
{
    /**
     * the decorated request
     *
     * @var  stubRequest
     */
    protected $request;
    /**
     * the prefix to use
     *
     * @var  string
     */
    protected $prefix;
    /**
     * sources to apply prefix on
     * 
     * Can be any of stubRequest::SOURCE_* or a combination of them (bit value)
     *
     * @var  int
     */
    protected $sources;

    /**
     * constructor
     *
     * @param  stubRequest  $request  the request to decorate
     * @param  string       $prefix   the prefix to use
     * @param  int          $sources  optional  can be any of stubRequest::SOURCE_* or a combination of them (bit value)
     */
    public function __construct(stubRequest $request, $prefix, $sources = stubRequest::SOURCE_PARAM)
    {
        $this->request = $request;
        $this->prefix  = $prefix;
        $this->sources = $sources;
    }

    /**
     * sets the prefix to another value
     *
     * @param   string       $prefix  the prefix to use
     * @return  stubRequest
     */
    public function setPrefix($prefix)
    {
        $this->prefix = $prefix;
        return $this;
    }

    /**
     * checks if requestor accepts cookies
     *
     * @return  bool
     */
    public function acceptsCookies()
    {
        return $this->request->acceptsCookies();
    }

    /**
     * checks whether a request param is set
     *
     * @param   string  $paramName
     * @return  bool
     * @since   1.3.0
     */
    public function hasParam($paramName)
    {
        if ($this->applyPrefix(stubRequest::SOURCE_PARAM) == true) {
            $paramName = $this->prefix . '_' . $paramName;
        }

        return $this->request->hasParam($paramName);
    }

    /**
     * checks whether a request header is set
     *
     * @param   string  $paramName
     * @return  bool
     * @since   1.3.0
     */
    public function hasHeader($headerName)
    {
        if ($this->applyPrefix(stubRequest::SOURCE_HEADER) == true) {
            $headerName = $this->prefix . '_' . $headerName;
        }

        return $this->request->hasHeader($headerName);
    }

    /**
     * checks whether a request cookie is set
     *
     * @param   string  $paramName
     * @return  bool
     * @since   1.3.0
     */
    public function hasCookie($cookieName)
    {
        if ($this->applyPrefix(stubRequest::SOURCE_COOKIE) == true) {
            $cookieName = $this->prefix . '_' . $cookieName;
        }

        return $this->request->hasCookie($cookieName);
    }

    /**
     * returns error collection for request parameters
     *
     * @return  stubRequestValueErrorCollection
     * @since   1.3.0
     */
    public function paramErrors()
    {
        $requestValueErrorCollection = $this->request->paramErrors();
        if ($this->applyPrefix(stubRequest::SOURCE_PARAM) == true) {
            return new stubPrefixedRequestValueErrorCollection($requestValueErrorCollection, $this->prefix);
        }

        return $requestValueErrorCollection;
    }

    /**
     * returns error collection for request headers
     *
     * @return  stubRequestValueErrorCollection
     * @since   1.3.0
     */
    public function headerErrors()
    {
        $requestValueErrorCollection = $this->request->headerErrors();
        if ($this->applyPrefix(stubRequest::SOURCE_HEADER) == true) {
            return new stubPrefixedRequestValueErrorCollection($requestValueErrorCollection, $this->prefix);
        }

        return $requestValueErrorCollection;
    }

    /**
     * returns error collection for request cookies
     *
     * @return  stubRequestValueErrorCollection
     * @since   1.3.0
     */
    public function cookieErrors()
    {
        $requestValueErrorCollection = $this->request->cookieErrors();
        if ($this->applyPrefix(stubRequest::SOURCE_COOKIE) == true) {
            return new stubPrefixedRequestValueErrorCollection($requestValueErrorCollection, $this->prefix);
        }

        return $requestValueErrorCollection;
    }

    /**
     * returns error collection for request body
     *
     * @return  stubRequestValueErrorCollection
     * @since   1.3.0
     */
    public function bodyErrors()
    {
        return $this->request->bodyErrors();
    }

    /**
     * cancels the request, e.g. if it was detected that it is invalid
     * 
     * @param  stubEventDispatcher  $dispatcher  optional  dispatcher to use for signalling
     *                                                     the event, if none given the
     *                                                     default one will be used
     */
    public function cancel(stubEventDispatcher $dispatcher = null)
    {
        $this->request->cancel($dispatcher);
    }

    /**
     * checks whether the request has been cancelled or not
     *
     * @return  bool
     */
    public function isCancelled()
    {
        return $this->request->isCancelled();
    }

    /**
     * returns the request method
     *
     * @return  string
     */
    public function getMethod()
    {
        return $this->request->getMethod();
    }

    /**
     * returns the uri of the request
     * 
     * @return  string
     */
    public function getURI()
    {
        return $this->request->getURI();
    }

    /**
     * returns complete uri including scheme
     *
     * @return  string
     * @since   1.3.0
     */
    public function getCompleteUri()
    {
        return $this->request->getCompleteUri();
    }

    /**
     * checks whether a request value from parameters is valid or not
     *
     * @param   string                      $paramName  name of request value
     * @return  stubValidatingRequestValue
     * @since   1.3.0
     */
    public function validateParam($paramName)
    {
        if ($this->applyPrefix(stubRequest::SOURCE_PARAM) == true) {
            $paramName = $this->prefix . '_' . $paramName;
        }

        return $this->request->validateParam($paramName);
    }

    /**
     * checks whether a request value from headers is valid or not
     *
     * @param   string                      $headerName  name of header
     * @return  stubValidatingRequestValue
     * @since   1.3.0
     */
    public function validateHeader($headerName)
    {
        if ($this->applyPrefix(stubRequest::SOURCE_HEADER) == true) {
            $headerName = $this->prefix . '_' . $headerName;
        }

        return $this->request->validateHeader($headerName);
    }

    /**
     * checks whether a request value from cookie is valid or not
     *
     * @param   string                      $cookieName  name of cookie
     * @return  stubValidatingRequestValue
     * @since   1.3.0
     */
    public function validateCookie($cookieName)
    {
        if ($this->applyPrefix(stubRequest::SOURCE_COOKIE) == true) {
            $cookieName = $this->prefix . '_' . $cookieName;
        }

        return $this->request->validateCookie($cookieName);
    }

    /**
     * checks whether a request body is valid or not
     *
     * @return  stubValidatingRequestValue
     * @since   1.3.0
     */
    public function validateBody()
    {
        return $this->request->validateBody();
    }

    /**
     * returns request value from params for filtering or validation
     *
     * @param   string                     $paramName  name of request value
     * @return  stubFilteringRequestValue
     * @since   1.3.0
     */
    public function readParam($paramName)
    {
        if ($this->applyPrefix(stubRequest::SOURCE_PARAM) == true) {
            $paramName = $this->prefix . '_' . $paramName;
        }

        return $this->request->readParam($paramName);
    }

    /**
     * returns request value from headers for filtering or validation
     *
     * @param   string                     $headerName  name of header
     * @return  stubFilteringRequestValue
     * @since   1.3.0
     */
    public function readHeader($headerName)
    {
        if ($this->applyPrefix(stubRequest::SOURCE_HEADER) == true) {
            $headerName = $this->prefix . '_' . $headerName;
        }

        return $this->request->readHeader($headerName);
    }

    /**
     * returns request value from cookies for filtering or validation
     *
     * @param   string                     $cookieName  name of cookie
     * @return  stubFilteringRequestValue
     * @since   1.3.0
     */
    public function readCookie($cookieName)
    {
        if ($this->applyPrefix(stubRequest::SOURCE_COOKIE) == true) {
            $cookieName = $this->prefix . '_' . $cookieName;
        }

        return $this->request->readCookie($cookieName);
    }

    /**
     * returns request body for filtering or validation
     *
     * @return  stubFilteringRequestValue
     * @since   1.3.0
     */
    public function readBody()
    {
        return $this->request->readBody();
    }

    /**
     * return an array of all param names registered in this request
     *
     * @return  array<string>
     * @since   1.3.0
     */
    public function getParamNames()
    {
        $paramNames = $this->request->getParamNames();
        if ($this->applyPrefix(stubRequest::SOURCE_PARAM) == false) {
            return $paramNames;
        }

        return $this->filterNames($paramNames);
    }

    /**
     * return an array of all header names registered in this request
     *
     * @return  array<string>
     * @since   1.3.0
     */
    public function getHeaderNames()
    {
        $headerNames = $this->request->getHeaderNames();
        if ($this->applyPrefix(stubRequest::SOURCE_HEADER) == false) {
            return $headerNames;
        }

        return $this->filterNames($headerNames);
    }

    /**
     * return an array of all cookie names registered in this request
     *
     * @return  array<string>
     * @since   1.3.0
     */
    public function getCookieNames()
    {
        $cookieNames = $this->request->getCookieNames();
        if ($this->applyPrefix(stubRequest::SOURCE_COOKIE) == false) {
            return $cookieNames;
        }

        return $this->filterNames($cookieNames);
    }

    /**
     * check whether the prefix has to be applied for requested source
     *
     * @param   int   $source  can be any of stubRequest::SOURCE_* or a combination of them (bit value)
     * @return  bool
     */
    protected function applyPrefix($source)
    {
        return (($this->sources & $source) != 0);
    }

    /**
     * filter names according to prefix
     *
     * @param   array<string>  $valueNames
     * @return  array<string>
     */
    protected function filterNames(array $valueNames)
    {
        $returnedValueNames = array();
        $checkLength        = strlen($this->prefix) + 1;
        foreach ($valueNames as $valueName) {
            if (substr($valueName, 0, $checkLength) == $this->prefix . '_') {
                $returnedValueNames[] = substr($valueName, $checkLength);
            }
        }

        return $returnedValueNames;
    }
}
?><?php
/**
 * Class containing error messages for request values.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubRequestValueError.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::stubClonable',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::php::string::stubLocalizedString'
);
/**
 * Class containing error messages for request values.
 *
 * This is mainly an internal class for the request package, a container for
 * error messages. The messages itself can contain value keys. These value
 * keys are thought to be replaced with concrete values to customize the error
 * message.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @XMLTag(tagName='error')
 * @XMLMethods[XMLMatcher](pattern='/getId|getMessages/')
 */
class stubRequestValueError extends stubSerializableObject implements stubClonable
{
    /**
     * id of the current stubRequestValueError
     *
     * @var  string
     */
    protected $id;
    /**
     * list of messages for current stubRequestValueError
     *
     * @var  array<string,string>
     */
    protected $messages = array();
    /**
     * required values for filling the message
     *
     * @var  array<string>
     */
    protected $values   = array();

    /**
     * constructor
     *
     * @param  string  $id         id of the current RequestValueError
     * @param  array   $messages   list of messages for current RequestValueError
     * @param  array   $valueKeys  optional  list of required values
     */
    public function __construct($id, array $messages, array $valueKeys = array())
    {
        $this->id       = $id;
        $this->messages = $messages;
        foreach ($valueKeys as $valueKey) {
            $this->values[$valueKey] = '';
        }
    }

    /**
     * returns the id of the current stubRequestValueError
     *
     * @return  string
     * @XMLAttribute(attributeName='id')
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * check whether a message for the given locale exists
     *
     * @param   string  $locale
     * @return  bool
     * @XMLIgnore
     */
    public function hasMessage($locale)
    {
        return isset($this->messages[$locale]);
    }

    /**
     * returns the message for the given locale
     *
     * @param   string  $locale
     * @return  string
     * @XMLIgnore
     */
    public function getMessage($locale)
    {
        if (isset($this->messages[$locale]) === true) {
            $message = $this->messages[$locale];
            foreach ($this->values as $key => $value) {
                $message = str_replace('{' . $key . '}', $this->flattenValue($value), $message);
            }

            return $message;
        }

        return null;
    }

    /**
     * returns all messages
     *
     * @return  array<stubLocalizedString>
     * @XMLTag(tagName='messages')
     */
    public function getMessages()
    {
        $messages = array();
        foreach ($this->messages as $locale => $message) {
            foreach ($this->values as $key => $value) {
                $message = str_replace('{' . $key . '}', $this->flattenValue($value), $message);
            }

            $messages[] = new stubLocalizedString($locale, $message);
        }

        return $messages;
    }

    /**
     * flattens the given value to be used within the message
     *
     * @param   mixed   $value
     * @return  string
     */
    protected function flattenValue($value)
    {
        if (is_array($value) === true) {
            $value = join(', ', $value);
        } elseif (is_object($value) === true) {
            if (method_exists($value, '__toString') == false) {
                $value = get_class($value);
            }
        }

        return (string) $value;
    }

    /**
     * Sets the values that should replace the value keys within the messages.
     *
     * This method could be used in conjunction with the getCriteria() method
     * of a validator: the return values of these mostly fit well to the
     * required value keys. Returns itself for easy use in conjunction with
     * the factory.
     *
     * @param   array<string,mixed>  $values
     * @return  stubRequestValueError
     * @throws  stubIllegalArgumentException
     * @XMLIgnore
     */
    public function setValues(array $values)
    {
        foreach (array_keys($this->values) as $key) {
            if (isset($values[$key]) === false) {
                throw new stubIllegalArgumentException('Value for key ' . $key . ' is missing.');
            }

            $this->values[$key] = $values[$key];
        }

        return $this;
    }

    /**
     * returns a list of all value keys
     *
     * @return  array<string>
     * @XMLIgnore
     */
    public function getValueKeys()
    {
        return array_keys($this->values);
    }
}
?><?php
/**
 * Container for a value error list.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubRequestValueErrorCollection.php 2637 2010-08-14 18:25:37Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueError');
/**
 * Container for a value error list.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @since       1.3.0
 */
interface stubRequestValueErrorCollection extends stubObject
{
    /**
     * add a value error to the collection
     *
     * Return value is the added $valueError instance.
     *
     * @param   stubRequestValueError  $valueError
     * @param   string                 $valueName
     * @return  stubRequestValueError
     */
    public function add(stubRequestValueError $valueError, $valueName);

    /**
     * returns number of collected errors
     *
     * @return  int
     */
    public function count();

    /**
     * checks whether there are any errors at all
     *
     * @return  bool
     */
    public function exist();

    /**
     * checks whether a request value has any error
     *
     * @param   string  $valueName  name of request value
     * @return  bool
     */
    public function existFor($valueName);

    /**
     * checks whether a request value has a specific error
     *
     * @param   string  $valueName  name of request value
     * @param   string  $errorId    id of error
     * @return  bool
     */
    public function existForWithId($valueName, $errorId);

    /**
     * returns list of all errors for all request values
     *
     * @return  array<string,array<string,stubRequestValueError>>
     */
    public function get();

    /**
     * returns a list of errors for given request value
     *
     * @param   string                               $valueName
     * @return  array<string,stubRequestValueError>
     */
    public function getFor($valueName);

    /**
     * returns a list of errors for given request value
     *
     * @param   string                 $valueName
     * @param   string                 $errorId    id of error
     * @return  stubRequestValueError
     */
    public function getForWithId($valueName, $errorId);
}
?><?php
/**
 * Interface for factories creating stubRequestValueErrors.
 * 
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubRequestValueErrorFactory.php 2653 2010-08-18 17:14:18Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueError');
/**
 * Interface for factories creating stubRequestValueErrors.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @ImplementedBy(net::stubbles::ipo::request::stubRequestValueErrorPropertiesFactory.class)
 */
interface stubRequestValueErrorFactory
{
    /**
     * creates the  RequestValueError with the id from the given source
     *
     * @param   string                 $id      id of RequestValueError to create
     * @return  stubRequestValueError
     */
    public function create($id);
}
?><?php
/**
 * Class for creating request value error codes from an ini configuration file.
 * 
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubRequestValueErrorPropertiesFactory.php 2653 2010-08-18 17:14:18Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestValueErrorFactory',
                      'net::stubbles::lang::stubFactory',
                      'net::stubbles::lang::stubProperties',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException'
);
/**
 * Class for creating request value error codes from an ini configuration file.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @since       1.3.0
 * @Singleton
 */
class stubRequestValueErrorPropertiesFactory extends stubBaseObject implements stubRequestValueErrorFactory
{
    /**
     * parsed properties
     *
     * @var  stubProperties
     */
    private $properties;

    /**
     * creates the RequestValueError with the id from the given source
     *
     * @param   string                 $id      id of RequestValueError to create
     * @return  stubRequestValueError
     * @throws  stubIllegalArgumentException
     */
    public function create($id)
    {
        $properties = $this->parseProperties();
        if ($properties->hasSection($id) === false) {
            throw new stubIllegalArgumentException('RequestValueError with id ' . $id . ' does not exist.');
        }

        $messages = $properties->getSection($id);
        if (isset($messages['valueKeys']) === true) {
            unset($messages['valueKeys']);
        }

        return new stubRequestValueError($id, $messages, $properties->parseArray($id, 'valueKeys', array()));
    }

    /**
     * parses properties from property files
     *
     * @return  stubProperties
     */
    protected function parseProperties()
    {
        if (null === $this->properties) {
            $this->properties = new stubProperties();
            foreach ($this->getResourceUris() as $resourceUri) {
                $this->properties = $this->properties->merge(stubProperties::fromFile($resourceUri));
            }
        }

        return $this->properties;
    }

    /**
     * returns list of resource uris which are property files containing request value error configurations
     *
     * @return  array<string>
     */
    protected function getResourceUris()
    {
        return stubFactory::getResourceURIs('ipo/request.ini');
    }
}
?><?php
/**
 * Value object for request values to check them against validators.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubValidatingRequestValue.php 2683 2010-08-24 19:33:16Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilter');
/**
 * Value object for request values to check them against validators.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 * @since       1.3.0
 */
class stubValidatingRequestValue extends stubBaseObject
{
    /**
     * original value
     *
     * @var  string
     */
    protected $value;
    /**
     * name of value
     *
     * @var  string
     */
    protected $name;

    /**
     * constructor
     *
     * @param  string  $name   name of value
     * @param  string  $value  original value
     */
    public function __construct($name, $value)
    {
        $this->name  = $name;
        $this->value = $value;
    }

    /**
     * checks whether value contains given string
     *
     * @param   string  $contained  byte sequence the value must contain
     * @return  bool
     */
    public function contains($contained)
    {
        stubClassLoader::load('net::stubbles::ipo::request::validator::stubContainsValidator');
        return $this->withValidator(new stubContainsValidator($contained));
    }


    /**
     * checks whether value equals given string
     *
     * @param   string  $expected   byte sequence the value must be equal to
     * @return  bool
     */
    public function isEqualTo($expected)
    {
        stubClassLoader::load('net::stubbles::ipo::request::validator::stubEqualValidator');
        return $this->withValidator(new stubEqualValidator($expected));
    }

    /**
     * checks whether value is an http url
     *
     * @param   bool    $checkDns  optional  whether to verify url via DNS
     * @return  bool
     */
    public function isHttpUrl($checkDns = false)
    {
        stubClassLoader::load('net::stubbles::ipo::request::validator::stubHTTPURLValidator');
        return $this->withValidator(new stubHTTPURLValidator($checkDns));
    }

    /**
     * checks whether value is an ip address
     *
     * @return  bool
     */
    public function isIpAddress()
    {
        stubClassLoader::load('net::stubbles::ipo::request::validator::stubIpValidator');
        return $this->withValidator(new stubIpValidator());
    }

    /**
     * checks whether value is a mail address
     *
     * @return  string
     */
    public function isMailAddress()
    {
        stubClassLoader::load('net::stubbles::ipo::request::validator::stubMailValidator');
        return $this->withValidator(new stubMailValidator());
    }

    /**
     * checks whether value is in a list of allowed values
     *
     * @param   array<string>  $allowedValues  list of allowed values
     * @return  bool
     */
    public function isOneOf(array $allowedValues)
    {
        stubClassLoader::load('net::stubbles::ipo::request::validator::stubPreSelectValidator');
        return $this->withValidator(new stubPreselectValidator($allowedValues));
    }

    /**
     * checks whether value satisfies given regular expression
     *
     * @param   string  $regex  regular expression to apply
     * @return  bool
     */
    public function satisfiesRegex($regex)
    {
        stubClassLoader::load('net::stubbles::ipo::request::validator::stubRegexValidator');
        return $this->withValidator(new stubRegexValidator($regex));
    }

    /**
     * checks value with given validator
     *
     * If value does not satisfy the validator return value will be null.
     *
     * @param   stubValidator  $validator  validator to use
     * @return  string
     */
    public function withValidator(stubValidator $validator)
    {
        return $validator->validate($this->value);
    }

    /**
     * returns name of value
     *
     * @return  string
     */
    public function getName()
    {
        return $this->name;
    }
}
?><?php
/**
 * Specialized class for access to web request data.
 * 
 * @package     stubbles
 * @subpackage  ipo_request
 * @version     $Id: stubWebRequest.php 2616 2010-08-03 16:41:04Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubAbstractRequest');
/**
 * Specialized class for access to web request data.
 * 
 * Please be aware that GET and POST values are merged to param values. There
 * is no possibility to detect if a param value is originally from GET or POST,
 * but one may use the getMethod() method to check if the request type was GET
 * or POST (return value of getMethod() is lower case only).
 * The headers contain all stuff from $_SERVER.
 *
 * @package     stubbles
 * @subpackage  ipo_request
 */
class stubWebRequest extends stubAbstractRequest
{
    /**
     * template method for child classes to do the real construction
     */
    protected function doConstuct()
    {
        $this->unsecureParams  = array_merge(array_map(array($this, 'stripSlashes'), $_GET), array_map(array($this, 'stripSlashes'), $_POST));
        $this->unsecureHeaders = $_SERVER;
        $this->unsecureCookies = $_COOKIE;
    }
    
    /**
     * strips slashes from request variables, even if request variable is an array
     * (wrapper around native stripslashes())
     *
     * @param   string|array  $value  request variable value to apply stripslashes on
     * @return  string|array  stripslashed' value
     */
    private function stripSlashes($value)
    {
        if (is_array($value) === false) {
            return stripslashes($value);
        }
        
        $tmp = array();
        foreach ($value as $id => $content) {
            $tmp[$id] = $this->stripslashes($content);
        }
            
        return $tmp;
    }
    
    /**
     * returns the request method
     *
     * @return  string
     */
    public function getMethod()
    {
        return strtolower($_SERVER['REQUEST_METHOD']);
    }
    
    /**
     * returns the uri of the request
     *
     * Return value depends on the HOST header. If the user agent does not send
     * a HOST header the URI will only consist of the REQUEST_URI.
     * 
     * @return  string
     */
    public function getURI()
    {
        if (isset($_SERVER['HTTP_HOST']) === true) {
            return $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'];
        }
        
        return $_SERVER['REQUEST_URI'];
    }

    /**
     * returns complete uri including scheme
     *
     * @return  string
     * @since   1.3.0
     */
    public function getCompleteUri()
    {
        if (isset($_SERVER['SERVER_PORT']) === true && '443' == $_SERVER['SERVER_PORT']) {
            $scheme = 'https';
        } else {
            $scheme = 'http';
        }

        return $scheme . '://' . $this->getURI();
    }
    
    /**
     * returns the raw data
     *
     * @return  string
     */
    protected function getRawData()
    {
        return file_get_contents('php://input');
    }
}
?><?php
/**
 * Value object for user agents.
 *
 * @package     stubbles
 * @subpackage  ipo_request_useragent
 * @version     $Id: stubUserAgent.php 2591 2010-07-21 15:13:19Z mikey $
 */
/**
 * Value object for user agents.
 *
 * @package     stubbles
 * @subpackage  ipo_request_useragent
 * @since       1.2.0
 * @XMLTag(tagName='userAgent')
 * @ProvidedBy(net::stubbles::ipo::request::useragent::stubUserAgentProvider.class)
 */
class stubUserAgent extends stubBaseObject
{
    /**
     * name of user agent
     *
     * @var  string
     */
    protected $name;
    /**
     * whether user agent is a bot or not
     *
     * @var  bool
     */
    protected $isBot;

    /**
     * constructor
     *
     * @param  string  $name  name of user agent
     * @param  bool    $isBot whether user agent is a bot or not
     */
    public function __construct($name, $isBot)
    {
        $this->name  = $name;
        $this->isBot = $isBot;
    }

    /**
     * returns name of user agent
     *
     * @return  string
     * @XMLAttribute(attributeName='name')
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * returns whether user agent is a bot or not
     *
     * @return  bool
     * @XMLAttribute(attributeName='isBot')
     */
    public function isBot()
    {
        return $this->isBot;
    }
}
?><?php
/**
 * Detector which detects single properties of user agents.
 *
 * @package     stubbles
 * @subpackage  ipo_request_useragent
 * @version     $Id: stubUserAgentDetector.php 2595 2010-07-27 11:17:48Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::useragent::stubUserAgent');
/**
 * Detector which detects single properties of user agents.
 *
 * Currently it only supports to detect if a user agent is a bot. This detection
 * is limited to the Googlebot, MSNbot, Yahoo! Slurp and the DotBot.
 *
 * @package     stubbles
 * @subpackage  ipo_request_useragent
 * @since       1.2.0
 */
class stubUserAgentDetector extends stubBaseObject
{
    /**
     * list of known bot user agents
     *
     * @var  array<string>
     */
    protected $botUserAgents = array('google' => '~Googlebot~',
                                     'msnbot' => '~msnbot~',
                                     'slurp'  => '~Slurp~',
                                     'dotbot' => '~DotBot~'
                               );

    /**
     * detects the user agent
     *
     * @param   string         $userAgentString
     * @return  stubUserAgent
     */
    public function detect($userAgentString)
    {
        return new stubUserAgent($userAgentString, $this->isBot($userAgentString));
    }

    /**
     * helper method to detect whether a user agent is a bot or not
     *
     * @param   string  $userAgentString
     * @return  bool
     */
    protected function isBot($userAgentString)
    {
        foreach ($this->botUserAgents as $botUserAgent) {
            if (preg_match($botUserAgent, $userAgentString) === 1) {
                return true;
            }
        }

        return false;
    }
}
?><?php
/**
 * Filter to detect a user agent.
 *
 * @package     stubbles
 * @subpackage  ipo_request_filter
 * @version     ipo_request_useragent
 */
stubClassLoader::load('net::stubbles::ipo::request::filter::stubFilter',
                      'net::stubbles::ipo::request::useragent::stubUserAgentDetector'
);
/**
 * Filter to detect a user agent.
 *
 * @package     stubbles
 * @subpackage  ipo_request_useragent
 * @since       1.2.0
 */
class stubUserAgentFilter extends stubBaseObject implements stubFilter
{
    /**
     * user agent detector to be used
     *
     * @var  stubUserAgentDetector
     */
    protected $userAgentDetector;

    /**
     * constructor
     *
     * @param  stubUserAgentDetector  $userAgentDetector
     * @Inject
     */
    public function  __construct(stubUserAgentDetector $userAgentDetector)
    {
        $this->userAgentDetector = $userAgentDetector;
    }

    /**
     * changes given value into a UserAgent value object.
     *
     * @param   string         $value  user agent value
     * @return  stubUserAgent
     */
    public function execute($value)
    {
        return $this->userAgentDetector->detect($value);
    }
}
?><?php
/**
 * Factory to create user agent instances.
 *
 * @package     stubbles
 * @subpackage  ipo_request_useragent
 * @version     $Id: stubUserAgentProvider.php 2629 2010-08-13 18:02:19Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::request::useragent::stubUserAgentFilter'
);
/**
 * Factory to create user agent instances.
 *
 * @package     stubbles
 * @subpackage  ipo_request_useragent
 * @since       1.2.0
 */
class stubUserAgentProvider extends stubBaseObject implements stubInjectionProvider
{
    /**
     * request instance to be used
     *
     * @var  stubRequest
     */
    protected $request;
    /**
     * filter to be used to detect the user agent
     *
     * @var  stubUserAgentFilter
     */
    protected $userAgentFilter;

    /**
     * constructor
     *
     * @param  stubRequest          $request
     * @param  stubUserAgentFilter  $userAgentFilter
     * @Inject
     */
    public function __construct(stubRequest $request, stubUserAgentFilter $userAgentFilter)
    {
        $this->request         = $request;
        $this->userAgentFilter = $userAgentFilter;
    }

    /**
     * returns the value to provide
     *
     * @param   string         $name  optional
     * @return  stubUserAgent
     */
    public function get($name = null)
    {
        return $this->request->readHeader('HTTP_USER_AGENT')->withFilter($this->userAgentFilter);
    }
}
?><?php
/**
 * Base class for composite validators.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubAbstractCompositeValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubCompositeValidator',
                      'net::stubbles::lang::exceptions::stubRuntimeException'
);
/**
 * Base class for composite validators.
 * 
 * A composite validator can be used to combine two or more validators
 * into a single validator which then applies all those validators for the
 * value to validate.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
abstract class stubAbstractCompositeValidator extends stubBaseObject implements stubCompositeValidator
{
    /**
     * list of validators to combine
     *
     * @var  array<stubValidator>
     */
    protected $validators = array();
    
    /**
     * add a validator
     *
     * @param  stubValidator  $validator
     */
    public function addValidator(stubValidator $validator)
    {
        $this->validators[] = $validator;
    }
    
    /**
     * validate the given value
     *
     * @param   mixed  $value
     * @return  bool   true if value is ok, else false
     * @throws  stubRuntimeException
     */
    public function validate($value)
    {
        if (count($this->validators) == 0) {
            throw new stubRuntimeException('No validators set for composite ' . __CLASS__);
        }
        
        return $this->doValidate($value);
    }
    
    /**
     * validate the given value
     *
     * @param   mixed  $value
     * @return  bool   true if value is ok, else false
     */
    protected abstract function doValidate($value);
    
    /**
     * returns a list of criteria for the validator
     *
     * @return  array<string,mixed>  key is criterion name, value is criterion value
     */
    public function getCriteria()
    {
        $criterias = array();
        foreach ($this->validators as $validator) {
            $criterias = array_merge($criterias, $validator->getCriteria());
        }
        
        return $criterias;
    }
}
?><?php
/**
 * Class that combines differant validators that all have to be true in order
 * that this validator also reports true.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubAndValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubAbstractCompositeValidator');
/**
 * Class that combines differant validators that all have to be true in order
 * that this validator also reports true.
 * 
 * If any of the combined validators returns false the stubAndValidator
 * will return false as well.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
class stubAndValidator extends stubAbstractCompositeValidator
{
    /**
     * validate the given value
     * 
     * If any of the validators returns false this will return false as well.
     *
     * @param   mixed  $value
     * @return  bool   true if value is ok, else false
     */
    protected function doValidate($value)
    {
        foreach ($this->validators as $validator) {
            if ($validator->validate($value) == false) {
                return false;
            }
        }
        
        return true;
    }
}
?><?php
/**
 * Interface for composite validators.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubCompositeValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubValidator');
/**
 * Interface for composite validators.
 * 
 * Composite validators can be used to combine two or more validators
 * into a single validator.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
interface stubCompositeValidator extends stubValidator
{
    /**
     * add a validator
     *
     * @param  stubValidator  $validator
     */
    public function addValidator(stubValidator $validator);
}
?><?php
/**
 * Class for validating that something is equal.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubContainsValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubValidator',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException'
);
/**
 * Class for validating that something is equal.
 * 
 * This class can compare any scalar value with an expected value. The
 * value to validate has to be of the same type and should have the same
 * content as the expected value.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
class stubContainsValidator extends stubBaseObject implements stubValidator
{
    /**
     * the scalar value to be contained in value to validate
     *
     * @var  string
     */
    protected $contained = null;
    
    /**
     * constructor
     * 
     * @param   scalar|null  $contained
     * @throws  stubIllegalArgumentException
     */
    public function __construct($contained)
    {
        if (is_scalar($contained) == false) {
            throw new stubIllegalArgumentException('Can only check scalar values.');
        }
        
        $this->contained = $contained;
    }

    /**
     * validate that the given value is eqal in content and type to the expected value
     *
     * @param   scalar|null  $value
     * @return  bool         true if value is equal to expected value, else false
     */
    public function validate($value)
    {
        if (is_scalar($value) === false || null === $value) {
            return false;
        }
        
        if (is_bool($this->contained) === true) {
            return ($value === $this->contained);
        }
        
        if ($value === $this->contained || false !== strpos($value, (string) $this->contained)) {
            return true;
        }

        return false;
    }
    
    /**
     * returns a list of criteria for the validator
     * 
     * <code>
     * array('contained' => [contained_value]);
     * </code>
     *
     * @return  array<string,mixed>  key is criterion name, value is criterion value
     */
    public function getCriteria()
    {
        return array('contained' => $this->contained);
    }
}
?><?php
/**
 * Validator that denies validaty of values.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubDenyValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubValidator');
/**
 * Validator that denies validaty of values.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
class stubDenyValidator extends stubBaseObject implements stubValidator
{
    /**
     * validate that the given value complies with the regular expression
     *
     * @param   mixed  $value
     * @return  bool   always true
     */
    public function validate($value)
    {
        return false;
    }

    /**
     * returns a list of criteria for the validator
     *
     * @return  array<string,array>  key is criterion name, value is criterion value
     */
    public function getCriteria()
    {
        return array();
    }

}
?><?php
/**
 * Class for validating that something is equal.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubEqualValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubValidator',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException'
);
/**
 * Class for validating that something is equal.
 * 
 * This class can compare any scalar value with an expected value. The
 * value to validate has to be of the same type and should have the same
 * content as the expected value.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
class stubEqualValidator extends stubBaseObject implements stubValidator
{
    /**
     * the expected password
     *
     * @var  string
     */
    protected $expected = null;
    
    /**
     * constructor
     * 
     * @param   scalar|null  $expected
     * @throws  stubIllegalArgumentException
     */
    public function __construct($expected)
    {
        if (is_scalar($expected) == false && null != $expected) {
            throw new stubIllegalArgumentException('Can only compare scalar values and null.');
        }
        
        $this->expected = $expected;
    }

    /**
     * validate that the given value is eqal in content and type to the expected value
     *
     * @param   scalar|null  $value
     * @return  bool         true if value is equal to expected value, else false
     */
    public function validate($value)
    {
        if ($this->expected !== $value) {
            return false;
        }

        return true;
    }
    
    /**
     * returns a list of criteria for the validator
     * 
     * <code>
     * array('expected' => [expected_value]);
     * </code>
     *
     * @return  array<string,mixed>  key is criterion name, value is criterion value
     */
    public function getCriteria()
    {
        return array('expected' => $this->expected);
    }
}
?><?php
/**
 * Validator to wrap the validators provided by ext/filter
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubExtFilterValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubValidator');
/**
 * Validator to wrap the validators provided by ext/filter
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @link        http://www.php.net/filter
 */
class stubExtFilterValidator extends stubBaseObject implements stubValidator
{
    /**
     * The filter to use
     *
     * @var  int
     */
    protected $filter;

    /**
     * The options to use
     *
     * @var  array
     */
    protected $options = array();

    /**
     * The flags to use
     *
     * @var  int
     */
    protected $flags = FILTER_FLAG_NONE;

    /**
     * constructor
     *
     * @param  string  $filter   name of filter to apply
     * @param  array   $options  optional  options for the filter
     * @param  int     $flags    optional  flags for the filter
     */
    public function __construct($filter, array $options = array(), $flags = FILTER_FLAG_NONE)
    {
        $this->filter  = $filter;
        $this->options = $options;
        $this->flags   = $flags;
    }

    /**
     * validate that the given value is greater than or equal to the maximum value
     *
     * @param   int|double  $value
     * @return  bool        true if value is greater than or equal to minimum value, else false
     */
    public function validate($value)
    {
        $result = filter_var($value, $this->filter, array('options' => $this->options, 'flags' => $this->flags));
        if ($result === false) {
            return false;
        }
        
        return true;
    }

    /**
     * returns a list of criteria for the validator
     *
     * @return  array<string,mixed>  key is criterion name, value is criterion value
     */
    public function getCriteria()
    {
        return array();
    }
}
?><?php
/**
 * Validator to ensure that a string is a http url.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubHTTPURLValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubValidator',
                      'net::stubbles::peer::stubMalformedURLException',
                      'net::stubbles::peer::http::stubHTTPURL'
);
/**
 * Validator to ensure that a string is a http url.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
class stubHTTPURLValidator extends stubBaseObject implements stubValidator
{
    /**
     * whether to check dns for existence of given url or not
     *
     * @var  bool
     */
    protected $checkDNS = false;

    /**
     * constructor
     *
     * @param  bool  $checkDNS  optional
     */
    public function __construct($checkDNS = false)
    {
        $this->checkDNS = $checkDNS;
    }

    /**
     * validate that the given value is a http url
     *
     * @param   string  $value
     * @return  bool
     */
    public function validate($value)
    {
        if (null == $value || strlen($value) == 0) {
            return false;
        }
        
        try {
            $url = stubHTTPURL::fromString($value);
            if (true === $this->checkDNS) {
                return $url->checkDNS();
            }
        } catch (stubMalformedURLException $murle) {
            return false;
        }
        
        return true;
    }
    
    /**
     * returns a list of criteria for the validator
     * 
     * <code>
     * array();
     * </code>
     *
     * @return  array<string,mixed>  key is criterion name, value is criterion value
     */
    public function getCriteria()
    {
        return array();
    }
}
?><?php
/**
 * Class for validating that something is an ip address.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubIpValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubValidator');
/**
 * Class for validating that something is an ip address.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
class stubIpValidator extends stubBaseObject implements stubValidator
{
    /**
     * validate that the given value is eqal in content and type to the expected value
     *
     * @param   mixed  $value
     * @return  bool   true if value is equal to expected value, else false
     */
    public function validate($value)
    {
        return (bool) preg_match('/^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$/', $value);
    }
    
    /**
     * returns a list of criteria for the validator
     * 
     * <code>
     * array('expected' => [expected_value]);
     * </code>
     *
     * @return  array<string,mixed>  key is criterion name, value is criterion value
     */
    public function getCriteria()
    {
        return array();
    }
}
?><?php
/**
 * Validator to ensure that a string is a mail address.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubMailValidator.php 2404 2009-12-07 19:05:53Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubValidator');
/**
 * Validator to ensure that a string is a mail address.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
class stubMailValidator extends stubBaseObject implements stubValidator
{
    /**
     * validate that the given value is not longer than the maximum length
     *
     * @param   string  $value
     * @return  bool    true if value is not longer than maximal length, else false
     */
    public function validate($value)
    {
        if (null == $value || strlen($value) == 0) {
            return false;
        }
        
        $url = @parse_url('mailto://' . $value);
        if (isset($url['host']) === false || preg_match('/^([a-zA-Z0-9-]*)\.([a-zA-Z]{2,4})$/', $url['host']) == false) {
            return false;
        }
        
        if (isset($url['user']) === false || strlen($url['user']) == 0 || preg_match('/^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*$/', $url['user']) == false) {
            return false;
        }
        
        return true;
    }
    
    /**
     * returns a list of criteria for the validator
     * 
     * <code>
     * array();
     * </code>
     *
     * @return  array<string,mixed>  key is criterion name, value is criterion value
     */
    public function getCriteria()
    {
        return array();
    }
}
?><?php
/**
 * Validator to ensure that a string is not longer than a given maximum length.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubMaxLengthValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubValidator');
/**
 * Validator to ensure that a string is not longer than a given maximum length.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
class stubMaxLengthValidator extends stubBaseObject implements stubValidator
{
    /**
     * the maximum length to use for validation
     *
     * @var  string
     */
    protected $maxLength;

    /**
     * constructor
     *
     * @param  int  $maxLength  maximum length
     */
    public function __construct($maxLength)
    {
        $this->maxLength = $maxLength;
    }

    /**
     * returns the maximum length to use for validation
     *
     * @return  int
     */
    public function getValue()
    {
        return $this->maxLength;
    }

    /**
     * validate that the given value is not longer than the maximum length
     *
     * @param   string  $value
     * @return  bool    true if value is not longer than maximal length, else false
     */
    public function validate($value)
    {
        if (iconv_strlen($value) > $this->maxLength) {
            return false;
        }
        
        return true;
    }

    /**
     * returns a list of criteria for the validator
     * 
     * <code>
     * array('maxLength' => [max_length_of_string]);
     * </code>
     *
     * @return  array<string,mixed>  key is criterion name, value is criterion value
     */
    public function getCriteria()
    {
        return array('maxLength' => $this->maxLength);
    }
}
?><?php
/**
 * Validator to ensure that a value is not greater than a given maximum value.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubMaxNumberValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubValidator');
/**
 * Validator to ensure that a value is not greater than a given maximum value.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
class stubMaxNumberValidator extends stubBaseObject implements stubValidator
{
    /**
     * the maximum value to use for validation
     *
     * @var  string
     */
    protected $maxValue;

    /**
     * constructor
     *
     * @param  int|double  $maxValue  maximum value
     */
    public function __construct($maxValue)
    {
        $this->maxValue = $maxValue;
    }

    /**
     * returns the minimum value to use for validation
     *
     * @return  double
     */
    public function getValue()
    {
        return $this->maxValue;
    }

    /**
     * validate that the given value is smaller than or equal to the maximum value
     *
     * @param   int|double  $value
     * @return  bool        true if value is smaller than or equal to maximum value, else false
     */
    public function validate($value)
    {
        if ($value > $this->maxValue) {
            return false;
        }

        return true;
    }

    /**
     * returns a list of criteria for the validator
     *
     * <code>
     * array('maxNumber' => [maximum_value]);
     * </code>
     *
     * @return  array<string,mixed>  key is criterion name, value is criterion value
     */
    public function getCriteria()
    {
        return array('maxNumber' => $this->maxValue);
    }
}
?><?php
/**
 * Validator to ensure that a string is not shorter than a given minimum length.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubMinLengthValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubValidator');
/**
 * Validator to ensure that a string is not shorter than a given minimum length.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
class stubMinLengthValidator extends stubBaseObject implements stubValidator
{
    /**
     * the minimum length to use for validation
     *
     * @var  int
     */
    protected $minLength;

    /**
     * constructor
     *
     * @param  int  $minLength  minimum length
     */
    public function __construct($minLength)
    {
        $this->minLength = $minLength;
    }

    /**
     * returns the minimum length to use for validation
     *
     * @return  int
     */
    public function getValue()
    {
        return $this->minLength;
    }

    /**
     * validate that the given value is not shorter than the maximum length
     *
     * @param   string  $value
     * @return  bool    true if value is not shorter than minimum length, else false
     */
    public function validate($value)
    {
        if (iconv_strlen($value) < $this->minLength) {
            return false;
        }

        return true;
    }

    /**
     * returns a list of criteria for the validator
     *
     * <code>
     * array('minLength' => [min_length_of_string]);
     * </code>
     *
     * @return  array<string,mixed>  key is criterion name, value is criterion value
     */
    public function getCriteria()
    {
        return array('minLength' => $this->minLength);
    }
}
?><?php
/**
 * Validator to ensure that a value is not smaller than a given minimum value.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubMinNumberValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubValidator');
/**
 * Validator to ensure that a value is not smaller than a given minimum value.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
class stubMinNumberValidator extends stubBaseObject implements stubValidator
{
    /**
     * the minimum value to use for validation
     *
     * @var  double
     */
    protected $minValue;

    /**
     * constructor
     *
     * @param  int|double  $minValue  minimum value
     */
    public function __construct($minValue)
    {
        $this->minValue = $minValue;
    }

    /**
     * returns the minimum value to use for validation
     *
     * @return  double
     */
    public function getValue()
    {
        return $this->minValue;
    }

    /**
     * validate that the given value is greater than or equal to the maximum value
     *
     * @param   int|double  $value
     * @return  bool        true if value is greater than or equal to minimum value, else false
     */
    public function validate($value)
    {
        if ($value < $this->minValue) {
            return false;
        }

        return true;
    }

    /**
     * returns a list of criteria for the validator
     *
     * <code>
     * array('minNumber' => [minimum_value]);
     * </code>
     *
     * @return  array<string,mixed>  key is criterion name, value is criterion value
     */
    public function getCriteria()
    {
        return array('minNumber' => $this->minValue);
    }
}
?><?php
/**
 * Class that combines differant validators where one has to be true.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubOrValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubAbstractCompositeValidator');
/**
 * Class that combines differant validators where one has to be true.
 * 
 * If any of the combined validators returns true the stubOrValidator
 * will return true as well.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
class stubOrValidator extends stubAbstractCompositeValidator
{
    /**
     * validate the given value
     * 
     * If any of the validators returns true this will return true as well.
     *
     * @param   mixed  $value
     * @return  bool   true if value is ok, else false
     */
    protected function doValidate($value)
    {
        foreach ($this->validators as $validator) {
            if ($validator->validate($value) == true) {
                return true;
            }
        }
        
        return false;
    }
}
?><?php
/**
 * Validator to validate a value against a list of allowed values.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubPreSelectValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubValidator');
/**
 * Validator to validate a value against a list of allowed values.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
class stubPreSelectValidator extends stubBaseObject implements stubValidator
{
    /**
     * list of allowed values
     *
     * @var  array
     */
    protected $allowedValues = array();

    /**
     * constructor
     *
     * @param  array  $allowedValues  list of allowed values
     */
    public function __construct(array $allowedValues)
    {
        $this->allowedValues = $allowedValues;
    }

    /**
     * returns list of allowed values
     *
     * @return  array
     */
    public function getAllowedValues()
    {
        return $this->allowedValues;
    }

    /**
     * validate that the given value is within a list of allowed values
     *
     * @param   mixed  $value
     * @return  bool   true if value is in list of allowed values, else false
     */
    public function validate($value)
    {
        if (!is_array($value)) {
            return in_array($value, $this->allowedValues);
        }
        
        foreach ($value as $val) {
            if (!in_array($val, $this->allowedValues)) {
                return false;
            }
        }
        
        return true;
    }

    /**
     * returns a list of criteria for the validator
     *
     * <code>
     * array('allowedValues' => [array_of_allowed_values]);
     * </code>
     *
     * @return  array<string,array>  key is criterion name, value is criterion value
     */
    public function getCriteria()
    {
        return array('allowedValues' => $this->allowedValues);
    }
}
?><?php
/**
 * Validator to ensure a value complies to a given regular expression.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubRegexValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubValidator');
/**
 * Validator to ensure a value complies to a given regular expression.
 *
 * The validator uses preg_match() and checks if the value occurs exactly
 * one time. Please make sure that the supplied regular expresion contains
 * correct delimiters, they will not be applied automatically. The validate()
 * method throws a runtime exception in case the regular expression is invalid.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
class stubRegexValidator extends stubBaseObject implements stubValidator
{
    /**
     * the regular expression to use for validation
     *
     * @var  string
     */
    protected $regex;

    /**
     * constructor
     *
     * @param  string  $regex  regular expression to use for validation
     */
    public function __construct($regex)
    {
        $this->regex = $regex;
    }

    /**
     * returns the regular expression to use for validation
     *
     * @return  string
     */
    public function getValue()
    {
        return $this->regex;
    }

    /**
     * validate that the given value complies with the regular expression
     *
     * @param   mixed  $value
     * @return  bool   true if value complies with regular expression, else false
     * @throws  stubRuntimeException  in case the used regular expresion is invalid
     */
    public function validate($value)
    {
        $check = @preg_match($this->regex, $value);
        if (false === $check) {
            throw new stubRuntimeException('Invalid regular expression ' . $this->regex);
        }
        
        return ((1 != $check) ? (false) : (true));
    }

    /**
     * returns a list of criteria for the validator
     *
     * <code>
     * array('regex' => [regular_expression]);
     * </code>
     *
     * @return  array<string,mixed>  key is criterion name, value is criterion value
     */
    public function getCriteria()
    {
        return array('regex' => $this->regex);
    }
}
?><?php
/**
 * Interface for validators.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Interface for validators.
 * 
 * Validators allow simple checks whether a value fulfils a set of criteria.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
interface stubValidator
{
    /**
     * validate the given value
     * 
     * Returns true if the value does fulfils all of the criteria, else false.
     *
     * @param   mixed  $value
     * @return  bool   true if value is ok, else false
     */
    public function validate($value);
    
    /**
     * returns a list of criteria for the validator
     *
     * @return  array<string,mixed>  key is criterion name, value is criterion value
     */
    public function getCriteria();
}
?><?php
/**
 * Class that combines differant validators where one has to be true.
 * 
 * @package     stubbles
 * @subpackage  ipo_request_validator
 * @version     $Id: stubXorValidator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubAbstractCompositeValidator');
/**
 * Class that combines differant validators where one has to be true.
 * 
 * If no validator or more than one validator returns false the stubXorValidator
 * will return false as well. It only returns true if one validator returns true
 * and any other validator returns false.
 *
 * @package     stubbles
 * @subpackage  ipo_request_validator
 */
class stubXorValidator extends stubAbstractCompositeValidator
{
    /**
     * validate the given value
     * 
     * If no validator or more than one validator returns false it
     * will return false as well. It only returns true if one
     * validator returns true and any other validator returns false.
     *
     * @param   mixed  $value
     * @return  bool   true if value is ok, else false
     */
    protected function doValidate($value)
    {
        $trueCount = 0;
        foreach ($this->validators as $validator) {
            if ($validator->validate($value) === true) {
                $trueCount++;
                if (1 < $trueCount) {
                    // more than one true received,
                    // can not return with true any more
                    return false;
                }
            }
        }
        
        return (1 == $trueCount);
    }
}
?><?php
/**
 * Base class for a response to a request.
 *
 * @package     stubbles
 * @subpackage  ipo_response
 * @version     $Id: stubBaseResponse.php 2899 2011-01-12 02:06:32Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::response::stubResponse',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException'
);
/**
 * Base class for a response to a request.
 *
 * This class can be used for responses in web environments. It
 * collects all data of the response and is able to send it back
 * to the source that initiated the request.
 *
 * @package     stubbles
 * @subpackage  ipo_response
 */
class stubBaseResponse extends stubBaseObject implements stubResponse
{
    /**
     * map of status codes to reason phrases
     *
     * @var  array<int,string>
     */
    protected static $reasonPhrases = array(100 => 'Continue',
                                            101 => 'Switching Protocols',
                                            200 => 'OK',
                                            201 => 'Created',
                                            202 => 'Accepted',
                                            203 => 'Non-Authoritative Information',
                                            204 => 'No Content',
                                            205 => 'Reset Content',
                                            206 => 'Partial Content',
                                            300 => 'Multiple Choices',
                                            301 => 'Moved Permanently',
                                            302 => 'Found',
                                            303 => 'See Other',
                                            304 => 'Not Modified',
                                            305 => 'Use Proxy',
                                            307 => 'Temporary Redirect',
                                            400 => 'Bad Request',
                                            401 => 'Unauthorized',
                                            402 => 'Payment Required',
                                            403 => 'Forbidden',
                                            404 => 'Not Found',
                                            405 => 'Method Not Allowed',
                                            406 => 'Not Acceptable',
                                            407 => 'Proxy Authentication Required',
                                            408 => 'Request Timeout',
                                            409 => 'Conflict',
                                            410 => 'Gone',
                                            411 => 'Length Required',
                                            412 => 'Precondition Failed',
                                            413 => 'Request Entity Too Large',
                                            414 => 'Request-URI Too Long',
                                            415 => 'Unsupported Media Type',
                                            416 => 'Requested Range Not Satisfiable',
                                            417 => 'Expectation Failed',
                                            500 => 'Internal Server Error',
                                            501 => 'Not Implemented',
                                            502 => 'Bad Gateway',
                                            503 => 'Service Unavailable',
                                            504 => 'Gateway Timeout',
                                            505 => 'HTTP Version Not Supported'
                                      );
    /**
     * current php sapi
     *
     * @var  string
     */
    protected $sapi;
    /**
     * http version to be used
     *
     * @var  string
     */
    protected $version;
    /**
     * status code to be send
     *
     * @var  int
     */
    protected $statusCode    = 200;
    /**
     * status message to be send
     *
     * @var  string
     */
    protected $reasonPhrase  = 'OK';
    /**
     * list of headers for this response
     *
     * @var  array<string,string>
     */
    protected $headers       = array();
    /**
     * list of cookies for this response
     *
     * @var  array<string,stubCookie>
     */
    protected $cookies       = array();
    /**
     * data to send as body of response
     *
     * @var  string
     */
    protected $data;

    /**
     * constructor
     *
     * @param  string  $version  optional  http version
     * @param  string  $sapi     optional  current php sapi
     */
    public function __construct($version = '1.1', $sapi = PHP_SAPI)
    {
        $this->version = $version;
        $this->sapi    = $sapi;
    }

    /**
     * clears the response
     *
     * @return  stubResponse
     */
    public function clear()
    {
        $this->setStatusCode(200);
        $this->headers      = array();
        $this->cookies      = array();
        $this->data         = null;
        return $this;
    }

    /**
     * sets the http version
     *
     * The version should be a string like '1.0' or '1.1'.
     *
     * @param   string        $version
     * @return  stubResponse
     */
    public function setVersion($version)
    {
        $this->version = $version;
        return $this;
    }

    /**
     * returns the http version
     *
     * @return  string
     */
    public function getVersion()
    {
        return $this->version;
    }

    /**
     * sets the status code to be send
     *
     * This needs only to be done if another status code then the default one
     * 200 Found should be send.
     *
     * The reason phrase is optional. If none given it will use the default
     * reason phrase according to the HTTP specification.
     *
     * @param   int           $statusCode
     * @param   string        $reasonPhrase  optional
     * @return  stubResponse
     * @throws  stubIllegalArgumentException
     */
    public function setStatusCode($statusCode, $reasonPhrase = null)
    {
        if (null == $statusCode) {
            $this->statusCode = null;
            return $this;
        }
        
        if (isset(self::$reasonPhrases[$statusCode]) === false) {
            throw new stubIllegalArgumentException('Given status code ' . $statusCode . ' is not a valid HTTP status code.');
        }

        $this->statusCode = $statusCode;
        if (null == $reasonPhrase) {
            $this->reasonPhrase = self::$reasonPhrases[$statusCode];
        } else {
            $this->reasonPhrase = $reasonPhrase;
        }

        return $this;
    }

    /**
     * returns status code to be send
     *
     * If return value is <null> the default one will be send.
     *
     * @return  int
     */
    public function getStatusCode()
    {
        return $this->statusCode;
    }

    /**
     * add a header to the response
     *
     * @param   string        $name   the name of the header
     * @param   string        $value  the value of the header
     * @return  stubResponse
     */
    public function addHeader($name, $value)
    {
        $this->headers[$name] = $value;
        return $this;
    }

    /**
     * returns the list of headers
     *
     * @return  array<string,string>
     */
    public function getHeaders()
    {
        return $this->headers;
    }

    /**
     * checks if header with given name is set
     *
     * @param   string  $name
     * @return  bool
     * @since   1.5.0
     */
    public function hasHeader($name)
    {
        return isset($this->headers[$name]);
    }

    /**
     * returns header with given name
     *
     * If header with given name does not exist return value is null.
     *
     * @param   string  $name
     * @return  string
     * @since   1.5.0
     */
    public function getHeader($name)
    {
        if ($this->hasHeader($name) === true) {
            return $this->headers[$name];
        }

        return null;
    }

    /**
     * add a cookie to the response
     *
     * @param   stubCookie    $cookie  the cookie to set
     * @return  stubResponse
     */
    public function addCookie(stubCookie $cookie)
    {
        $this->cookies[$cookie->getName()] = $cookie;
        return $this;
    }

    /**
     * add a cookie to the response
     *
     * @param   stubCookie    $cookie  the cookie to set
     * @return  stubResponse
     * @deprecated  use addCookie() instead
     */
    public function setCookie(stubCookie $cookie)
    {
        return $this->addCookie($cookie);
    }

    /**
     * returns the list of cookies
     *
     * @return  array<string,stubCookie>
     */
    public function getCookies()
    {
        return $this->cookies;
    }

    /**
     * checks if cookie with given name is set
     *
     * @param   string  $name
     * @return  bool
     * @since   1.5.0
     */
    public function hasCookie($name)
    {
        return isset($this->cookies[$name]);
    }

    /**
     * returns cookie with given name
     *
     * If cookie with given name does not exist return value is null.
     *
     * @param   string      $name
     * @return  stubCookie
     * @since   1.5.0
     */
    public function getCookie($name)
    {
        if ($this->hasCookie($name) === true) {
            return $this->cookies[$name];
        }

        return null;
    }

    /**
     * write data into the response
     *
     * @param   string        $data
     * @return  stubResponse
     */
    public function write($data)
    {
        $this->data .= $data;
        return $this;
    }

    /**
     * returns the data written so far
     *
     * @return  string
     */
    public function getData()
    {
        return $this->data;
    }

    /**
     * replaces the data written so far with the new data
     *
     * @param   string        $data
     * @return  stubResponse
     */
    public function replaceData($data)
    {
        $this->data = $data;
        return $this;
    }

    /**
     * removes data completely
     *
     * @return  stubResponse
     */
    public function clearData()
    {
        $this->data = null;
        return $this;
    }

    /**
     * creates a Location header which causes a redirect when the response is send
     *
     * Status code is optional, default is 302.
     *
     * The reason phrase is optional. If none given it will use the default
     * reason phrase for the given status code according to the HTTP specification.
     *
     * @param   string        $url           url to redirect to
     * @param   int           $statusCode    optional HTTP status code to redirect with (301, 302, ...)
     * @param   string        $reasonPhrase  optional HTTP status code reason phrase
     * @return  stubBaseResponse
     * @since   1.3.0
     */
    public function redirect($url, $statusCode = 302, $reasonPhrase = null)
    {
        $this->addHeader('Location', $url);
        $this->setStatusCode($statusCode, $reasonPhrase);
        return $this;
    }

    /**
     * send the response out
     *
     * @return  stubResponse
     */
    public function send()
    {
        if (null !== $this->statusCode) {
            if ('cgi' === $this->sapi) {
                $this->header('Status: ' . $this->statusCode . ' ' . $this->reasonPhrase);
            } else {
                $this->header('HTTP/' . $this->version . ' ' . $this->statusCode . ' ' . $this->reasonPhrase);
            }
        }

        foreach ($this->headers as $name => $value) {
            $this->header($name . ': ' . $value);
        }

        foreach ($this->cookies as $cookie) {
            $cookie->send();
        }

        if (null != $this->data) {
            $this->sendData($this->data);
        }

        return $this;
    }

    /**
     * helper method to send the header
     *
     * @param  string  $header
     */
    protected function header($header)
    {
        header($header);
    }

    /**
     * helper method to send the data
     *
     * @param  string  $data
     */
    protected function sendData($data)
    {
        echo $data;
        flush();
    }
}
?><?php
/**
 * Container for cookies to be send out to the user.
 *
 * @package     stubbles
 * @subpackage  ipo_response
 * @version     $Id: stubCookie.php 2888 2011-01-11 22:26:49Z mikey $
 */
/**
 * Container for cookies to be send out to the user.
 *
 * Cookies are used to store user-related data within the user-agent
 * e.g. to help detecting that requests are done by the same user.
 * Common applications are session cookies or low-level signon help.
 *
 * @package     stubbles
 * @subpackage  ipo_response
 * @link        http://wp.netscape.com/newsref/std/cookie_spec.html
 * @link        http://www.faqs.org/rfcs/rfc2109.html
 */
class stubCookie extends stubBaseObject
{
    /**
     * name of the cookie
     *
     * @var  string
     */
    protected $name     = '';
    /**
     * value of the cookie
     *
     * @var  string
     */
    protected $value    = '';
    /**
     * timestamp when cookie expires
     *
     * @var  int
     */
    protected $expires  = 0;
    /**
     * path for which the cookie should be available
     *
     * @var  string
     */
    protected $path     = null;
    /**
     * domain where this cookie will be available
     *
     * @var  string
     */
    protected $domain   = null;
    /**
     * switch whether cookie should only be used in secure connections
     *
     * @var  bool
     */
    protected $secure   = false;
    /**
     * switch whether cookie should only be accessible through http
     *
     * @var  bool
     */
    protected $httpOnly = false;

    /**
     * constructor
     *
     * @param  string  $name   name of the cookie
     * @param  string  $value  value of the cookie
     */
    public function __construct($name, $value)
    {
        $this->name  = $name;
        $this->value = $value;
    }

    /**
     * creates the cookie
     *
     * @param   string      $name   name of the cookie
     * @param   string      $value  value of the cookie
     * @return  stubCookie
     */
    public static function create($name, $value)
    {
        $cookie = new self($name, $value);
        return $cookie;
    }

    /**
     * set the timestamp when the cookie will expire
     *
     * Please note that $expires must be a timestamp in the future.
     *
     * @param   int         $expires  timestamp in seconds since 1970
     * @return  stubCookie
     */
    public function expiringAt($expires)
    {
        $this->expires = $expires;
        return $this;
    }

    /**
     * sets the cookie to expire after given amount of seconds
     *
     * The method will add the current timestamp to the given amount of seconds.
     *
     * @param   int         $seconds
     * @return  stubCookie
     * @since   1.5.0
     */
    public function expiringIn($seconds)
    {
        $this->expires = time() + $seconds;
        return $this;
    }

    /**
     * set the path for which the cookie should be available
     *
     * @param   string      $path
     * @return  stubCookie
     */
    public function forPath($path)
    {
        $this->path = $path;
        return $this;
    }

    /**
     * set the domain where this cookie will be available
     *
     * @param   string      $domain
     * @return  stubCookie
     */
    public function forDomain($domain)
    {
        $this->domain = $domain;
        return $this;
    }

    /**
     * switch whether cookie should only be used in secure connections
     *
     * @param   bool        $secure
     * @return  stubCookie
     */
    public function withSecurity($secure)
    {
        $this->secure = $secure;
        return $this;
    }

    /**
     * switch whether cookie should only be accessible through http
     *
     * @param   bool        $httpOnly
     * @return  stubCookie
     */
    public function usingHttpOnly($httpOnly)
    {
        $this->httpOnly = $httpOnly;
        return $this;
    }

    /**
     * returns name of cookie
     *
     * @return  string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * returns value of cookie
     *
     * @return  string
     */
    public function getValue()
    {
        return $this->value;
    }

    /**
     * returns expiration timestamp of cookie
     *
     * @return  int
     */
    public function getExpiration()
    {
        return $this->expires;
    }

    /**
     * returns path of cookie
     *
     * @return  string
     */
    public function getPath()
    {
        return $this->path;
    }

    /**
     * returns domain of cookie
     *
     * @return  string
     */
    public function getDomain()
    {
        return $this->domain;
    }

    /**
     * checks whether cookie should only be used in secure connections
     *
     * @return  bool
     */
    public function isSecure()
    {
        return $this->secure;
    }

    /**
     * checks whether cookie should only be accessible through http
     *
     * @return  bool
     */
    public function isHttpOnly()
    {
        return $this->httpOnly;
    }

    /**
     * sends the cookie
     */
    // @codeCoverageIgnoreStart
    public function send()
    {
        setcookie($this->name, $this->value, $this->expires, $this->path, $this->domain, $this->secure, $this->httpOnly);
    }
    // @codeCoverageIgnoreEnd
}
?><?php
/**
 * Interface for a response to a request.
 *
 * @package     stubbles
 * @subpackage  ipo_response
 * @version     $Id: stubResponse.php 2899 2011-01-12 02:06:32Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::response::stubCookie');
/**
 * Interface for a response to a request.
 * 
 * The response collects all data that should be send to the source
 * that initiated the request.
 *
 * @package     stubbles
 * @subpackage  ipo_response
 */
interface stubResponse extends stubObject
{
    /**
     * clears the response
     *
     * @return  stubResponse
     */
    public function clear();

    /**
     * sets the http version
     *
     * The version should be a string like '1.0' or '1.1'.
     *
     * @param   string        $version
     * @return  stubResponse
     */
    public function setVersion($version);

    /**
     * returns the http version
     *
     * @return  string
     */
    public function getVersion();

    /**
     * sets the status code to be send
     *
     * This needs only to be done if another status code then the default one
     * 200 Found should be send.
     *
     * The reason phrase is optional. If none given it will use the default
     * reason phrase according to the HTTP specification.
     *
     * @param   int           $statusCode
     * @param   string        $reasonPhrase  optional
     * @return  stubResponse
     */
    public function setStatusCode($statusCode, $reasonPhrase = null);

    /**
     * returns status code to be send
     *
     * If return value is <null> the default one will be send.
     *
     * @return  int
     */
    public function getStatusCode();

    /**
     * add a header to the response
     *
     * @param   string        $name   the name of the header
     * @param   string        $value  the value of the header
     * @return  stubResponse
     */
    public function addHeader($name, $value);

    /**
     * returns the list of headers
     *
     * @return  array<string,string>
     */
    public function getHeaders();

    /**
     * checks if header with given name is set
     *
     * @param   string  $name
     * @return  bool
     * @since   1.5.0
     */
    public function hasHeader($name);

    /**
     * returns header with given name
     *
     * If header with given name does not exist return value is null.
     *
     * @param   string  $name
     * @return  string
     * @since   1.5.0
     */
    public function getHeader($name);

    /**
     * add a cookie to the response
     *
     * @param   stubCookie    $cookie  the cookie to set
     * @return  stubResponse
     */
    public function addCookie(stubCookie $cookie);

    /**
     * add a cookie to the response
     *
     * @param   stubCookie    $cookie  the cookie to set
     * @return  stubResponse
     * @deprecated  use addCookie() instead
     */
    public function setCookie(stubCookie $cookie);

    /**
     * returns the list of cookies
     *
     * @return  array<string,stubCookie>
     */
    public function getCookies();

    /**
     * checks if cookie with given name is set
     *
     * @param   string  $name
     * @return  bool
     * @since   1.5.0
     */
    public function hasCookie($name);

    /**
     * returns cookie with given name
     *
     * If cookie with given name does not exist return value is null.
     *
     * @param   string      $name
     * @return  stubCookie
     * @since   1.5.0
     */
    public function getCookie($name);

    /**
     * write data into the response
     *
     * @param   string        $data
     * @return  stubResponse
     */
    public function write($data);

    /**
     * returns the data written so far
     * 
     * @return  string
     */
    public function getData();

    /**
     * replaces the data written so far with the new data
     *
     * @param   string        $data
     * @return  stubResponse
     */
    public function replaceData($data);

    /**
     * removes data completely
     *
     * @return  stubResponse
     */
    public function clearData();

    /**
     * creates a Location header which causes a redirect when the response is send
     *
     * Status code is optional, default is 302.
     *
     * The reason phrase is optional. If none given it will use the default
     * reason phrase for the given status code according to the HTTP specification.
     *
     * @param   string        $url           url to redirect to
     * @param   int           $statusCode    optional HTTP status code to redirect with (301, 302, ...)
     * @param   string        $reasonPhrase  optional HTTP status code reason phrase
     * @return  stubResponse
     * @since   1.3.0
     */
    public function redirect($url, $statusCode = 302, $reasonPhrase = null);

    /**
     * send the response out
     *
     * @return  stubResponse
     */
    public function send();
}
?><?php
/**
 * Base class for session implementations.
 *
 * @package     stubbles
 * @subpackage  ipo_session
 * @version     $Id: stubAbstractSession.php 2886 2011-01-11 22:00:42Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::response::stubResponse',
                      'net::stubbles::ipo::session::stubSession',
                      'net::stubbles::lang::exceptions::stubIllegalStateException',
                      'net::stubbles::lang::exceptions::stubRuntimeException'
);
/**
 * Base class for session implementations.
 *
 * This class offers a basic implementation for session handling, mainly for
 * the default values of a session which are the start time of the session,
 * the fingerprint of the user and the token of the current and the next
 * request. While a concrete instance is created the class checks the session
 * to prevent the user against session fixation and session hijacking.
 *
 * @package     stubbles
 * @subpackage  ipo_session
 */
abstract class stubAbstractSession extends stubBaseObject implements stubSession
{
    /**
     * switch whether session is new or not
     *
     * @var  bool
     */
    protected $isNew       = false;
    /**
     * the current token of the session, changes on every instantiation
     *
     * @var  string
     */
    protected $token       = '';
    /**
     * name of the session
     *
     * @var  string
     */
    protected $sessionName = '';
    /**
     * cache for objects
     *
     * @var  array<string,object>
     */
    protected $objectCache = array();

    /**
     * constructor
     *
     * @param  stubRequest   $request      request instance
     * @param  stubResponse  $response     response instance
     * @param  string        $sessionName  name of the session
     */
    public function __construct(stubRequest $request, stubResponse $response, $sessionName)
    {
        $this->sessionName = $sessionName;
        if ($this->doConstruct($request, $response, $sessionName) === false) {
            return;
        }

        if ($this->hasValue(stubSession::START_TIME) == false || $this->doGetValue(stubSession::FINGERPRINT) != $this->getFingerprint()) {
            if ($this->hasValue(stubSession::START_TIME) == false) {
                // prevent session fixation
                $this->regenerateId();
            } else {
                // prevent session hijacking
                $this->invalidate();
            }

            $this->putValue(stubSession::START_TIME, time());
            $this->isNew = true;
            $this->putValue(stubSession::FINGERPRINT, $this->getFingerprint());
            $this->token = md5(uniqid(rand()));
        } else {
            $this->token = $this->doGetValue(stubSession::NEXT_TOKEN);
        }

        $this->putValue(stubSession::NEXT_TOKEN, md5(uniqid(rand())));
    }

    /**
     * template method for child classes to do the real construction
     *
     * @param   stubRequest   $request      request instance
     * @param   stubResponse  $response     response instance
     * @param   string        $sessionName  name of the session
     * @return  bool
     */
    protected abstract function doConstruct(stubRequest $request, stubResponse $response, $sessionName);

    /**
     * clear up object cache (make sure that changed objects are written into session store)
     */
    public final function __destruct()
    {
        foreach ($this->objectCache as $key => $value) {
            $this->managePutValue($key, $value);
        }

        $this->doDescruct();
    }

    /**
     * template method for child classes to do specific descruction
     */
    protected function doDescruct()
    {
        // intentionally empty
    }

    /**
     * returns fingerprint for user: has to use same user agent all over the session
     *
     * @return  string
     */
    protected abstract function getFingerprint();

    /**
     * cloning is forbidden
     *
     * @throws  stubRuntimeException
     */
    public final function __clone()
    {
        throw new stubRuntimeException('Cloning the session is somewhat... useless.');
    }

    /**
     * checks whether session has been started
     *
     * Typically, a session is new on the first request of a user,
     * afterwards it should never be new.
     *
     * @return  bool  true if session has been started, else false
     */
    public function isNew()
    {
        return $this->isNew;
    }

    /**
     * returns unix timestamp when session was started
     *
     * @return  int
     * @throws  stubIllegalStateException
     */
    public function getStartTime()
    {
        if ($this->isValid() == false) {
            throw new stubIllegalStateException('Session is in an invalid state.');
        }

        return $this->getValue(stubSession::START_TIME);
    }

    /**
     * returns the name of the session
     *
     * @return  string
     */
    public function getName()
    {
        return $this->sessionName;
    }

    /**
     * returns token of current request
     *
     * @return  string  the token
     */
    public function getCurrentToken()
    {
        return $this->token;
    }

    /**
     * returns token for next request
     *
     * @return  string  the token
     */
    public function getNextToken()
    {
        return $this->getValue(stubSession::NEXT_TOKEN);
    }

    /**
     * checks if this session is valid
     *
     * @return  bool
     */
    public function isValid()
    {
        return $this->hasValue(stubSession::START_TIME);
    }

    /**
     * resets the session and deletes all session data
     *
     * @return  int
     */
    public function reset()
    {
        $this->objectCache = array();
        $valueKeys         = $this->getValueKeys();
        $count             = 0;
        foreach ($valueKeys as $valueKey) {
            if (stubSession::NEXT_TOKEN == $valueKey || stubSession::FINGERPRINT == $valueKey) {
                continue;
            }

            if (stubSession::START_TIME == $valueKey) {
                $this->putValue(stubSession::START_TIME, time());
                continue;
            }

            $count += (int) $this->doRemoveValue($valueKey);
        }

        return $count;
    }

    /**
     * stores a value associated with the key
     *
     * @param  string  $key    key to store value under
     * @param  mixed   $value  data to store
     */
    public function putValue($key, $value)
    {
        $this->managePutValue($key, $value);
        if (is_object($value) === true) {
            $this->objectCache[$key] = $value;
        }
    }

    /**
     * helper method for storing the value into the session
     *
     * @param  string  $key    key to store value under
     * @param  mixed   $value  data to store
     */
    protected function managePutValue($key, $value)
    {
        // This will enable lazy loading for stubObjects that are stored within
        // the session and implement the stubSerializable interface.
        if ($value instanceof stubSerializable) {
            $this->doPutValue($key, $value->getSerialized());
        } else {
            $this->doPutValue($key, $value);
        }
    }

    /**
     * returns a value associated with the key or the default value
     *
     * @param  string  $key    key to store value under
     * @param  mixed   $value  data to store
     */
    protected abstract function doPutValue($key, $value);

    /**
     * returns a value associated with the key or the default value
     *
     * @param   string  $key      key where value is stored under
     * @param   mixed   $default  optional  return this if no data is associated with $key
     * @return  mixed
     * @throws  stubIllegalStateException
     */
    public function getValue($key, $default = null)
    {
        if ($this->isValid() == false) {
            throw new stubIllegalStateException('Session is in an invalid state.');
        }

        if (isset($this->objectCache[$key]) === true) {
            return $this->objectCache[$key];
        }

        if ($this->hasValue($key) == true) {
            $value = $this->doGetValue($key);
            if ($value instanceof stubSerializedObject) {
                $this->objectCache[$key] = $value->getUnserialized();
                return $this->objectCache[$key];
            }

            if (is_object($value) === true) {
                $this->objectCache[$key] = $value;
            }

            return $value;
        }

        return $default;
    }

    /**
     * returns a value associated with the key or the default value
     *
     * @param   string  $key  key where value is stored under
     * @return  mixed
     */
    protected abstract function doGetValue($key);

    /**
     * removes a value from the session
     *
     * @param   string  $key  key where value is stored under
     * @return  bool    true if value existed and was removed, else false
     * @throws  stubIllegalStateException
     */
    public function removeValue($key)
    {
        if ($this->isValid() == false) {
            throw new stubIllegalStateException('Session is in an invalid state.');
        }

        if (isset($this->objectCache[$key]) === true) {
            unset($this->objectCache[$key]);
        }

        if ($this->hasValue($key) == true) {
            return $this->doRemoveValue($key);
        }

        return false;
    }

    /**
     * removes a value from the session
     *
     * @param   string  $key  key where value is stored under
     * @return  bool   true if value existed and was removed, else false
     */
    protected abstract function doRemoveValue($key);

    /**
     * return an array of all keys registered in this session
     *
     * @return  array<string>
     * @throws  stubIllegalStateException
     */
    public function getValueKeys()
    {
        if ($this->isValid() == false) {
            throw new stubIllegalStateException('Session is in an invalid state.');
        }

        $valueKeys = array();
        foreach ($this->doGetValueKeys() as $valueKey) {
            if (substr($valueKey, 0, 11) !== '__stubbles_') {
                $valueKeys[] = $valueKey;
            }
        }

        return $valueKeys;
    }

    /**
     * return an array of all keys registered in this session
     *
     * @return  array<string>
     */
    protected abstract function doGetValueKeys();
}
?><?php
/**
 * Decorator for sessions which throw exceptions on their creation to ensure
 * that the site will still work by falling back to another session implementation.
 *
 * @package     stubbles
 * @subpackage  ipo_session
 * @version     $Id: stubFallbackSession.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::session::stubNoneDurableSession',
                      'net::stubbles::ipo::session::stubSession'
);
/**
 * Decorator for sessions which throw exceptions on their creation to ensure
 * that the site will still work by falling back to another session implementation.
 *
 * @package     stubbles
 * @subpackage  ipo_session
 */
abstract class stubFallbackSession extends stubBaseObject implements stubSession
{
    /**
     * decorated session
     *
     * @var  stubSession
     */
    protected $session;

    /**
     * constructor
     * 
     * @param  stubRequest   $request      request instance
     * @param  stubResponse  $response     response instance
     * @param  string        $sessionName  name of the session
     */
    public final function __construct(stubRequest $request, stubResponse $response, $sessionName)
    {
        try {
            $this->session = $this->doConstruct($request, $response, $sessionName);
        } catch (stubException $e) {
            $this->session = new stubNoneDurableSession($request, $response, $sessionName);
        }
    }

    /**
     * creates the decorated and possibly exception-throwing session instance
     *
     * @param   stubRequest   $request      request instance
     * @param   stubResponse  $response     response instance
     * @param   string        $sessionName  name of the session
     * @return  stubSession
     */
    protected abstract function doConstruct(stubRequest $request, stubResponse $response, $sessionName);

    /**
     * checks whether session has been started
     * 
     * Typically, a session is new on the first request of a user,
     * afterwards it should never be new.
     *
     * @return  bool  true if session has been started, else false
     */
    public function isNew()
    {
        return $this->session->isNew();
    }

    /**
     * returns unix timestamp when session was started
     *
     * @return  int
     */
    public function getStartTime()
    {
        return $this->session->getStartTime();
    }

    /**
     * returns session id
     *
     * @return  string  the session id
     */
    public function getId()
    {
        return $this->session->getId();
    }

    /**
     * returns the name of the session
     *
     * @return  string
     */
    public function getName()
    {
        return $this->session->getName();
    }

    /**
     * regenerates the session id but leaves session data
     *
     * @param   string       $sessionId  optional  new session id to be used
     * @return  stubSession
     */
    public function regenerateId($sessionId = null)
    {
        $this->session->regenerateId($sessionId);
        return $this;
    }

    /**
     * returns token of current request
     *
     * @return  string  the token
     */
    public function getCurrentToken()
    {
        return $this->session->getCurrentToken();
    }

    /**
     * returns token for next request
     *
     * @return  string  the token
     */
    public function getNextToken()
    {
        return $this->session->getNextToken();
    }

    /**
     * checks if this session is valid
     *
     * @return  bool
     */
    public function isValid()
    {
        return $this->session->isValid();
    }

    /**
     * invalidates current session and creates a new one
     */
    public function invalidate()
    {
        $this->session->invalidate();
    }

    /**
     * resets the session and deletes all session data
     *
     * @return  int
     */
    public function reset()
    {
        return $this->session->reset();
    }

    /**
     * stores a value associated with the key
     *
     * @param  string  $key    key to store value under
     * @param  mixed   $value  data to store
     */
    public function putValue($key, $value)
    {
        $this->session->putValue($key, $value);
    }

    /**
     * returns a value associated with the key or the default value
     *
     * @param   string  $key      key where value is stored under
     * @param   mixed   $default  optional  return this if no data is associated with $key
     * @return  mixed
     */
    public function getValue($key, $default = null)
    {
        return $this->session->getValue($key, $default);
    }

    /**
     * checks whether a value associated with key exists
     *
     * @param   string  $key  key where value is stored under
     * @return  bool
     */
    public function hasValue($key)
    {
        return $this->session->hasValue($key);
    }

    /**
     * removes a value from the session
     *
     * @param   string  $name  key where value is stored under
     * @return  bool    true if value existed and was removed, else false
     */
    public function removeValue($name)
    {
        return $this->session->removeValue($name);
    }

    /**
     * return an array of all keys registered in this session
     *
     * @return  array<string>
     */
    public function getValueKeys()
    {
        return $this->session->getValueKeys();
    }
}
?><?php
/**
 * Session class that is not durable for more than one request.
 *
 * @package     stubbles
 * @subpackage  ipo_session
 * @version     $Id: stubNoneDurableSession.php 2430 2009-12-28 17:13:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::session::stubAbstractSession');
/**
 * Session class that is not durable for more than one request.
 *
 * @package     stubbles
 * @subpackage  ipo_session
 */
class stubNoneDurableSession extends stubAbstractSession
{
    /**
     * the session id
     *
     * @var  int
     */
    protected $id;
    /**
     * the data
     *
     * @var  array
     */
    protected $data           = array();

    /**
     * template method for child classes to do the real construction
     * 
     * @param   stubRequest   $request      request instance
     * @param   stubResponse  $response     response instance
     * @param   string        $sessionName  name of the session
     * @return  bool
     */
    protected function doConstruct(stubRequest $request, stubResponse $response, $sessionName)
    {
        $this->id = md5(uniqid(rand(), true));
        return true;
    }

    /**
     * returns fingerprint for user: not possible, as session lasts only for single request
     * 
     * @return  string
     */
    protected function getFingerprint()
    {
        return '';
    }

    /**
     * returns session id
     *
     * @return  string  the session id
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * regenerates the session id but leaves session data
     *
     * @param   string       $sessionId  optional  new session id to be used
     * @return  stubSession
     */
    public function regenerateId($sessionId = null)
    {
        $this->id = $sessionId;
        if (null == $this->id) {
            $this->id = md5(uniqid(rand(), true));
        }
        
        return $this;
    }

    /**
     * invalidates current session and creates a new one
     */
    public function invalidate()
    {
        $this->data = array();
    }

    /**
     * stores a value associated with the key
     *
     * @param  string  $key    key to store value under
     * @param  mixed   $value  data to store
     */
    protected function doPutValue($key, $value)
    {
        $this->data[$key] = $value;
    }

    /**
     * returns a value associated with the key or the default value
     *
     * @param   string  $key  key where value is stored under
     * @return  mixed
     */
    protected function doGetValue($key)
    {
        return $this->data[$key];
    }

    /**
     * checks whether a value associated with key exists
     *
     * @param   string  $key  key where value is stored under
     * @return  bool
     */
    public function hasValue($key)
    {
        return isset($this->data[$key]);
    }

    /**
     * removes a value from the session
     *
     * @param   string  $key  key where value is stored under
     * @return  bool    true if value existed and was removed, else false
     */
    protected function doRemoveValue($key)
    {
        unset($this->data[$key]);
        return true;
    }

    /**
     * return an array of all keys registered in this session
     *
     * @return  array<string>
     */
    protected function doGetValueKeys()
    {
        return array_keys($this->data);
    }
}
?><?php
/**
 * Session class that is durable for more than one request but does not store any data between requests.
 *
 * @package     stubbles
 * @subpackage  ipo_session
 * @version     $Id: stubNoneStoringSession.php 2897 2011-01-12 01:05:55Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::session::stubNoneDurableSession');
/**
 * Session class that is durable for more than one request but does not store any data between requests.
 *
 * @package     stubbles
 * @subpackage  ipo_session
 */
class stubNoneStoringSession extends stubNoneDurableSession
{
    /**
     * the response instance
     *
     * @var  stubResponse
     */
    protected $response;
    /**
     * regular expression to validate the session id
     *
     * @var  string
     */
    protected $sessionIdRegex = '/^([a-zA-Z0-9]{32})$/D';

    /**
     * template method for child classes to do the real construction
     * 
     * @param   stubRequest   $request      request instance
     * @param   stubResponse  $response     response instance
     * @param   string        $sessionName  name of the session
     * @return  bool
     */
    protected function doConstruct(stubRequest $request, stubResponse $response, $sessionName)
    {
        $this->response = $response;
        if ($request->hasParam($sessionName) === true) {
            $this->id   = $request->readParam($sessionName)->ifSatisfiesRegex($this->sessionIdRegex);
            $this->data = array(stubSession::START_TIME  => time(),
                                stubSession::FINGERPRINT => '',
                                stubSession::NEXT_TOKEN  => ''
                          );
        } elseif ($request->hasCookie($sessionName) === true) {
            $this->id   = $request->readCookie($sessionName)->ifSatisfiesRegex($this->sessionIdRegex);
            $this->data = array(stubSession::START_TIME  => time(),
                                stubSession::FINGERPRINT => '',
                                stubSession::NEXT_TOKEN  => ''
                          );
        } else {
            parent::doConstruct($request, $response, $sessionName);
        }
        
        $this->response->addCookie(stubCookie::create($this->sessionName, $this->id)
                                             ->forPath('/')
                                             ->usingHttpOnly(true)
        );
        return true;
    }

    /**
     * regenerates the session id but leaves session data
     *
     * @param   string       $sessionId  optional  new session id to be used
     * @return  stubSession
     */
    public function regenerateId($sessionId = null)
    {
        parent::regenerateId($sessionId);
        $this->response->addCookie(stubCookie::create($this->sessionName, $this->id)
                                             ->forPath('/')
                                             ->usingHttpOnly(true)
        );
        return $this;
    }

    /**
     * invalidates current session and creates a new one
     */
    public function invalidate()
    {
        parent::invalidate();
        $this->response->addCookie(stubCookie::create($this->sessionName, $this->id)
                                             ->forPath('/')
                                             ->usingHttpOnly(true)
                                             ->expiringAt(time() - 86400)
        );
    }
}
?><?php
/**
 * Session class using default PHP sessions.
 *
 * @package     stubbles
 * @subpackage  ipo_session
 * @version     $Id: stubPHPSession.php 2626 2010-08-12 17:05:15Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::session::stubAbstractSession',
                      'net::stubbles::php::string::stubMd5Encoder'
);
/**
 * Session class using default PHP sessions.
 *
 * This session class offers session handling based on the default PHP session
 * functions.
 *
 * @package     stubbles
 * @subpackage  ipo_session
 * @uses        http://php.net/session
 */
class stubPHPSession extends stubAbstractSession
{
    /**
     * the request instance
     *
     * @var  stubRequest
     */
    protected $request;

    /**
     * template method for child classes to do the real construction
     *
     * @param   stubRequest   $request      request instance
     * @param   stubResponse  $response     response instance
     * @param   string        $sessionName  name of the session
     * @return  bool
     */
    protected function doConstruct(stubRequest $request, stubResponse $response, $sessionName)
    {
        $this->request = $request;
        session_name($sessionName);
        @session_start();
        return true;
    }

    /**
     * returns fingerprint for user: has to use same user agent all over the session
     *
     * @return  string
     */
    protected function getFingerprint()
    {
        $encoder = new stubMd5Encoder();
        return $encoder->encode($this->request->readHeader('HTTP_USER_AGENT')->unsecure());
    }

    /**
     * returns session id
     *
     * @return  string  the session id
     */
    public function getId()
    {
        return session_id();
    }

    /**
     * regenerates the session id but leaves session data
     *
     * @param   string       $sessionId  optional  new session id to be used
     * @return  stubSession
     */
    public function regenerateId($sessionId = null)
    {
        @session_regenerate_id(true);
    }

    /**
     * invalidates current session and creates a new one
     */
    public function invalidate()
    {
        $_SESSION = array();
        @session_destroy();
        @session_start();
    }

    /**
     * stores a value associated with the key
     *
     * @param  string  $key    key to store value under
     * @param  mixed   $value  data to store
     */
    protected function doPutValue($key, $value)
    {
        $_SESSION[$key] = $value;
    }

    /**
     * returns a value associated with the key or the default value
     *
     * @param   string  $key  key where value is stored under
     * @return  mixed
     */
    protected function doGetValue($key)
    {
        return $_SESSION[$key];
    }

    /**
     * checks whether a value associated with key exists
     *
     * @param   string  $key  key where value is stored under
     * @return  bool
     */
    public function hasValue($key)
    {
        return isset($_SESSION[$key]);
    }

    /**
     * removes a value from the session
     *
     * @param   string  $key  key where value is stored under
     * @return  bool    true if value existed and was removed, else false
     */
    protected function doRemoveValue($key)
    {
        unset($_SESSION[$key]);
        return true;
    }

    /**
     * return an array of all keys registered in this session
     *
     * @return  array<string>
     */
    protected function doGetValueKeys()
    {
        return array_keys($_SESSION);
    }
}
?><?php
/**
 * Interface for sessions.
 *
 * @package     stubbles
 * @subpackage  ipo_session
 * @version     $Id: stubSession.php 2430 2009-12-28 17:13:39Z mikey $
 */
/**
 * Interface for sessions.
 *
 * @package     stubbles
 * @subpackage  ipo_session
 */
interface stubSession extends stubObject
{
    /**
     * key to be associated with the start time of the session
     */
    const START_TIME           = '__stubbles_SessionStartTime';
    /**
     * key to be associated with the token for the next request
     */
    const NEXT_TOKEN           = '__stubbles_SessionNextToken';
    /**
     * key to be associated with the fingerprint of the user
     */
    const FINGERPRINT          = '__stubbles_SessionFingerprint';
    /**
     * default session name
     */
    const DEFAULT_SESSION_NAME = 'PHPSESSID';

    /**
     * checks whether session has been started
     * 
     * Typically, a session is new on the first request of a user,
     * afterwards it should never be new.
     *
     * @return  bool  true if session has been started, else false
     */
    public function isNew();

    /**
     * returns unix timestamp when session was started
     *
     * @return  int
     */
    public function getStartTime();

    /**
     * returns session id
     *
     * @return  string  the session id
     */
    public function getId();

    /**
     * returns the name of the session
     *
     * @return  string
     */
    public function getName();

    /**
     * regenerates the session id but leaves session data
     *
     * @param   string       $sessionId  optional  new session id to be used
     * @return  stubSession
     */
    public function regenerateId($sessionId = null);

    /**
     * returns token of current request
     *
     * @return  string  the token
     */
    public function getCurrentToken();

    /**
     * returns token for next request
     *
     * @return  string  the token
     */
    public function getNextToken();

    /**
     * checks if this session is valid
     *
     * @return  bool
     */
    public function isValid();

    /**
     * invalidates current session and creates a new one
     */
    public function invalidate();

    /**
     * resets the session and deletes all session data
     *
     * @return  int
     */
    public function reset();

    /**
     * stores a value associated with the key
     *
     * @param  string  $key    key to store value under
     * @param  mixed   $value  data to store
     */
    public function putValue($key, $value);

    /**
     * returns a value associated with the key or the default value
     *
     * @param   string  $key      key where value is stored under
     * @param   mixed   $default  optional  return this if no data is associated with $key
     * @return  mixed
     */
    public function getValue($key, $default = null);

    /**
     * checks whether a value associated with key exists
     *
     * @param   string  $key  key where value is stored under
     * @return  bool
     */
    public function hasValue($key);

    /**
     * removes a value from the session
     *
     * @param   string  $name  key where value is stored under
     * @return  bool    true if value existed and was removed, else false
     */
    public function removeValue($name);

    /**
     * return an array of all keys registered in this session
     *
     * @return  array<string>
     */
    public function getValueKeys();
}
?><?php
/**
 * Abstract base implementation for exception handlers, containing logging of exceptions.
 *
 * @package     stubbles
 * @subpackage  lang_errorhandler
 * @version     $Id: stubAbstractExceptionHandler.php 2308 2009-09-01 12:18:02Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::response::stubBaseResponse',
                      'net::stubbles::lang::errorhandler::stubExceptionHandler',
                      'net::stubbles::util::log::stubLogger'
);
/**
 * Abstract base implementation for exception handlers, containing logging of exceptions.
 *
 * @package     stubbles
 * @subpackage  lang_errorhandler
 * @see         http://php.net/set_exception_handler
 */
abstract class stubAbstractExceptionHandler extends stubBaseObject implements stubExceptionHandler
{
    /**
     * switch whether logging is enabled or not
     *
     * @var  bool
     */
    protected $loggingEnabled = true;
    /**
     * target of the log data
     *
     * @var  string
     */
    protected $logTarget      = 'exceptions';
    /**
     * directory to log errors into
     *
     * @var  string
     */
    protected $logDir;
    /**
     * mode for new directories
     *
     * @var  int
     */
    protected $mode           = 0700;

    /**
     * constructor
     */
    public function __construct()
    {
        $this->logDir = stubPathRegistry::getLogPath() . DIRECTORY_SEPARATOR . 'errors' . DIRECTORY_SEPARATOR . '{Y}' . DIRECTORY_SEPARATOR . '{M}';
    }

    /**
     * set whether logging is enabled or not
     *
     * @param  bool  $loggingEnabled
     */
    public function setLogging($loggingEnabled)
    {
        $this->loggingEnabled = $loggingEnabled;
    }

    /**
     * sets the target of the log data
     *
     * @param  string  $logTarget
     */
    public function setLogTarget($logTarget)
    {
        $this->logTarget = $logTarget;
    }

    /**
     * sets the directory to log into
     *
     * @param  string  $logDir
     */
    public function setLogDirectory($logDir)
    {
        $this->logDir = $logDir;
    }

    /**
     * sets the mode for new log directories
     *
     * @param  int  $mode
     */
    public function setMode($mode)
    {
        $this->mode = $mode;
    }

    /**
     * handles the exception
     *
     * @param  Exception  $exception  the uncatched exception
     */
    public function handleException(Exception $exception)
    {
        $response = new stubBaseResponse();
        $response->setStatusCode(null);
        $this->fillResponse($response, $exception);
        if (true === $this->loggingEnabled) {
            $this->log($exception);
        }
        
        // send the response because the request will end right after this
        // method has been finished
        $response->send();
    }

    /**
     * fills response with useful data for display
     *
     * @param  stubResponse  $response   response to be send
     * @param  Exception     $exception  the uncatched exception
     */
    protected abstract function fillResponse(stubResponse $response, Exception $exception);

    /**
     * logs the exception into a logfile
     *
     * @param  Exception  $exception  the uncatched exception
     */
    protected function log(Exception $exception)
    {
        $logData  = date('Y-m-d H:i:s');
        $logData .= '|' . ((($exception instanceof stubThrowable) === true) ? ($exception->getClassName()) : (get_class($exception)));
        $logData .= '|' . $exception->getMessage();
        $logData .= '|' . $exception->getFile();
        $logData .= '|' . $exception->getLine();
        if ($exception instanceof stubChainedException && null !== $exception->getCause()) {
            $cause = $exception->getCause();
            $logData .= '|' . (($cause instanceof stubThrowable) ? ($cause->getClassName()) : (get_class($cause)));
            $logData .= '|' . $cause->getMessage();
            $logData .= '|' . $cause->getFile();
            $logData .= '|' . $cause->getLine();
        } else {
            $logData .= '||||';
        }
        
        $logDir = str_replace('{Y}', date('Y'), str_replace('{M}', date('m'), $this->logDir));
        if (file_exists($logDir) === false) {
            mkdir($logDir, $this->mode, true);
        }
        
        error_log($logData . "\n", 3, $logDir . DIRECTORY_SEPARATOR . $this->logTarget . '-' . date('Y-m-d') . '.log');
    }
}<?php
/**
 * Container for a collection of PHP error handlers.
 * 
 * @package     stubbles
 * @subpackage  lang_errorhandler
 * @version     $Id: stubCompositeErrorHandler.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::errorhandler::stubErrorHandler');
/**
 * Container for a collection of PHP error handlers.
 * 
 * @package     stubbles
 * @subpackage  lang_errorhandler
 * @see         http://php.net/set_error_handler
 */
class stubCompositeErrorHandler extends stubBaseObject implements stubErrorHandler
{
    /**
     * list of registered error handlers
     *
     * @var  array<stubErrorHandler>
     */
    protected $errorHandlers = array();

    /**
     * adds an error handler to the collection
     *
     * @param  stubErrorHandler  $errorHandler
     */
    public function addErrorHandler(stubErrorHandler $errorHandler)
    {
        $this->errorHandlers[] = $errorHandler;
    }

    /**
     * returns the list of error handlers
     *
     * @return  array<stubErrorHandler>
     */
    public function getErrorHandlers()
    {
        return $this->errorHandlers;
    }

    /**
     * checks whether this error handler is responsible for the given error
     * 
     * This method is called in case the level is 0. It decides whether the
     * error has to be handled or if it can be omitted.
     *
     * @param   int     $level    level of the raised error
     * @param   string  $message  error message
     * @param   string  $file     optional  filename that the error was raised in
     * @param   int     $line     optional  line number the error was raised at
     * @param   array   $context  optional  array of every variable that existed in the scope the error was triggered in
     * @return  bool    true if error handler is responsible, else false
     */
    public function isResponsible($level, $message, $file = null, $line = null, array $context = array())
    {
        foreach ($this->errorHandlers as $errorHandler) {
            if ($errorHandler->isResponsible($level, $message, $file, $line, $context) == true) {
                return true;
            }
        }
        
        return false;
    }

    /**
     * checks whether this error is supressable
     *
     * @param   int     $level    level of the raised error
     * @param   string  $message  error message
     * @param   string  $file     optional  filename that the error was raised in
     * @param   int     $line     optional  line number the error was raised at
     * @param   array   $context  optional  array of every variable that existed in the scope the error was triggered in
     * @return  bool    true if error is supressable, else false
     */
    public function isSupressable($level, $message, $file = null, $line = null, array $context = array())
    {
        foreach ($this->errorHandlers as $errorHandler) {
            if ($errorHandler->isSupressable($level, $message, $file, $line, $context) == false) {
                return false;
            }
        }
        
        return true;
    }

    /**
     * handles the given error
     *
     * @param   int     $level    level of the raised error
     * @param   string  $message  error message
     * @param   string  $file     optional  filename that the error was raised in
     * @param   int     $line     optional  line number the error was raised at
     * @param   array   $context  optional  array of every variable that existed in the scope the error was triggered in
     * @return  bool    true if error message should populate $php_errormsg, else false
     * @throws  stubException  error handlers are allowed to throw every exception they want to
     */
    public function handle($level, $message, $file = null, $line = null, array $context = array())
    {
        $errorReporting = error_reporting();
        foreach ($this->errorHandlers as $errorHandler) {
            if ($errorHandler->isResponsible($level, $message, $file, $line, $context) == true) {
                // if function/method was called with prepended @ and error is supressable
                if (0 == $errorReporting && $errorHandler->isSupressable($level, $message, $file, $line, $context) == true) {
                    return true;
                }
                
                return $errorHandler->handle($level, $message, $file, $line, $context);
            }
        }
        
        return true;
    }
}
?><?php
/**
 * Default collection of PHP error handlers.
 * 
 * @package     stubbles
 * @subpackage  lang_errorhandler
 */
stubClassLoader::load('net::stubbles::lang::errorhandler::stubCompositeErrorHandler',
                      'net::stubbles::lang::errorhandler::stubIllegalArgumentErrorHandler',
                      'net::stubbles::lang::errorhandler::stubLogErrorHandler'
);
/**
 * Default collection of PHP error handlers.
 *
 * The collection consists of:
 *  - stubIllegalArgumentErrorHandler
 *      throws a stubIllegalArgumentException in case of an E_RECOVERABLE saying
 *      that a type hint was violated
 *  - stubLogErrorHandler
 *      logs all remaining errors into the logfile php-errors with log level error
 * 
 * @package     stubbles
 * @subpackage  lang_errorhandler
 * @see         http://php.net/set_error_handler
 */
class stubDefaultErrorHandler extends stubCompositeErrorHandler
{
    /**
     * constructor
     */
    public function __construct()
    {
        $this->addErrorHandler(new stubIllegalArgumentErrorHandler());
        $this->addErrorHandler(new stubLogErrorHandler());
    }
}
?><?php
/**
 * Exception handler that displays the exception message nicely formated in the response.
 *
 * @package     stubbles
 * @subpackage  lang_errorhandler
 * @version     $Id: stubDisplayExceptionHandler.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::errorhandler::stubAbstractExceptionHandler');
/**
 * Exception handler that displays the exception message nicely formated in the response.
 *
 * You should not use this exception handler in production mode!
 *
 * @package     stubbles
 * @subpackage  lang_errorhandler
 */
class stubDisplayExceptionHandler extends stubAbstractExceptionHandler
{
    /**
     * fills response with useful data for display
     *
     * @param  stubResponse  $response   response to be send
     * @param  Exception     $exception  the uncatched exception
     */
    protected function fillResponse(stubResponse $response, Exception $exception)
    {
        if ($exception instanceof stubThrowable) {
            $response->write((string) $exception);
        } else {
            $response->write($exception->getMessage());
        }
        
        $response->write("\nTrace:\n" . $exception->getTraceAsString());
    }
}<?php
/**
 * Interface for PHP error handlers.
 * 
 * @package     stubbles
 * @subpackage  lang_errorhandler
 * @version     $Id: stubErrorHandler.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Interface for PHP error handlers.
 * 
 * @package     stubbles
 * @subpackage  lang_errorhandler
 * @see         http://php.net/set_error_handler
 */
interface stubErrorHandler extends stubObject
{
    /**
     * checks whether this error handler is responsible for the given error
     *
     * @param   int     $level    level of the raised error
     * @param   string  $message  error message
     * @param   string  $file     optional  filename that the error was raised in
     * @param   int     $line     optional  line number the error was raised at
     * @param   array   $context  optional  array of every variable that existed in the scope the error was triggered in
     * @return  bool    true if error handler is responsible, else false
     */
    public function isResponsible($level, $message, $file = null, $line = null, array $context = array());

    /**
     * checks whether this error is supressable
     * 
     * This method is called in case the level is 0. It decides whether the
     * error has to be handled or if it can be omitted.
     *
     * @param   int     $level    level of the raised error
     * @param   string  $message  error message
     * @param   string  $file     optional  filename that the error was raised in
     * @param   int     $line     optional  line number the error was raised at
     * @param   array   $context  optional  array of every variable that existed in the scope the error was triggered in
     * @return  bool    true if error is supressable, else false
     */
    public function isSupressable($level, $message, $file = null, $line = null, array $context = array());

    /**
     * handles the given error
     *
     * @param   int     $level    level of the raised error
     * @param   string  $message  error message
     * @param   string  $file     optional  filename that the error was raised in
     * @param   int     $line     optional  line number the error was raised at
     * @param   array   $context  optional  array of every variable that existed in the scope the error was triggered in
     * @return  bool    true if error message should populate $php_errormsg, else false
     * @throws  stubException  error handlers are allowed to throw every exception they want to
     */
    public function handle($level, $message, $file = null, $line = null, array $context = array());
}
?><?php
/**
 * Interface for exception handlers.
 *
 * @package     stubbles
 * @subpackage  lang_errorhandler
 * @version     $Id: stubExceptionHandler.php 2082 2009-02-10 12:48:36Z mikey $
 */
/**
 * Interface for exception handlers.
 *
 * @package     stubbles
 * @subpackage  lang_errorhandler
 * @see         http://php.net/set_exception_handler
 */
interface stubExceptionHandler extends stubObject
{
    /**
     * handles the exception
     *
     * @param  Exception  $exception  the uncatched exception
     */
    public function handleException(Exception $exception);
}
?><?php
/**
 * Error handler for illegal arguments.
 *
 * @package     stubbles
 * @subpackage  lang_errorhandler
 * @version     $Id: stubIllegalArgumentErrorHandler.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::errorhandler::stubErrorHandler',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException'
);
/**
 * Error handler for illegal arguments.
 * 
 * This error handler is responsible for errors of type E_RECOVERABLE_ERROR which denote that
 * a type hint has been infringed with an argument of another type. If such an error is detected
 * an stubIllegalArgumentException will be thrown.
 *
 * @package     stubbles
 * @subpackage  lang_errorhandler
 * @see         http://php.net/set_error_handler
 */
class stubIllegalArgumentErrorHandler extends stubBaseObject implements stubErrorHandler
{
    /**
     * checks whether this error handler is responsible for the given error
     *
     * @param   int     $level    level of the raised error
     * @param   string  $message  error message
     * @param   string  $file     optional  filename that the error was raised in
     * @param   int     $line     optional  line number the error was raised at
     * @param   array   $context  optional  array of every variable that existed in the scope the error was triggered in
     * @return  bool    true if error handler is responsible, else false
     */
    public function isResponsible($level, $message, $file = null, $line = null, array $context = array())
    {
        if (E_RECOVERABLE_ERROR != $level) {
            return false;
        }
        
        return (bool) preg_match('/Argument [0-9]+ passed to [a-zA-Z0-9_]+::[a-zA-Z0-9_]+\(\) must be an instance of [a-zA-Z0-9_]+, [a-zA-Z0-9_]+ given/', $message);
    }

    /**
     * checks whether this error is supressable
     * 
     * This method is called in case the level is 0. A type hint infringement
     * is never supressable.
     *
     * @param   int     $level    level of the raised error
     * @param   string  $message  error message
     * @param   string  $file     optional  filename that the error was raised in
     * @param   int     $line     optional  line number the error was raised at
     * @param   array   $context  optional  array of every variable that existed in the scope the error was triggered in
     * @return  bool    true if error is supressable, else false
     */
    public function isSupressable($level, $message, $file = null, $line = null, array $context = array())
    {
        return false;
    }

    /**
     * handles the given error
     *
     * @param   int     $level    level of the raised error
     * @param   string  $message  error message
     * @param   string  $file     optional  filename that the error was raised in
     * @param   int     $line     optional  line number the error was raised at
     * @param   array   $context  optional  array of every variable that existed in the scope the error was triggered in
     * @return  bool    true if error message should populate $php_errormsg, else false
     * @throws  stubIllegalArgumentException
     */
    public function handle($level, $message, $file = null, $line = null, array $context = array())
    {
        throw new stubIllegalArgumentException($message . ' @ ' . $file . ' on line ' . $line);
    }
}
?><?php
/**
 * Error handler that logs all errors.
 *
 * @package     stubbles
 * @subpackage  lang_errorhandler
 * @version     $Id: stubLogErrorHandler.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::stubPathRegistry',
                      'net::stubbles::lang::errorhandler::stubErrorHandler'
);
/**
 * Error handler that logs all errors.
 * 
 * This error handler logs all errors that occured. In a composition of error
 * handlers it should be added as last one so it catches all errors that have
 * not been handled before.
 *
 * @package     stubbles
 * @subpackage  lang_errorhandler
 * @see         http://php.net/set_error_handler
 */
class stubLogErrorHandler extends stubBaseObject implements stubErrorHandler
{
    /**
     * list of error levels and their string representation
     *
     * @var  array<int,string>
     */
    protected static $levelStrings  = array(E_ERROR             => 'E_ERROR',
                                            E_WARNING           => 'E_WARNING',
                                            E_PARSE             => 'E_PARSE',
                                            E_NOTICE            => 'E_NOTICE',
                                            E_CORE_ERROR        => 'E_CORE_ERROR',
                                            E_CORE_WARNING      => 'E_CORE_WARNING',
                                            E_COMPILE_ERROR     => 'E_COMPILE_ERROR',
                                            E_COMPILE_WARNING   => 'E_COMPILE_WARNING',
                                            E_USER_ERROR        => 'E_USER_ERROR',
                                            E_USER_WARNING      => 'E_USER_WARNING',
                                            E_USER_NOTICE       => 'E_USER_NOTICE',
                                            E_STRICT            => 'E_STRICT',
                                            E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR',
                                            E_ALL               => 'E_ALL'
                                      );
    /**
     * target of the log data
     *
     * @var  string
     */
    protected $logTarget = 'php-error';
    /**
     * directory to log errors into
     *
     * @var  string
     */
    protected $logDir;
    /**
     * mode for new directories
     *
     * @var  int
     */
    protected $mode      = 0700;

    /**
     * constructor
     */
    public function __construct()
    {
        $this->logDir = stubPathRegistry::getLogPath() . DIRECTORY_SEPARATOR . 'errors' . DIRECTORY_SEPARATOR . '{Y}' . DIRECTORY_SEPARATOR . '{M}';
    }

    /**
     * sets the target of the log data
     *
     * @param  string  $logTarget
     */
    public function setLogTarget($logTarget)
    {
        $this->logTarget = $logTarget;
    }

    /**
     * sets the directory to log into
     *
     * @param  string  $logDir
     */
    public function setLogDirectory($logDir)
    {
        $this->logDir = $logDir;
    }

    /**
     * sets the mode for new log directories
     *
     * @param  int  $mode
     */
    public function setMode($mode)
    {
        $this->mode = $mode;
    }

    /**
     * checks whether this error handler is responsible for the given error
     * 
     * This error handler is always responsible.
     *
     * @param   int     $level    level of the raised error
     * @param   string  $message  error message
     * @param   string  $file     optional  filename that the error was raised in
     * @param   int     $line     optional  line number the error was raised at
     * @param   array   $context  optional  array of every variable that existed in the scope the error was triggered in
     * @return  bool    true
     */
    public function isResponsible($level, $message, $file = null, $line = null, array $context = array())
    {
        return true;
    }

    /**
     * checks whether this error is supressable
     * 
     * This method is called in case the level is 0. An error to log is never
     * supressable.
     *
     * @param   int     $level    level of the raised error
     * @param   string  $message  error message
     * @param   string  $file     optional  filename that the error was raised in
     * @param   int     $line     optional  line number the error was raised at
     * @param   array   $context  optional  array of every variable that existed in the scope the error was triggered in
     * @return  bool    true if error is supressable, else false
     */
    public function isSupressable($level, $message, $file = null, $line = null, array $context = array())
    {
        return false;
    }

    /**
     * handles the given error
     *
     * @param   int     $level    level of the raised error
     * @param   string  $message  error message
     * @param   string  $file     optional  filename that the error was raised in
     * @param   int     $line     optional  line number the error was raised at
     * @param   array   $context  optional  array of every variable that existed in the scope the error was triggered in
     * @return  bool    true if error message should populate $php_errormsg, else false
     */
    public function handle($level, $message, $file = null, $line = null, array $context = array())
    {
        $logData  = date('Y-m-d H:i:s') . '|' . $level;
        $logData .= '|' . ((isset(self::$levelStrings[$level]) === true) ? (self::$levelStrings[$level]) : ('unknown'));
        $logData .= '|' . $message;
        $logData .= '|' . $file;
        $logData .= '|' . $line;
        $logDir   = $this->buildLogDir();
        if (file_exists($logDir) === false) {
            mkdir($logDir, $this->mode, true);
        }
        
        error_log($logData . "\n", 3, $logDir . DIRECTORY_SEPARATOR . $this->logTarget . '-' . date('Y-m-d') . '.log');
        return true;
    }

    /**
     * builds the log directory
     *
     * @return  string
     */
    protected function buildLogDir()
    {
        return str_replace('{Y}', date('Y'), str_replace('{M}', date('m'), $this->logDir));
    }

}
?><?php
/**
 * Exception handler for production mode: triggers a 500 Internal Server Error response.
 *
 * @package     stubbles
 * @subpackage  lang_errorhandler
 * @version     $Id: stubProdModeExceptionHandler.php 2899 2011-01-12 02:06:32Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::stubPathRegistry',
                      'net::stubbles::lang::errorhandler::stubAbstractExceptionHandler'
);
/**
 * Exception handler for production mode: triggers a 500 Internal Server Error response.
 *
 * @package     stubbles
 * @subpackage  lang_errorhandler
 */
class stubProdModeExceptionHandler extends stubAbstractExceptionHandler
{
    /**
     * fills response with useful data for display
     *
     * @param  stubResponse  $response   response to be send
     * @param  Exception     $exception  the uncatched exception
     */
    protected function fillResponse(stubResponse $response, Exception $exception)
    {
        $response->setStatusCode(500);
        $response->write(file_get_contents(stubPathRegistry::getConfigPath() . '/errors/500.html'));
    }
}<?php
/**
 * Class to chain exceptions, e.g. to wrap php-builtin exceptions.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 * @version     $Id: stubChainedException.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Class to chain exceptions, e.g. to wrap php-builtin exceptions.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 */
abstract class stubChainedException extends stubException
{
    /**
     * cause of the exception
     *
     * @var  Exception
     */
    protected $cause;

    /**
     * constructor
     *
     * @param  string     $message  the message of the exception
     * @param  Exception  $cause    the exception that caused this exception
     */
    public function __construct($message, Exception $cause = null)
    {
        parent::__construct($message);
        $this->cause = $cause;
    }

    /**
     * checks whether a cause exists
     *
     * @return  bool
     */
    public function hasCause()
    {
        return null !== $this->cause;
    }

    /**
     * returns the cause for this exception
     *
     * @return  Exception
     */
    public function getCause()
    {
        return $this->cause;
    }

    /**
     * returns final message
     *
     * @return  string
     */
    public function getFinalMessage()
    {
        if (null === $this->cause) {
            return $this->getMessage();
        }
        
        if (($this->cause instanceof stubChainedException) === false) {
            return $this->cause->getMessage();
        }
        
        return $this->cause->getFinalMessage();
    }

    /**
     * returns a string representation of the class
     * 
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * [fully-qualified-class-name] ' {' [members-and-value-list] '}'
     * <code>
     * example::MyException {
     *     message(string): This is an exception.
     *     file(string): foo.php
     *     line(integer): 4
     *     code(integer): 3
     *     stacktrace(string): __STACKTRACE__
     * } caused by AnotherExeption {
     *     message(string): This is another exception.
     *     file(string): bar.php
     *     line(integer): 55
     *     code(integer): 4
     *     stacktrace(string): __STACKTRACE__
     * }
     * </code>
     *
     * @return  string
     */
    public function __toString()
    {
        $parentString = parent::__toString();
        if (null === $this->cause) {
            return $parentString;
        }
        
        $string  = substr($parentString, 0, strlen($parentString) - 1);
        $string .= ' caused by ';
        if ($this->cause instanceof stubChainedException) {
            $string .= $this->cause->__toString();
        } else {
            if ($this->cause instanceof stubThrowable) {
                $string .= $this->cause->getClassName();
            } else {
                $string .= get_class($this->cause);
            }
            
            $string .= " {\n    message(string): " . $this->cause->getMessage() . "\n";
            $string .= '    file(string): ' . $this->cause->getFile() . "\n";
            $string .= '    line(integer): ' . $this->cause->getLine() . "\n";
            $string .= '    code(integer): ' . $this->cause->getCode() . "\n";
            $string .= '    stacktrace(string): ' . $this->cause->getTraceAsString() . "\n";
            $string .= "}\n";
        }
        
        return $string;
    }
}
?><?php
/**
 * Exception to be thrown in case any component has not been configured correctly
 *
 * @package     stubbles
 * @subpackage  lang_exceptions
 * @version     $Id: stubConfigurationException.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubChainedException');
/**
 * Exception to be thrown in case any component has not been configured correctly
 *
 * @package     stubbles
 * @subpackage  lang_exceptions
 */
class stubConfigurationException extends stubChainedException
{
    // nothing to do
}
?><?php
/**
 * Base exception class for all stubbles exceptions.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 * @version     $Id: stubException.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Base exception class for all stubbles exceptions.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 */
class stubException extends Exception implements stubThrowable
{
    /**
     * returns class informations
     *
     * @return  stubReflectionObject
     * @XMLIgnore
     */
    public function getClass()
    {
        stubClassLoader::load('net::stubbles::reflection::stubReflectionObject');
        $refObject = new stubReflectionObject($this);
        return $refObject;
    }

    /**
     * returns package informations
     *
     * @return  stubReflectionPackage
     * @XMLIgnore
     */
    public function getPackage()
    {
         stubClassLoader::load('net::stubbles::reflection::stubReflectionPackage');
         $refPackage = new stubReflectionPackage(stubClassLoader::getPackageName($this->getClassName()));
         return $refPackage;
    }

    /**
     * returns the full qualified class name
     *
     * @return  string
     * @XMLIgnore
     */
    public function getClassName()
    {
        return stubClassLoader::getFullQualifiedClassName(get_class($this));
    }

    /**
     * returns the name of the package where the class is inside
     *
     * @return  string
     * @XMLIgnore
     */
    public function getPackageName()
    {
        return stubClassLoader::getPackageName($this->getClassName());
    }

    /**
     * returns a unique hash code for the class
     *
     * @return  string
     * @XMLIgnore
     */
    public function hashCode()
    {
        return spl_object_hash($this);
    }

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if ($compare instanceof stubObject) {
            return ($this->hashCode() == $compare->hashCode());
        }
        
        return false;
    }

    /**
     * returns a string representation of the class
     * 
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * [fully-qualified-class-name] ' {' [members-and-value-list] '}'
     * <code>
     * example::MyException {
     *     message(string): This is an exception.
     *     file(string): foo.php
     *     line(integer): 4
     *     code(integer): 3
     *     stacktrace(string): __STACKTRACE__
     * }
     * </code>
     *
     * @return  string
     * @XMLIgnore
     */
    public function __toString()
    {
        $string  = $this->getClassName() . " {\n";
        $string .= '    message(string): ' . $this->getMessage() . "\n";
        $string .= '    file(string): ' . $this->getFile() . "\n";
        $string .= '    line(integer): ' . $this->getLine() . "\n";
        $string .= '    code(integer): ' . $this->getCode() . "\n";
        $string .= '    stacktrace(string): ' . $this->getTraceAsString() . "\n";
        $string .= "}\n";
        return $string;
    }
}
?><?php
/**
 * Exception to be thrown in case a file could not be found.
 *
 * @package     stubbles
 * @subpackage  lang_exceptions
 * @version     $Id: stubFileNotFoundException.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIOException');
/**
 * Exception to be thrown in case a file could not be found.
 *
 * @package     stubbles
 * @subpackage  lang_exceptions
 */
class stubFileNotFoundException extends stubIOException
{
    /**
     * constructor
     *
     * @param  string  $fileName  name of file that was not found
     */
    public function __construct($fileName)
    {
        $this->message = "The file {$fileName} could not be found or is not readable.";
    }
}
?><?php
/**
 *  An IllegalAccessException is thrown when an object is accessed in a way for which no permissions exist.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 * @version     $Id: stubIllegalAccessException.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 *  An IllegalAccessException is thrown when an object is accessed in a way for which no permissions exist.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 */
class stubIllegalAccessException extends stubException
{
    // nothing to do
}
?><?php
/**
 * Exception to be thrown in case an illegal argument was given.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 * @version     $Id: stubIllegalArgumentException.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Exception to be thrown in case an illegal argument was given.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 */
class stubIllegalArgumentException extends stubException
{
    // nothing to do
}
?><?php
/**
 * An IllegalStateException is thrown when a method has been invoked at an
 * illegal or inappropriate time.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 * @version     $Id: stubIllegalStateException.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * An IllegalStateException is thrown when a method has been invoked at an
 * illegal or inappropriate time.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 */
class stubIllegalStateException extends stubException
{
    // nothing to do
}
?><?php
/**
 * Exception to be thrown in case an IO error occurred.
 *
 * @package     stubbles
 * @subpackage  lang_exceptions
 * @version     $Id: stubIOException.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Exception to be thrown in case an IO error occurred.
 *
 * @package     stubbles
 * @subpackage  lang_exceptions
 */
class stubIOException extends stubException
{
    // nothing to do
}
?><?php
/**
 * Exception to be thrown in case any component has not been configured correctly
 *
 * @package     stubbles
 * @subpackage  lang_exceptions
 * @version     $Id: stubMethodInvocationException.php 2173 2009-04-23 21:59:00Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubChainedException');
/**
 * Exception to be thrown in case any component has not been configured correctly
 *
 * @package     stubbles
 * @subpackage  lang_exceptions
 */
class stubMethodInvocationException extends stubChainedException
{
    // nothing to do
}
?><?php
/**
 * Exception to be thrown in case a method is called which is not supported by
 * a specific implementation.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 * @version     $Id: stubMethodNotSupportedException.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubRuntimeException');
/**
 * Exception to be thrown in case a method is called which is not supported by
 * a specific implementation.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 */
class stubMethodNotSupportedException extends stubRuntimeException
{
    // intentionally empty
}
?><?php
/**
 * Base exception class for all stubbles runtime exceptions.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 * @version     $Id: stubRuntimeException.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Base exception class for all stubbles runtime exceptions.
 *
 * A runtime exception should be thrown if a class is used in wrong way, e.g.
 * a missing configuration file or wrong class instance is supplied. Instances
 * of this and inherited exceptions should never be catched. The docblock of a
 * method must not indicate that a runtime exception may be thrown.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 */
class stubRuntimeException extends Exception implements stubThrowable
{
    /**
     * returns class informations
     *
     * @return  stubReflectionObject
     * @XMLIgnore
     */
    public function getClass()
    {
        stubClassLoader::load('net::stubbles::reflection::stubReflectionObject');
        $refObject = new stubReflectionObject($this);
        return $refObject;
    }

    /**
     * returns package informations
     *
     * @return  stubReflectionPackage
     * @XMLIgnore
     */
    public function getPackage()
    {
         stubClassLoader::load('net::stubbles::reflection::stubReflectionPackage');
         $refPackage = new stubReflectionPackage(stubClassLoader::getPackageName($this->getClassName()));
         return $refPackage;
    }

    /**
     * returns the full qualified class name
     *
     * @return  string
     * @XMLIgnore
     */
    public function getClassName()
    {
        return stubClassLoader::getFullQualifiedClassName(get_class($this));
    }

    /**
     * returns the name of the package where the class is inside
     *
     * @return  string
     * @XMLIgnore
     */
    public function getPackageName()
    {
        return stubClassLoader::getPackageName($this->getClassName());
    }

    /**
     * returns a unique hash code for the class
     *
     * @return  string
     * @XMLIgnore
     */
    public function hashCode()
    {
        return spl_object_hash($this);
    }

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if ($compare instanceof stubObject) {
            return ($this->hashCode() == $compare->hashCode());
        }
        
        return false;
    }

    /**
     * returns a string representation of the class
     * 
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * [fully-qualified-class-name] ' {' [members-and-value-list] '}'
     * <code>
     * net::stubbles::lang::exceptions::stubRuntimeException {
     *     message(string): This is a runtime exception.
     *     file(string): foo.php
     *     line(integer): 4
     *     code(integer): 3
     *     stacktrace(string): __STACKTRACE__
     * }
     * [stack trace]
     * </code>
     *
     * @return  string
     * @XMLIgnore
     */
    public function __toString()
    {
        $string  = $this->getClassName() . " {\n";
        $string .= '    message(string): ' . $this->getMessage() . "\n";
        $string .= '    file(string): ' . $this->getFile() . "\n";
        $string .= '    line(integer): ' . $this->getLine() . "\n";
        $string .= '    code(integer): ' . $this->getCode() . "\n";
        $string .= '    stacktrace(string): ' . $this->getTraceAsString() . "\n";
        $string .= "}\n";
        return $string;
    }
}
?><?php
/**
 * Base interface for all exception classes.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 * @version     $Id: stubThrowable.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Base interface for all exception classes.
 * 
 * @package     stubbles
 * @subpackage  lang_exceptions
 */
interface stubThrowable extends stubObject
{
    // intentionally empty
}
?><?php
/**
 * Interface for initializers of all kind.
 *
 * @package     stubbles
 * @subpackage  lang_initializer
 * @version     $Id: stubInitializer.php 2222 2009-06-09 21:55:06Z mikey $
 */
/**
 * Interface for initializers of all kind.
 *
 * @package     stubbles
 * @subpackage  lang_initializer
 */
interface stubInitializer extends stubObject
{
    /**
     * initializing method
     *
     * @return  stubInitializer
     */
    public function init();
}
?><?php
/**
 * Interface for objects that can be serialized.
 * 
 * @package     stubbles
 * @subpackage  lang_serialize
 * @version     $Id: stubSerializable.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Interface for objects that can be serialized.
 * 
 * @package     stubbles
 * @subpackage  lang_serialize
 */
interface stubSerializable extends stubObject
{
    /**
     * returns a serialized representation of the class
     * 
     * @return  stubSerializedObject
     */
    public function getSerialized();
}
?><?php
/**
 * base class for all other stubbles classes except static ones and classes
 * extending php built-in classes
 * 
 * @package     stubbles
 * @subpackage  lang_serialize
 * @version     $Id: stubSerializableObject.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * base class for all other stubbles classes except static ones and classes
 * extending php built-in classes
 * 
 * @package     stubbles
 * @subpackage  lang_serialize
 */
class stubSerializableObject extends stubBaseObject implements stubSerializable
{
    /**
     * a list of serialized properties
     * 
     * Do not ever use this property in extended classes. It is only protected
     * and not private because of some PHP-$�&%&�%&!
     *
     * @var  array<string,stubSerializedObject>
     */
    protected $_serializedProperties = array();

    /**
     * returns a serialized representation of the class
     * 
     * @return  stubSerializedObject
     * @XMLIgnore
     */
    public function getSerialized()
    {
        $serialized = new stubSerializedObject($this);
        return $serialized;
    }

    /**
     * ensure that all instances of stubSerializable are correctly serialized
     *
     * @return  array<string>  list of properties to serialize
     * @XMLIgnore
     */
    public final function __sleep()
    {
        $this->_serializedProperties = array();
        $nonAllowedProperties        = $this->__doSleep();
        $propertiesToSerialize       = array();
        foreach ($this->_extractProperties($this) as $name => $value) {
            if (in_array($name, $nonAllowedProperties) == true) {
                continue;
            }
            
            $this->__doSerialize($propertiesToSerialize, $name, $value);
        }
        
        return $propertiesToSerialize;
    }

    /**
     * template method to hook into __sleep()
     *
     * @return  array<string>  list of property names that should not be serialized
     */
    protected function __doSleep()
    {
        return array();
    }

    /**
     * takes care of serializing the value
     *
     * @param  array   &$propertiesToSerialize  list of properties to serialize
     * @param  string  $name                    name of the property to serialize
     * @param  mixed   $value                   value to serialize
     */
    protected function __doSerialize(&$propertiesToSerialize, $name, $value)
    {
        if ($value instanceof stubSerializable) {
            $this->_serializedProperties[$name] = $value->getSerialized();
        } else {
            $propertiesToSerialize[] = $name;
        }
    }
    
    /**
     * restore all instances that are of type stubSerializable
     * 
     * @XMLIgnore
     */
    public final function __wakeup()
    {
        $this->__doWakeUp();
        foreach ($this->_serializedProperties as $name => $serializedValue) {
            $this->__doUnserialize($name, $serializedValue);
        }
        
        $this->_serializedProperties = array();
    }

    /**
     * template method to hook into __wakeup()
     */
    protected function __doWakeUp()
    {
        // intentionally empty
    }

    /**
     * takes care of unserializing the value
     *
     * @param  string  $name             name of the property
     * @param  mixed   $serializedValue  value of the property
     */
    protected function __doUnserialize($name, $serializedValue)
    {
        if ($serializedValue instanceof stubSerializedObject) {
            $this->$name = $serializedValue->getUnserialized();
        } else {
            $this->$name = $serializedValue;
        }
    }
}
?><?php
/**
 * Serialized representation of a stubObject.
 *
 * @package     stubbles
 * @subpackage  lang_serialize
 * @version     $Id: stubSerializedObject.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Serialized representation of a stubObject.
 * 
 * Using this allows lazy loading of classes stored in session.
 * 
 * @package     stubbles
 * @subpackage  lang_serialize
 */
class stubSerializedObject implements stubObject
{
    /**
     * full qualified class name of the serialized class
     *
     * @var  string
     */
    protected $fqClassName;
    /**
     * non qualified class name
     *
     * @var  string
     */
    protected $nqClassName;
    /**
     * the instance of the serialized class
     *
     * @var  stubObject
     */
    protected $classInstance;
    /**
     * hash code of serialized class
     *
     * @var  string
     */
    protected $hashCode;
    /**
     * the serialized class data
     *
     * @var  string
     */
    protected $data;

    /**
     * constructor
     *
     * @param  stubSerializable  $serializable  the instance to serialize
     */
    public function __construct(stubSerializable $serializable)
    {
        $this->fqClassName = $serializable->getClassName();
        if (null != $this->fqClassName) {
            $this->nqClassName = stubClassLoader::getNonQualifiedClassName($this->fqClassName);
        } else {
            $this->nqClassName = get_class($serializable);
        }
        
        $this->classInstance = $serializable;
        $this->hashCode      = $serializable->hashCode();
    }

    /**
     * interceptor called before object instance is serialized
     *
     * @return  array
     */
    public function __sleep()
    {
        if (null == $this->data && null != $this->classInstance) {
            $this->data = serialize($this->classInstance);
        }
        
        return array('fqClassName', 'nqClassName', 'hashCode', 'data');
    }

    /**
     * returns an unserialized version of the class
     * 
     * If the class was not loaded before it is loaded before unserialization.
     *
     * @return  stubSerializable
     */
    public function getUnserialized()
    {
        if (null != $this->classInstance) {
            return $this->classInstance;
        }
        
        if (class_exists($this->nqClassName, false) == false) {
            stubClassLoader::load($this->fqClassName);
        }
        
        $this->classInstance = unserialize($this->data);
        return $this->classInstance;
    }

    /**
     * returns the class name of the serialized class
     *
     * @return  string
     */
    public function getSerializedClassName()
    {
        return $this->fqClassName;
    }

    /**
     * returns class informations
     *
     * @return  stubReflectionObject
     * @XMLIgnore
     */
    public function getClass()
    {
        stubClassLoader::load('net::stubbles::reflection::stubReflectionObject');
        $refObject = new stubReflectionObject($this);
        return $refObject;
    }

    /**
     * returns package informations
     *
     * @return  stubReflectionPackage
     * @XMLIgnore
     */
    public function getPackage()
    {
         stubClassLoader::load('net::stubbles::reflection::stubReflectionPackage');
         $refPackage = new stubReflectionPackage(stubClassLoader::getPackageName($this->getClassName()));
         return $refPackage;
    }

    /**
     * returns the full qualified class name
     *
     * @return  string
     * @XMLIgnore
     */
    public function getClassName()
    {
        return stubClassLoader::getFullQualifiedClassName(__CLASS__);
    }

    /**
     * returns the name of the package where the class is inside
     *
     * @return  string
     * @XMLIgnore
     */
    public function getPackageName()
    {
        return stubClassLoader::getPackageName($this->getClassName());
    }

    /**
     * returns a unique hash code for the class
     *
     * @return  string
     */
    public function hashCode()
    {
        return 'serialized: ' . $this->hashCode;
    }

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     * @XMLIgnore
     */
    public function equals($compare)
    {
        if ($compare instanceof self) {
            return $this->hashCode == $compare->hashCode;
        }
        
        return false;
    }

    /**
     * returns a serialized representation of the class
     * 
     * @throws  Exception
     * @XMLIgnore
     */
    public function getSerialized()
    {
        // do not throw a stubException to prevent cirular references
        throw new Exception('Can not serialize a serialized ' . $this->getClassName() . ' representation of ' . $this->fqClassName);
    }

    /**
     * returns a string representation of the class
     * 
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * [fully-qualified-class-name] ' {' [members-and-value-list] '}'
     * <code>
     * net::stubbles::lang::serialize::stubSerializedObject {
     *     class(string): net:.stubbles::stubExample
     *     data(string): [serialized representation of net::stubbles::stubExample]
     * }
     * </code>
     *
     * @return  string
     * @XMLIgnore
     */
    public function __toString()
    {
        $string  = $this->getClassName() . " {\n";
        $string .= '    fqClassName(string): ' . $this->fqClassName . "\n";
        $string .= '    nqClassName(string): ' . $this->nqClassName . "\n";
        $string .= '    data(string): ' . serialize($this->classInstance) . "\n";
        $string .= "}\n";
        return $string;
    }
}
?><?php
/**
 * Container to allow method chaining for returned arrays.
 *
 * @package     stubbles
 * @subpackage  lang
 * @version     $Id: stubArrayAccessor.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalAccessException');
/**
 * Container to allow method chaining for returned arrays.
 *
 * In case a method returns an array it may return an instance of this class as
 * well, constructed with the array intended for return. This will allow other
 * methods for method chaining. This is required in some circumstances as PHP
 * does not allow to write code like
 * <code>
 * echo asArray()[0]
 * </code>
 * which would access the first value of the returned array. A work around is
 * to write
 * <code>
 * $array = asArray();
 * echo $array[0];
 * </code>
 * With this class it is possible to write it as follows:
 * <code>
 * echo asArray()->first()
 * </code>
 *
 * @package     stubbles
 * @subpackage  lang
 */
class stubArrayAccessor extends stubBaseObject implements ArrayAccess, Countable, IteratorAggregate
{
    /**
     * the wrapped array
     *
     * @var  array
     */
    protected $data = array();

    /**
     * constructor
     *
     * @param  array  $data  optional
     */
    public function __construct(array $data = array())
    {
        $this->data = $data;
    }

    /**
     * returns value of first element
     *
     * Returns null if there is no first element.
     *
     * @return  mixed
     */
    public function first()
    {
        if (count($this->data) === 0) {
            return null;
        }
        
        reset($this->data);
        return current($this->data);
    }

    /**
     * returns value of last element
     *
     * @return  mixed
     */
    public function last()
    {
        if (count($this->data) === 0) {
            return null;
        }
        
        return end($this->data);
    }

    /**
     * returns value stored under given offset
     *
     * @param   string|int  $offset
     * @return  mixed
     */
    public function at($offset)
    {
        return $this->offsetGet($offset);
    }

    /**
     * replaces current array with another array
     *
     * @param  array  $data
     */
    public function replace(array $data)
    {
        $this->data = $data;
    }

    /**
     * returns raw array
     *
     * @return  array
     */
    public function toArray()
    {
        return $this->data;
    }

    /**
     * checks whether an entry for given offset exists
     *
     * @param   string|int  $offset
     * @return  bool
     */
    public function offsetExists($offset)
    {
        return isset($this->data[$offset]);
    }

    /**
     * returns value stored under given offset
     *
     * @param   string|int  $offset
     * @return  mixed
     * @throws  stubIllegalAccessException
     */
    public function offsetGet($offset)
    {
        if (isset($this->data[$offset]) === true) {
            return $this->data[$offset];
        }
        
        throw new stubIllegalAccessException('No element for offset ' . $offset);
    }

    /**
     * sets value at given offset
     *
     * @param  string|int  $offset
     * @param  mixed       $value
     */
    public function offsetSet($offset, $value)
    {
        $this->data[$offset] = $value;
    }

    /**
     * removes given offset
     *
     * @param  string|int  $offset
     */
    public function offsetUnset($offset)
    {
        if (isset($this->data[$offset]) === true) {
            unset($this->data[$offset]);
        }
    }

    /**
     * returns amount of elements
     *
     * @return  int
     */
    public function count()
    {
        return count($this->data);
    }

    /**
     * returns an iterator to be used in foreach
     *
     * @return  Iterator
     */
    public function getIterator()
    {
        return new ArrayIterator($this->data);
    }

    /**
     * returns a list of all keys of the wrapped array
     *
     * @return  array<int,scalar>
     */
    public function getKeys()
    {
        return array_keys($this->data);
    }
}
?><?php
/**
 * base class for all other stubbles classes except static ones and classes
 * extending php built-in classes
 *
 * @author      Frank Kleine  <mikey@stubbles.net>
 * @package     stubbles
 * @subpackage  lang
 */
/**
 * base class for all other stubbles classes except static ones and classes
 * extending php built-in classes
 *
 * @package     stubbles
 * @subpackage  lang
 */
class stubBaseObject implements stubObject
{
    /**
     * returns class informations
     *
     * @return  stubReflectionObject
     * @XMLIgnore
     */
    public function getClass()
    {
        stubClassLoader::load('net::stubbles::reflection::stubReflectionObject');
        $refObject = new stubReflectionObject($this);
        return $refObject;
    }

    /**
     * returns package informations
     *
     * @return  stubReflectionPackage
     * @XMLIgnore
     */
    public function getPackage()
    {
         stubClassLoader::load('net::stubbles::reflection::stubReflectionPackage');
         $refPackage = new stubReflectionPackage(stubClassLoader::getPackageName($this->getClassName()));
         return $refPackage;
    }

    /**
     * returns the full qualified class name
     *
     * @return  string
     * @XMLIgnore
     */
    public function getClassName()
    {
        return stubClassLoader::getFullQualifiedClassName(get_class($this));
    }

    /**
     * returns the name of the package where the class is inside
     *
     * @return  string
     * @XMLIgnore
     */
    public function getPackageName()
    {
        return stubClassLoader::getPackageName($this->getClassName());
    }

    /**
     * returns a unique hash code for the class
     *
     * @return  string
     * @XMLIgnore
     */
    public function hashCode()
    {
        return spl_object_hash($this);
    }

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if ($compare instanceof stubObject) {
            return ($this->hashCode() == $compare->hashCode());
        }

        return false;
    }

    /**
     * returns a string representation of the class
     *
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * [fully-qualified-class-name] ' {' [members-and-value-list] '}'
     * <code>
     * example::MyClass {
     *     foo(string): hello
     *     bar(example::AnotherClass): example::AnotherClass {
     *         baz(int): 5
     *     }
     * }
     * </code>
     *
     * @return  string
     * @XMLIgnore
     */
    public function __toString()
    {
        return self::getStringRepresentationOf($this, self::_extractProperties($this));
    }

    /**
     * helper method to extract all properties regardless of their visibility
     *
     * This is a workaround for the problem that as of PHP 5.2.4 get_object_vars()
     * is not any more capable of retrieving private properties from child classes.
     * See http://stubbles.org/archives/32-Subtle-BC-break-in-PHP-5.2.4.html.
     *
     * @param   mixed  $object
     * @return  array<string,mixed>
     */
    protected static function _extractProperties($object)
    {
        $properties      = (array) $object;
        $fixedProperties = array();
        foreach ($properties as $propertyName => $propertyValue) {
            if (strstr($propertyName, "\0") === false) {
                $fixedProperties[$propertyName] = $propertyValue;
                continue;
            }
            
            $fixedProperties[substr($propertyName, strrpos($propertyName, "\0") + 1)] = $propertyValue;
        }
        
        return $fixedProperties;
    }

    /**
     * returns a string representation of the class
     *
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * [fully-qualified-class-name] ' {' [members-and-value-list] '}'
     * <code>
     * example::MyClass {
     *     foo(string): hello
     *     bar(example::AnotherClass): example::AnotherClass {
     *         baz(int): 5
     *     }
     * }
     * </code>
     * Please note that protected and private properties of the class wil only be
     * in the result if the second argument contains a list of the properties and
     * its values. If not set only public properties can be extracted due to the
     * behaviour of get_object_vars().
     *
     * @param   stubObject  $object      the object to convert to a string
     * @param   array       $properties  optional  the properties, if not set they will be retrieved
     * @return  string
     * @XMLIgnore
     */
    public static function getStringRepresentationOf(stubObject $object, array $properties = null)
    {
        if (null === $properties) {
            $properties = self::_extractProperties($object);
        }

        $string = $object->getClassName() . " {\n";
        foreach ($properties as $name => $value) {
            if ('_serializedProperties' == $name) {
                continue;
            }

            $string .= '    ' . $name . '(' . self::_determineType($value) . '): ';
            if (($value instanceof self) == false) {
                $string .= $value . "\n";
                continue;
            }

            $lines       = explode("\n", (string) $value);
            $lineCounter = 0;
            foreach ($lines as $line) {
                if (empty($line) == true) {
                    continue;
                }

                if (0 != $lineCounter) {
                    $string .= '    ' . $line . "\n";
                } else {
                    $string .= $line . "\n";
                }

                $lineCounter++;
            }
        }

        $string .= "}\n";
        return $string;
    }

    /**
     * determines the correct type of a value
     *
     * @param   mixed   &$value
     * @return  string
     */
    private static function _determineType(&$value)
    {
        if (is_object($value) === false) {
            if (is_resource($value) === false) {
                return gettype($value);
            }

            return 'resource[' . get_resource_type($value) . ']';
        }

        if ($value instanceof stubObject) {
            return $value->getClassName();
        }

        return get_class($value);
    }
}
?><?php
/**
 * Marker interface for clonable classes.
 * 
 * @package     stubbles
 * @subpackage  lang
 * @version     $Id: stubClonable.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Marker interface for clonable classes.
 * 
 * @package     stubbles
 * @subpackage  lang
 */
interface stubClonable extends stubObject
{
    // intentionally empty
}
?><?php
/**
 * Handlings for different runtime modes of Stubbles.
 *
 * @package     stubbles
 * @subpackage  lang
 * @version     $Id: stubDefaultMode.php 2110 2009-03-04 13:02:45Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::stubMode',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException'
);
/**
 * Handlings for different runtime modes of Stubbles.
 *
 * The mode instance contains information about which exception handler and
 * which error handler should be used, else well as whether caching is enabled
 * or not. Currently, there are four different default modes available:
 * stubDefaultMode::prod()
 *      - uses exception handler net::stubbles::lang::errorhandler::stubProdModeExceptionHandler
 *      - uses default error handler net::stubbles::lang::errorhandler::stubDefaultErrorHandler
 *      - caching enabled
 * stubDefaultMode::test()
 *      - uses exception handler net::stubbles::lang::errorhandler::stubDisplayExceptionHandler
 *      - uses default error handler net::stubbles::lang::errorhandler::stubDefaultErrorHandler
 *      - caching enabled
 * stubDefaultMode::stage()
 *      - uses exception handler net::stubbles::lang::errorhandler::stubDisplayExceptionHandler
 *      - no error handler
 *      - caching disabled
 * stubDefaultMode::dev()
 *      - uses exception handler net::stubbles::lang::errorhandler::stubDisplayExceptionHandler
 *      - no error handler
 *      - caching disabled
 * While stage and dev mode currently are not different this may change in
 * future in case new mode depending switches become neccessary.
 *
 * To change the exception and/or error handler to be used, set the new ones
 * via setExceptionHandler()/setErrorHandler().
 * Please be aware that you still need to register the exception/error handler,
 * this is not done automatically, regardless whether you set your own ones or
 * not. Use registerExceptionHandler() and registerErrorHandler() to do so.
 *
 * @package     stubbles
 * @subpackage  lang
 */
class stubDefaultMode extends stubBaseObject implements stubMode
{
    /**
     * name of mode
     *
     * @var  string
     */
    protected $modeName;
    /**
     * exception handler to be used in the mode
     *
     * @var  array<string,string>
     */
    protected $exceptionHandler = null;
    /**
     * error handler to be used in the mode
     *
     * @var  array<string,string>
     */
    protected $errorHandler     = null;
    /**
     * switch whether cache should be enabled in mode or not
     *
     * @var  bool
     */
    protected $cacheEnabled     = true;

    /**
     * constructor
     *
     * Use this to create your own mode. However you might want to use one of
     * the four default modes delivered by this class, see below for the static
     * constructor methods prod(), test(), stage() and dev().
     *
     * @param  string                $modeName
     * @param  array<string,string>  $exceptionHandler
     * @param  array<string,string>  $errorHandler
     * @param  bool                  $cacheEnabled
     */
    public function __construct($modeName, array $exceptionHandler, array $errorHandler, $cacheEnabled)
    {
        $this->modeName         = $modeName;
        $this->exceptionHandler = ((count($exceptionHandler) > 0) ? ($exceptionHandler) : (null));
        $this->errorHandler     = ((count($errorHandler) > 0) ? ($errorHandler) : (null));
        $this->cacheEnabled     = $cacheEnabled;
    }

    /**
     * creates default production mode
     *
     * - exceptions will be logged, error 500 will be shown instead of exception
     * - default error handling for PHP errors
     * - caching enabled
     *
     * @return  stubMode
     */
    public static function prod()
    {
        return new self('PROD',
                        array('class'  => 'net::stubbles::lang::errorhandler::stubProdModeExceptionHandler',
                              'method' => 'handleException',
                              'type'   => stubMode::HANDLER_INSTANCE
                        ),
                        array('class'  => 'net::stubbles::lang::errorhandler::stubDefaultErrorHandler',
                              'method' => 'handle',
                              'type'   => stubMode::HANDLER_INSTANCE
                        ),
                        true
               );
    }

    /**
     * creates default test mode
     *
     * - exceptions will be displayed
     * - default error handling for PHP errors
     * - caching enabled
     *
     * @return  stubMode
     */
    public static function test()
    {
        return new self('TEST',
                        array('class'  => 'net::stubbles::lang::errorhandler::stubDisplayExceptionHandler',
                              'method' => 'handleException',
                              'type'   => stubMode::HANDLER_INSTANCE
                        ),
                        array('class'  => 'net::stubbles::lang::errorhandler::stubDefaultErrorHandler',
                              'method' => 'handle',
                              'type'   => stubMode::HANDLER_INSTANCE
                        ),
                        true
               );
    }

    /**
     * creates default stage mode
     *
     * - exceptions will be displayed
     * - no error handling for PHP errors
     * - caching disabled
     *
     * @return  stubMode
     */
    public static function stage()
    {
        return new self('STAGE',
                        array('class'  => 'net::stubbles::lang::errorhandler::stubDisplayExceptionHandler',
                              'method' => 'handleException',
                              'type'   => stubMode::HANDLER_INSTANCE
                        ),
                        array(),
                        false
               );
    }

    /**
     * creates default dev mode
     *
     * - exceptions will be displayed
     * - no error handling for PHP errors
     * - caching disabled
     *
     * @return  stubMode
     */
    public static function dev()
    {
        return new self('DEV',
                        array('class'  => 'net::stubbles::lang::errorhandler::stubDisplayExceptionHandler',
                              'method' => 'handleException',
                              'type'   => stubMode::HANDLER_INSTANCE
                        ),
                        array(),
                        false
               );
    }

    /**
     * returns the name of the mode
     *
     * @return  string
     */
    public function name()
    {
        return $this->modeName;
    }

    /**
     * sets the exception handler to given class and method name
     *
     * To register the new exception handler call registerExceptionHandler().
     *
     * @param   string|object  $class        name or instance of exception handler class
     * @param   string         $methodName   name of exception handler method
     * @param   string         $type         optional  whether method has to be called statically or via an instance
     * @return  stubMode
     */
    public function setExceptionHandler($class, $methodName, $type = stubMode::HANDLER_INSTANCE)
    {
        $this->exceptionHandler = array('class'  => $class,
                                        'method' => $methodName,
                                        'type'   => $type
                                  );
        return $this;
    }

    /**
     * registers exception handler for current mode
     *
     * Return value depends on registration: if no exception handler set return
     * value will be false, if registered handler was an instance the handler
     * instance will be returned, and true in any other case.
     *
     * @return  bool|object
     */
    public function registerExceptionHandler()
    {
        if (null === $this->exceptionHandler) {
            return false;
        }
        
        $callback = $this->getCallback($this->exceptionHandler);
        set_exception_handler($callback);
        if (is_object($callback[0]) === true) {
            return $callback[0];
        }
        
        return true;
    }

    /**
     * sets the error handler to given class and method name
     *
     * To register the new error handler call registerErrorHandler().
     *
     * @param   string|object  $class        name or instance of error handler class
     * @param   string         $methodName   name of error handler method
     * @param   string         $type         optional  whether method has to be called statically or via an instance
     * @return  stubMode
     */
    public function setErrorHandler($class, $methodName, $type = stubMode::HANDLER_INSTANCE)
    {
        $this->errorHandler = array('class'  => $class,
                                    'method' => $methodName,
                                    'type'   => $type
                              );
        return $this;
    }

    /**
     * registers error handler for current mode
     *
     * Return value depends on registration: if no error handler set return value
     * will be false, if registered handler was an instance the handler instance
     * will be returned, and true in any other case.
     *
     * @return  bool|object
     */
    public function registerErrorHandler()
    {
        if (null === $this->errorHandler) {
            return false;
        }
        
        $callback = $this->getCallback($this->errorHandler);
        set_error_handler($callback);
        if (is_object($callback[0]) === true) {
            return $callback[0];
        }
        
        return true;
    }

    /**
     * checks whether cache is enabled or not
     *
     * @return  bool
     */
    public function isCacheEnabled()
    {
        return $this->cacheEnabled;
    }

    /**
     * helper method to create the callback from the handler data
     *
     * @param   array     &$handler  handler data
     * @return  callback
     * @throws  stubIllegalArgumentException
     */
    protected function getCallback(array &$handler)
    {
        if (is_string($handler['class']) === true && class_exists($handler['class'], false) === false) {
            stubClassLoader::load($handler['class']);
        }
        
        if (stubMode::HANDLER_INSTANCE === $handler['type']) {
            if (is_string($handler['class']) === true) {
                $class    = stubClassLoader::getNonQualifiedClassName($handler['class']);
                $instance = new $class();
            } else {
                $instance = $handler['class'];
            }
            
             return array($instance, $handler['method']);
        }
        
        if (is_string($handler['class']) === false) {
            throw new stubIllegalArgumentException('Callback type should be stubMode::HANDLER_STATIC, but given handler class is an instance.');
        }
        
        return array(stubClassLoader::getNonQualifiedClassName($handler['class']), $handler['method']);
    }
}
?><?php
/**
 * Base class for enums.
 *
 * @author      Frank Kleine  <mikey@stubbles.net>
 * @package     stubbles
 * @subpackage  lang
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException');
/**
 * Base class for enums.
 *
 * @package     stubbles
 * @subpackage  lang
 */
abstract class stubEnum extends stubBaseObject
{
    /**
     * name of the enum
     *
     * @var  string
     */
    protected $name;
    /**
     * value of enum
     *
     * @var  int
     */
    protected $value;

    /**
     * constructor
     *
     * @param  string  $name
     * @param  mixed   $value  optional
     */
    protected function __construct($name, $value = null)
    {
        $this->name  = $name;
        $this->value = ((null !== $value) ? ($value) : ($name));
    }

    /**
     * forbid cloning of enums
     *
     * @throws  stubRuntimeException
     */
    public final function __clone()
    {
        throw new stubRuntimeException('Cloning of enums is not allowed.');
    }

    /**
     * returns the name of the enum
     *
     * @return  string
     */
    public function name()
    {
        return $this->name;
    }

    /**
     * returns the value of the enum
     *
     * @return  mixed
     */
    public function value()
    {
        return $this->value;
    }

    /**
     * returns the enum instance of given class identified by its name
     *
     * @param   ReflectionClass  $enum
     * @param   string           $name
     * @return  stubEnum
     * @throws  stubIllegalArgumentException
     */
    public static function forName(ReflectionClass $enum, $name)
    {
        if ($enum->isSubclassOf(__CLASS__) === false) {
            throw new stubIllegalArgumentException('Given class is not an instance of ' . stubClassLoader::getFullQualifiedClassName(__CLASS__));
        }
        
        try {
            return $enum->getStaticPropertyValue($name);
        } catch (ReflectionException $re) {
            try {
                return $enum->getStaticPropertyValue(strtoupper($name));
            } catch (ReflectionException $re) {
                throw new stubIllegalArgumentException($re->getMessage());
            }
        }
    }

    /**
     * returns the enum instance of given class identified by its value
     *
     * @param   ReflectionClass  $enum
     * @param   string           $value
     * @return  stubEnum
     * @throws  stubIllegalArgumentException
     */
    public static function forValue(ReflectionClass $enum, $value)
    {
        if ($enum->isSubclassOf(__CLASS__) === false) {
            throw new stubIllegalArgumentException('Given class is not an instance of ' . stubClassLoader::getFullQualifiedClassName(__CLASS__));
        }
        
        try {
            foreach ($enum->getStaticProperties() as $instance) {
                if ($instance->value() === $value) {
                    return $instance;
                }
            }
        } catch (ReflectionException $re) {
            throw new stubIllegalArgumentException($re->getMessage());
        }
        
        throw new stubIllegalArgumentException('Enum ' . stubClassLoader::getFullQualifiedClassName($enum->getName()) . ' for value ' . $value . ' does not exist.');
    }

    /**
     * returns a list of all instances for given enum
     *
     * @param   ReflectionClass  $enum
     * @return  array<$enum->getName()>
     * @throws  stubIllegalArgumentException
     */
    public static function instances(ReflectionClass $enum)
    {
        if ($enum->isSubclassOf(__CLASS__) === false) {
            throw new stubIllegalArgumentException('Given class is not an instance of ' . stubClassLoader::getFullQualifiedClassName(__CLASS__));
        }
        
        return array_values($enum->getStaticProperties());
    }

    /**
     * returns a list of enum names for given enum
     *
     * @param   ReflectionClass  $enum
     * @return  array<string>
     * @throws  stubIllegalArgumentException
     */
    public static function namesOf(ReflectionClass $enum)
    {
        if ($enum->isSubclassOf(__CLASS__) === false) {
            throw new stubIllegalArgumentException('Given class is not an instance of ' . stubClassLoader::getFullQualifiedClassName(__CLASS__));
        }
        
        return array_keys($enum->getStaticProperties());
    }

    /**
     * returns a list of values for given enum
     *
     * @param   ReflectionClass      $enum
     * @return  array<string,mixed>
     * @throws  stubIllegalArgumentException
     */
    public static function valuesOf(ReflectionClass $enum)
    {
        if ($enum->isSubclassOf(__CLASS__) === false) {
            throw new stubIllegalArgumentException('Given class is not an instance of ' . stubClassLoader::getFullQualifiedClassName(__CLASS__));
        }
        
        $values = array();
        foreach ($enum->getStaticProperties() as $name => $instance) {
            $values[$name] = $instance->value;
        }
        
        return $values;
    }

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     * @XMLIgnore
     */
    public function equals($compare)
    {
        if ($compare instanceof stubEnum) {
            return ($compare->getClassName() === $this->getClassName() && $compare->name() === $this->name);
        }

        return false;
    }

    /**
     * returns a string representation of the class
     *
     * @return  string
     * @XMLIgnore
     */
    public function __toString()
    {
        $string  = $this->getClassName() . " {\n";
        $string .= '    ' . $this->name . "\n";
        $string .= '    ' . $this->value . "\n";
        $string .= "}\n";
        return $string;
    }
}
?><?php
/**
 * Class that holds informations used throughout a bunch of other classes.
 * 
 * @package     stubbles
 * @subpackage  lang
 * @version     $Id: stubFactory.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Class that holds informations used throughout a bunch of other classes.
 * 
 * @static
 * @package     stubbles
 * @subpackage  lang
 */
class stubFactory
{
    /**
     * uri to resource files
     *
     * @var  string
     */
    private static $resourcePath = null;
    /**
     * switch whether to use star files or not
     *
     * @var  bool
     */
    private static $useStar      = null;
    
    /**
     * static initializing
     */
    // @codeCoverageIgnoreStart
    public static function __static()
    {
        self::$resourcePath = stubBootstrap::getSourcePath() . DIRECTORY_SEPARATOR . 'resources' . DIRECTORY_SEPARATOR;
        self::$useStar      = class_exists('StarClassRegistry', false);
    }
    // @codeCoverageIgnoreEnd
    
    /**
     * return the uris for a resource
     *
     * @param   string  $fileName  the resource to retrieve the uris for
     * @return  array<string>
     */
    public static function getResourceURIs($fileName)
    {
        if (true == self::$useStar) {
            $uris = StarClassRegistry::getUrisForResource($fileName);
        } else {
            $uris = array();
        }
        
        if (file_exists(self::$resourcePath . $fileName) == true) {
            $uris[] = self::$resourcePath . $fileName;
        }
        
        return $uris;
    }
    
    /**
     * returns the uri for a resource in the real resource path
     *
     * @param   string  $fileName  the resource to retrieve the path for
     * @return  string
     */
    public static function getFileResourceURI($fileName)
    {
        return self::$resourcePath . $fileName;
    }
}
?><?php
/**
 * Handlings for different runtime modes of Stubbles.
 *
 * @package     stubbles
 * @subpackage  lang
 * @version     $Id: stubMode.php 2110 2009-03-04 13:02:45Z mikey $
 */
/**
 * Handlings for different runtime modes of Stubbles.
 *
 * The mode instance contains information about which exception handler and
 * which error handler should be used, else well as whether caching is enabled
 * or not.
 *
 * @package     stubbles
 * @subpackage  lang
 */
interface stubMode extends stubObject
{
    /**
     * handler method must be called statically
     */
    const HANDLER_STATIC   = 'static';
    /**
     * handler has to be an instance
     */
    const HANDLER_INSTANCE = 'instance';

    /**
     * returns the name of the mode
     *
     * @return  string
     */
    public function name();

    /**
     * sets the exception handler to given class and method name
     *
     * To register the new exception handler call registerExceptionHandler().
     *
     * @param   string|object  $class        name or instance of exception handler class
     * @param   string         $methodName   name of exception handler method
     * @param   string         $type         optional  whether method has to be called statically or via an instance
     * @return  stubMode
     */
    public function setExceptionHandler($class, $methodName, $type = self::HANDLER_INSTANCE);

    /**
     * registers exception handler for current mode
     *
     * Return value depends on registration: if no exception handler set return
     * value will be false, if registered handler was an instance the handler
     * instance will be returned, and true in any other case.
     *
     * @return  bool|object
     */
    public function registerExceptionHandler();

    /**
     * sets the error handler to given class and method name
     *
     * To register the new error handler call registerErrorHandler().
     *
     * @param   string|object  $class        name or instance of error handler class
     * @param   string         $methodName   name of error handler method
     * @param   string         $type         optional  whether method has to be called statically or via an instance
     * @return  stubMode
     */
    public function setErrorHandler($class, $methodName, $type = self::HANDLER_INSTANCE);

    /**
     * registers error handler for current mode
     *
     * Return value depends on registration: if no error handler set return value
     * will be false, if registered handler was an instance the handler instance
     * will be returned, and true in any other case.
     *
     * @return  bool|object
     */
    public function registerErrorHandler();

    /**
     * checks whether cache is enabled or not
     *
     * @return  bool
     */
    public function isCacheEnabled();
}
?><?php
/**
 * Base interface for all stubbles classes except static ones and classes
 * extending php built-in classes.
 * 
 * @package     stubbles
 * @subpackage  lang
 * @version     $Id: stubObject.php 2854 2011-01-10 13:25:44Z mikey $
 */
/**
 * Base interface for all stubbles classes except static ones and classes
 * extending php built-in classes.
 * 
 * @package     stubbles
 * @subpackage  lang
 */
interface stubObject
{
    /**
     * returns class informations
     *
     * @return  stubReflectionObject
     */
    public function getClass();

    /**
     * returns package informations
     *
     * @return  stubReflectionPackage
     */
    public function getPackage();

    /**
     * returns the full qualified class name
     *
     * @return  string
     */
    public function getClassName();

    /**
     * returns the name of the package where the class is inside
     *
     * @return  string
     */
    public function getPackageName();

    /**
     * returns a unique hash code for the class
     *
     * @return  string
     */
    public function hashCode();

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare);

    /**
     * returns a string representation of the class
     * 
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * [fully-qualified-class-name] ' {' [members-and-value-list] '}'
     * <code>
     * example.MyClass {
     *     foo(string): hello
     *     bar(example::AnotherClass): example::AnotherClass {
     *         baz(int): 5
     *     }
     * }
     * </code>
     *
     * @return  string
     */
    public function __toString();
}
?><?php
/**
 * Registry for the different pathes used throughout an application.
 *
 * @package     stubbles
 * @subpackage  lang
 * @version     $Id: stubPathRegistry.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubConfigurationException');
/**
 * Registry for the different pathes used throughout an application.
 *
 * @package     stubbles
 * @subpackage  lang
 */
class stubPathRegistry extends stubBaseObject
{
    /**
     * list of pathes
     *
     * @var  array<string,string>
     */
    protected static $pathes = array();

    /**
     * sets all pathes
     *
     * @param  array<string,string>  $pathes
     */
    public static function setPathes(array $pathes)
    {
        // set general project path if available
        if (isset($pathes['project']) === true) {
            self::setProjectPath($pathes['project']);
        }
        
        // set other pathes (overwrite default of project path if necessary)
        if (isset($pathes['cache']) === true) {
            self::setCachePath($pathes['cache']);
        }
        
        if (isset($pathes['config']) === true) {
            self::setConfigPath($pathes['config']);
        }
        
        if (isset($pathes['log']) === true) {
            self::setLogPath($pathes['log']);
        }
        
        if (isset($pathes['page']) === true) {
            self::setPagePath($pathes['page']);
        }
    }

    /**
     * sets the project path
     *
     * Setting the project path will set all other pathes to their default
     * location within a project.
     *
     * @param  string  $projectPath
     */
    public static function setProjectPath($projectPath)
    {
        self::setCachePath($projectPath . DIRECTORY_SEPARATOR . 'cache');
        self::setConfigPath($projectPath . DIRECTORY_SEPARATOR . 'config');
        self::setLogPath($projectPath . DIRECTORY_SEPARATOR . 'log');
        self::setPagePath($projectPath . DIRECTORY_SEPARATOR . 'pages');
    }

    /**
     * sets path where cache files should be stored
     *
     * @param  string  $cachePath
     */
    public static function setCachePath($cachePath)
    {
        self::$pathes['cache'] = $cachePath;
    }

    /**
     * resets cache path
     */
    public static function resetCachePath()
    {
        unset(self::$pathes['cache']);
    }

    /**
     * returns path where cache files should be stored
     *
     * @param   string  $default  optional  return value if path not set
     * @return  string
     */
    public static function getCachePath($default = null)
    {
        return self::retrievePath('cache', $default);
    }

    /**
     * sets path where config files are stored
     *
     * @param  string  $configPath
     */
    public static function setConfigPath($configPath)
    {
        self::$pathes['config'] = $configPath;
    }

    /**
     * resets config path
     */
    public static function resetConfigPath()
    {
        unset(self::$pathes['config']);
    }

    /**
     * returns path where config files are stored
     *
     * @param   string  $default  optional  return value if path not set
     * @return  string
     */
    public static function getConfigPath($default = null)
    {
        return self::retrievePath('config', $default);
    }

    /**
     * sets path where log files should be stored
     *
     * @param  string  $logPath
     */
    public static function setLogPath($logPath)
    {
        self::$pathes['log'] = $logPath;
    }

    /**
     * resets log path
     */
    public static function resetLogPath()
    {
        unset(self::$pathes['log']);
    }

    /**
     * returns path where log files should be stored
     *
     * @param   string  $default  optional  return value if path not set
     * @return  string
     */
    public static function getLogPath($default = null)
    {
        return self::retrievePath('log', $default);
    }

    /**
     * sets path where page data is stored
     *
     * @param  string  $pagePath
     */
    public static function setPagePath($pagePath)
    {
        self::$pathes['page'] = $pagePath;
    }

    /**
     * resets page path
     */
    public static function resetPagePath()
    {
        unset(self::$pathes['page']);
    }

    /**
     * returns path where page data is stored
     *
     * @param   string  $default  optional  return value if path not set
     * @return  string
     */
    public static function getPagePath($default = null)
    {
        return self::retrievePath('page', $default);
    }

    /**
     * helper method to retrieve the path with given key
     *
     * @param   string  $key
     * @param   string  $default  return value if path not set
     * @return  string
     * @throws  stubConfigurationException  if path not set and no default value given
     */
    protected static function retrievePath($key, $default)
    {
        if (isset(self::$pathes[$key]) === false) {
            if (null == $default) {
                throw new stubConfigurationException($key . ' path not set.');
            }
            
            return $default;
        }
        
        return self::$pathes[$key];
    }
}
?><?php
/**
 * Class to read and parse properties.
 *
 * @package     stubbles
 * @subpackage  lang
 * @version     $Id: stubProperties.php 2793 2010-11-25 22:40:19Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubFileNotFoundException',
                      'net::stubbles::lang::exceptions::stubIOException'
);
/**
 * Class to read and parse properties.
 *
 * Properties are iterable using foreach:
 * <code>
 * foreach (stubProperties::fromFile($propertyFile) as $sectionName => $section) {
 *     // $section is an array containing all section values as key-value pairs
 * }
 * </code>
 *
 * @package     stubbles
 * @subpackage  lang
 */
class stubProperties extends stubBaseObject implements Iterator
{
    /**
     * property data
     *
     * @var  array
     */
    protected $propertyData;

    /**
     * constructor
     *
     * @param  array  $propertyData  optional  the property data
     */
    public function __construct(array $propertyData = array())
    {
        $this->propertyData = $propertyData;
    }

    /**
     * construct class from a file
     *
     * Note: the stubIOException may only be thrown with PHP versions >= 5.2.7
     * because starting with this version PHP's parse_ini_file() returns false
     * if it can not parse the property file, before this version it just returns
     * an array which we can not distinguish from an empty property file.
     *
     * @param   string                     $propertiesFile  full path to file containing properties
     * @return  stubProperties
     * @throws  stubFileNotFoundException  if file can not be found or is not readable
     * @throws  stubIOException            if file contains errors and can not be parsed
     */
    public static function fromFile($propertiesFile)
    {
        if (file_exists($propertiesFile) === false || is_readable($propertiesFile) === false) {
            throw new stubFileNotFoundException($propertiesFile);
        }
        
        $propertyData = @parse_ini_file($propertiesFile, true);
        if (false === $propertyData) {
            throw new stubIOException('Property file at ' . $propertiesFile . ' contains errors and can not be parsed.');
        }
        
        return new self($propertyData);
    }

    /**
     * merges properties from another instance into itself
     *
     * The return value is a new instance with properties from this and the other
     * instance combined. If both instances have sections of the same name the
     * section from the other instance overwrite the section from this instance.
     *
     * @param   stubProperties  $otherProperties
     * @return  stubProperties
     * @since   1.3.0
     */
    public function merge(self $otherProperties)
    {
        return new self(array_merge($this->propertyData, $otherProperties->propertyData));
    }

    /**
     * returns a list of section keys
     *
     * @return  array<string>
     */
    public function getSections()
    {
        return array_keys($this->propertyData);
    }

    /**
     * checks if a certain section exists
     *
     * @param   string  $section  name of the section
     * @return  bool
     */
    public function hasSection($section)
    {
        return isset($this->propertyData[$section]);
    }

    /**
     * returns a whole section if it exists or the default if the section does not exist
     *
     * @param   string                $section  name of the section
     * @param   array                 $default  optional  value to return if section does not exist
     * @return  array<string,scalar>
     */
    public function getSection($section, array $default = array())
    {
        if (isset($this->propertyData[$section]) === true) {
            return $this->propertyData[$section];
        }
        
        return $default;
    }

    /**
     * returns a list of all keys of a specific section
     *
     * @param   string         $section  name of the section
     * @param   array<string>  $default  optional  value to return if section does not exist
     * @return  array<string>
     */
    public function getSectionKeys($section, array $default = array())
    {
        if (isset($this->propertyData[$section]) === true) {
            return array_keys($this->propertyData[$section]);
        }

        return $default;
    }

    /**
     * checks if a certain section contains a certain key
     *
     * @param   string  $section  name of the section
     * @param   string  $key      name of the key
     * @return  bool
     */
    public function hasValue($section, $key)
    {
        if (isset($this->propertyData[$section]) === true && isset($this->propertyData[$section][$key]) === true) {
            return true;
        }
        
        return false;
    }

    /**
     * returns a value from a section or a default value if the section or key does not exist
     *
     * @param   string  $section  name of the section
     * @param   string  $key      name of the key
     * @param   mixed   $default  optional  value to return if section or key does not exist
     * @return  scalar
     */
    public function getValue($section, $key, $default = null)
    {
        if (isset($this->propertyData[$section]) === true && isset($this->propertyData[$section][$key]) === true) {
            return $this->propertyData[$section][$key];
        }
        
        return $default;
    }

    /**
     * returns a string from a section or a default string if the section or key does not exist
     *
     * @param   string  $section  name of the section
     * @param   string  $key      name of the key
     * @param   string  $default  optional  string to return if section or key does not exist
     * @return  string
     */
    public function parseString($section, $key, $default = null)
    {
        if (isset($this->propertyData[$section]) === true && isset($this->propertyData[$section][$key]) === true) {
            return (string) $this->propertyData[$section][$key];
        }
        
        return $default;
    }

    /**
     * returns an integer or a default value if the section or key does not exist
     *
     * @param   string  $section  name of the section
     * @param   string  $key      name of the key
     * @param   int     $default  optional  value to return if section or key does not exist
     * @return  int
     */
    public function parseInt($section, $key, $default = 0)
    {
        if (isset($this->propertyData[$section]) === false || isset($this->propertyData[$section][$key]) === false) {
            return $default;
        }
        
        return intval($this->propertyData[$section][$key]);
    }

    /**
     * returns a float or a default value if the section or key does not exist
     *
     * @param   string  $section  name of the section
     * @param   string  $key      name of the key
     * @param   float   $default  optional  value to return if section or key does not exist
     * @return  float
     */
    public function parseFloat($section, $key, $default = 0.0)
    {
        if (isset($this->propertyData[$section]) === false || isset($this->propertyData[$section][$key]) === false) {
            return $default;
        }
        
        return floatval($this->propertyData[$section][$key]);
    }

    /**
     * returns a boolean or a default value if the section or key does not exist
     *
     * The return value is true if the property value is either "1", "yes",
     * "true" or "on". In any other case the return value will be false.
     *
     * @param   string  $section  name of the section
     * @param   string  $key      name of the key
     * @param   bool    $default  optional  value to return if section or key does not exist
     * @return  bool
     */
    public function parseBool($section, $key, $default = false)
    {
        if (isset($this->propertyData[$section]) === false || isset($this->propertyData[$section][$key]) === false) {
            return $default;
        }
        
        $val = $this->propertyData[$section][$key];
        return ('1' == $val || 'yes' === $val || 'true' === $val || 'on' === $val);
    }

    /**
     * returns an array from a section or a default array if the section or key does not exist
     *
     * If the value is empty the return value will be an empty array. If the
     * value is not empty it will be splitted at "|".
     * Example:
     * <code>
     * key = "foo|bar|baz"
     * </code>
     * The resulting array would be array('foo', 'bar', 'baz')
     *
     * @param   string  $section  name of the section
     * @param   string  $key      name of the key
     * @param   array   $default  optional  array to return if section or key does not exist
     * @return  array
     */
    public function parseArray($section, $key, array $default = null)
    {
        if (isset($this->propertyData[$section]) === false || isset($this->propertyData[$section][$key]) === false) {
            return $default;
        }
        
        if (empty($this->propertyData[$section][$key]) === true) {
            return array();
        }
        
        return explode('|', $this->propertyData[$section][$key]);
    }

    /**
     * returns a hash from a section or a default hash if the section or key does not exist
     *
     * If the value is empty the return value will be an empty hash. If the
     * value is not empty it will be splitted at "|". The resulting array will
     * be splitted at the first ":", the first part becoming the key and the rest
     * becoming the value in the hash. If no ":" is present, the whole value will
     * be appended to the hash using a numeric value.
     * Example:
     * <code>
     * key = "foo:bar|baz"
     * </code>
     * The resulting hash would be array('foo' => 'bar', 'baz')
     *
     * @param   string  $section  name of the section
     * @param   string  $key      name of the key
     * @param   array   $default  optional  array to return if section or key does not exist
     * @return  array
     */
    public function parseHash($section, $key, array $default = null)
    {
        if (isset($this->propertyData[$section]) === false || isset($this->propertyData[$section][$key]) === false) {
            return $default;
        }
        
        if (empty($this->propertyData[$section][$key]) === true) {
            return array();
        }
        
        $hash = array();
        foreach (explode('|', $this->propertyData[$section][$key]) as $keyValue) {
            if (strstr($keyValue, ':') !== false) {
                list($key, $value) = explode(':', $keyValue, 2);
                $hash[$key]        = $value;
            } else {
                $hash[] = $keyValue;
            }
        }
        
        return $hash;
    }

    /**
     * returns an array containing values from min to max of the range or a default if the section or key does not exist
     *
     * Ranges in properties should be written as
     * <code>
     * key = 1..5
     * </code>
     * This will return an array: array(1, 2, 3, 4, 5)
     * Works also with letters and reverse order:
     * <code>
     * letters = a..e
     * letter_reverse = e..a
     * numbers_reverese = 1..5
     * </code>
     *
     * @param   string  $section  name of the section
     * @param   string  $key      name of the key
     * @param   array   $default  optional  range to return if section or key does not exist
     * @return  array
     */
    public function parseRange($section, $key, array $default = array())
    {
        if (isset($this->propertyData[$section]) === false || isset($this->propertyData[$section][$key]) === false) {
            return $default;
        }
        
        if (strstr($this->propertyData[$section][$key], '..') === false) {
            return array();
        }
        
        list($min, $max) = explode('..', $this->propertyData[$section][$key]);
        if (null == $min || null == $max) {
            return array();
        }
        
        return range($min, $max);
    }

    /**
     * returns current section
     *
     * @return  array
     * @see     http://php.net/manual/en/spl.iterators.php
     */
    public function current()
    {
        return current($this->propertyData);
    }

    /**
     * returns name of current section
     *
     * @return  string
     * @see     http://php.net/manual/en/spl.iterators.php
     */
    public function key()
    {
        return key($this->propertyData);
    }

    /**
     * forwards to next section
     *
     * @see  http://php.net/manual/en/spl.iterators.php
     */
    public function next()
    {
        next($this->propertyData);
    }

    /**
     * rewind to first section
     *
     * @see  http://php.net/manual/en/spl.iterators.php
     */
    public function rewind()
    {
        reset($this->propertyData);
    }

    /**
     * checks if there are more valid sections
     *
     * @return  bool
     * @see     http://php.net/manual/en/spl.iterators.php
     */
    public function valid()
    {
        return current($this->propertyData);
    }
}
?><?php
/**
 * Class for date/time handling.
 *
 * @package     stubbles
 * @subpackage  lang_types
 * @version     $Id: stubDate.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::lang::types::stubTimeZone'
);
/**
 * Class for date/time handling.
 *
 * Shameless rip from the XP framework. ;-) Wraps PHP's internal date/time
 * functions for ease of use.
 *
 * @package     stubbles
 * @subpackage  lang_types
 * @XMLTag(tagName='date')
 */
class stubDate extends stubSerializableObject
{
    /**
     * internal date/time handle
     *
     * @var  DateTime
     */
    protected $dateTime;

    /**
     * constructor
     *
     * Creates a new date object through either a
     * <ul>
     *   <li>integer - interpreted as timestamp</li>
     *   <li>string - parsed into a date</li>
     *   <li>DateTime object - will be used as is</li>
     *   <li>NULL - creates a date representing the current time</li>
     *  </ul>
     *
     * Timezone assignment works through these rules:
     * <ul>
     *   <li>If the time is given as string and contains a parseable timezone
     *       identifier that one is used.</li>
     *   <li>If no timezone could be determined, the timezone given by the
     *       second parameter is used.</li>
     *   <li>If no timezone has been given as second parameter, the system's
     *       default timezone is used.</li>
     *
     * @param   int|string|DateTime   $dateTime  optional
     * @param   stubTimeZone          $timeZone  optional
     * @throws  stubIllegalArgumentException
     */
    public function __construct($dateTime = null, stubTimeZone $timeZone = null)
    {
        if (is_numeric($dateTime) === true) {
            $this->dateTime = date_create('@' . $dateTime, timezone_open('UTC'));
            if (false !== $this->dateTime) {
                date_timezone_set($this->dateTime, (null === $timeZone) ? (new DateTimeZone(date_default_timezone_get())) : ($timeZone->getHandle()));
            }
        } elseif (is_string($dateTime) === true) {
            try {
                if (null === $timeZone) {
                    $this->dateTime = new DateTime($dateTime);
                } else {
                    $this->dateTime = new DateTime($dateTime, $timeZone->getHandle());
                }
            } catch (Exception $e) {
                throw new stubIllegalArgumentException('Given datetime string ' . $dateTime . ' is not a valid date string.');
            }
        } else {
            $this->dateTime = $dateTime;
        }

        if (($this->dateTime instanceof DateTime) === false) {
            throw new stubIllegalArgumentException('Datetime must be either unix timestamp, well-formed timestamp or instance of DateTime, but was ' . $dateTime);
        }
    }

    /**
     * returns current date/time
     *
     * @return  stubDate
     */
    public static function now()
    {
        return new self(time());
    }

    /**
     * returns internal date/time handle
     *
     * @return  DateTime
     * @XMLIgnore
     */
    public function getHandle()
    {
        return clone $this->dateTime;
    }

    /**
     * returns a new date instance which represents the changed date
     *
     * @param   string    $target  relative format accepted by strtotime()
     * @return  stubDate
     */
    public function changeTo($target)
    {
        $modifiedHandle = clone $this->dateTime;
        $modifiedHandle->modify($target);
        return new self($modifiedHandle);
    }

    /**
     * returns timestamp for this date/time
     *
     * @return  int
     * @XMLIgnore
     */
    public function getTimestamp()
    {
        return (int) $this->dateTime->format('U');
    }

    /**
     * returns seconds of current date/time
     *
     * @return  int
     * @XMLIgnore
     */
    public function getSeconds()
    {
        return (int) $this->dateTime->format('s');
    }

    /**
     * returns minutes of current date/time
     *
     * @return  int
     * @XMLIgnore
     */
    public function getMinutes()
    {
        return (int) $this->dateTime->format('i');
    }

    /**
     * returns hours of current date/time
     *
     * @return  int
     * @XMLIgnore
     */
    public function getHours()
    {
        return (int) $this->dateTime->format('G');
    }

    /**
     * returns day of current date/time
     *
     * @return  int
     * @XMLIgnore
     */
    public function getDay()
    {
        return (int) $this->dateTime->format('d');
    }

    /**
     * returns month of current date/time
     *
     * @return  int
     * @XMLIgnore
     */
    public function getMonth()
    {
        return (int) $this->dateTime->format('m');
    }

    /**
     * returns year of current date/time
     *
     * @return  int
     * @XMLIgnore
     */
    public function getYear()
    {
        return (int) $this->dateTime->format('Y');
    }

    /**
     * returns offset to UTC in "+MMSS" notation
     *
     * @return  string
     * @XMLIgnore
     */
    public function getOffset()
    {
        return $this->dateTime->format('O');
    }

    /**
     * returns offset to UTC in seconds
     *
     * @return  int
     * @XMLIgnore
     */
    public function getOffsetInSeconds()
    {
        return (int) $this->dateTime->format('Z');
    }

    /**
     * checks whether this date is before a given date
     *
     * @param   stubDate  $date
     * @return  bool
     */
    public function isBefore(self $date)
    {
        return $this->getTimestamp() < $date->getTimestamp();
    }

    /**
     * checks whether this date is after a given date
     *
     * @param   stubDate  $date
     * @return  bool
     */
    public function isAfter(self $date)
    {
        return $this->getTimestamp() > $date->getTimestamp();
    }

    /**
     * returns time zone of this date
     *
     * @return  stubTimeZone
     * @XMLIgnore
     */
    public function getTimeZone()
    {
        return new stubTimeZone($this->dateTime->getTimezone());
    }

    /**
     * returns date as string
     *
     * @return  string
     * @XMLAttribute(attributeName='value')
     */
    public function asString()
    {
        return $this->format('Y-m-d H:i:sO');
    }

    /**
     * returns formatted date/time string
     *
     * @param   string        $format    format, see http://php.net/date
     * @param   stubTimeZone  $timeZone  optional  target time zone of formatted string
     * @return  string
     */
    public function format($format, stubTimeZone $timeZone = null)
    {
        if (null !== $timeZone) {
            return $timeZone->translate($this)->format($format);
        }

        return $this->dateTime->format($format);
    }

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if ($compare instanceof self) {
            return ($this->getTimestamp() === $compare->getTimestamp());
        }

        return false;
    }

    /**
     * returns a string representation of the class
     *
     * @return  string
     */
    public function __toString()
    {
        return self::getStringRepresentationOf($this, array('dateTime' => $this->format('Y-m-d H:i:sO')));
    }

    /**
     * make sure handle is cloned as well
     */
    public function __clone()
    {
        $this->dateTime = clone $this->dateTime;
    }

    /**
     * takes care of serializing the value
     *
     * @param  array   &$propertiesToSerialize  list of properties to serialize
     * @param  string  $name                    name of the property to serialize
     * @param  mixed   $value                   value to serialize
     */
    protected function __doSerialize(&$propertiesToSerialize, $name, $value)
    {
        if ('dateTime' == $name) {
            $this->_serializedProperties[$name] = $value->format('c');
            return;
        }

        parent::__doSerialize($propertiesToSerialize, $name, $value);
    }

    /**
     * takes care of unserializing the value
     *
     * @param  string  $name             name of the property
     * @param  mixed   $serializedValue  value of the property
     */
    protected function __doUnserialize($name, $serializedValue)
    {
        if ('dateTime' == $name) {
            $this->dateTime = new DateTime($serializedValue);
            return;
        }

        parent::__doUnserialize($name, $serializedValue);
    }
}
?><?php
/**
 * Class for time zone handling.
 *
 * @package     stubbles
 * @subpackage  lang_types
 * @version     $Id: stubTimeZone.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::lang::types::stubDate'
);
/**
 * Class for time zone handling.
 *
 * Shameless rip from the XP framework. ;-) Wraps PHP's internal time zone
 * functions for ease of use.
 *
 * @package     stubbles
 * @subpackage  lang_types
 */
class stubTimeZone extends stubBaseObject
{
    /**
     * internal time zone handle
     *
     * @var  DateTimeZone
     */
    protected $timeZone;

    /**
     * constructor
     *
     * Time zone can be a string like 'Europe/Berlin', a DateTimeZone instance
     * or null.
     *
     * @param   string|DateTimeZone   $timeZone  optional
     * @throws  stubIllegalArgumentException
     */
    public function __construct($timeZone = null)
    {
        if (is_string($timeZone) === true) {
            $this->timeZone = @timezone_open($timeZone);
        } elseif (null === $timeZone) {
            $this->timeZone = timezone_open(date_default_timezone_get());
        } else {
            $this->timeZone = $timeZone;
        }
        
        if (($this->timeZone instanceof DateTimeZone) === false) {
            throw new stubIllegalArgumentException('Invalid time zone identifier ' . $timeZone);
        }
    }

    /**
     * returns internal time zone handle
     *
     * @return  DateTimeZone
     */
    public function getHandle()
    {
        return clone $this->timeZone;
    }

    /**
     * returns name of time zone
     *
     * @return  string
     */
    public function getName()
    {
        return $this->timeZone->getName();
    }

    /**
     * returns offset of the time zone
     *
     * @param   stubDate  $date  optional  defaults to current date
     * @return  string
     */
    public function getOffset(stubDate $date = null)
    {
        $offset  = $this->getOffsetInSeconds($date);
        $hours   = intval(abs($offset) / 3600);
        $minutes = (abs($offset)- ($hours * 3600)) / 60;
        return sprintf('%s%02d%02d', ($offset < 0 ? '-' : '+'), $hours, $minutes);
    }

    /**
     * returns offset to given date in seconds
     *
     * Because a timezone may have different offsets when its in DST or non-DST
     * mode, a date object must be given which is used to determine whether DST
     * or non-DST offset should be returned.
     *
     * @param   stubDate  $date  optional  defaults to current date
     * @return  int
     */
    public function getOffsetInSeconds(stubDate $date = null)
    {
        if (null === $date) {
            return $this->timeZone->getOffset(new DateTime('now'));
        }
        
        return $this->timeZone->getOffset($date->getHandle());
    }

    /**
     * checks whether time zone as dst mode or not
     *
     * @return  bool
     */
    public function hasDst()
    {
        // if there is at least one transition the time zone has a dst mode
        return (count($this->timeZone->getTransitions()) > 0);
    }

    /**
     * translates a date from one timezone to a date of this timezone
     *
     * A new date instance will be returned while the given date is not changed.
     *
     * @param   stubDate  $date
     * @return  stubDate
     */
    public function translate(stubDate $date)
    {
        $handle = clone $date->getHandle();
        $handle->setTimezone($this->timeZone);
        return new stubDate($handle);
    }

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if ($compare instanceof self) {
            return ($this->getName() === $compare->getName());
        }

        return false;
    }

    /**
     * returns a string representation of the class
     *
     * @return  string
     */
    public function __toString()
    {
        return self::getStringRepresentationOf($this, array('timeZone' => $this->timeZone->getName()));
    }
}
?><?php
/**
 * Class to work with all kinds of Accept* headers.
 *
 * @package     stubbles
 * @subpackage  peer_http
 * @version     $Id: stubAcceptHeader.php 2655 2010-08-19 09:48:05Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException');
/**
 * Class to work with all kinds of Accept* headers.
 *
 * @package     stubbles
 * @subpackage  peer_http
 */
class stubAcceptHeader extends stubBaseObject implements Countable
{
    /**
     * list of acceptables
     *
     * @var  array<string,float>
     */
    protected $acceptables = array();

    /**
     * method to create an instance from a string header value
     *
     * @param   string            $headerValue
     * @return  stubAcceptHeader
     */
    public static function parse($headerValue)
    {
        $self = new self();
        foreach (explode(',', $headerValue) as $acceptable) {
            // seems to be impossible to parse acceptables with regular
            // expressions or even scanf(), so we do some string crunching here
            if (strstr($acceptable, 'q=') !== false) {
                list($acceptable, $priority) = explode('q=', trim($acceptable));
            } else {
                $priority = 1;
            }

            settype($priority, 'float');
            $acceptable = trim($acceptable);
            if (substr($acceptable, -1) === ';') {
                $acceptable = substr($acceptable, 0, -1);
            }

            $self->addAcceptable($acceptable, $priority);
        }

        return $self;
    }

    /**
     * amount of acceptables
     *
     * @return  int
     */
    public function count()
    {
        return count($this->acceptables);
    }

    /**
     * add an acceptable to the list
     *
     * @param   string            $acceptable
     * @param   float             $priority    optional  defaults to 1.0
     * @return  stubAcceptHeader
     * @throws  stubIllegalArgumentException
     */
    public function addAcceptable($acceptable, $priority = 1.0)
    {
        if (0 > $priority || 1.0 < $priority) {
            throw new stubIllegalArgumentException('Invalid priority, must be between 0 and 1.0');
        }

        $this->acceptables[$acceptable] = $priority;
        return $this;
    }

    /**
     * returns current list of acceptables
     *
     * @return  array<string,float>
     */
    public function getList()
    {
        return $this->acceptables;
    }

    /**
     * returns priority for given acceptable
     *
     * If returned priority is 0 the requested acceptable is not in the list. In
     * case no acceptables were added before every requested acceptable has a
     * priority of 1.0.
     *
     * @param   string  $acceptable
     * @return  float
     */
    public function priorityFor($acceptable)
    {
        if (isset($this->acceptables[$acceptable]) === false) {
            if ($this->count() === 0) {
                return 1.0;
            } elseif (isset($this->acceptables['*/*']) === true) {
                return $this->acceptables['*/*'];
            }

            list($maintype, $subtype) = explode('/', $acceptable);
            if (isset($this->acceptables[$maintype . '/*']) === true) {
                return $this->acceptables[$maintype . '/*'];
            }
            
            return 0;
        }

        return $this->acceptables[$acceptable];
    }

    /**
     * find match with highest priority
     *
     * Checks given list of acceptables if they are in the list, and returns the
     * one with the greatest priority. If return value is null none of the given
     * acceptables matches any in the list.
     *
     * @param   array<string>  $acceptables
     * @return  string
     */
    public function findMatchWithGreatestPriority(array $acceptables)
    {
        $sharedAcceptables = array_intersect_key($this->acceptables,
                                                 array_flip($this->getSharedAcceptables($acceptables))
        );
        if (count($sharedAcceptables) > 0) {
            return $this->findAcceptableWithGreatestPriorityFromList($sharedAcceptables);
        }

        foreach ($acceptables as $acceptable) {
            list($maintype, $subtype) = explode('/', $acceptable);
            if (isset($this->acceptables[$maintype . '/*']) === true) {
                return $acceptable;
            }
        }

        if (isset($this->acceptables['*/*']) === true) {
            return array_shift($acceptables);
        }
        
        return null;
    }

    /**
     * helper method to find the acceptable with the greatest priority from a given list of acceptables
     *
     * @param   array<string,float>  $acceptables
     * @return  string
     */
    protected function findAcceptableWithGreatestPriorityFromList(array $acceptables)
    {
        if (count($acceptables) === 0) {
            return null;
        }
        
        arsort($acceptables);
        // use temp var to prevent E_STRICT Only variables should be passed by reference
        $acceptableKeys = array_keys($acceptables);
        return array_shift($acceptableKeys);
    }

    /**
     * returns the acceptable with the greatest priority
     *
     * If two acceptables have the same priority the last one added wins.
     *
     * @return  string
     */
    public function findAcceptableWithGreatestPriority()
    {
        return $this->findAcceptableWithGreatestPriorityFromList($this->acceptables);
    }

    /**
     * checks whether there are shares acceptables in header and given list
     *
     * @param   array<string>  $acceptables
     * @return  bool
     */
    public function hasSharedAcceptables(array $acceptables)
    {
        return (count($this->getSharedAcceptables($acceptables)) > 0);
    }

    /**
     * returns a list of acceptables that are both in header and given list
     *
     * @param   array<string>  $acceptables
     * @return  array<string>
     */
    public function getSharedAcceptables(array $acceptables)
    {
        return array_intersect(array_keys($this->acceptables), $acceptables);
    }

    /**
     * returns current list as string
     *
     * @return  string
     */
    public function asString()
    {
        $parts = array();
        foreach ($this->acceptables as $acceptable => $priority) {
            if (1.0 === $priority) {
                $parts[] = $acceptable;
            } else {
                $parts[] = $acceptable . ';q=' . $priority;
            }
        }

        return join(',', $parts);
    }
}
?><?php
/**
 * Class for connections to URLs of HTTP/HTTPS.
 *
 * @package     stubbles
 * @subpackage  peer_http
 * @version     $Id: stubHTTPConnection.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::peer::stubHeaderList',
                      'net::stubbles::peer::http::stubHTTPRequest',
                      'net::stubbles::peer::http::stubHTTPResponse'
);
/**
 * Class for connections to URLs of HTTP/HTTPS.
 *
 * @package     stubbles
 * @subpackage  peer_http
 */
class stubHTTPConnection extends stubBaseObject
{
    /**
     * request object to open connection
     *
     * @var  stubHTTPURLContainer
     */
    protected $url      = null;
    /**
     * contains request headers
     *
     * @var  stubHeaderList
     */
    protected $headers  = null;
    /**
     * timeout
     *
     * @var  int
     */
    protected $timeout  = 30;
    /**
     * end-of-line marker
     */
    const END_OF_LINE   = "\r\n";

    /**
     * constructor
     *
     * @param  stubHTTPURLContainer  $http     url to create connection to
     * @param  stubHeaderList        $headers  optional  list of headers to be used
     */
    public function __construct(stubHTTPURLContainer $http, stubHeaderList $headers = null)
    {
        $this->url = $http;
        if (null === $headers) {
            $this->headers = new stubHeaderList();
        } else {
            $this->headers = $headers;
        }
    }

    /**
     * returns list of headers
     *
     * @return  stubHeaderList
     */
    public function getHeaderList()
    {
        return $this->headers;
    }

    /**
     * set timeout for connection
     *
     * @param   int                 $timeout  timeout for connection in seconds
     * @return  stubHTTPConnection
     */
    public function timeout($timeout)
    {
        $this->timeout = $timeout;
        return $this;
    }

    /**
     * returns timeout for connection
     *
     * @return  int
     */
    public function getTimeout()
    {
        return $this->timeout;
    }

    /**
     * do the request with the given user agent header
     *
     * @param   string              $userAgent
     * @return  stubHTTPConnection
     */
    public function asUserAgent($userAgent)
    {
        $this->headers->putUserAgent($userAgent);
        return $this;
    }

    /**
     * say the connection was refered from given url
     *
     * @param   string              $referer
     * @return  stubHTTPConnection
     */
    public function referedFrom($referer)
    {
        $this->headers->putReferer($referer);
        return $this;
    }

    /**
     * add some cookie data to the request
     *
     * @param   array<string,string>  $cookieValues  list of key-value pairs
     * @return  stubHTTPConnection
     */
    public function withCookie(array $cookieValues)
    {
        $this->headers->putCookie($cookieValues);
        return $this;
    }

    /**
     * authorize with given credentials
     *
     * @param   string              $user
     * @param   string              $password
     * @return  stubHTTPConnection
     */
    public function authorizedAs($user, $password)
    {
        $this->headers->putAuthorization($user, $password);
        return $this;
    }

    /**
     * adds any arbitrary header
     *
     * @param   string             $key    name of header
     * @param   string             $value  value of header
     * @return  stubHTTPConnection
     */
    public function usingHeader($key, $value)
    {
        $this->headers->put($key, $value);
        return $this;
    }

    /**
     * returns response object for given URL after GET request
     *
     * @param   string            $version  optional  HTTP version
     * @return  stubHTTPResponse
     */
    public function get($version = null)
    {
        return $this->createRequest()->get($version);
    }

    /**
     * returns response object for given URL after HEAD request
     *
     * @param   string            $version  optional  HTTP version
     * @return  stubHTTPResponse
     */
    public function head($version = null)
    {
        return $this->createRequest()->head($version);
    }

    /**
     * returns response object for given URL after POST request
     *
     * @param   array<string,string>  $postValues  post data to send with POST request
     * @param   string                $version     optional  HTTP version
     * @return  stubHTTPResponse
     */
    public function post(array $postValues, $version = null)
    {
        return $this->createRequest()->preparePost($postValues)->post($version);
    }

    /**
     * helper method to create the request
     *
     * @return  stubHTTPRequest
     */
    // @codeCoverageIgnoreStart
    protected function createRequest()
    {
        return new stubHTTPRequest($this->url, $this->headers, $this->timeout);
    }
    // @codeCoverageIgnoreEnd
}
?><?php
/**
 * Class for sending a HTTP request.
 *
 * @package     stubbles
 * @subpackage  peer_http
 * @version     $Id: stubHTTPRequest.php 2256 2009-06-23 22:07:09Z mikey $
 */
stubClassLoader::load('net::stubbles::peer::stubHeaderList',
                      'net::stubbles::peer::stubConnectionException',
                      'net::stubbles::peer::stubSocket',
                      'net::stubbles::peer::http::stubHTTPConnection',
                      'net::stubbles::peer::http::stubHTTPResponse',
                      'net::stubbles::peer::http::stubHTTPURLContainer'
);
/**
 * Class for sending a HTTP request.
 *
 * @package     stubbles
 * @subpackage  peer_http
 */
class stubHTTPRequest extends stubBaseObject
{
    /**
     * the http address to setup a connection to
     *
     * @var  stubHTTPURLContainer
     */
    protected $httpURL = null;
    /**
     * contains request headers
     *
     * @var  stubHeaderList
     */
    protected $headers = null;
    /**
     * contains body for request
     *
     * @var  string
     */
    protected $body    = '';
    /**
     * timeout
     *
     * @var  int
     */
    protected $timeout = 30;
    /**
     * request method type: GET
     */
    const METHOD_GET   = 'GET';
    /**
     * request method type: POST
     */
    const METHOD_POST  = 'POST';
    /**
     * request method type: HEAD
     */
    const METHOD_HEAD  = 'HEAD';
    /**
     * HTTP version: 1.0
     */
    const VERSION_1_0  = 'HTTP/1.0';
    /**
     * HTTP version: 1.1
     */
    const VERSION_1_1  = 'HTTP/1.1';

    /**
     * constructor
     *
     * @param  stubHTTPURLContainer  $httpURL  HTTP URL to perform a request to
     * @param  stubHeaderList        $header   list of request headers
     * @param  int                   $timeout  timeout for connection in seconds
     */
    public function __construct(stubHTTPURLContainer $httpURL, stubHeaderList $header, $timeout)
    {
        $this->httpURL = $httpURL;
        $this->headers = $header;
        $this->timeout = $timeout;
    }

    /**
     * initializes a get request
     *
     * @param   string            $version  optional  HTTP version
     * @return  stubHTTPResponse
     */
    public function get($version = null)
    {
        $socket = $this->createSocket();
        $this->processHeader($socket, self::METHOD_GET, $version);
        $socket->write(stubHTTPConnection::END_OF_LINE);
        return new stubHTTPResponse($socket);
    }

    /**
     * initializes a head request
     *
     * @param   string            $version  optional  HTTP version
     * @return  stubHTTPResponse
     */
    public function head($version = null)
    {
        $socket = $this->createSocket();
        $this->processHeader($socket, self::METHOD_HEAD, $version);
        $socket->write('Connection: close' . stubHTTPConnection::END_OF_LINE . stubHTTPConnection::END_OF_LINE);
        return new stubHTTPResponse($socket);
    }

    /**
     * creates required headers for post request and encodes post values
     *
     * @param   array<string,string>  $postValues  post values to submit
     * @return  stubHTTPRequest
     */
    public function preparePost(array $postValues)
    {
        foreach ($postValues as $key => $value) {
            $this->body .= urlencode($key) . '=' . urlencode($value) . '&';
        }
        
        $this->headers->put('Content-Type', 'application/x-www-form-urlencoded');
        $this->headers->put('Content-Length', strlen($this->body));
        return $this;
    }

    /**
     * initializes a post request
     *
     * @param   string            $version  optional  HTTP version
     * @return  stubHTTPResponse
     */
    public function post($version = null)
    {
        $socket = $this->createSocket();
        $this->processHeader($socket, self::METHOD_POST, $version);
        $socket->write(stubHTTPConnection::END_OF_LINE);
        $socket->write($this->body);
        return new stubHTTPResponse($socket);
    }

    /**
     * creates the socket
     *
     * @return  stubSocket
     */
    protected function createSocket()
    {
        return new stubSocket($this->httpURL->getHost(),
                              $this->httpURL->getPort(),
                              (($this->httpURL->getScheme() === 'https') ? ('ssl://') : (null))
               );
    }

    /**
     * helper method to send the headers
     *
     * @param  stubSocket  $socket   the socket to write headers to
     * @param  string      $method   HTTP method
     * @param  string      $version  HTTP version
     */
    protected function processHeader(stubSocket $socket, $method, $version)
    {
        if (self::METHOD_POST != $method && self::METHOD_GET != $method && self::METHOD_HEAD != $method) {
            $method = self::METHOD_GET;
        }
        
        if (self::VERSION_1_0 != $version && self::VERSION_1_1 != $version) {
            $version = self::VERSION_1_1;
        }
        
        $socket->setTimeout($this->timeout);
        $socket->connect();
        $socket->write($method . ' ' . $this->httpURL->getPath() . ' ' . $version . stubHTTPConnection::END_OF_LINE);
        $socket->write('Host: ' . $this->httpURL->getHost() . stubHTTPConnection::END_OF_LINE);
        
        // prepare last headers and write all headers to socket
        if ($this->headers->containsKey('User-Agent') === false) {
            $this->headers->putUserAgent('stubbles HTTP Client');
        }
        
        $this->headers->enablePower();
        $this->headers->putDate();
        foreach ($this->headers as $key => $value) {
            $socket->write($key . ': ' . $value . stubHTTPConnection::END_OF_LINE);
        }
    }
}
?><?php
/**
 * Class for reading a HTTP response.
 *
 * @package     stubbles
 * @subpackage  peer_http
 * @version     $Id: stubHTTPResponse.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalAccessException',
                      'net::stubbles::peer::stubHeaderList',
                      'net::stubbles::peer::stubConnectionException',
                      'net::stubbles::peer::stubSocket'
);
/**
 * Class for reading a HTTP response.
 *
 * @package     stubbles
 * @subpackage  peer_http
 */
class stubHTTPResponse extends stubBaseObject
{
    /**
     * the socket we read the response from
     *
     * @var  stubSocket
     */
    protected $socket               = null;
    /**
     * list of response parts
     *
     * @var  array<string,scalar>
     */
    protected $response             = array();
    /**
     * contains headers of response
     *
     * @var  stubHeaderList
     */
    protected $headers              = null;
    /**
     * contains body of response
     *
     * @var  string
     */
    protected $body                 = '';
    /**
     * response type data: status line
     */
    const TYPE_STATUS_LINE          = 'Status-Line';
    /**
     * response type data: HTTP version
     */
    const TYPE_HTTP_VERSION         = 'HTTP-Version';
    /**
     * response type data: status code
     */
    const TYPE_STATUS_CODE          = 'Status-Code';
    /**
     * response type data: status class
     */
    const TYPE_STATUS_CLASS         = 'Status-Class';
    /**
     * response type data: reason phrase
     */
    const TYPE_REASON_PHRASE        = 'Reason-Phrase';
    /**
     * response status class: informational (100-199)
     */
    const STATUS_CLASS_INFO         = 'Informational';
    /**
     * response status class: successful request (200-299)
     */
    const STATUS_CLASS_SUCCESS      = 'Success';
    /**
     * response status class: redirection (300-399)
     */
    const STATUS_CLASS_REDIRECT     = 'Redirection';
    /**
     * response status class: errors by client (400-499)
     */
    const STATUS_CLASS_ERROR_CLIENT = 'Client Error';
    /**
     * response status class: errors on server (500-599)
     */
    const STATUS_CLASS_ERROR_SERVER = 'Server Error';
    /**
     * response status class: unknown status code
     */
    const STATUS_CLASS_UNKNOWN      = 'Unknown';

    /**
     * constructor
     *
     * @param  stubSocket  $socket  socket where the response can be read from
     */
    public function __construct(stubSocket $socket)
    {
        $this->socket = $socket;
    }

    /**
     * destructor
     */
    public function __destruct()
    {
        $this->socket->disconnect();
    }

    /**
     * returns the used socket
     *
     * @return  stubSocket
     */
    public function getSocket()
    {
        return $this->socket;
    }

    /**
     * read the response from socket and parse it
     *
     * @return  stubHTTPResponse
     */
    public function read()
    {
        return $this->readHeader()->readBody();
    }

    /**
     * reads response headers
     *
     * @return  stubHTTPResponse
     */
    public function readHeader()
    {
        $this->parseHead($this->socket->readLine());
        $header = '';
        $line   = '';
        while ($this->socket->eof() === false && stubHTTPConnection::END_OF_LINE !== $line) {
            $line    = $this->socket->read();
            $header .= $line;
        }

        $this->headers = stubHeaderList::fromString($header);
        return $this;
    }

    /**
     * reads the response body
     *
     * @return  stubHTTPResponse
     * @throws  stubIllegalAccessException
     */
    public function readBody()
    {
        if (null === $this->headers) {
            throw new stubIllegalAccessException('Need to read response headers first.');
        }

        if ($this->headers->get('Transfer-Encoding') === 'chunked') {
            $this->body = $this->readChunked();
        } else {
            $this->body = $this->readDefault($this->headers->get('Content-Length', 4096));
        }

        return $this;
    }

    /**
     * helper method to read chunked response body
     *
     * @return  string
     */
    protected function readChunked()
    {
        // it gets a little bit more complicated because we can not read the data in a whole
        // the following lines implement the pseudo code given in RFC 2616 section 19.4.6: Introduction of Transfer-Encoding
        $readLength = 0;
        $chunksize  = null;
        $extension  = null;
        $body       = '';
        // read chunk-size, chunk-extension (if any) and CRLF
        sscanf($this->socket->read(1024), "%x%s\r\n", $chunksize, $extension);
        while (0 < $chunksize) {
            // read chunk-data and CRLF
            $data        = $this->socket->readBinary($chunksize + 2);
            // append chunk-data to entity-body
            $body       .= rtrim($data);
            $readLength += $chunksize;
            // read chunk-size and CRLF
            sscanf($this->socket->read(1024), "%x\r\n", $chunksize);
        }

        #read entity-header
        #while (entity-header not empty) {
        #    append entity-header to existing header fields
        #    read entity-header
        #}

        // set correct content length
        $this->headers->put('Content-Length', $readLength);
        // remove "chunked" from Transfer-Encoding
        $this->headers->remove('Transfer-Encoding');
        return $body;
    }

    /**
     * helper method for default reading of response body
     *
     * @param   int     $readLength  expected length of response body
     * @return  string
     */
    protected function readDefault($readLength)
    {
        $body = $buffer = '';
        $read = 0;

        while ($read < $readLength) {
            $buffer  = $this->socket->read($readLength);
            $read   += strlen($buffer);
            $body   .= $buffer;
        }

        return $body;
    }

    /**
     * returns response data of requested type
     *
     * @param   string  $type  type of response data
     * @return  string
     */
    public function getType($type)
    {
        if (isset($this->response[$type]) === true) {
            return $this->response[$type];
        }

        return null;
    }

    /**
     * returns list of available response types
     *
     * @return  array<string>
     */
    public function getTypes()
    {
        static $types = array();
        if (count($types) === 0) {
            $refClass  = new ReflectionClass(__CLASS__);
            $constants = $refClass->getConstants();
            foreach (array_keys($constants) as $name) {
                if (strstr($name, 'TYPE_') !== false) {
                    $types[] = $name;
                }
            }
        }

        return $types;
    }

    /**
     * returns list of headers from response
     *
     * @return  stubHeaderList
     */
    public function getHeader()
    {
        return $this->headers;
    }

    /**
     * returns body of response
     *
     * @return  string
     */
    public function getBody()
    {
        return $this->body;
    }

    /**
     * returns status code of response
     *
     * @return  int
     */
    public function getStatusCode()
    {
        return (int) $this->getType(self::TYPE_STATUS_CODE);
    }

    /**
     * parses first line of response
     *
     * @param  string  $head  first line of response
     */
    protected function parseHead($head)
    {
        $matches = array();
        if (preg_match('=^(HTTP/\d+\.\d+) (\d{3}) ([^' . stubHTTPConnection::END_OF_LINE . ']*)=', $head, $matches) == false) {
            return;
        }

        $this->response[self::TYPE_STATUS_LINE]   = $matches[0];
        $this->response[self::TYPE_HTTP_VERSION]  = $matches[1];
        $this->response[self::TYPE_STATUS_CODE]   = $matches[2];
        $this->response[self::TYPE_REASON_PHRASE] = $matches[3];
        switch ($this->response[self::TYPE_STATUS_CODE][0]) {
            case 1:
                $this->response[self::TYPE_STATUS_CLASS] = self::STATUS_CLASS_INFO;
                break;

            case 2:
                $this->response[self::TYPE_STATUS_CLASS] = self::STATUS_CLASS_SUCCESS;
                break;

            case 3:
                $this->response[self::TYPE_STATUS_CLASS] = self::STATUS_CLASS_REDIRECT;
                break;

            case 4:
                $this->response[self::TYPE_STATUS_CLASS] = self::STATUS_CLASS_ERROR_CLIENT;
                break;

            case 5:
                $this->response[self::TYPE_STATUS_CLASS] = self::STATUS_CLASS_ERROR_SERVER;
                break;

            default:
                $this->response[self::TYPE_STATUS_CLASS] = self::STATUS_CLASS_UNKNOWN;
        }
    }
}
?><?php
/**
 * Class for URLs of scheme hypertext transfer protocol.
 *
 * @package     stubbles
 * @subpackage  peer_http
 * @version     $Id: stubHTTPURL.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::peer::stubURL',
                      'net::stubbles::peer::http::stubHTTPURLContainer'
);
/**
 * Class for URLs of scheme hypertext transfer protocol.
 *
 * @package     stubbles
 * @subpackage  peer_http
 */
class stubHTTPURL extends stubURL implements stubHTTPURLContainer
{
    /**
     * constructor
     *
     * @param   string  $url
     * @throws  stubMalformedURLException
     */
    protected function __construct($url)
    {
        parent::__construct($url);
        if (isset($this->url['port']) === false) {
            $this->url['port']   = ('https' == $this->getScheme()) ? 443 : 80;
        }
        
        if (isset($this->url['path']) === false || strlen($this->url['path']) === 0) {
            $this->url['path'] = '/';
        }
    }

    /**
     * parses an url out of a string
     *
     * @param   string       $urlString
     * @return  stubHTTPURL
     * @throws  stubMalformedURLException
     */
    public static function fromString($urlString)
    {
        if (strlen($urlString) === 0) {
            return null;
        }
        
        $url = new self($urlString);
        if ($url->isValid() == false) {
            throw new stubMalformedURLException('The URL ' . $urlString . ' is not a valid HTTP-URL.');
        }
        
        return $url;
    }

    /**
     * Checks whether URL is a correct URL.
     *
     * @return  bool
     */
    public function isValid()
    {
        if (parent::isValid() === false) {
            return false;
        }
        
        if ('http' !== $this->url['scheme'] && 'https' !==  $this->url['scheme']) {
            return false;
        }
        
        return true;
    }

    /**
     * checks whether the url uses a default port or not
     *
     * Default ports are 80 for http and 443 for https
     *
     * @return  bool
     */
    public function hasDefaultPort()
    {
        if ('http' === $this->url['scheme'] && $this->url['port'] != 80) {
            return false;
        }
        
        if ('https' === $this->url['scheme'] && $this->url['port'] != 443) {
            return false;
        }
        
        return true;
    }

    /**
     * creates a stubHTTPConnection for this URL
     *
     * To submit a complete HTTP request use this:
     * <code>
     * $response = $url->connect()->asUserAgent('Not Mozilla')
     *                            ->timeout(5)
     *                            ->usingHeader('X-Money', 'Euro')
     *                            ->get();
     * </code>
     *
     * @param   stubHeaderList      $headers  optional  list of headers to be used
     * @return  stubHTTPConnection
     */
    public function connect(stubHeaderList $headers = null)
    {
        stubClassLoader::load('net::stubbles::peer::http::stubHTTPConnection');
        return new stubHTTPConnection($this, $headers);
    }
}
?><?php
/**
 * Interface for URLs of scheme hypertext transfer protocol.
 *
 * @package     stubbles
 * @subpackage  peer_http
 * @version     $Id: stubHTTPURLContainer.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::peer::stubHeaderList',
                      'net::stubbles::peer::stubURLContainer'
);
/**
 * Interface for URLs of scheme hypertext transfer protocol.
 *
 * @package     stubbles
 * @subpackage  peer_http
 */
interface stubHTTPURLContainer extends stubURLContainer
{
    /**
     * creates a stubHTTPConnection for this URL
     *
     * @param   stubHeaderList      $headers  optional  list of headers to be used
     * @return  stubHTTPConnection
     */
    public function connect(stubHeaderList $headers = null);
}
?><?php
/**
 * Represents a LDAP connection.
 *
 * Currently modifying of content in a LDAP directory is not supported.
 *
 * @package     stubbles
 * @subpackage  peer_ldap
 * @see         RFC 4510  LDAP: Technical Specification Road Map              http://tools.ietf.org/html/rfc4510
 * @see         RFC 4515  LDAP: String Representation of Search Filters       http://tools.ietf.org/html/rfc4515
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::peer::stubConnectionException',
                      'net::stubbles::peer::ldap::stubLDAPURLContainer',
                      'net::stubbles::peer::ldap::stubLDAPSearchResult'
);
/**
 * Represents a LDAP connection.
 *
 * Currently modifying of content in a LDAP directory is not supported.
 *
 * @package     stubbles
 * @subpackage  peer_ldap
 * @see         RFC 4510  LDAP: Technical Specification Road Map              http://tools.ietf.org/html/rfc4510
 * @see         RFC 4515  LDAP: String Representation of Search Filters       http://tools.ietf.org/html/rfc4515
 */
class stubLDAPConnection extends stubBaseObject
{
    /**
     * access to url parts
     *
     * @var  stubLDAPURL
     */
    protected $ldap;
    /**
     * ldap connection identifier
     *
     * @var  resource
     */
    protected $handle;
    /**
     * decision provider for protocol choice (default is LDAPv3).
     *
     * @var  bool
     */
    protected $usesProtocolVersionDefault;
    /**
     * ldap options
     *
     * Keys are used for equality check, the values are actually superfluous).
     * LDAP_OPT_NETWORK_TIMEOUT is not yet supported (requires >php5.3).
     *
     * @var  array(int, int)
     */
    protected static $options = array(LDAP_OPT_DEREF            => LDAP_OPT_DEREF,
                                      LDAP_OPT_SIZELIMIT        => LDAP_OPT_SIZELIMIT,
                                      LDAP_OPT_TIMELIMIT        => LDAP_OPT_TIMELIMIT,
                                      LDAP_OPT_PROTOCOL_VERSION => LDAP_OPT_PROTOCOL_VERSION,
                                      LDAP_OPT_ERROR_NUMBER     => LDAP_OPT_ERROR_NUMBER,
                                      LDAP_OPT_REFERRALS        => LDAP_OPT_REFERRALS,
                                      LDAP_OPT_RESTART          => LDAP_OPT_RESTART,
                                      LDAP_OPT_HOST_NAME        => LDAP_OPT_HOST_NAME,
                                      LDAP_OPT_ERROR_STRING     => LDAP_OPT_ERROR_STRING,
                                      LDAP_OPT_MATCHED_DN       => LDAP_OPT_MATCHED_DN,
                                      LDAP_OPT_SERVER_CONTROLS  => LDAP_OPT_SERVER_CONTROLS,
                                      LDAP_OPT_CLIENT_CONTROLS  => LDAP_OPT_CLIENT_CONTROLS);

    /**
     * constructor
     *
     * @param  stubLDAPURLContainer  $ldapUrl
     */
    public function __construct(stubLDAPURLContainer $ldapUrl)
    {
        $this->ldap   = $ldapUrl;
        $this->handle = ldap_connect($this->ldap->getHost(), $this->ldap->getPort());
        $this->usesProtocolVersionDefault = true;
    }

    /**
     * Checks a LDAP option.
     *
     * @param   string  $name
     * @return  bool
     * @link    http://de.php.net/manual/de/function.ldap-set-option.php
     */
    public function isOptionValid($name)
    {
        return isset(self::$options[$name]);
    }

    /**
     * Sets a LDAP option.
     *
     * Possible options and their type:
     * (depends also on which types the server returns)
     *
     * LDAP_OPT_DEREF               integer
     * LDAP_OPT_SIZELIMIT           integer
     * LDAP_OPT_TIMELIMIT           integer
     * LDAP_OPT_NETWORK_TIMEOUT     integer
     * LDAP_OPT_PROTOCOL_VERSION    integer
     * LDAP_OPT_ERROR_NUMBER        integer
     * LDAP_OPT_REFERRALS           bool
     * LDAP_OPT_RESTART             bool
     * LDAP_OPT_HOST_NAME           string
     * LDAP_OPT_ERROR_STRING        string
     * LDAP_OPT_MATCHED_DN          string
     * LDAP_OPT_SERVER_CONTROLS     array
     * LDAP_OPT_CLIENT_CONTROLS     array
     *
     * @param   string                        $name
     * @param   string                        $value
     * @throws  stubConnectionException
     * @throws  stubIllegalArgumentException
     * @return  stubLDAPConnection
     */
    public function option($name, $value)
    {
        if($this->isOptionValid($name) === false) {
            throw new stubIllegalArgumentException($name . ' is no valid LDAP option.');
        }

        if($name === LDAP_OPT_PROTOCOL_VERSION && $value != 3) {
            $this->usesProtocolVersionDefault = false;
        }

        $success = @ldap_set_option($this->handle, $name, $value);
        if($success === false) {
            throw new stubConnectionException(ldap_error($this->handle));
        }

        return $this;
    }

    /**
     * Gets a LDAP option.
     *
     * Possible options and their type:
     * (depends also on which types the server returns)
     *
     * LDAP_OPT_DEREF               integer
     * LDAP_OPT_SIZELIMIT           integer
     * LDAP_OPT_TIMELIMIT           integer
     * LDAP_OPT_NETWORK_TIMEOUT     integer
     * LDAP_OPT_PROTOCOL_VERSION    integer
     * LDAP_OPT_ERROR_NUMBER        integer
     * LDAP_OPT_REFERRALS           bool
     * LDAP_OPT_RESTART             bool
     * LDAP_OPT_HOST_NAME           string
     * LDAP_OPT_ERROR_STRING        string
     * LDAP_OPT_MATCHED_DN          string
     * LDAP_OPT_SERVER_CONTROLS     array
     * LDAP_OPT_CLIENT_CONTROLS     array
     *
     * @param   string                        $name
     * @throws  stubConnectionException
     * @throws  stubIllegalArgumentException
     * @return  mixed                         $retValue
     */
    public function getOption($name)
    {
        if($this->isOptionValid($name) === false) {
            throw new stubIllegalArgumentException($name . ' is no valid LDAP Option.');
        }

        $success = @ldap_get_option($this->handle, $name, $retValue);
        if($success === false) {
            throw new stubConnectionException(ldap_error($this->handle));
        }

        return $retValue;
    }

    /**
     * Binds the LDAP connection (authentication).
     * Uses per default LDAPv3.
     *
     * @throws  stubConnectionException
     * @return  stubLDAPConnection
     */
    public function bind()
    {
        if($this->usesProtocolVersionDefault === true) {
            $this->option(LDAP_OPT_PROTOCOL_VERSION, 3);
        }

        if($this->ldap->getUser() === null || $this->ldap->getPassword() === null) {
            // anonymous bind
            $success = @ldap_bind($this->handle);
        } else {
            $success = @ldap_bind($this->handle, $this->ldap->getUser(), $this->ldap->getPassword());
        }

        if($success === false) {
            throw new stubConnectionException(ldap_error($this->handle));
        }

        return $this;
    }

    /**
     * Unbinds (closes) the LDAP connection.
     */
    public function unbind()
    {
        if(gettype($this->handle) !== 'unknown type' ) {
            ldap_unbind($this->handle);
        }
    }

    /**
     * Changes the originally used base dn (distinguished name).
     *
     * @param  string  $newBaseDn
     */
    public function setBaseDn($newBaseDn)
    {
        $this->ldap->setBaseDn($newBaseDn);
    }

    /**
     * Retrieves the LDAP entries.
     * If no parameters set, the paramteres from the LDAP url are used (or the defaults).
     *
     * @param   string                        $attributes  ldap attributes  narrow result set
     * @param   string                        $scope       ldap scope       (base|one|sub)
     * @param   string                        $filter      ldap filter      must be surrounded with parentheses
     * @throws  stubConnectionException
     * @throws  stubIllegalArgumentException
     * @return  stubLDAPSearchResult
     */
    public function search($attributes = null, $scope = null, $filter = null)
    {
        $result = false;

        // set attributes
        if($attributes === null) {
            $attributes = $this->ldap->getParam('attributes');
            $attributes = ($attributes !== null && $attributes !== '') ? explode(',', $attributes) : array();
        } else {
            $attributes = explode(',', $attributes);
        }

        // set scope
        if($scope === null) {
            $scope = $this->ldap->getParam('scope');
        }

        // set filter
        if($filter === null) {
            $filter = $this->ldap->getParam('filter');
        }

        switch($scope) {
            case stubLDAPURL::SCOPE_BASE:
                $result = @ldap_read($this->handle, $this->ldap->getBaseDn(), $filter, $attributes);
                break;

            case stubLDAPURL::SCOPE_ONE:
                $result = @ldap_list($this->handle, $this->ldap->getBaseDn(), $filter, $attributes);
                break;

            case stubLDAPURL::SCOPE_SUB:
                $result = @ldap_search($this->handle, $this->ldap->getBaseDn(), $filter, $attributes);
                break;

            default:
                throw new stubIllegalArgumentException('Inavlid scope: ' . $scope . ', must be one of "base", "sub" or "one".');
        }

        if($result === false) {
            throw new stubConnectionException(ldap_error($this->handle));
        }

        return new stubLDAPSearchResult($this->handle, $result);
    }
}
?><?php
/**
 * Representation of a LDAP entry.
 *
 * @package     stubbles
 * @subpackage  peer_ldap
 * @version     $Id: stubLDAPEntry.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Representation of a LDAP entry.
 *
 * @package     stubbles
 * @subpackage  peer_ldap
 */
class stubLDAPEntry extends stubBaseObject
{
    /**
     * attributes
     *
     * @var  array<string,array<string>>
     */
    protected $attributes;
    /**
     * objectClass attribute
     *
     * @var  array<string>
     */
    protected $objectClass;
    /**
     * amount of attributes (inclusive objectClass)
     *
     * @var  int
     */
    protected $attributeCount;
    /**
     * distinguished name (dn)
     *
     * @var  string
     */
    protected $dn;

    /**
     * constructor
     *
     * @param  string  $dn
     * @param  array   $objectClass
     * @param  array   $attributes
     * @param  int     $attributeCount
     */
    public function __construct($dn, $objectClass, $attributes, $attributeCount)
    {
        $this->dn             = $dn;
        $this->objectClass    = $objectClass;
        foreach ($attributes as $name => $values) {
            $this->attributes[$name] = $values;
        }
        $this->attributeCount = $attributeCount;    // with objectClass

    }

    /**
     * Gets the dn (distinguished name).
     *
     * @return  string
     */
    public function getDn()
    {
        return $this->dn;
    }

    /**
     * Gets the objectClass values.
     *
     * @return  array<string>
     */
    public function getObjectClassValues()
    {
        return $this->objectClass;
    }

    /**
     * Gets the attributes.
     *
     * @return  array<string,array<string>>
     */
    public function getAttributes()
    {
        return $this->attributes;
    }

    /**
     * Gets the value(s) for an attribute.
     *
     * @param   string         $name
     * @return  array<string>
     */
    public function getAttributeValuesByName($name)
    {
        return (isset($this->attributes[$name]) !== false) ? $this->attributes[$name] : null;
    }

    /**
     * Gets the attribute names.
     *
     * @return  array<string>
     */
    public function getAttributeNames()
    {
        return array_keys($this->attributes);
    }

    /**
     * Gets amount of attributes (inclusive objectClass).
     *
     * @return  int
     */
    public function getAttributeCount()
    {
        return $this->attributeCount;
    }
}
?><?php
/**
 * Representation of a LDAP search result.
 *
 * @package     stubbles
 * @subpackage  peer_ldap
 * @version     $Id: stubLDAPSearchResult.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::peer::ldap::stubLDAPEntry');
/**
 * Representation of a LDAP search result.
 *
 * @package     stubbles
 * @subpackage  peer_ldap
 */
class stubLDAPSearchResult extends stubBaseObject implements Iterator
{
    /**
     * ldap connection identifier
     *
     * @var  resource
     */
    protected $handle;
    /**
     * ldap result identifier
     *
     * @var  resource
     */
    protected $result;
    /**
     * current ldap entryId
     *
     * @var  ressource
     */
    protected $current;

    /**
     * constructor (creates stubLDAPEntry objects)
     *
     * Unset calls remove the count value for better looping
     * and because this value is ascertainable later.
     *
     * @param  resource  $handle  ldap connection identifier
     * @param  resource  $result  ldap result identifier
     */
    public function __construct($handle, $result)
    {
        $this->handle  = $handle;
        $this->result  = $result;
        $entry = ldap_first_entry($handle, $result);
        $this->current = ($entry !== false) ? $entry : null;
    }

    /**
     * Provides a stubLDAPEntry.
     *
     * @param   int  $entryId  ldap entry identifier
     * @return  stubLDAPEntry
     */
    protected function provideLDAPEntry($entryId)
    {
        $attributes = ldap_get_attributes($this->handle, $entryId);

        $entryAttr   = array();
        $objectClass = array();
        foreach ($attributes as $name => $values) {
            // reject special attributes
            if($name === 'count' || is_int($name)) {
                continue;
            }

            // get rid of amount
            if(isset($values['count'])) {
                unset($values['count']);
            }

            // get object class values
            if($name === 'objectClass') {
                $objectClass = $values;
                continue;
            }

            // save 'normal' attributes
            $entryAttr[$name] = $values;
        }

        $dn = ldap_get_dn($this->handle, $entryId);
        if(empty($objectClass)) {
            $objectClass = ldap_read($this->handle, $dn, '(objectClass=*)', array('objectclass'));
        }

        $ldapEntry = new stubLDAPEntry(
                           $dn,
                           $objectClass,
                           $entryAttr,
                           $attributes['count']
                         );

        return $ldapEntry;
    }

    /**
     * Gets the current entry.
     *
     * @return  stubLDAPEntry
     */
    public function getEntry()
    {
        return ($this->current() !== null ? $this->provideLDAPEntry($this->current()) : null);
    }

    /**
     * Returns the current entry identifier.
     *
     * @return  ressource
     */
    public function current()
    {
        return $this->current;
    }

    /**
     * Returns the key of the current element.
     *
     * @return  ressource
     */
    public function key()
    {
        return $this->current();
    }

    /**
     * Moves forward to next element.
     */
    public function next()
    {
        $this->current = ($result = ldap_next_entry($this->handle, $this->current())) ? $result : null;
    }

    /**
     * Rewinds the Iterator to the first element.
     */
    public function rewind()
    {
        $this->current = ldap_first_entry($this->handle, $this->result);
    }

    /**
     * Checks if there is a current element after calls to rewind() or next().
     *
     * @return  boolean
     */
    public function valid()
    {
        return ($this->current() !== null) ? true : false;
    }
}
?><?php
/**
 * Entry point for LDAP usage (via stubLDAPURL::fromString(urlString)).
 *
 * @package     stubbles
 * @subpackage  peer_ldap
 * @version     $Id: stubLDAPURL.php 2352 2009-10-09 12:09:21Z mikey $
 */
stubClassLoader::load('net::stubbles::peer::stubURL',
                      'net::stubbles::peer::ldap::stubLDAPConnection',
                      'net::stubbles::peer::ldap::stubLDAPURLContainer'
);
/**
 * Entry point for LDAP usage (via stubLDAPURL::fromString(urlString)).
 *
 * @package     stubbles
 * @subpackage  peer_ldap
 * @see         RFC 4510  LDAP: Technical Specification Road Map              http://tools.ietf.org/html/rfc4510
 * @see         RFC 4514  LDAP: String Representation of Distinguished Names  http://tools.ietf.org/html/rfc4514
 * @see         RFC 4516  LDAP: Uniform Resource Locator                      http://tools.ietf.org/html/rfc4516
 * @see         RFC 4515  LDAP: String Representation of Search Filters       http://tools.ietf.org/html/rfc4515
 */
class stubLDAPURL extends stubURL implements stubLDAPURLContainer
{
    /**
     * LDAP scope constant for one
     */
    const SCOPE_ONE  = 'one';
    /**
     * LDAP scope constant for base
     */
    const SCOPE_BASE = 'base';
    /**
     * LDAP scope constant for sub
     */
    const SCOPE_SUB  = 'sub';

    /**
     * constructor
     *
     * @param  string  $urlString
     */
    protected function __construct($urlString)
    {
        // use default host if none given
        if (preg_match('~///~', $urlString) === 1) {
            $urlString = str_replace('///', '//localhost/', $urlString);
        }

        // setting $this->url['scheme'] / ['host'] / ['port'] / ['path'] / ['query']
        $this->url = parse_url($urlString);

        // use default ports if none given
        if (isset($this->url['port']) === false) {
            $this->url['port'] = ($this->getScheme() === 'ldaps') ? 636 : 389;
        }

        // set dn
        if (isset($this->url['path']) === true) {
            $this->url['base_dn'] = ltrim($this->url['path'], '/');
        }
    }

    /**
     * Entrace point for LDAP usage.
     *
     * The urlString has to be in the following format whereas the part
     * "user:password@" is an addition from Stubbles to ease the LDAP usage:
     *
     * ldap[s]://user:password@hostname:port/base_dn?attributes?scope?filter
     *
     * port=389 ldap
     * port=636 ldaps (non standard but commmonly used)
     *
     * @param   string  $urlString
     * @return  stubLDAPURL
     * @throws  stubMalformedURLException
     */
    public static function fromString($urlString)
    {
        if (strlen($urlString) == 0) {
            return null;
        }

        $url = new self($urlString);
        if ($url->isValid() === false) {
            throw new stubMalformedURLException('The URL ' . $urlString . ' is not a valid LDAP-URL.');
        }
        
        return $url;
    }


    /**
     * Checks LDAP url validity.
     *
     * @return  boolean
     */
    public function isValid()
    {
        // check scheme, user/password & host syntax (in general)
        if (parent::isValid() === false) {
            return false;
        }

        // check scheme
        if ($this->url['scheme'] !== 'ldap' && $this->url['scheme'] !== 'ldaps') {
            return false;
        }

        // check dn
        if (isset($this->url['base_dn']) === false || preg_match('/^([A-Za-z0-9]+=[A-Za-z0-9 ]+,?)*$/', $this->url['base_dn']) === 0) {
            return false;
        }

        // (optional) attributes & (optional) filters are passed through only scope is checked
        if ($this->getParam('scope') !== null
          && (self::SCOPE_ONE !== $this->getParam('scope')
          && self::SCOPE_BASE !== $this->getParam('scope')
          && self::SCOPE_SUB !== $this->getParam('scope'))) {
            return false;
        }

        return true;
    }

    /**
     * Gets the base dn (distinguished name).
     *
     * @return  string
     */
    public function getBaseDn()
    {
        if (isset($this->url['base_dn']) === false) {
            return null;
        }

        return $this->url['base_dn'];
    }

    /**
     * Changes the originally used base dn (distinguished name).
     *
     * @param  string  $newBaseDn
     */
    public function setBaseDn($newBaseDn)
    {
        $this->url['base_dn'] = $newBaseDn;
    }

    /**
     * Gets the base dn (distinguished name).
     *
     * @return  string
     */
    public function getPath()
    {
        if (isset($this->url['base_dn']) === false) {
            return null;
        }

        return $this->url['base_dn'];
    }

    /**
     * Checks if query string was provided.
     *
     * query:= {attributes}?{scope}?{filter}'
     *
     * @return  boolean
     */
    public function hasQuery()
    {
        return ((isset($this->url['query']) === true && strlen($this->url['query']) > 0));
    }

    /**
     * Gets the value of an optional parameter from the query string.
     * Valid LDAP parameters are 'attributes', 'scope' or 'filter'.
     *
     * If they were not set before the default values are:
     * attributes = ''
     * scope      = 'base'
     * filters    = '(objectClass=*)'
     *
     * possibilities for query string:
     *   attr  scope  filter
     *    x
     *    x    ?x
     *    x    ?x     ?x
     *         ?x     ?x
     *    x    ?      ?x
     *         ?      ?x
     *
     * @param   string       $name
     * @param   string       $defaultValue
     * @return  string|null
     */
    public function getParam($name, $defaultValue = null)
    {
        $result = $defaultValue;

        if ($this->hasQuery() === false) {
            $queryValues = null;
        } else {
            $queryValues = explode('?', $this->url['query']);
        }

        switch($name) {
            case 'attributes':
                $result = ($queryValues !== null
                                && $queryValues[0] !== '') ? $queryValues[0] : '';
                break;

            case 'scope':
                $result = ($queryValues !== null
                                && count($queryValues) >= 2
                                && $queryValues[1] !== '') ? $queryValues[1] : 'base';
                break;

            case 'filter':
                $result = ($queryValues !== null
                                && count($queryValues) >= 3
                                && $queryValues[2] !== '') ? $queryValues[2] : '(objectClass=*)';
                break;

            default:
                // intentionally empty
        }

        return $result;
    }

    /**
     * Returns the LDAP url.
     *
     * @param   boolean  $withPort  optional  true if port should be within returned url string
     * @return  string
     */
    public function get($withPort = false)
    {
        $url  = '';
        $user = '';
        if (isset($this->url['user']) === true) {
            $user = $this->url['user'];
            if (isset($this->url['pass']) === true) {
                $user .= ':' . $this->url['pass'];
            }

            $user .= '@';
        }

        if ($withPort === true && isset($this->url['port']) === true) {
            $port =  ':' . $this->url['port'];
        } else {
            $port = '';
        }

        if (isset($this->url['scheme']) === true) {
            $url = $this->url['scheme'] . '://';
            if (isset($this->url['host']) === true) {
                $url .= $user . $this->url['host'] . $port;
            }

            if (isset($this->url['base_dn']) == true) {
                $url .= '/' . $this->url['base_dn'];
            }
        }

        if ($this->hasQuery() === true) {
            $possibleParams = array('attributes', 'scope', 'filter');
            foreach ($possibleParams as $val) {
                $cur = $this->getParam($val);
                if($cur !== null) {
                    $url .= '?' . $cur;
                }
            }
        }

        return $url;
    }

    /**
     * Returns a stubLDAPConnection.
     *
     * @return  stubLDAPConnection
     */
    public function connect()
    {
        return new stubLDAPConnection($this);
    }
}
?><?php
/**
 * Container for LDAP urls.
 *
 * @package     stubbles
 * @subpackage  peer_ldap
 * @version     $Id: stubLDAPURLContainer.php 2350 2009-10-09 11:57:08Z mikey $
 */
stubClassLoader::load('net::stubbles::peer::stubURLContainer');
/**
 * Container for LDAP urls.
 *
 * @package     stubbles
 * @subpackage  peer_ldap
 * @see         RFC 4510  LDAP: Technical Specification Road Map              http://tools.ietf.org/html/rfc4510
 * @see         RFC 4514  LDAP: String Representation of Distinguished Names  http://tools.ietf.org/html/rfc4514
 * @see         RFC 4516  LDAP: Uniform Resource Locator                      http://tools.ietf.org/html/rfc4516
 * @see         RFC 4515  LDAP: String Representation of Search Filters       http://tools.ietf.org/html/rfc4515
 */
interface stubLDAPURLContainer extends stubURLContainer
{
    /**
     * Gets the base dn (distinguished name).
     *
     * @return  string
     */
    public function getBaseDn();

    /**
     * Changes the originally used base dn (distinguished name).
     *
     * @param  string  $newBaseDn
     */
    public function setBaseDn($newBaseDn);

    /**
     * Returns a stubLDAPConnection.
     *
     * @return  stubLDAPConnection
     */
    public function connect();
}
?><?php
/**
 * Class for operations on bsd-style sockets.
 *
 * @package     stubbles
 * @subpackage  peer
 * @version     $Id: stubBSDSocket.php 2435 2010-01-04 22:10:32Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::lang::exceptions::stubIllegalStateException',
                      'net::stubbles::peer::stubSocket',
                      'net::stubbles::peer::stubConnectionException'
);
/**
 * Class for operations on bsd-style sockets.
 *
 * @package     stubbles
 * @subpackage  peer
 */
class stubBSDSocket extends stubSocket
{
    /**
     * switch whether end of file was reached or not
     *
     * @var  bool
     */
    protected $eof            = true;
    /**
     * host to open socket to
     *
     * @var  string
     */
    protected $domain         = AF_INET;
    /**
     * port to use for opening the socket
     *
     * @var  int
     */
    protected $type           = SOCK_STREAM;
    /**
     * timeout
     *
     * @var  int
     */
    protected $protocol       = SOL_TCP;
    /**
     * list of options for the socket
     *
     * @var  array<int,array<int,mixed>>
     */
    protected $options        = array();
    /**
     * list of available domains
     *
     * @var  array<int,string>
     */
    protected static $domains = array(AF_INET  => 'AF_INET',
                                      AF_INET6 => 'AF_INET6',
                                      AF_UNIX  => 'AF_UNIX'
                                );
    /**
     * list of available socket types
     *
     * @var  array<int,string>
     */
    protected static $types   = array(SOCK_STREAM    => 'SOCK_STREAM',
                                      SOCK_DGRAM     => 'SOCK_DGRAM',
                                      SOCK_RAW       => 'SOCK_RAW',
                                      SOCK_SEQPACKET => 'SOCK_SEQPACKET',
                                      SOCK_RDM       => 'SOCK_RDM'
                                );

    /**
     * sets the domain
     *
     * @param   int            $domain  one of AF_INET, AF_INET6 or AF_UNIX
     * @return  stubBSDSocket
     * @throws  stubIllegalArgumentException
     * @throws  stubIllegalStateException
     */
    public function setDomain($domain)
    {
        if (in_array($domain, array_keys(self::$domains)) === false) {
            throw new stubIllegalArgumentException('Domain must be one of AF_INET, AF_INET6 or AF_UNIX.');
        }
        
        if ($this->isConnected() === true) {
            throw new stubIllegalStateException('Can not change domain on already connected socket.');
        }
        
        $this->domain = $domain;
        return $this;
    }

    /**
     * returns the domain
     *
     * @return  int
     */
    public function getDomain()
    {
        return $this->domain;
    }

    /**
     * sets the socket type
     *
     * @param   int            $type  one of SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_SEQPACKET or SOCK_RDM
     * @return  stubBSDSocket
     * @throws  stubIllegalArgumentException
     * @throws  stubIllegalStateException
     */
    public function setType($type)
    {
        if (in_array($type, array_keys(self::$types)) === false) {
            throw new stubIllegalArgumentException('Type must be one of SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_SEQPACKET or SOCK_RDM.');
        }
        
        if ($this->isConnected() === true) {
            throw new stubIllegalStateException('Can not change type on already connected socket.');
        }
        
        $this->type = $type;
        return $this;
    }

    /**
     * returns the socket type
     *
     * @return  int
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * sets the protocol for the socket
     *
     * @param   int            $protocol  one of SOL_TCP or SOL_UDP
     * @return  stubBSDSocket
     * @throws  stubIllegalArgumentException
     * @throws  stubIllegalStateException
     */
    public function setProtocol($protocol)
    {
        if (0 !== $protocol && in_array($protocol, array(SOL_TCP, SOL_UDP)) === false) {
            throw new stubIllegalArgumentException('Protocol must be one of SOL_TCP or SOL_UDP.');
        }
        
        if ($this->isConnected() === true) {
            throw new stubIllegalStateException('Can not change protocol on already connected socket.');
        }
        
        $this->protocol = $protocol;
        return $this;
    }

    /**
     * returns the protocol used by the socket
     *
     * @return  int
     */
    public function getProtocol()
    {
        return $this->protocol;
    }

    /**
     * sets an option
     *
     * @param   int            $level  protocol level of option
     * @param   int            $name   option name
     * @param   mixed          $value  option value
     * @return  stubBSDSocket
     * @throws  stubConnectionException
     */
    public function setOption($level, $name, $value)
    {
        if (isset($this->options[$level]) === false) {
            $this->options[$level] = array();
        }
        
        $this->options[$level][$name] = $value;
        if ($this->isConnected() === true) {
            if (socket_set_option($this->fp, $level, $name, $value) === false) {
                throw new stubConnectionException('Failed to set option ' . $name . ' on level ' . $level . ' to value ' . $value);
            }
        }

        return $this;
    }

    /**
     * returns an option
     *
     * @param   int    $level  protocol level of option
     * @param   int    $name   option name
     * @return  mixed
     * @throws  stubConnectionException
     */
    public function getOption($level, $name)
    {
        if ($this->isConnected() === true) {
            $option = socket_get_option($this->fp, $level, $name);
            if (false === $option) {
                throw new stubConnectionException('Failed to retrieve option ' . $name . ' on level ' . $level);
            }
            
            if (isset($this->options[$level]) === false) {
                $this->options[$level] = array();
            }
            
            $this->options[$level][$name] = $option;
        }
        
        if (isset($this->options[$level]) === true && isset($this->options[$level][$name]) === true) {
            return $this->options[$level][$name];
        }
        
        return null;
    }

    /**
     * opens a socket connection
     *
     * @return  bool    true if connect was successful
     * @throws  stubConnectionException
     */
    public function connect()
    {
        if ($this->isConnected() === true) {
            return true;
        }
        
        $this->fp = @socket_create($this->domain, $this->type, $this->protocol);
        if (false === $this->fp) {
            $this->fp = null;
            throw new stubConnectionException(sprintf('Create of %s socket (type %s, protocol %s) failed.',
                                                      self::$domains[$this->domain],
                                                      self::$types[$this->type],
                                                      getprotobynumber($this->protocol)
                                              )
                      );
        }
        
        foreach ($this->options as $level => $pairs) {
            foreach ($pairs as $name => $value) {
                socket_set_option($this->fp, $level, $name, $value);
            }
        }
      
        switch ($this->domain) {
            case AF_INET:
                $result = socket_connect($this->fp, gethostbyname($this->host), $this->port);
                break;
            
            case AF_UNIX:
                $result = socket_connect($this->fp, $this->host);
                break;
            
            default:
                throw new stubConnectionException('Connect to ' . $this->host . ':' .$this->port . ' failed: Illegal domain type ' . $this->domain . ' used.');
        }
        
        if (false === $result) {
            $errorMessage = $this->lastError();
            $this->fp     = null;
            throw new stubConnectionException('Connect to ' . $this->host . ':' .$this->port . ' failed: ' . $errorMessage);
        }
        
        $this->eof = false;
        return true;
    }

    /**
     * closes a connection
     *
     * @return  stubBSDSocket
     */
    public function disconnect()
    {
        if ($this->isConnected() === true) {
            socket_close($this->fp);
        }

        return $this;
    }

    /**
     * returns last error
     *
     * @return  string
     */
    public function lastError()
    {
        $e = socket_last_error($this->fp);
        return $e . ': ' . socket_strerror($e);
    }

    /**
     * read from socket
     *
     * @param   int     $length  optional  length of data to read
     * @return  string
     * @throws  stubIllegalStateException
     */
    public function read($length = 4096)
    {
        if ($this->isConnected() == false) {
            throw new stubIllegalStateException('Can not read on unconnected socket.');
        }
        
        return $this->doRead($length, PHP_NORMAL_READ);
    }

    /**
     * read a whole line from socket
     *
     * @param   int     $length  optional  length of data to read
     * @return  string
     */
    public function readLine($length = 4096)
    {
        return rtrim($this->read($length));
    }

    /**
     * read binary data from socket
     *
     * @param   int     $length  optional  length of data to read
     * @return  string
     * @throws  stubIllegalStateException
     */
    public function readBinary($length = 1024)
    {
        if ($this->isConnected() == false) {
            throw new stubIllegalStateException('Can not read on unconnected socket.');
        }
        
        return $this->doRead($length, PHP_BINARY_READ);
    }

    /**
     * write data to socket and returns the amount of written bytes
     *
     * @param   string  $data  data to write
     * @return  int
     * @throws  stubConnectionException
     * @throws  stubIllegalStateException
     */
    public function write($data)
    {
        if ($this->isConnected() == false) {
            throw new stubIllegalStateException('Can not write on unconnected socket.');
        }
        
        $length = socket_write($this->fp, $data, strlen($data));
        if (false === $length) {
            throw new stubConnectionException('"Writing of ' . strlen($data) . ' bytes failed.');
        }

        return $length;
    }

    /**
     * helper method to do the actual reading
     *
     * @param   int    $length  length of data to read
     * @param   int    $type    one of PHP_BINARY_READ or PHP_NORMAL_READ
     * @return  string
     * @throws  stubConnectionException
     */
    protected function doRead($length, $type)
    {
        $result = socket_read($this->fp, $length, $type);
        if (false === $result) {
            throw new stubConnectionException('Read failed: ' . $this->lastError());
        }
        
        if (empty($result) === true) {
            $this->eof = true;
            $result = null;
        }
        
        return $result;
    }

    /**
     * check if we reached end of data
     *
     * @return  bool
     */
    public function eof()
    {
        return $this->eof;
    }
}
?><?php
/**
 * Exception to be thrown when an error on a network connection occurs.
 *
 * @package     stubbles
 * @subpackage  peer
 * @version     $Id: stubConnectionException.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubChainedException');
/**
 * Exception to be thrown when an error on a network connection occurs.
 *
 * @package     stubbles
 * @subpackage  peer
 */
class stubConnectionException extends stubChainedException
{
    // intentionally empty
}
?><?php
/**
 * Container for list of headers.
 *
 * @package     stubbles
 * @subpackage  peer
 * @version     $Id: stubHeaderList.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::peer::stubURL'
);
/**
 * Container for list of headers.
 *
 * @package     stubbles
 * @subpackage  peer
 */
class stubHeaderList extends stubBaseObject implements IteratorAggregate
{
    /**
     * list of headers
     *
     * @var  array<string,string>
     */
    private $headers = array();

    /**
     * creates headerlist from given string
     *
     * @param   string          $headers  string to parse for headers
     * @return  stubHeaderList
     */
    public static function fromString($headers)
    {
        $headerList = new self();
        $matches    = array();
        preg_match_all('=^(.+): ([^\r\n]*)=m', $headers, $matches, PREG_SET_ORDER);
        foreach ($matches as $line) {
            $headerList->put($line[1], $line[2]);
        }
        
        return $headerList;
    }

    /**
     * creates header with value for key
     *
     * @param   string          $key    name of header
     * @param   string          $value  value of header
     * @return  stubHeaderList
     * @throws  stubIllegalArgumentException
     */
    public function put($key, $value)
    {
        if (is_string($key) == false) {
            throw new stubIllegalArgumentException('Argument 1 passed to ' . __METHOD__ . ' must be an instance of string.');
        }
        
        if (is_scalar($value) == false) {
            throw new stubIllegalArgumentException('Argument 2 passed to ' . __METHOD__ . ' must be an instance of a scalar value.');
        }
        
        $this->headers[$key] = (string) $value;
        return $this;
    }

    /**
     * removes header with given key
     *
     * @param   string  $key    name of header
     * @return  stubHeaderList
     */
    public function remove($key)
    {
        if (isset($this->headers[$key]) == true) {
            unset($this->headers[$key]);
        }
        
        return $this;
    }

    /**
     * creates header for user agent
     *
     * @param   string          $userAgent  name of user agent
     * @return  stubHeaderList
     */
    public function putUserAgent($userAgent)
    {
        $this->put('User-Agent', $userAgent);
        return $this;
    }

    /**
     * creates header for referer
     *
     * @param   string          $referer  referer url
     * @return  stubHeaderList
     */
    public function putReferer($referer)
    {
        $this->put('Referer', $referer);
        return $this;
    }

    /**
     * creates header for cookie
     *
     * @param   array           $cookieValues  cookie values
     * @return  stubHeaderList
     */
    public function putCookie(array $cookieValues)
    {
        $cookieValue = '';
        foreach ($cookieValues as $key => $value) {
            $cookieValue .= $key . '=' . urlencode($value) . ';';
        }
        
        $this->put('Cookie', $cookieValue);
        return $this;
    }

    /**
     * creates header for authorization
     *
     * @param   string          $user      login name
     * @param   string          $password  login password
     * @return  stubHeaderList
     */
    public function putAuthorization($user, $password)
    {
        $this->put('Authorization', 'BASIC ' . base64_encode($user . ':' . $password));
        return $this;
    }

    /**
     * adds a date header
     *
     * @param   int             $date  optional  timestamp to use as date
     * @return  stubHeaderList
     */
    public function putDate($date = null)
    {
        if (null === $date) {
            $date = gmdate('D, d M Y H:i:s');
        } else {
            $date = gmdate('D, d M Y H:i:s', $date);
        }
        
        $this->put('Date', $date . ' GMT');
        return $this;
    }

    /**
     * creates X-Binford header
     *
     * @return  stubHeaderList
     */
    public function enablePower()
    {
        $this->put('X-Binford', 'More power!');
        return $this;
    }

    /**
     * removes all headers
     *
     * @return  stubHeaderList
     */
    public function clear()
    {
        $this->headers = array();
        return $this;
    }

    /**
     * returns value of header with given key
     *
     * @param   string  $key      name of header
     * @param   mixed   $default  optional  value to return if given header not set
     * @return  string
     */
    public function get($key, $default = null)
    {
        if ($this->containsKey($key) == true) {
            return $this->headers[$key];
        }
        
        return $default;
    }

    /**
     * returns true if an header with given key exists
     *
     * @param   string  $key  name of header
     * @return  bool
     */
    public function containsKey($key)
    {
        return isset($this->headers[$key]);
    }

    /**
     * returns an iterator object
     *
     * @return  ArrayObject
     */
    public function getIterator()
    {
        return new ArrayObject($this->headers);
    }

    /**
     * returns amount of headers
     *
     * @return  int
     */
    public function size()
    {
        return count($this->headers);
    }
}
?><?php
/**
 * Exception to be thrown when an URL can not be parsed from a string.
 *
 * @package     stubbles
 * @subpackage  peer
 * @version     $Id: stubMalformedURLException.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Exception to be thrown when an URL can not be parsed from a string.
 *
 * @package     stubbles
 * @subpackage  peer
 */
class stubMalformedURLException extends stubException
{
    // intentionally empty
}
?><?php
/**
 * Class for operations on sockets.
 *
 * @package     stubbles
 * @subpackage  peer
 * @version     $Id: stubSocket.php 2435 2010-01-04 22:10:32Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalStateException',
                      'net::stubbles::peer::stubConnectionException'
);
/**
 * Class for operations on sockets.
 *
 * @package     stubbles
 * @subpackage  peer
 */
class stubSocket extends stubBaseObject
{
    /**
     * host to open socket to
     *
     * @var  string
     */
    protected $host;
    /**
     * port to use for opening the socket
     *
     * @var  int
     */
    protected $port;
    /**
     * prefix for host, e.g. ssl://
     *
     * @var  string
     */
    protected $prefix;
    /**
     * timeout
     *
     * @var  int
     */
    protected $timeout;
    /**
     * internal resource pointer
     *
     * @var  resource
     */
    protected $fp;

    /**
     * constructor
     *
     * @param  string  $host     host to open socket to
     * @param  int     $port     optional  port to use for opening the socket
     * @param  string  $prefix   optional  prefix for host, e.g. ssl://
     * @param  int     $timeout  optional  connection timeout
     */
    public function __construct($host, $port = 80, $prefix = null, $timeout = 5)
    {
        $this->host    = $host;
        $this->port    = $port;
        $this->prefix  = $prefix;
        $this->timeout = $timeout;
    }

    /**
     * destructor
     */
    public function __destruct()
    {
        $this->disconnect();
    }

    /**
     * opens a connection to host
     *
     * @param   int   $connectTimeout  optional  timeout for establishing the connection
     * @return  bool  true if connect was successful
     * @throws  stubConnectionException
     */
    public function connect($connectTimeout = 2)
    {
        if ($this->isConnected() === true) {
            return true;
        }

        if (null == $this->host) {
            return false;
        }

        $errno    = 0;
        $errstr   = '';
        $this->fp = @fsockopen($this->prefix . $this->host, $this->port, $errno, $errstr, $connectTimeout);
        if (false === $this->fp) {
            $this->fp = null;
            throw new stubConnectionException('Connecting to ' . $this->prefix . $this->host . ':' . $this->port . ' within ' . $connectTimeout . ' seconds failed: ' . $errstr . ' (' . $errno . ').');
        }

        socket_set_timeout($this->fp, $this->timeout);
        return true;
    }

    /**
     * closes a connection
     *
     * @return  stubSocket
     */
    public function disconnect()
    {
        if ($this->isConnected() === true) {
            fclose($this->fp);
            $this->fp = null;
        }

        return $this;
    }

    /**
     * set timeout for connections
     *
     * @param   int         $timeout  timeout for connection in seconds
     * @return  stubSocket
     */
    public function setTimeout($timeout)
    {
        $this->timeout = $timeout;
        if ($this->isConnected() === true) {
            socket_set_timeout($this->fp, $this->timeout);
        }

        return $this;
    }

    /**
     * read from socket
     *
     * @param   int     $length  optional  length of data to read
     * @return  string  data read from socket
     * @throws  stubConnectionException
     * @throws  stubIllegalStateException
     */
    public function read($length = 4096)
    {
        if ($this->isConnected() === false) {
            throw new stubIllegalStateException('Can not read on unconnected socket.');
        }

        $data = fgets($this->fp, $length);
        if (false === $data) {
            // fgets returns false on eof while feof() returned false before
            // but will now return true
            if ($this->eof() === true) {
                return null;
            }
            
            throw new stubConnectionException('Reading of ' . $length . ' bytes failed.');
        }

        return $data;
    }

    /**
     * read a whole line from socket
     *
     * @param   int     $length  optional  length of data to read
     * @return  string  data read from socket
     */
    public function readLine($length = 4096)
    {
        return rtrim($this->read($length));
    }

    /**
     * read binary data from socket
     *
     * @param   int     $length  optional  length of data to read
     * @return  string  data read from socket
     * @throws  stubConnectionException
     * @throws  stubIllegalStateException
     */
    public function readBinary($length = 1024)
    {
        if ($this->isConnected() === false) {
            throw new stubIllegalStateException('Can not read on unconnected socket.');
        }

        $data = fread($this->fp, $length);
        if (false === $data) {
            throw new stubConnectionException('Reading of ' . $length . ' bytes failed.');
        }

        return $data;
    }

    /**
     * write data to socket
     *
     * @param   string  $data  data to write
     * @return  int     amount of bytes written to socket
     * @throws  stubConnectionException
     * @throws  stubIllegalStateException
     */
    public function write($data)
    {
        if ($this->isConnected() === false) {
            throw new stubIllegalStateException('Can not write on unconnected socket.');
        }

        $length = fputs($this->fp, $data, strlen($data));
        if (false === $length) {
            throw new stubConnectionException('"Writing of ' . strlen($data) . ' bytes failed.');
        }

        return $length;
    }

    /**
     * get host of current connection
     *
     * @return  string
     */
    public function getHost()
    {
        return $this->host;
    }

    /**
     * get port of current connection
     *
     * @return  int
     */
    public function getPort()
    {
        return $this->port;
    }

    /**
     * returns prefix for host, e.g. ssl://
     *
     * @return  string
     */
    public function getPrefix()
    {
        return $this->prefix;
    }

    /**
     * get timeout for connections
     *
     * @return  int
     */
    public function getTimeout()
    {
        return $this->timeout;
    }

    /**
     * checks if we already have a connection
     *
     * @return  bool
     */
    public function isConnected()
    {
        return is_resource($this->fp);
    }

    /**
     * check if we reached end of data
     *
     * @return  bool
     */
    public function eof()
    {
        if ($this->isConnected() === true) {
            return feof($this->fp);
        }

        return true;
    }
}
?><?php
/**
 * Input stream for reading sockets.
 *
 * @package     stubbles
 * @subpackage  peer
 * @version     $Id: stubSocketInputStream.php 2254 2009-06-23 20:38:41Z mikey $
 */
stubClassLoader::load('net::stubbles::peer::stubSocket',
                      'net::stubbles::streams::stubInputStream'
);
/**
 * Input stream for reading sockets.
 *
 * @package     stubbles
 * @subpackage  peer
 */
class stubSocketInputStream extends stubBaseObject implements stubInputStream
{
    /**
     * socket to read from
     *
     * @var  stubSocket
     */
    protected $socket;

    /**
     * constructor
     *
     * @param  stubSocket  $socket
     */
    public function __construct(stubSocket $socket)
    {
        $this->socket = $socket;
        $this->socket->connect();
    }

    /**
     * reads given amount of bytes
     *
     * @param   int     $length  optional  max amount of bytes to read
     * @return  string
     */
    public function read($length = 8192)
    {
        return $this->socket->read($length);
    }

    /**
     * reads given amount of bytes or until next line break
     *
     * @param   int     $length  optional  max amount of bytes to read
     * @return  string
     */
    public function readLine($length = 8192)
    {
        return $this->socket->readLine($length);
    }

    /**
     * returns the amount of byted left to be read
     *
     * @return  int
     */
    public function bytesLeft()
    {
        if ($this->socket->eof() === true) {
            return -1;
        }
        
        return 1;
    }

    /**
     * returns true if the stream pointer is at EOF
     *
     * @return  bool
     */
    public function eof()
    {
        return $this->socket->eof();
    }

    /**
     * closes the stream
     */
    public function close()
    {
        $this->socket->disconnect();
    }
}
?><?php
/**
 * Output stream for writing to sockets.
 *
 * @package     stubbles
 * @subpackage  peer
 * @version     $Id: stubSocketOutputStream.php 2254 2009-06-23 20:38:41Z mikey $
 */
stubClassLoader::load('net::stubbles::peer::stubSocket',
                      'net::stubbles::streams::stubOutputStream'
);
/**
 * Output stream for writing to sockets.
 *
 * @package     stubbles
 * @subpackage  peer
 */
class stubSocketOutputStream extends stubBaseObject implements stubOutputStream
{
    /**
     * socket to read from
     *
     * @var  stubSocket
     */
    protected $socket;

    /**
     * constructor
     *
     * @param  stubSocket  $socket
     */
    public function __construct(stubSocket $socket)
    {
        $this->socket = $socket;
        $this->socket->connect();
    }

    /**
     * writes given bytes
     *
     * @param   string  $bytes
     * @return  int     amount of written bytes
     */
    public function write($bytes)
    {
        return $this->socket->write($bytes);
    }

    /**
     * writes given bytes and appends a line break
     *
     * @param   string  $bytes
     * @return  int     amount of written bytes excluding line break
     */
    public function writeLine($bytes)
    {
        return $this->socket->write($bytes . "\r\n");
    }

    /**
     * closes the stream
     */
    public function close()
    {
        $this->socket->disconnect();
    }
}
?><?php
/**
 * Class for URLs and methods on URLs.
 *
 * @package     stubbles
 * @subpackage  peer
 * @version     $Id: stubURL.php 2597 2010-07-27 13:22:51Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::peer::stubMalformedURLException',
                      'net::stubbles::peer::stubURLContainer'
);
/**
 * Class for URLs and methods on URLs.
 *
 * @package     stubbles
 * @subpackage  peer
 */
class stubURL extends stubBaseObject implements stubURLContainer
{
    /**
     * internal representation after parse_url()
     *
     * @var  array
     */
    protected $url    = array();
    /**
     * parameters for url
     *
     * @var  array
     */
    protected $params = array();

    /**
     * constructor
     *
     * @param  string  $url
     */
    protected function __construct($url)
    {
        $this->url = parse_url($url);
        if (isset($this->url['host']) === true) {
            $this->url['host'] = strtolower($this->url['host']);
        }

        // bugfix for a PHP issue: ftp://user:@auxiliary.kl-s.com/
        // will lead to an unset $this->url['pass'] which is wrong
        // due to RFC1738 3.1, it has to be an empty string
        if (isset($this->url['user']) === true && isset($this->url['pass']) === false && $this->get(true) !== $url) {
            $this->url['pass'] = '';
        }

        if ($this->hasQuery() === true) {
            // do not use parse_str() as this breaks param names containing
            // dots or spaces
            foreach (explode('&', $this->url['query']) as $param) {
                if (strstr($param, '=') !== false) {
                    list($key, $value)  = explode('=', $param);
                    $this->params[$key] = $value;
                } else {
                    $this->params[$param] = '';
                }
            }
        }
    }

    /**
     * parses an url out of a string
     *
     * @param   string   $urlString
     * @return  stubURL
     * @throws  stubMalformedURLException
     */
    public static function fromString($urlString)
    {
        if (strlen($urlString) === 0) {
            return null;
        }

        $url = new self($urlString);
        if ($url->isValid() === false) {
            throw new stubMalformedURLException('The URL ' . $urlString . ' is not a valid URL.');
        }

        return $url;
    }

    /**
     * Checks whether URL is a correct URL.
     *
     * @return  bool
     */
    public function isValid()
    {
        if (strlen($this->get()) === 0) {
            return false;
        }

        if (isset($this->url['scheme']) === false) {
            return false;
        }

        if (isset($this->url['user']) === true) {
            if (preg_match('~([@:/])~', $this->url['user']) != 0) {
                return false;
            }

            if (isset($this->url['pass']) === true && preg_match('~([@:/])~', $this->url['pass']) != 0) {
                return false;
            }
        }

        // if host is set and seems to comply with host character rules or host is localhost syntax is ok
        if (isset($this->url['host']) === true
                && (preg_match('~([a-zA-Z0-9-]*)\.([a-z]{2,4})~', $this->url['host']) != 0
                        || preg_match('~([0-9-]{1,3})\.([0-9-]{1,3})\.([0-9-]{1,3})\.([0-9-]{1,3})~', $this->url['host']) != 0
                        || 'localhost' == $this->url['host'])) {
            return true;
        } elseif (isset($this->url['host']) === false || strlen($this->url['host']) === 0) {
            return true;
        }

        return false;
    }

    /**
     * checks whether host of url is listed in dns
     *
     * @return  bool
     */
    public function checkDNS()
    {
        // no valid url, no dns :)
        if ($this->isValid() === false) {
            return false;
        }

        // no host, no dns :)
        if (isset($this->url['host']) === false) {
            return false;
        }

        if ('localhost' === $this->url['host'] || '127.0.0.1' === $this->url['host']) {
            return true;
        }

        // windows does not support dns functions :(
        if (function_exists('checkdnsrr') === false) {
            return true;
        }

        if (checkdnsrr($this->url['host'], 'ANY') === true || checkdnsrr($this->url['host'], 'MX') === true) {
            return true;
        }

        return false;
    }

    /**
     * checks whether the url uses a default port or not
     *
     * @return  bool
     */
    public function hasDefaultPort()
    {
        return false;
    }

    /**
     * returns the url
     *
     * The both port params have the following influence:
     * 1. $port = false: port gets never added to returned url, even if initially set
     * 2. $port = true, $onlyNonDefaultPort = false: port gets always added to the returned url
     * 3. $port = true, $onlyNonDefaultPort = true: port gets only added to the returned url if it is not the default port of the scheme
     *
     * @param   bool    $port                optional  true if port should be within returned url string
     * @param   bool    $onlyNonDefaultPort  optional  true if port should only be returned if it is not the default port
     * @return  string
     */
    public function get($port = false, $onlyNonDefaultPort = false)
    {
        $url  = '';
        $user = '';
        if (isset($this->url['user']) === true) {
            $user = $this->url['user'];
            if (isset($this->url['pass']) === true) {
                $user .= ':' . $this->url['pass'];
            }

            $user .= '@';
        }

        // see description about ports above about the sense of this if-construct
        if (true === $port && isset($this->url['port']) === true
          && ((true === $onlyNonDefaultPort && $this->hasDefaultPort() === false) || false === $onlyNonDefaultPort)) {
            $port =  ':' . $this->url['port'];
        } else {
            $port = '';
        }

        if (isset($this->url['scheme']) === true) {
            $url = $this->url['scheme'] . '://';
            if (isset($this->url['host']) === true) {
                $url .= $user . $this->url['host'] . $port;
            }

            if (isset($this->url['path']) === true) {
                $url .= $this->url['path'];
            }
        }

        if ($this->hasQuery() === true) {
            $url .= '?' . $this->buildQuery();
        }

        if (isset($this->url['fragment']) && strlen($this->url['fragment']) > 0) {
            $url .= '#' . $this->url['fragment'];
        }

        return $url;
    }

    /**
     * set the protocol sheme
     *
     * @param  string  $scheme  e.g. - http, https, ftp
     */
    public function setScheme($scheme)
    {
        $this->url['scheme'] = $scheme;
    }

    /**
     * returns the scheme of the url
     *
     * @return  string
     */
    public function getScheme()
    {
        if (isset($this->url['scheme']) === true) {
            return $this->url['scheme'];
        }

        return null;
    }

    /**
     * returns the user
     *
     * @param   string  $defaultUser  optional  user to return if no user is set
     * @return  string
     */
    public function getUser($defaultUser = null)
    {
        if (isset($this->url['user']) === true) {
            return $this->url['user'];
        }

        return $defaultUser;
    }

    /**
     * returns the password
     *
     * @param   string  $defaultPassword  optional  password to return if no password is set
     * @return  string
     */
    public function getPassword($defaultPassword = null)
    {
        if (isset($this->url['pass']) === true) {
            return $this->url['pass'];
        }

        return $defaultPassword;
    }

    /**
     * returns hostname of the url
     *
     * @param   string  $defaultHost  optional  default host to return if no host is defined
     * @return  string
     */
    public function getHost($defaultHost = null)
    {
        if (isset($this->url['host']) === true) {
            return $this->url['host'];
        }

        return $defaultHost;
    }

    /**
     * sets the port
     *
     * @param  int  $port
     */
    public function setPort($port)
    {
        $this->url['port'] = $port;
    }

    /**
     * returns port of the url
     *
     * @param   int     $defaultPort  optional  port to be used if no port is defined
     * @return  string
     */
    public function getPort($defaultPort = null)
    {
        if (isset($this->url['port']) === true) {
            return $this->url['port'];
        }

        return $defaultPort;
    }

    /**
     * returns path of the url
     *
     * @return  string
     */
    public function getPath()
    {
        if (isset($this->url['path']) === false) {
            return null;
        }

        if ($this->hasQuery() === true) {
            return $this->url['path'] . '?' . $this->buildQuery();
        }

        return $this->url['path'];
    }

    /**
     * checks whether url has a query
     *
     * @return  bool
     */
    public function hasQuery()
    {
        return (count($this->params) > 0 ||  (isset($this->url['query']) === true && strlen($this->url['query']) > 0));
    }

    /**
     * add a parameter to the url
     *
     * If given value is null the param will be removed.
     *
     * @param   string   $key    name of parameter
     * @param   mixed    $value  value of parameter
     * @return  stubURL
     * @throws  stubIllegalArgumentException
     */
    public function addParam($key, $value)
    {
        if (is_string($key) === false) {
            throw new stubIllegalArgumentException('Argument 1 passed to ' . __METHOD__ . '() must be an instance of string.');
        }

        if (null !== $value && is_array($value) === false && is_scalar($value) === false) {
            throw new stubIllegalArgumentException('Argument 2 passed to ' . __METHOD__ . '() must be an instance of string, array or any other scalar value or null.');
        }

        if (null === $value and isset($this->params[$key]) === true) {
            unset($this->params[$key]);
        } elseif (null !== $value) {
            if (false === $value) {
                $value = 0;
            } elseif (true === $value) {
                $value = 1;
            }

            $this->params[$key] = $value;
        }

        return $this;
    }

    /**
     * remove a param from url
     *
     * @param   string   $key    name of parameter
     * @return  stubURL
     * @since   1.1.2
     */
    public function removeParam($key)
    {
        if (isset($this->params[$key]) === true) {
            unset($this->params[$key]);
            if (count($this->params) === 0) {
                unset($this->url['query']);
            }
        }

        return $this;
    }

    /**
     * checks whether a certain param is set
     *
     * @param   string  $key
     * @return  bool
     * @since   1.1.2
     */
    public function hasParam($key)
    {
        return isset($this->params[$key]);
    }

    /**
     * returns the value of a param
     *
     * @param   string  $name          name of the param
     * @param   mixed   $defaultValue  optional  default value to return if param is not set
     * @return  mixed
     */
    public function getParam($name, $defaultValue = null)
    {
        if (isset($this->params[$name]) === false) {
            return $defaultValue;
        }

        return $this->params[$name];
    }

    /**
     * build the query from given parameters
     *
     * @return  string
     */
    protected function buildQuery()
    {
        if ($this->hasQuery() === false) {
            return null;
        }

        $query = '';
        foreach ($this->params as $key => $value) {
            if (is_array($value) === false) {
                if (strlen($query) > 0) {
                    $query .= '&';
                }

                if($value !== '') {
                    $query .= $key . '=' . urlencode($value);
                } else {
                    $query .= $key;
                }
            } else {
                foreach ($value as $assoc_key => $single) {
                    if (strlen($query) > 0) {
                        $query .= '&';
                    }

                    if (is_string($assoc_key) === true) {
                        $query .= $key . '[' . $assoc_key . ']=' . urlencode($single);
                    } else {
                        $query .= $key . '[]=' . urlencode($single);
                    }
                }
            }
        }

        return $query;
    }
}
?>
<?php
/**
 * Interface for URLs.
 *
 * @package     stubbles
 * @subpackage  peer
 * @version     $Id: stubURLContainer.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Interface for URLs.
 *
 * @package     stubbles
 * @subpackage  peer
 */
interface stubURLContainer extends stubObject
{
    /**
     * Checks whether URL is a correct URL.
     *
     * @return  bool
     */
    public function isValid();

    /**
     * checks whether host of url is listed in dns
     *
     * @return  bool
     */
    public function checkDNS();

    /**
     * checks whether the url uses a default port or not
     *
     * @return  bool
     */
    public function hasDefaultPort();

    /**
     * returns the url
     *
     * @param   bool    $port  optional  true if port should be within returned url string
     * @return  string
     */
    public function get($port = false);

    /**
     * set the protocol scheme
     *
     * @param  string  $scheme
     */
    public function setScheme($scheme);

    /**
     * returns the scheme of the url
     *
     * @return  string
     */
    public function getScheme();

    /**
     * returns the user
     *
     * @param   string  $defaultUser  optional  user to return if no user is set
     * @return  string
     */
    public function getUser($defaultUser = null);
    /**
     * returns the password
     *
     * @param   string  $defaultPassword  optional  password to return if no password is set
     * @return  string
     */
    public function getPassword($defaultPassword = null);

    /**
     * returns hostname of the url
     *
     * @param   string  $defaultHost  optional  default host to return if no host is defined
     * @return  string
     */
    public function getHost($defaultHost = null);

    /**
     * sets the port
     *
     * @param  int  $port
     */
    public function setPort($port);

    /**
     * returns port of the url
     *
     * @param   int     $defaultPort  optional  port to be used if no port is defined
     * @return  string
     */
    public function getPort($defaultPort = null);

    /**
     * returns path of the url
     *
     * @return  string
     */
    public function getPath();

    /**
     * checks whether url has a query
     *
     * @return  bool
     */
    public function hasQuery();

    /**
     * add a parameter to the url
     *
     * @param   string            $key    name of parameter
     * @param   mixed             $value  value of parameter
     * @return  stubURLContainer
     * @throws  stubIllegalArgumentException
     */
    public function addParam($key, $value);

    /**
     * remove a param from url
     *
     * @param   string   $key    name of parameter
     * @return  stubURL
     * @since   1.1.2
     */
    public function removeParam($key);

    /**
     * checks whether a certain param is set
     *
     * @param   string  $key
     * @return  bool
     * @since   1.1.2
     */
    public function hasParam($key);

    /**
     * returns the value of a param
     *
     * @param   string  $name          name of the param
     * @param   mixed   $defaultValue  optional  default value to return if param is not set
     * @return  mixed
     */
    public function getParam($name, $defaultValue = null);
}
?><?php
/**
 * Holds a reference to another exception.
 *
 * @package     stubbles
 * @subpackage  php_serializer
 * @version     $Id: stubExceptionReference.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubChainedException');
/**
 * Holds a reference to another exception.
 *
 * @package     stubbles
 * @subpackage  php_serializer
 */
class stubExceptionReference extends stubChainedException
{
    /**
     * name of referenced exception
     *
     * @var  string
     */
    protected $exceptionName;
    /**
     * the stack trace of the referenced exception
     *
     * @var  array<string,scalar>
     */
    protected $stackTrace = array();

    /**
     * sets the name of the referenced exception
     *
     * @param  string  $exceptionName
     */
    public function setReferencedExceptionName($exceptionName)
    {
        $this->exceptionName = $exceptionName;
    }

    /**
     * returns the name of the referenced exception
     *
     * @return  string
     */
    public function getReferencedExceptionName()
    {
        return $this->exceptionName;
    }

    /**
     * sets the stack trace of the referenced exception
     *
     * @param  array<string,scalar>  $stackTrace
     */
    public function setReferencedStackTrace(array $stackTrace)
    {
        $this->stackTrace = $stackTrace;
    }

    /**
     * returns the referenced stack trace
     *
     * @return  array<string,scalar>
     */
    public function getReferencedStackTrace()
    {
        return $this->stackTrace;
    }
}
?><?php
/**
 * Exception to be thrown in case the serialized format contains unknown data.
 * 
 * @package     stubbles
 * @subpackage  php_serializer
 * @version     $Id: stubFormatException.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Exception to be thrown in case the serialized format contains unknown data.
 * 
 * @package     stubbles
 * @subpackage  php_serializer
 */
class stubFormatException extends stubException
{
    // intentionally empty
}
?><?php
/**
 * Helper class to operate on strings containing serialized data.
 * 
 * @package     stubbles
 * @subpackage  php_serializer
 * @version     $Id: stubPHPSerializedData.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Helper class to operate on strings containing serialized data.
 * 
 * Taken from the XP frameworks's class remote.protocol.SerializedData.
 * 
 * @package     stubbles
 * @subpackage  php_serializer
 */
class stubPHPSerializedData extends stubBaseObject
{
    /**
     * the serialized data itself
     *
     * @var  string
     */
    protected $data;
    /**
     * the offset where we currently are
     *
     * @var  int
     */
    protected $offset = 0;

    /**
     * constructor
     *
     * @param  string  $data  the serialized data
     */
    public function __construct($data)
    {
        $this->data = $data;
    }

    /**
     * returns the current offset
     *
     * @return  int
     */
    public function getOffset()
    {
        return $this->offset;
    }

    /**
     * move the offset for given length
     *
     * @param  int  $length  optional
     */
    public function moveOffset($length = 1)
    {
        $this->offset += $length;
    }

    /**
     * returns the character at the given offset
     *
     * @param   int   $offset
     * @return  char
     */
    public function getCharAt($offset)
    {
        return $this->data{$offset};
    }

    /**
     * returns a subpart of the data
     *
     * @param   int     $start
     * @param   int     $end
     * @return  string
     */
    public function getSubData($start, $end)
    {
        return substr($this->data, $start, ($end - $start));
    }

    /**
     * consume a string ([length]:"[string]")
     * 
     * @return  string
     */
    public function consumeString()
    {
        $length        = substr($this->data, $this->offset, strpos($this->data, ':', $this->offset) - $this->offset);
        $bound         = strlen($length) + 2;       // 1 for ':', 1 for '"'
        $value         = substr($this->data, $this->offset + $bound, $length);
        $this->offset += $bound + $length + 2; // 1 for '"', +1 to set the marker behind
        return $value;
    }

    /**
     * consume everything up to the next ";" and return it
     * 
     * @return  string
     */
    public function consumeWord()
    {
        $value         = substr($this->data, $this->offset, strpos($this->data, ';', $this->offset) - $this->offset);
        $this->offset += strlen($value) + 1;  // +1 to set the marker behind
        return $value;
    }

    /**
     * consume everything up to the next ":" character and return it
     * 
     * @return  string
     */
    public function consumeSize()
    {
        $value         = substr($this->data, $this->offset, @strpos($this->data, ':', $this->offset) - $this->offset);
        $this->offset += strlen($value) + 1;  // +1 to set the marker behind
        return $value;
    }
}
?><?php
/**
 * Class that serializes arbitrary data into the format used by PHP's (un)serialize function.
 * 
 * @package     stubbles
 * @subpackage  php_serializer
 * @version     $Id: stubPHPSerializer.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::php::serializer::stubFormatException',
                      'net::stubbles::php::serializer::stubPHPSerializedData',
                      'net::stubbles::php::serializer::stubPHPSerializerMapping',
                      'net::stubbles::php::serializer::stubPHPSerializerObjectMapping',
                      'net::stubbles::php::serializer::stubPHPSerializerSPLSerializableMapping',
                      'net::stubbles::php::serializer::stubUnknownObject',
                      'net::stubbles::reflection::stubReflectionObject'
);
/**
 * Class that serializes arbitrary data into the format used by PHP's (un)serialize function.
 * 
 * You should not use this class for serializing in PHP only environments, use
 * serialize() and unserialize() directly in such cases. This class is to be used
 * when the format needs to be extended.
 * 
 * Taken from the XP frameworks's class remote.protocol.Serializer.
 * 
 * @package     stubbles
 * @subpackage  php_serializer
 */
class stubPHPSerializer extends stubBaseObject
{
    /**
     * mapping of data types
     *
     * @var  array<char,stubPHPSerializerMapping>
     */
    protected $mappings             = array();
    /**
     * a cache for class mappings
     *
     * @var  array<string,stubPHPSerializerMapping>
     */
    protected $classMappingCache    = array();
    /**
     * mapping for default objects
     *
     * @var  stubPHPSerializerObjectMapping
     */
    protected $defaultObjectMapping;
    /**
     * mapping of packages
     *
     * @var  array<string,string>
     */
    protected $packageMapping       = array();
    /**
     * mapping of exceptions
     *
     * @var  array<string,string>
     */
    protected $exceptionMapping     = array();

    /**
     * constructor
     */
    public function __construct()
    {
        // default mapper can not be added to mapping because there is no
        // common root class for PHP classes
        $this->defaultObjectMapping = new stubPHPSerializerObjectMapping();
        
        // add mapping for classes implementing the Serializable interface from SPL
        $this->addMapping(new stubPHPSerializerSPLSerializableMapping());
    }

    /**
     * register a mapping
     * 
     * Be careful when adding mappings that may apply to the same class: later
     * added mappings with same distance are favoroured about earlier added
     * mappings.
     *
     * @param  stubPHPSerializerMapping  $mapping  the mapping to add
     * @param  char                      $token    optional  token to use instead of the default token
     */
    public function addMapping(stubPHPSerializerMapping $mapping, $token = null)
    {
        if (null === $token) {
            $token = $mapping->getToken();
        }
        
        $this->mappings[$token]  = $mapping;
        $this->classMappingCache = array();
    }

    /**
     * fetch best fitted mapper for the given object
     *
     * @param   object  $object               the object to retrieve the mapping for
     * @return  stubPHPSerializerMapping
     * @throws  stubIllegalArgumentException
     */
    public function findMappingFor($object)
    {
        if (is_object($object) == false) {
            throw new stubIllegalArgumentException('Can only retrieve mappings for objects.');
        }
        
        $fqClassName = (($object instanceof stubObject) ? ($object->getClassName()) : (get_class($object)));
        // Check the mapping-cache for an entry for this object's class
        if (isset($this->classMappingCache[$fqClassName]) == true) {
            return $this->classMappingCache[$fqClassName];
        }
        
        // Find most suitable mapping by calculating the distance in the inheritance
        // tree of the object's class to the class being handled by the mapping.
        $cinfo = array();
        $class = (($object instanceof stubObject) ? ($object->getClass()) : (new stubReflectionObject($object)));
        foreach ($this->mappings as $mapping) {
            $refClass     = $mapping->getHandledClass();
            $refClassName = $refClass->getName();
            if (($object instanceof $refClassName) === false) {
                continue;
            }
            
            $distance    = 0;
            $objectClass = $class;
            do {
                // check for direct match
                if ($refClass->getName() != $objectClass->getName()) {
                    $distance++;
                }
            } while (0 < $distance && null !== ($objectClass = $objectClass->getParentClass()));
            
            // register distance to object's class in cinfo
            $cinfo[$distance] = $mapping;
    
            if (isset($cinfo[0]) == true) {
                break;
            }
        }
        
        // no handlers found
        if (0 == count($cinfo)) {
            return null;
        }
    
        ksort($cinfo, SORT_NUMERIC);
        // first class is best class
        // remember this, so we can take shortcut next time
        $this->classMappingCache[$fqClassName] = $cinfo[key($cinfo)];
        return $this->classMappingCache[$fqClassName];
    }

    /**
     * add a package mapping
     *
     * @param  string  $localPackage   name of the package locally
     * @param  string  $remotePackage  name of the package on remote server
     */
    public function addPackageMapping($localPackage, $remotePackage)
    {
        $this->packageMapping[$remotePackage] = $localPackage;
    }

    /**
     * returns locale package name for given remote package
     *
     * @param   string  $remotePackage
     * @return  string
     */
    public function translateToLocalePackage($remotePackage)
    {
        return strtr($remotePackage, $this->packageMapping);
    }

    /**
     * add an exception mapping
     *
     * @param  string  $localException   name of the exception locally
     * @param  string  $remoteException  name of the exception on remote server
     */
    public function addExceptionMapping($localException, $remoteException)
    {
        $this->exceptionMapping[$localException] = $remoteException;
    }

    /**
     * returns the local exception for a given remote exception
     * 
     * If none is found net::stubbles::php::serializer::stubExceptionReference
     * will be used instead.
     *
     * @param   string  $remoteException  name of the exception to use instead
     * @return  string
     */
    public function getLocalException($remoteException)
    {
        $localException = array_search($remoteException, $this->exceptionMapping);
        if (false === $localException) {
            return 'net::stubbles::php::serializer::stubExceptionReference';
        }
        
        return $localException;
    }

    /**
     * returns the full qualified classname of the remote exception to use
     * instead of the local exception
     *
     * If none is found the return value is null.
     *
     * @param   string  $localException  name of the exception locally
     * @return  string
     */
    public function getRemoteException($localException)
    {
        if (isset($this->exceptionMapping[$localException]) === true) {
            return $this->exceptionMapping[$localException];
        }
        
        return null;
    }
    /**
     * serialize data into PHP's serialize() format
     *
     * @param   mixed                $data     the data to serialize
     * @param   array<string,mixed>  $context  optional  context data
     * @return  string
     * @throws  stubFormatException if an error is encountered in the format
     */
    public function serialize($data, array $context = array())
    {
        $type = gettype($data);
        switch ($type) {
            case 'NULL':
                return 'N;';
            
            case 'boolean':
                return 'b:' . (true === $data ? 1 : 0) . ';';

            case 'integer':
                return 'i:' . $data . ';';
            
            case 'double':
                return 'd:' . $data . ';';
            
            case 'string':
                return 's:' . strlen($data) . ':"' . $data . '";';
            
            case 'array':
                $s = 'a:' . sizeof($data) . ':{';
                foreach (array_keys($data) as $key) {
                    $s .= serialize($key) . $this->serialize($data[$key], $context);
                }
                
                return $s . '}';
            
            case 'resource':
                return ''; // ignore (resources can't be serialized)

            case 'object':
                $mapping = $this->findMappingFor($data);
                if (null !== $mapping) {
                    return $mapping->serialize($this, $data, $context);
                }

                return $this->defaultObjectMapping->serialize($this, $data, $context);

            default:
                throw new stubFormatException('Cannot serialize unknown type ' . $type);
        }
    }

    /**
     * Retrieve serialized representation of a variable
     *
     * @param   stubPHPSerializedData  $serialized
     * @param   array<string,mixed>    $context     optional  context data
     * @return  mixed
     * @throws  stubFormatException
     */
    public function unserialize(stubPHPSerializedData $serialized, array $context = array())
    {
        $start = $serialized->getOffset();
        $token = $serialized->getCharAt($start);
        switch ($token) {
            case 'N':
                // null
                $serialized->moveOffset(2);
                return null;
            
            case 'b':
                // booleans
                $serialized->moveOffset(2);
                return (bool) $serialized->consumeWord();
            
            case 'i':
                // integers
                $serialized->moveOffset(2);
                return (int) $serialized->consumeWord();
            
            case 'd':
                // decimals
                $serialized->moveOffset(2);
                return (float) $serialized->consumeWord();
            
            case 's':
                // strings
                $serialized->moveOffset(2);
                return $serialized->consumeString();

            case 'a':
                // arrays
                $serialized->moveOffset(2);
                $a    = array();
                $size = $serialized->consumeSize();
                $serialized->moveOffset();   // opening "{"
                for ($i = 0; $i < $size; $i++) {
                    $key     = $this->unserialize($serialized, $context);
                    $a[$key] = $this->unserialize($serialized, $context);
                }
                
                $serialized->moveOffset();  // closing "}"
                return $a;
            
            case 'O':
                // objects
                return $this->defaultObjectMapping->unserialize($this, $serialized, $context);

            default:
                // default, check if we have a mapping
                if (isset($this->mappings[$token]) == false) {
                    throw new stubFormatException('Cannot unserialize unknown type "' . $token . '" (' . $serialized . ')');
                }

                return $this->mappings[$token]->unserialize($this, $serialized, $context);
        }
    }

}
?><?php
/**
 * Interface for mapping the serializing of objects.
 * 
 * @package     stubbles
 * @subpackage  php_serializer
 * @version     $Id: stubPHPSerializerMapping.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Interface for mapping the serializing of objects.
 * 
 * A serializer mapping takes control over how an object is serialized and
 * unserialized. It is responsible for one specific class.
 * 
 * Taken from the XP frameworks's interface remote.protocol.SerializerMapping.
 * 
 * @package     stubbles
 * @subpackage  php_serializer
 */
interface stubPHPSerializerMapping extends stubObject
{
    /**
     * returns the token to be used by this mapping
     *
     * The token may be any string, but a simple char is preferred to keep
     * descriptional data within the serialized data small.
     *
     * @return  string
     */
    public function getToken();

    /**
     * return reflection instance of mapped class
     *
     * @return  ReflectionClass
     */
    public function getHandledClass();

    /**
     * Returns an on-the-wire representation of the given object
     *
     * @param   stubPHPSerializer    $serializer
     * @param   object               $object
     * @param   array<string,mixed>  $context     optional  context data
     * @return  string
     */
    public function serialize(stubPHPSerializer $serializer, $object, array $context = array());

    /**
     * returns a value for the given serialized string
     *
     * @param   stubPHPSerializer      $serializer  the serializer instance
     * @param   stubPHPSerializedData  $serialized  the serialized data
     * @param   array<string,mixed>    $context     optional  context data
     * @return  mixed
     */
    public function unserialize(stubPHPSerializer $serializer, stubPHPSerializedData $serialized, array $context = array());
}
?><?php
/**
 * Class for default serialization of objects.
 * 
 * @package     stubbles
 * @subpackage  php_serializer
 * @version     $Id: stubPHPSerializerObjectMapping.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::php::serializer::stubPHPSerializerMapping'
);
/**
 * Class for default serialization of objects.
 * 
 * @package     stubbles
 * @subpackage  php_serializer
 */
class stubPHPSerializerObjectMapping extends stubBaseObject implements stubPHPSerializerMapping
{
    /**
     * the class to handle with this mapping
     *
     * @var  ReflectionClass
     */
    protected static $handledClass = null;

    /**
     * returns the token to be used by this mapping
     *
     * @return  string
     */
    public function getToken()
    {
        return 'O';
    }

    /**
     * return reflection instance of mapped class
     *
     * @return  ReflectionClass
     */
    public function getHandledClass()
    {
        if (null === self::$handledClass) {
            self::$handledClass = new ReflectionClass('stdClass');
        }
        
        return self::$handledClass;
    }

    /**
     * Returns an on-the-wire representation of the given object
     *
     * @param   stubPHPSerializer    $serializer  the serializer instance
     * @param   object               $object      the object to serialize
     * @param   array<string,mixed>  $context     optional  context data
     * @return  string
     * @throws  stubIllegalArgumentException
     */
    public function serialize(stubPHPSerializer $serializer, $object, array $context = array())
    {
        if (is_object($object) === false) {
            throw new stubIllegalArgumentException('Can only serialize objects.');
        }
        
        $className  = get_class($object);
        // casting the object to an array gives us access to protected
        // and private properties as well
        $properties = (array) $object;
        if (method_exists($object, '__sleep') == true) {
            $propsToSerialize = $object->__sleep();
        } else {
            $propsToSerialize = array_keys($properties);
        }
        
        $s = 'O:' . strlen($className) . ':"' . $className . '":' . sizeof($propsToSerialize) . ':{';
        foreach (array_keys($properties) as $propertyName) {
            if (in_array($propertyName, $propsToSerialize) == false
                && in_array($this->removeAccessInfoFromPropertyName($propertyName), $propsToSerialize) == false) {
                continue;
            }
            
            $s .= serialize($propertyName) . $serializer->serialize($properties[$propertyName], $context);
        }
        
        return $s . '}';
    }

    /**
     * helper method to remove access information from the property name string
     *
     * @param   string  $propertyName
     * @return  string
     */
    protected function removeAccessInfoFromPropertyName($propertyName)
    {
        if ("\0" !== $propertyName{0}) {
            return $propertyName;
        }
        
        return substr($propertyName, strrpos($propertyName, "\0") + 1);
    }

    /**
     * returns a value for the given serialized string
     *
     * @param   stubPHPSerializer      $serializer  the serializer instance
     * @param   stubPHPSerializedData  $serialized  the serialized data
     * @param   array<string,mixed>    $context     optional  context data
     * @return  mixed
     * @throws  stubFormatException
     */
    public function unserialize(stubPHPSerializer $serializer, stubPHPSerializedData $serialized, array $context = array())
    {
        $serialized->moveOffset(2); // token
        $className = $serialized->consumeString();
        $size      = $serialized->consumeSize();
        $serialized->moveOffset();  // opening "{"
        if (class_exists($className, false) == false) {
            $instance = new stubUnknownObject($className, $this->unserializeProperties($serializer, $serialized, $context, $size));
        } else {
            $refClass = new ReflectionClass($className);
            if ($refClass->hasMethod('__set_state') == false) {
                // throw away property data, just move the pointer to the end
                $this->unserializeProperties($serializer, $serialized, $context, $size);
                // use php's native unserialize -> won't work if the object
                // contains properties which have been serialized with another
                // mapping
                $instance = @unserialize($serialized->getSubData($start, $serialized->getOffset() + 1));
                if (false === $instance) {
                    throw new stubFormatException('Cannot unserialize type "' . $className . '" (' . $serialized . '), contains invalid serialized data.');
                }
            } else {
                $instance = call_user_func_array(array($className, '__set_state'), array($this->unserializeProperties($serializer, $serialized, $context, $size, true)));
            }
            
            if (method_exists($instance, '__wakeup') == true) {
                $instance->__wakeup();
            }
        }
        
        $serialized->moveOffset(); // closing "}"
        return $instance;
    }

    /**
     * strips all members out of the serialized data
     *
     * @param   stubPHPSerializer      $serializer    the serializer instance
     * @param   stubPHPSerializedData  $serialized    the serialized data
     * @param   array<string,mixed>    $context       context data
     * @param   int                    $propertySize  number of properties
     * @param   bool                   $stripAccess   optional  whether to strip access informations from member names or nor
     * @return  array<string,mixed>
     */
    protected function unserializeProperties(stubPHPSerializer $serializer, stubPHPSerializedData $serialized, array $context, $propertySize, $stripAccess = false)
    {
        $properties = array();
        for ($i = 0; $i < $propertySize; $i++) {
            $propertyName = $serializer->unserialize($serialized, $context);
            if (true === $stripAccess && "\0" == $propertyName{0}) {
                $propertyName = $this->removeAccessInfoFromPropertyName($propertyName);
            }
            
            $properties[$propertyName] = $serializer->unserialize($serialized, $context);
        }
        
        return $properties;
    }
}
?><?php
/**
 * Class for serialization of objects that implement the SPL Serializable interface.
 * 
 * @package     stubbles
 * @subpackage  php_serializer
 * @version     $Id: stubPHPSerializerSPLSerializableMapping.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::php::serializer::stubPHPSerializerMapping'
);
/**
 * Class for serialization of objects that implement the SPL Serializable interface.
 * 
 * @package     stubbles
 * @subpackage  php_serializer
 * @link        http://www.php.net/~helly/php/ext/spl/interfaceSerializable.html
 */
class stubPHPSerializerSPLSerializableMapping extends stubBaseObject implements stubPHPSerializerMapping
{
    /**
     * the class to handle with this mapping
     *
     * @var  ReflectionClass
     */
    protected static $handledClass = null;

    /**
     * returns the token to be used by this mapping
     *
     * @return  string
     */
    public function getToken()
    {
        return 'C';
    }

    /**
     * return reflection instance of mapped class
     *
     * @return  ReflectionClass
     */
    public function getHandledClass()
    {
        if (null === self::$handledClass) {
            self::$handledClass = new ReflectionClass('Serializable');
        }
        
        return self::$handledClass;
    }

    /**
     * Returns an on-the-wire representation of the given object
     *
     * @param   stubPHPSerializer    $serializer
     * @param   object               $object
     * @param   array<string,mixed>  $context     optional  context data
     * @return  string
     * @throws  stubIllegalArgumentException
     */
    public function serialize(stubPHPSerializer $serializer, $object, array $context = array())
    {
        if (($object instanceof Serializable) === false) {
            throw new stubIllegalArgumentException($this->getClassName() . ' can only serialize objects of instance Serializable.');
        }
        
        return serialize($object);
    }

    /**
     * returns a value for the given serialized string
     *
     * @param   stubPHPSerializer      $serializer  the serializer instance
     * @param   stubPHPSerializedData  $serialized  the serialized data
     * @param   array<string,mixed>    $context     optional  context data
     * @return  mixed
     * @throws  stubFormatException
     */
    public function unserialize(stubPHPSerializer $serializer, stubPHPSerializedData $serialized, array $context = array())
    {
        $offset    = $serialized->getOffset();
        $serialized->moveOffset(2); // token
        $className = $serialized->consumeString();
        $size      = (int) $serialized->consumeSize();
        //                      C   :   info about classname length  :   classname          in "  :   info about data size : data in {}
        $endOffset = ($offset + 1 + 1 + strlen(strlen($className)) + 1 + strlen($className) + 2 + 1 + strlen($size) + 1 + $size + 2);
        $data      = $serialized->getSubData($offset, $endOffset);
        $serialized->moveOffset($size + strlen($className) + 1); // closing "}"
        $instance = @unserialize($data);
        if (false === $instance) {
            throw new stubFormatException('Cannot unserialize type "' . $className . '" (' . $serialized . '), contains invalid serialized data.');
        }
        
        return $instance;
    }
}
?><?php
/**
 * Represents an unserialized object where the appropriate class was not loaded.
 * 
 * @package     stubbles
 * @subpackage  php_serializer
 * @version     $Id: stubUnknownObject.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalAccessException');
/**
 * Represents an unserialized object where the appropriate class was not loaded.
 * 
 * Taken from the XP frameworks's class remote.UnknownRemoteObject.
 * 
 * @package     stubbles
 * @subpackage  php_serializer
 */
class stubUnknownObject extends stubBaseObject
{
    /**
     * name of the unknown class
     *
     * @var  string
     */
    protected $name;
    /**
     * properties of the unknown class
     *
     * @var  array<string,mixed>
     */
    protected $properties;

    /**
     * constructor
     *
     * @param  string               $name        name of the unknown class
     * @param  array<string,mixed>  $properties  properties of the unknown class
     */
    public function __construct($name, $properties)
    {
        $this->name       = $name;
        $this->properties = $properties;
    }

    /**
     * returns the name of the unknown class
     *
     * @return  string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * returns the properties of the unknown class
     *
     * @return  array<string,mixed>
     */
    public function getProperties()
    {
        return $this->properties;
    }

    /**
     * member set interceptor
     *
     * @param   string  $name
     * @param   mixed   $value
     * @throws  stubIllegalAccessException
     */
    public function __set($name, $value)
    {
        throw new stubIllegalAccessException('Access to undefined member "' . $name . '"');
    }

    /**
     * member get interceptor
     *
     * @param   string  $name
     * @throws  stubIllegalAccessException
     */
    public function __get($name)
    {
        throw new stubIllegalAccessException('Access to undefined member "' . $name . '"');
    }

    /**
     * method call interceptor
     *
     * @param   string  $name
     * @param   array   $args
     * @throws  stubIllegalAccessException
     */
    public function __call($name, $args)
    {
        throw new stubIllegalAccessException('Cannot call method "' . $name . '" on an unknown object');
    }

    /**
     * clone interceptor
     *
     * @throws  stubIllegalAccessException
     */
    public function __clone()
    {
        throw new stubIllegalAccessException('Cannot clone an unknown object');
    }
}
?><?php
/**
 * Base implementation for an encoder/decoder that decorates other en-/decoders.
 *
 * @package     stubbles
 * @subpackage  php_string
 * @version     $Id: stubAbstractDecoratedStringEncoder.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubMethodNotSupportedException',
                      'net::stubbles::php::string::stubAbstractStringEncoder'
);
/**
 * Base implementation for an encoder/decoder that decorates other en-/decoders.
 *
 * @package     stubbles
 * @subpackage  php_string
 */
abstract class stubAbstractDecoratedStringEncoder extends stubAbstractStringEncoder
{
    /**
     * the decorated encoder
     *
     * @var  stubStringEncoder
     */
    protected $encoder;

    /**
     * constructor
     *
     * @param  stubStringEncoder  $encoder  the encoder to apply recursively
     */
    public function __construct(stubStringEncoder $encoder)
    {
        $this->encoder = $encoder;
    }

    /**
     * redirect method calls for non-existing methods to the decorated encoder
     *
     * @param   string  $method     the method to call
     * @param   array   $arguments  the arguments for the method call
     * @return  mixed   return value of the method call
     * @throws  stubMethodNotSupportedException
     */
    public function __call($method, $arguments)
    {
        if (is_callable(array($this->encoder, $method)) === true) {
            return call_user_func_array(array($this->encoder, $method), $arguments);
        }
        
        throw new stubMethodNotSupportedException('The method ' . $method . ' is not supported by ' . $this->encoder->getClassName());
    }
}
?><?php
/**
 * Abstract base implementation for string encoders.
 *
 * @package     stubbles
 * @subpackage  php_string
 * @version     $Id: stubAbstractStringEncoder.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::php::string::stubStringEncoder'
);
/**
 * Abstract base implementation for string encoders.
 *
 * @package     stubbles
 * @subpackage  php_string
 */
abstract class stubAbstractStringEncoder extends stubBaseObject implements stubStringEncoder
{
    /**
     * applies the encoder with the given mode
     *
     * A MethodNotSupportedException is thrown in case the encoder does not
     * support decoding a string.
     *
     * @param   string  $string
     * @param   int     $mode
     * @return  string
     * @throws  stubIllegalArgumentException
     */
    public function apply($string, $mode)
    {
        switch ($mode) {
            case stubStringEncoder::MODE_ENCODE:
                return $this->encode($string);
            
            case stubStringEncoder::MODE_DECODE:
                return $this->decode($string);
            
            default:
                throw new stubIllegalArgumentException('Invalid mode.');
        }
    }

    /**
     * checks whether an encoding is reversible or not
     *
     * @return  bool
     */
    public function isReversible()
    {
        return true;
    }
}
?><?php
/**
 * Encoder/decoder for base64.
 *
 * @package     stubbles
 * @subpackage  php_string
 * @version     $Id: stubBase64Encoder.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::php::string::stubAbstractStringEncoder');
/**
 * Encoder/decoder for base64.
 *
 * @package     stubbles
 * @subpackage  php_string
 */
class stubBase64Encoder extends stubAbstractStringEncoder
{
    /**
     * encodes a string
     *
     * @param   string  $string
     * @return  string
     */
    public function encode($string)
    {
        return base64_encode($string);
    }

    /**
     * decodes a string
     *
     * @param   string  $string
     * @return  string
     */
    public function decode($string)
    {
        return base64_decode($string);
    }
}
?><?php
/**
 * Encoder/decoder for special HTML characters.
 *
 * @package     stubbles
 * @subpackage  php_string
 * @version     $Id: stubHTMLSpecialCharsEncoder.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::php::string::stubAbstractStringEncoder'
);
/**
 * Encoder/decoder for special HTML characters.
 *
 * @package     stubbles
 * @subpackage  php_string
 * @see         http://php.net/htmlspecialchars
 */
class stubHTMLSpecialCharsEncoder extends stubAbstractStringEncoder
{
    /**
     * style for how to encode quotes
     *
     * @var  int
     */
    protected $quoteStyle   = ENT_QUOTES;
    /**
     * the charset to use for the encoding
     *
     * @var  string
     */
    protected $charset      = 'UTF-8';
    /**
     * switch whether to encode already encoded parts again
     *
     * @var  bool
     */
    protected $doubleEncode = false;

    /**
     * sets the quote style to use
     *
     * @param   int  $quoteStyle
     * @throws  stubIllegalArgumentException
     */
    public function setQuoteStyle($quoteStyle)
    {
        if (in_array($quoteStyle, array(ENT_QUOTES, ENT_NOQUOTES, ENT_COMPAT)) === false) {
            throw new stubIllegalArgumentException('Quote style must be one of ENT_QUOTES, ENT_NOQUOTES or ENT_COMPAT.');
        }
        
        $this->quoteStyle = $quoteStyle;
    }

    /**
     * character set used for encoding
     * 
     * See http://php.net/htmlspecialchars for a list of supported character
     * sets. Unrecognized charsets will fall back to ISO-8859-1.
     *
     * @param  string  $charset
     */
    public function setCharset($charset)
    {
        $this->charset = $charset;
    }

    /**
     * sets whether already encoded parts should be encoded again or not
     *
     * @param  bool  $doubleEncode
     */
    public function setDoubleEncode($doubleEncode)
    {
        $this->doubleEncode = (bool) $doubleEncode;
    }

    /**
     * encodes a string
     *
     * @param   string  $string
     * @return  string
     */
    public function encode($string)
    {
        if (version_compare(PHP_VERSION, '5.2.3') === -1) {
            return htmlspecialchars($string, $this->quoteStyle, $this->charset);
        }
        
        return htmlspecialchars($string, $this->quoteStyle, $this->charset, $this->doubleEncode);
    }

    /**
     * decodes a string
     *
     * @param   string  $string
     * @return  string
     */
    public function decode($string)
    {
        return htmlspecialchars_decode($string, $this->quoteStyle);
    }
}
?><?php
/**
 * Class containing a localized string.
 *
 * @package     stubbles
 * @subpackage  php_string
 * @version     $Id: stubLocalizedString.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Class containing a localized string.
 *
 * @package     stubbles
 * @subpackage  php_string
 * @XMLTag(tagName='string')
 */
class stubLocalizedString extends stubBaseObject
{
    /**
     * locale of the message
     *
     * @var  string
     */
    protected $locale;
    /**
     * content of the message
     *
     * @var  string
     */
    protected $message;

    /**
     * constructor
     *
     * @param  string  $locale
     * @param  string  $message
     */
    public function __construct($locale, $message)
    {
        $this->locale  = $locale;
        $this->message = $message;
    }

    /**
     * returns the locale of the message
     *
     * @return  string
     * @XMLAttribute(attributeName='locale')
     */
    public function getLocale()
    {
        return $this->locale;
    }

    /**
     * returns the content of the message
     *
     * @return  string
     * @XMLTag(tagName='content')
     */
    public function getMessage()
    {
        return $this->message;
    }
}
?><?php
/**
 * Encoder for md5.
 *
 * @package     stubbles
 * @subpackage  php_string
 * @version     $Id: stubMd5Encoder.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::php::string::stubAbstractStringEncoder');
/**
 * Encoder for md5.
 *
 * @package     stubbles
 * @subpackage  php_string
 */
class stubMd5Encoder extends stubAbstractStringEncoder
{
    /**
     * prefix of the value to filter
     *
     * @var  string
     */
    protected $prefix = '';
    /**
     * postfix of the value to filter
     *
     * @var  string
     */
    protected $postfix = '';

    /**
     * constructor
     *
     * @param  string  $prefix   prefix of the value to filter
     * @param  string  $postfix  postfix of the value to filter
     */
    public function __construct($prefix = '', $postfix = '')
    {
        $this->setPrefix($prefix);
        $this->setPostfix($postfix);
    }

    /**
     * sets the prefix
     *
     * @param  string  $prefix  prefix of the value to filter
     */
    public function setPrefix($prefix)
    {
        $this->prefix = $prefix;
    }

    /**
     * sets the postfix
     *
     * @param  string  $postfix  postfix of the value to filter
     */
    public function setPostfix($postfix)
    {
        $this->postfix = $postfix;
    }

    /**
     * encodes a string
     *
     * @param   string  $string
     * @return  string
     */
    public function encode($string)
    {
        return md5($this->prefix . $string . $this->postfix);
    }

    /**
     * decodes a string
     *
     * @param   string  $string
     * @return  string
     * @throws  stubMethodNotSupportedException
     */
    public function decode($string)
    {
        throw new stubMethodNotSupportedException('Can not decode md5-encoded string ' . $string . ', encoding is not reversible.');
    }

    /**
     * checks whether an encoding is reversible or not
     *
     * @return  bool
     */
    public function isReversible()
    {
        return false;
    }
}
?><?php
/**
 * Encoder/decoder that decorates other en-/decoders and applies the en-/decoding
 * recursively if the value to en-/decode is an array or object.
 *
 * @package     stubbles
 * @subpackage  php_string
 * @version     $Id: stubRecursiveStringEncoder.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::php::string::stubAbstractDecoratedStringEncoder');
/**
 * Encoder/decoder that decorates other en-/decoders and applies the en-/decoding
 * recursively if the value to en-/decode is an array or object.
 *
 * @package     stubbles
 * @subpackage  php_string
 */
class stubRecursiveStringEncoder extends stubAbstractDecoratedStringEncoder
{
    /**
     * encodes a value recursively
     *
     * @param   string  $string
     * @return  string
     */
    public function encode($string)
    {
        if (is_scalar($string) === true) {
            return $this->encoder->encode($string);
        }
        
        if (is_array($string) === true) {
            foreach ($string as $key => $val) {
                $string[$key] = $this->encode($val);
            }
        } elseif (is_object($string) === true) {
            foreach (get_object_vars($string) as $key => $val) {
                $string->$key = $this->encode($val);
            }
        }
        
        return $string;
    }

    /**
     * decodes a value recursively
     *
     * @param   string  $string
     * @return  string
     */
    public function decode($string)
    {
        if (is_scalar($string) === true) {
            return $this->encoder->decode($string);
        }
        
        if (is_array($string) === true) {
            foreach ($string as $key => $val) {
                $string[$key] = $this->decode($val);
            }
        } elseif (is_object($string) === true) {
            foreach (get_object_vars($string) as $key => $val) {
                $string->$key = $this->decode($val);
            }
        }
        
        return $string;
    }
}
?><?php
/**
 * Interface for string encoders.
 *
 * @package     stubbles
 * @subpackage  php_string
 * @version     $Id: stubStringEncoder.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubMethodNotSupportedException');
/**
 * Interface for string encoders.
 *
 * @package     stubbles
 * @subpackage  php_string
 */
interface stubStringEncoder extends stubObject
{
    /**
     * the mode to apply onto the string: encode the string
     *
     * @see  apply()
     */
    const MODE_ENCODE = 1;
    /**
     * the mode to apply onto the string: decode the string
     *
     * @see  apply()
     */
    const MODE_DECODE = 2;

    /**
     * applies the encoder with the given mode
     *
     * A MethodNotSupportedException is thrown in case the encoder does not
     * support decoding a string.
     *
     * @param   string  $string
     * @param   int     $mode
     * @return  string
     * @throws  stubMethodNotSupportedException
     */
    public function apply($string, $mode);

    /**
     * encodes a string
     *
     * @param   string  $string
     * @return  string
     */
    public function encode($string);

    /**
     * decodes a string
     *
     * @param   string  $string
     * @return  string
     * @throws  stubMethodNotSupportedException
     */
    public function decode($string);

    /**
     * checks whether an encoding is reversible or not
     *
     * @return  bool
     */
    public function isReversible();
}
?><?php
/**
 * Encoder/decoder for URLs.
 *
 * @package     stubbles
 * @subpackage  php_string
 * @version     $Id: stubURLEncoder.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::php::string::stubAbstractStringEncoder');
/**
 * Encoder/decoder for URLs.
 *
 * @package     stubbles
 * @subpackage  php_string
 */
class stubURLEncoder extends stubAbstractStringEncoder
{
    /**
     * encodes a string
     *
     * @param   string  $string
     * @return  string
     */
    public function encode($string)
    {
        return urlencode($string);
    }

    /**
     * decodes a string
     *
     * @param   string  $string
     * @return  string
     */
    public function decode($string)
    {
        return urldecode($string);
    }
}
?><?php
/**
 * Encoder/decoder for UTF-8.
 *
 * @package     stubbles
 * @subpackage  php_string
 * @version     $Id: stubUTF8Encoder.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::php::string::stubAbstractStringEncoder');
/**
 * Encoder/decoder for UTF-8.
 *
 * @package     stubbles
 * @subpackage  php_string
 */
class stubUTF8Encoder extends stubAbstractStringEncoder
{
    /**
     * encodes a string
     *
     * @param   string  $string
     * @return  string
     */
    public function encode($string)
    {
        // prevent that numbers, booleans or anything else will be converted
        // into a string
        if (is_string($string) === false) {
            return $string;
        }
        
        return utf8_encode($string);
    }

    /**
     * decodes a string
     *
     * @param   string  $string
     * @return  string
     */
    public function decode($string)
    {
        // prevent that numbers, booleans or anything else will be converted
        // into a string
        if (is_string($string) === false) {
            return $string;
        }
        
        return utf8_decode($string);
    }
}
?><?php
/**
 * Base class for a composition of several criteria.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 * @version     $Id: stubAbstractCompositeCriterion.php 2145 2009-03-29 12:47:02Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalStateException',
                      'net::stubbles::rdbms::criteria::stubCompositeCriterion'
);
/**
 * Base class for a composition of several criteria.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 */
abstract class stubAbstractCompositeCriterion extends stubBaseObject implements stubCompositeCriterion
{
    /**
     * the list of criteria
     *
     * @var  array<stubCriterion>
     */
    protected $criteria = array();

    /**
     * add a criterion to the composition
     *
     * @param   stubCriterion           $criterion
     * @return  stubCompositeCriterion
     */
    public function addCriterion(stubCriterion $criterion)
    {
        $this->criteria[] = $criterion;
        return $this;
    }

    /**
     * checks whether there is any criterion
     *
     * @return  bool
     */
    public function hasCriterion()
    {
        return (count($this->criteria) > 0);
    }

    /**
     * returns the criterion as sql
     * 
     * @return  string
     * @throws  stubIllegalStateException
     */
    public function toSQL()
    {
        if (count($this->criteria) == 0) {
            throw new stubIllegalStateException('Can not translate to sql: criterion does not have any criteria to connect.');
        }
        
        $sql = '(';
        foreach ($this->criteria as $key => $criterion) {
            if (0 < $key) {
                $sql .= ' ' . $this->getOperator() . ' ';
            }
            
            $sql .= $criterion->toSQL();
        }
        
        return $sql . ')';
    }

    /**
     * returns the the operator to connect the criteria
     *
     * @return  string
     */
    protected abstract function getOperator();
}
?><?php
/**
 * Base criterion class.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 * @version     $Id: stubAbstractCriterion.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::criteria::stubCriterion');
/**
 * Base criterion class.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 */
abstract class stubAbstractCriterion extends stubBaseObject implements stubCriterion
{
    /**
     * the name of the table where the field is in
     *
     * @var  string
     */
    protected $tableName;
    /**
     * the fieldname that contains the value to search for
     *
     * @var  string
     */
    protected $fieldName;
    /**
     * the value to search for
     *
     * @var  scalar
     */
    protected $searchValue;
    
    /**
     * constructor
     *
     * @param  string  $fieldName    the fieldname that contains the value to search for
     * @param  string  $searchValue  the value to search for
     * @param  string  $tableName    optional  the name of the table where the field is in
     */
    public function __construct($fieldName, $searchValue, $tableName = null)
    {
        $this->tableName   = $tableName;
        $this->fieldName   = $fieldName;
        $this->searchValue = $searchValue;
    }
    
    /**
     * returns the criterion as sql
     * 
     * @return  string
     */
    public function toSQL()
    {
        $sql = '`' . $this->fieldName . '` ' . $this->getOperator() . ' ' . $this->getSearchValue();
        if (null != $this->tableName) {
            $sql = '`' . $this->tableName . '`.' . $sql;
        }
        
        return $sql;
    }
    
    /**
     * returns the operator of the criteria
     *
     * @return  string
     */
    protected abstract function getOperator();
    
    /**
     * returns the the search value
     *
     * @return  string
     */
    protected function getSearchValue()
    {
        return "'" . $this->searchValue . "'";
    }
}
?><?php
/**
 * Composition of several criteria connected by AND.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 * @version     $Id: stubAndCriterion.php 2145 2009-03-29 12:47:02Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::criteria::stubAbstractCompositeCriterion');
/**
 * Composition of several criteria connected by AND.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 */
class stubAndCriterion extends stubAbstractCompositeCriterion
{
    /**
     * static constructor
     *
     * @return  stubAndCriterion
     */
    public static function create()
    {
        return new self();
    }

    /**
     * returns the the operator to connect the criteria
     *
     * @return  string
     */
    protected function getOperator()
    {
        return 'AND';
    }
}
?><?php
/**
 * Interface for a composition of several criteria.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 * @version     $Id: stubCompositeCriterion.php 2145 2009-03-29 12:47:02Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::criteria::stubCriterion');
/**
 * Interface for a composition of several criteria.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 */
interface stubCompositeCriterion extends stubCriterion
{
    /**
     * add a criterion to the composition
     *
     * @param   stubCriterion           $criterion
     * @return  stubCompositeCriterion
     */
    public function addCriterion(stubCriterion $criterion);
}
?><?php
/**
 * Interface for criteria.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 * @version     $Id: stubCriterion.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Interface for criteria.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 */
interface stubCriterion extends stubObject
{
    /**
     * returns the criterion as sql
     * 
     * @return  string
     */
    public function toSQL();
}
?><?php
/**
 * Criterion to check for equality.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 * @version     $Id: stubEqualCriterion.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::criteria::stubAbstractCriterion');
/**
 * Criterion to check for equality.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 */
class stubEqualCriterion extends stubAbstractCriterion
{
    /**
     * returns the operator of the criterion
     *
     * @return  string
     */
    protected function getOperator()
    {
        if (null !== $this->searchValue) {
            return '=';
        }
        
        return 'IS';
    }
    
    /**
     * returns the the search value
     *
     * @return  string
     */
    protected function getSearchValue()
    {
        if (null !== $this->searchValue) {
            return "'" . $this->searchValue . "'";
        }
        
        return 'NULL';
    }
}
?><?php
/**
 * Criterion to check for values equal to or greater than the search value.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 * @version     $Id: stubGreaterEqualCriterion.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::rdbms::criteria::stubAbstractCriterion'
);
/**
 * Criterion to check for values equal to or greater than the search value.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 */
class stubGreaterEqualCriterion extends stubAbstractCriterion
{
    /**
     * constructor
     *
     * @param   string  $fieldName    the fieldname that contains the value to search for
     * @param   string  $searchValue  the value to search for
     * @param   string  $tableName    optional  the name of the table where the field is in
     * @throws  stubIllegalArgumentException
     */
    public function __construct($fieldName, $searchValue, $tableName = null)
    {
        if (null === $searchValue) {
            throw new stubIllegalArgumentException('SeachValue for GREATER EQUAL criteria can not be NULL.');
        }
        
        parent::__construct($fieldName, $searchValue, $tableName);
    }
    
    /**
     * returns the operator of the criterion
     *
     * @return  string
     */
    protected function getOperator()
    {
        return '>=';
    }
}
?><?php
/**
 * Criterion to check for values greater than the search value.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 * @version     $Id: stubGreaterThanCriterion.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::rdbms::criteria::stubAbstractCriterion'
);
/**
 * Criterion to check for values greater than the search value.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 */
class stubGreaterThanCriterion extends stubAbstractCriterion
{
    /**
     * constructor
     *
     * @param   string  $fieldName    the fieldname that contains the value to search for
     * @param   string  $searchValue  the value to search for
     * @param   string  $tableName    optional  the name of the table where the field is in
     * @throws  stubIllegalArgumentException
     */
    public function __construct($fieldName, $searchValue, $tableName = null)
    {
        if (null === $searchValue) {
            throw new stubIllegalArgumentException('SeachValue for GREATER THEN criteria can not be NULL.');
        }
        
        parent::__construct($fieldName, $searchValue, $tableName);
    }
    
    /**
     * returns the operator of the criterion
     *
     * @return  string
     */
    protected function getOperator()
    {
        return '>';
    }
}
?><?php
/**
 * Criterion to check if something is one of a list of expected values.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 * @version     $Id: stubInCriterion.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::rdbms::criteria::stubAbstractCriterion'
);
/**
 * Criterion to check if something is one of a list of expected values.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 */
class stubInCriterion extends stubAbstractCriterion
{
    /**
     * constructor
     *
     * @param   string  $fieldName    the fieldname that contains the value to search for
     * @param   array   $searchValue  the values to search for
     * @param   string  $tableName    optional  the name of the table where the field is in
     * @throws  stubIllegalArgumentException
     */
    public function __construct($fieldName, $searchValue, $tableName = null)
    {
        if (is_array($searchValue) == false) {
            throw new stubIllegalArgumentException('SeachValue for IN criteria must be of type array.');
        }
        
        parent::__construct($fieldName, $searchValue, $tableName);
    }
    
    /**
     * returns the operator of the criterion
     *
     * @return  string
     */
    protected function getOperator()
    {
        return 'IN';
    }
    
    /**
     * returns the the search value
     *
     * @return  string
     */
    protected function getSearchValue()
    {
        return "('" . join("', '", $this->searchValue) . "')";
    }
}
?><?php
/**
 * Criterion to check for values equal to or lesser than the search value.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 * @version     $Id: stubLessEqualCriterion.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::rdbms::criteria::stubAbstractCriterion'
);
/**
 * Criterion to check for values equal to or lesser than the search value.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 */
class stubLessEqualCriterion extends stubAbstractCriterion
{
    /**
     * constructor
     *
     * @param   string  $fieldName    the fieldname that contains the value to search for
     * @param   string  $searchValue  the value to search for
     * @param   string  $tableName    optional  the name of the table where the field is in
     * @throws  stubIllegalArgumentException
     */
    public function __construct($fieldName, $searchValue, $tableName = null)
    {
        if (null === $searchValue) {
            throw new stubIllegalArgumentException('SeachValue for LESS EQUAL criteria can not be NULL.');
        }
        
        parent::__construct($fieldName, $searchValue, $tableName);
    }
    
    /**
     * returns the operator of the criterion
     *
     * @return  string
     */
    protected function getOperator()
    {
        return '<=';
    }
}
?><?php
/**
 * Criterion to check for values lesser than the search value.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 * @version     $Id: stubLessThanCriterion.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::rdbms::criteria::stubAbstractCriterion'
);
/**
 * Criterion to check for values lesser than the search value.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 */
class stubLessThanCriterion extends stubAbstractCriterion
{
    /**
     * constructor
     *
     * @param   string  $fieldName    the fieldname that contains the value to search for
     * @param   string  $searchValue  the value to search for
     * @param   string  $tableName    optional  the name of the table where the field is in
     * @throws  stubIllegalArgumentException
     */
    public function __construct($fieldName, $searchValue, $tableName = null)
    {
        if (null === $searchValue) {
            throw new stubIllegalArgumentException('SeachValue for LESS THEN criteria can not be NULL.');
        }
        
        parent::__construct($fieldName, $searchValue, $tableName);
    }
    
    /**
     * returns the operator of the criterion
     *
     * @return  string
     */
    protected function getOperator()
    {
        return '<';
    }
}
?><?php
/**
 * Criterion to check if something is like an expected value.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 * @version     $Id: stubLikeCriterion.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::rdbms::criteria::stubAbstractCriterion'
);
/**
 * Criterion to check if something is like an expected value.
 * 
 * The searchValue has to contain %, it can not be appended or prepended by
 * the class.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 */
class stubLikeCriterion extends stubAbstractCriterion
{
    /**
     * constructor
     *
     * @param   string  $fieldName    the fieldname that contains the value to search for
     * @param   string  $searchValue  the value to search for
     * @param   string  $tableName    optional  the name of the table where the field is in
     * @throws  stubIllegalArgumentException
     */
    public function __construct($fieldName, $searchValue, $tableName = null)
    {
        if (null === $searchValue) {
            throw new stubIllegalArgumentException('SeachValue for LIKE criteria can not be NULL.');
        }
        
        parent::__construct($fieldName, $searchValue, $tableName);
    }
    
    /**
     * returns the operator of the criterion
     *
     * @return  string
     */
    protected function getOperator()
    {
        return 'LIKE';
    }
}
?><?php
/**
 * Criterion to negate another criterion.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 * @version     $Id: stubNegateCriterion.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::criteria::stubCriterion');
/**
 * Criterion to negate another criterion.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 */
class stubNegateCriterion extends stubBaseObject implements stubCriterion
{
    /**
     * the criterion that should be negated
     *
     * @var  stubCriterion
     */
    protected $criterion;
    
    /**
     * constructor
     *
     * @param  stubCriterion  $criterion  criterion that should be negated
     */
    public function __construct(stubCriterion $criterion)
    {
        $this->criterion = $criterion;
    }
    
    /**
     * returns the criterion as sql
     *
     * @return  string
     */
    public function toSQL()
    {
        return 'NOT (' . $this->criterion->toSQL() . ')';
    }
}
?><?php
/**
 * Composition of several criteria connected by OR.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 * @version     $Id: stubOrCriterion.php 2145 2009-03-29 12:47:02Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::criteria::stubAbstractCompositeCriterion');
/**
 * Composition of several criteria connected by OR.
 * 
 * @package     stubbles
 * @subpackage  rdbms_criteria
 */
class stubOrCriterion extends stubAbstractCompositeCriterion
{
    /**
     * static constructor
     *
     * @return  stubOrCriterion
     */
    public static function create()
    {
        return new self();
    }

    /**
     * returns the the operator to connect the criteria
     *
     * @return  string
     */
    protected function getOperator()
    {
        return 'OR';
    }
}
?><?php
/**
 * Binding module for the database package.
 *
 * @package     stubbles
 * @subpackage  rdbms_ioc
 * @version     $Id: stubDatabaseBindingModule.php 2512 2010-03-03 12:57:14Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::module::stubBindingModule');
/**
 * Binding module for the database package.
 *
 * @package     stubbles
 * @subpackage  rdbms_ioc
 */
class stubDatabaseBindingModule extends stubBaseObject implements stubBindingModule
{
    /**
     * whether to allow fallback to default connection if named connection does not exist
     *
     * @var  bool
     */
    protected $fallback;
    /**
     * descriptor to be used for initializer
     *
     * @var  string
     */
    protected $descriptor;
    /**
     * name of database initializer class to bind
     *
     * @var  string
     */
    protected $databaseInitializerClassName        = 'net::stubbles::rdbms::stubPropertyBasedDatabaseInitializer';
    /**
     * name of database connection provider class to bind
     *
     * @var  string
     */
    protected $databaseConnectionProviderClassName = 'net::stubbles::rdbms::ioc::stubDatabaseConnectionProvider';

    /**
     * constructor
     *
     * @param  bool    $fallback    optional  whether to allow fallback to default connection if named connection does not exist
     * @param  string  $descriptor  optional  descriptor for database initializer
     */
    public function __construct($fallback = true, $descriptor = null)
    {
        $this->fallback   = $fallback;
        $this->descriptor = $descriptor;
    }

    /**
     * static constructor
     *
     * @param   bool                       $fallback    optional  whether to allow fallback to default connection if named connection does not exist
     * @param   string                     $descriptor  optional  descriptor for database initializer
     * @return  stubDatabaseBindingModule
     * @since   1.2.0
     */
    public static function create($fallback = true, $descriptor = null)
    {
        return new self($fallback, $descriptor);
    }

    /**
     * sets name of database initializer class to bind
     *
     * @param   string                     $databaseInitializerClassName
     * @return  stubDatabaseBindingModule
     * @since   1.2.0
     */
    public function setDatabaseInitializerClassName($databaseInitializerClassName)
    {
        $this->databaseInitializerClassName = $databaseInitializerClassName;
        return $this;
    }

    /**
     * sets name of database connection provider class to bind
     *
     * @param   string                     $databaseConnectionProviderClassName
     * @return  stubDatabaseBindingModule
     * @since   1.2.0
     */
    public function setDatabaseConnectionProviderClassName($databaseConnectionProviderClassName)
    {
        $this->databaseConnectionProviderClassName = $databaseConnectionProviderClassName;
        return $this;
    }

    /**
     * configure the binder
     *
     * @param  stubBinder  $binder
     */
    public function configure(stubBinder $binder)
    {
        $binder->bind('stubDatabaseInitializer')
               ->to($this->databaseInitializerClassName);
        $binder->bind('stubDatabaseConnection')
               ->toProviderClass($this->databaseConnectionProviderClassName);
        $binder->bindConstant()
               ->named('net.stubbles.rdbms.fallback')
               ->to($this->fallback);
        if (null !== $this->descriptor) {
            $binder->bindConstant()
                   ->named('net.stubbles.rdbms.descriptor')
                   ->to($this->descriptor);
        }
    }
}
?><?php
/**
 * IoC provider for database connections.
 *
 * @package     stubbles
 * @subpackage  rdbms_ioc
 * @version     $Id: stubDatabaseConnectionProvider.php 2501 2010-02-04 15:52:40Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjectionProvider',
                      'net::stubbles::rdbms::stubDatabaseConnectionData',
                      'net::stubbles::rdbms::stubDatabaseException',
                      'net::stubbles::rdbms::stubDatabaseInitializer'
);
/**
 * IoC provider for database connections.
 *
 * @package     stubbles
 * @subpackage  rdbms_ioc
 */
class stubDatabaseConnectionProvider extends stubBaseObject implements stubInjectionProvider
{
    /**
     * database connection data initializer
     *
     * @var  stubDatabaseInitializer
     */
    protected $dbInitializer;
    /**
     * set of database connections
     *
     * @var  array<string,stubDatabaseConnection>
     */
    protected $connections   = array();
    /**
     * switch whether to fallback to default connection if no named connection exists
     *
     * @var  bool
     */
    protected $fallback      = true;

    /**
     * constructor
     *
     * @param  stubDatabaseInitializer  $dbInitializer  database connection data initializer
     * @Inject
     */
    public function __construct(stubDatabaseInitializer $dbInitializer)
    {
        $this->dbInitializer = $dbInitializer;
    }

    /**
     *
     * @param   bool                            $fallback  whether to fallback to default connection if no named connection exists
     * @return  stubDatabaseConnectionProvider
     * @Inject(optional=true)
     * @Named('net.stubbles.rdbms.fallback')
     */
    public function setFallback($fallback)
    {
        $this->fallback = $fallback;
        return $this;
    }

    /**
     * returns the connection to be injected
     *
     * If a name is provided and a connection with this name exists this
     * connection will be returned. If fallback is enabled and the named
     * connection does not exist the default connection will be returned, if
     * fallback is disabled a stubDatabaseException will be thrown.
     *
     * If no name is provided the default connection will be returned.
     *
     * @param   string                  $name  optional
     * @return  stubDatabaseConnection
     * @throws  stubDatabaseException
     */
    public function get($name = null)
    {
        if (null == $name) {
            return $this->get(stubDatabaseConnectionData::DEFAULT_ID);
        }
        
        if (isset($this->connections[$name]) === true) {
            return $this->connections[$name];
        }

        if ($this->dbInitializer->hasConnectionData($name) === false) {
            if (stubDatabaseConnectionData::DEFAULT_ID !== $name && true === $this->fallback) {
                return $this->get(stubDatabaseConnectionData::DEFAULT_ID);
            }
            
            throw new stubDatabaseException('No connection and no dsn known for connection associated with id ' . $name);
        }
        
        $connectionData      = $this->dbInitializer->getConnectionData($name);
        $connectionClassName = $connectionData->getConnectionClassName();
        $nqClassName         = stubClassLoader::getNonQualifiedClassName($connectionClassName);
        if (class_exists($nqClassName, false) === false) {
            stubClassLoader::load($connectionClassName);
        }
         
        $connection = new $nqClassName($connectionData);
        if (($connection instanceof stubDatabaseConnection) === false) {
            throw new stubDatabaseException($connectionClassName . ' is not an instance of net::stubbles::rdbms::stubDatabaseConnection.');
        }
        
        $this->connections[$name] = $connection;
        return $connection;
    }
}
?><?php
/**
 * Description of stubEntityManagerProvider
 *
 * @package     stubbles
 * @subpackage  rdbms_ioc
 * @version     $Id: stubEntityManagerProvider.php 2471 2010-01-18 16:50:55Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjectionProvider',
                      'net::stubbles::ioc::stubInjector',
                      'net::stubbles::rdbms::persistence::stubDefaultEntityManager',
                      'net::stubbles::rdbms::persistence::eraser::stubDatabaseEraser',
                      'net::stubbles::rdbms::persistence::finder::stubDatabaseFinder',
                      'net::stubbles::rdbms::persistence::serializer::stubDatabaseSerializer'
);
/**
 * Description of stubEntityManagerProvider
 *
 * @package     stubbles
 * @subpackage  rdbms_ioc
 */
class stubEntityManagerProvider extends stubBaseObject implements stubInjectionProvider
{
    /**
     * injector instance
     *
     * @var  stubInjector
     */
    protected $injector;
    /**
     * singleton query builder factory instance
     *
     * @var  stubDatabaseQueryBuilderFactory
     */
    protected $queryBuilderFactory;
    /**
     * singleton finder instance
     *
     * @var  stubDatabaseFinder
     */
    protected $finder;
    /**
     * singleton serializer instance
     *
     * @var  stubDatabaseSerializer
     */
    protected $serializer;
    /**
     * singleton eraser instance
     *
     * @var  stubDatabaseEraser
     */
    protected $eraser;

    /**
     * constructor
     *
     * @param  stubInjector  $injector
     * @Inject
     */
    public function __construct(stubInjector $injector)
    {
        $this->injector = $injector;
    }

    /**
     * returns the entity manager to be injected
     *
     * The name refers to the database connection to be used.
     *
     * @param   string             $name  optional
     * @return  stubEntityManager
     */
    public function get($name = null)
    {
        return new stubDefaultEntityManager($this->injector->getInstance('stubDatabaseConnection', $name),
                                            $this->getFinder(),
                                            $this->getSerializer(),
                                            $this->getEraser()
               );
    }

    /**
     * returns query builder factory instance
     *
     * @return  stubDatabaseQueryBuilderFactory
     */
    protected function getQueryBuilderFactory()
    {
        if (null === $this->queryBuilderFactory) {
            $this->queryBuilderFactory = new stubDatabaseQueryBuilderFactory();
        }

        return $this->queryBuilderFactory;
    }

    /**
     * returns finder instance
     *
     * @return  stubDatabaseFinder
     */
    protected function getFinder()
    {
        if (null === $this->finder) {
            $this->finder = new stubDatabaseFinder($this->getQueryBuilderFactory());
        }

        return $this->finder;
    }

    /**
     * returns serializer instance
     *
     * @return  stubDatabaseSerializer
     */
    protected function getSerializer()
    {
        if (null === $this->serializer) {
            $this->serializer = new stubDatabaseSerializer($this->getQueryBuilderFactory());
        }

        return $this->serializer;
    }

    /**
     * returns eraser instance
     *
     * @return  stubDatabaseEraser
     */
    protected function getEraser()
    {
        if (null === $this->eraser) {
            $this->eraser = new stubDatabaseEraser($this->getQueryBuilderFactory());
        }

        return $this->eraser;
    }
}
?><?php
/**
 * wrapper around the pdo connection
 *
 * @package     stubbles
 * @subpackage  rdbms_pdo
 * @version     $Id: stubDatabasePDOConnection.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::stubDatabaseConnection',
                      'net::stubbles::rdbms::pdo::stubDatabasePDOStatement'
);
/**
 * wrapper around the pdo connection
 *
 * @package     stubbles
 * @subpackage  rdbms_pdo
 * @see         http://php.net/pdo
 */
class stubDatabasePDOConnection extends stubBaseObject implements stubDatabaseConnection
{
    /**
     * container that contains the data required to establish the connection
     *
     * @var  stubDatabaseConnectionData
     */
    protected $connectionData;
    /**
     * instance of pdo
     * 
     * @var  PDO
     */
    protected  $pdo           = null;

    /**
     * constructor
     *
     * @param   stubDatabaseConnectionData  $connectionData  container that contains the data required to establish the connection
     * @throws  stubRuntimeException
     */
    public function __construct(stubDatabaseConnectionData $connectionData)
    {
        if (extension_loaded('pdo') == false) {
            throw new stubRuntimeException('Can not create ' . __CLASS__ . ', requires PHP-extension "pdo".');
        }
        
        $this->connectionData = $connectionData;
    }

    /**
     * destructor
     */
    public function __destruct()
    {
        $this->disconnect();
    }

    /**
     * establishes the connection
     * 
     * @throws  stubDatabaseException
     */
    public function connect()
    {
        if (null !== $this->pdo) {
            return;
        }
        
        try {
            $this->createPDO();
            $this->pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
            if ($this->connectionData->hasInitialQuery() === true) {
                $this->pdo->query($this->connectionData->getInitialQuery());
            }
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * tries to create a new pdo instance
     * 
     * @throws  PDOException
     */
    // @codeCoverageIgnoreStart
    protected function createPDO()
    {
        $driverOptions = $this->connectionData->getDriverOptions();
        if (count($driverOptions) === 0) {
            $this->pdo = new PDO($this->connectionData->getDSN(),
                                 $this->connectionData->getUserName(),
                                 $this->connectionData->getPassword()
                         );
        } else {
            $this->pdo = new PDO($this->connectionData->getDSN(),
                                 $this->connectionData->getUserName(),
                                 $this->connectionData->getPassword(),
                                 $driverOptions
                         );
        }
    }
    // @codeCoverageIgnoreEnd

    /**
     * disconnects the database
     */
    public function disconnect()
    {
        $this->pdo = null;
    }

    /**
     * returns the connection data used for the connection
     *
     * @return  stubDatabaseConnectionData
     */
    public function getConnectionData()
    {
        return $this->connectionData;
    }

    /**
     * redirects calls on non-existing methods to the pdo object
     * 
     * @param   string  $method     name of the method to call
     * @param   array   $arguments  list of arguments for the method call
     * @return  mixed
     * @throws  stubDatabaseException
     */
    public function __call($method, $arguments)
    {
        if (null === $this->pdo) {
            $this->connect();
        }
        
        if (method_exists($this->pdo, $method) == false) {
            throw new stubDatabaseException('Call to undefined method ' . $this->getClassName() . '::' . $method . '().');
        }
        
        try {
            return call_user_func_array(array($this->pdo, $method), $arguments);
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * start a transaction
     *
     * @return  bool
     * @throws  stubDatabaseException
     */
    public function beginTransaction()
    {
        return $this->__call('beginTransaction', array());
    }

    /**
     * commit a transaction
     *
     * @return  bool
     * @throws  stubDatabaseException
     */
    public function commit()
    {
        return $this->__call('commit', array());
    }

    /**
     * rollback a transaction
     *
     * @return  bool
     * @throws  stubDatabaseException
     */
    public function rollback()
    {
        return $this->__call('rollBack', array());
    }

    /**
     * creates a prepared statement
     * 
     * @param   string  $statement      SQL statement
     * @param   array   $driverOptions  optional  one or more key=>value pairs to set attribute values for the Statement object
     * @return  stubDatabasePDOStatement
     * @throws  stubDatabaseException
     * @see     http://php.net/pdo-prepare
     */
    public function prepare($statement, array $driverOptions = array())
    {
        if (null === $this->pdo) {
            $this->connect();
        }
        
        try {
            $statement = new stubDatabasePDOStatement($this->pdo->prepare($statement, $driverOptions));
            return $statement;
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * executes a SQL statement
     * 
     * The driver options can be:
     * <code>
     * fetchMode => one of the PDO::FETCH_* constants
     * colNo     => if fetchMode == PDO::FETCH_COLUMN this denotes the column number to fetch
     * object    => if fetchMode == PDO::FETCH_INTO this denotes the object to fetch the data into
     * classname => if fetchMode == PDO::FETCH_CLASS this denotes the class to create and fetch the data into
     * ctorargs  => (optional) if fetchMode == PDO::FETCH_CLASS this denotes the list of arguments for the constructor of the class to create and fetch the data into
     * </code>
     * 
     * @param   string  $sql            the sql query to use
     * @param   array   $driverOptions  optional  how to fetch the data
     * @return  stubDatabasePDOStatement
     * @throws  stubDatabaseException
     * @see     http://php.net/pdo-query
     * @see     http://php.net/pdostatement-setfetchmode for the details on the fetch mode options
     */
    public function query($sql, array $driverOptions = array())
    {
        if (null === $this->pdo) {
            $this->connect();
        }
        
        try {
            if (isset($driverOptions['fetchMode']) == true) {
                switch ($driverOptions['fetchMode']) {
                    case PDO::FETCH_COLUMN:
                        if (isset($driverOptions['colNo']) == false) {
                            throw new stubDatabaseException('Fetch mode COLUMN requires driver option �colNo�.');
                        }
                        
                        $pdoStatement = $this->pdo->query($sql, $driverOptions['fetchMode'], $driverOptions['colNo']);
                        break;
                    
                    case PDO::FETCH_INTO:
                        if (isset($driverOptions['object']) == false) {
                            throw new stubDatabaseException('Fetch mode INTO requires driver option �object�.');
                        }
                        
                        $pdoStatement = $this->pdo->query($sql, $driverOptions['fetchMode'], $driverOptions['object']);
                        break;
                    
                    case PDO::FETCH_CLASS:
                        if (isset($driverOptions['classname']) == false) {
                            throw new stubDatabaseException('Fetch mode CLASS requires driver option �classname�.');
                        }
                        
                        if (isset($driverOptions['ctorargs']) == false) {
                            $driverOptions['ctorargs'] = array();
                        }
                        
                        $pdoStatement = $this->pdo->query($sql, $driverOptions['fetchMode'], $driverOptions['classname'], $driverOptions['ctorargs']);
                        break;
                    
                    default:
                        $pdoStatement = $this->pdo->query($sql, $driverOptions['fetchMode']);
                }
            } else {
                $pdoStatement = $this->pdo->query($sql);
            }
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
        
        $statement = new stubDatabasePDOStatement($pdoStatement);
        return $statement;
    }

    /**
     * execute an SQL statement and return the number of affected rows
     *
     * @param   string  $statement      the sql statement to execute
     * @param   array   $driverOptions  optional  one or more driver specific options for the call to query()
     * @return  int     number of effected rows
     * @throws  stubDatabaseException
     */
    public function exec($statement, array $driverOptions = array())
    {
        if (null === $this->pdo) {
            $this->connect();
        }
        
        try {
            return $this->pdo->exec($statement);
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * returns the last insert id
     *
     * @param   string  $name  optional  name of the sequence object from which the ID should be returned.
     * @return  int
     * @throws  stubDatabaseException
     */
    public function getLastInsertId($name = null)
    {
        if (null === $this->pdo) {
            throw new stubDatabaseException('Not connected: can not retrieve last insert id.');
        }
        
        try {
            return $this->pdo->lastInsertId($name);
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * returns the database name (e.g. MySQL or PostgreSQL)
     *
     * @return  string
     */
    public function getDatabase()
    {
        $dsnParts = explode(':', $this->connectionData->getDSN());
        return $dsnParts[0];
    }
}
?><?php
/**
 * Wrapper around the PDOStatement object.
 *
 * @package     stubbles
 * @subpackage  rdbms_pdo
 * @version     $Id: stubDatabasePDOStatement.php 2790 2010-11-25 21:48:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::rdbms::stubDatabaseStatement',
                      'net::stubbles::rdbms::stubDatabaseResult'
);
/**
 * Wrapper around the PDOStatement object.
 *
 * @package     stubbles
 * @subpackage  rdbms_pdo
 * @see         http://php.net/pdo
 */
class stubDatabasePDOStatement extends stubBaseObject implements stubDatabaseStatement, stubDatabaseResult
{
    /**
     * the wrapped pdo statement
     *
     * @var  PDOStatement
     */
    protected $pdoStatement;

    /**
     * constructor
     *
     * @param  PDOStatement  $pdoStatement  the pdo statement to wrap
     */
    public function __construct(PDOStatement $pdoStatement)
    {
        $this->pdoStatement = $pdoStatement;
    }

    /**
     * redirects calls on non-existing methods to the pdo statement object
     * 
     * @param   string  $method     name of the method to call
     * @param   array   $arguments  list of arguments for the method call
     * @return  mixed
     * @throws  stubDatabaseException
     */
    public function __call($method, $arguments)
    {
        try {
            return call_user_func_array(array($this->pdoStatement, $method), $arguments);
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * bind a result column to a variable
     *
     * @param   int|string  $column     column number or name to bind the variable to
     * @param   mixed       &$variable  the variable to bind to the column
     * @param   int|string  $type       optional  type of the binded variable
     * @return  bool        true on success, false on failure
     * @throws  stubDatabaseException
     * @see     http://php.net/pdostatement-bindColumn
     * @see     net::stubbles::rdbms::stubDatabaseResult::bindColumn()
     */
    public function bindColumn($column, &$variable, $type = null)
    {
        try {
            return $this->pdoStatement->bindColumn($column, $variable, $type, null, null);
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * bind a parameter of a prepared query to the specified variable
     * 
     * The binding will be via reference, so it is evaluated at the time when
     * the prepared statement is executed meaning that in opposite to
     * bindValue() the value of the variable at the time of execution will be
     * used, not the value at the time when this method is called.
     *
     * @param   int|string  $param      the order number of the parameter or its name
     * @param   mixed       &$variable  the variable to bind to the parameter
     * @param   int|string  $type       optional  type of the parameter
     * @param   int         $length     optional  length of the data type
     * @return  bool        true on success, false on failure
     * @throws  stubDatabaseException
     * @see     http://php.net/pdostatement-bindParam
     * @see     net::stubbles::rdbms::stubDatabaseStatement::bindParam()
     */
    public function bindParam($param, &$variable, $type = null, $length = null)
    {
        try {
            return $this->pdoStatement->bindParam($param, $variable, $type, $length, null);
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * bind a value to the parameter of a prepared query
     * 
     * In opposite to bindParam() this will use the value as it is at the time
     * when this method is called.
     * 
     * @param   int|string  $param  the order number of the parameter or its name
     * @param   mixed       $value  the value to bind
     * @param   int|string  $type   optional  type of the parameter
     * @return  bool        true on success, false on failure
     * @throws  stubDatabaseException
     * @see     http://php.net/pdostatement-bindValue
     * @see     net::stubbles::rdbms::stubDatabaseStatement::bindValue()
     */
    public function bindValue($param, $value, $type = null)
    {
        try {
            return $this->pdoStatement->bindValue($param, $value, $type);
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * executes a prepared statement
     *
     * @param   array  $values  optional  specifies all necessary information for bindParam()
     *                                    the array elements must use keys corresponding to the
     *                                    number of the position or name of the parameter
     * @return  stubDatabaseResult
     * @throws  stubDatabaseException
     * @see     http://php.net/pdostatement-execute
     * @see     net::stubbles::rdbms::stubDatabaseStatement::execute()
     */
    public function execute(array $values = array())
    {
        try {
            if (true === $this->pdoStatement->execute($values)) {
                return $this;
            }
            
            throw new stubDatabaseException('Executing the prepared statement failed.');
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * fetch a result
     *
     * @param   int    $fetchMode      optional  the mode to use for fetching the data
     * @param   array  $driverOptions  optional  driver specific arguments
     * @return  mixed
     * @throws  stubDatabaseException
     * @see     http://php.net/pdostatement-fetch
     * @see     net::stubbles::rdbms::stubDatabaseResult::fetch()
     */
    public function fetch($fetchMode = null, array $driverOptions = array())
    {
        if (null === $fetchMode) {
            $fetchMode = PDO::FETCH_BOTH;
        }
        
        try {
            return $this->pdoStatement->fetch($fetchMode,
                                              ((isset($driverOptions['cursorOrientation']) == false) ? (null) : ($driverOptions['cursorOrientation'])),
                                              ((isset($driverOptions['cursorOffset']) == false) ? (null) : ($driverOptions['cursorOffset']))
                   );
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * fetch single column from the next row from a result set
     *
     * @param   int     $columnNumber  optional  the column number to fetch, default is first column
     * @return  string
     * @throws  stubDatabaseException
     * @see     http://php.net/pdostatement-fetchColumn
     * @see     net::stubbles::rdbms::stubDatabaseResult::fetchOne()
     */
    public function fetchOne($columnNumber = 0)
    {
        try {
            return $this->pdoStatement->fetchColumn($columnNumber);
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * returns an array containing all of the result set rows
     *
     * @param   int    $fetchMode      optional  the mode to use for fetching the data
     * @param   array  $driverOptions  optional  driver specific arguments
     * @return  array
     * @throws  stubDatabaseException
     * @throws  stubIllegalArgumentException
     * @see     http://php.net/pdostatement-fetchAll
     * @see     net::stubbles::rdbms::stubDatabaseResult::fetchAll()
     */
    public function fetchAll($fetchMode = null, array $driverOptions = array())
    {
        try {
            if (null === $fetchMode) {
                return $this->pdoStatement->fetchAll();
            }
            
            if (PDO::FETCH_COLUMN == $fetchMode) {
                return $this->pdoStatement->fetchAll(PDO::FETCH_COLUMN,
                                                     ((isset($driverOptions['columnIndex']) === false) ? (0) : ($driverOptions['columnIndex']))
                       );
            }

            if (PDO::FETCH_CLASS == $fetchMode) {
                if (isset($driverOptions['classname']) === false) {
                    throw new stubIllegalArgumentException('Tried to use PDO::FETCH_CLASS but no classname given in driver options.');
                }
                
                return $this->pdoStatement->fetchAll(PDO::FETCH_CLASS,
                                                     $driverOptions['classname'],
                                                     ((isset($driverOptions['arguments']) === false) ? (null) : ($driverOptions['arguments']))
                       );
            }

            if (PDO::FETCH_FUNC == $fetchMode) {
                if (isset($driverOptions['function']) === false) {
                    throw new stubIllegalArgumentException('Tried to use PDO::FETCH_FUNC but no function given in driver options.');
                }

                return $this->pdoStatement->fetchAll(PDO::FETCH_FUNC,
                                                     $driverOptions['function']
                       );
            }
            
            return $this->pdoStatement->fetchAll($fetchMode);
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * moves the internal result pointer to the next result row
     *
     * @return  bool  true on success, false on failure
     * @throws  stubDatabaseException
     * @see     http://php.net/pdostatement-nextRowset
     * @see     net::stubbles::rdbms::stubDatabaseResult::next()
     */
    public function next()
    {
        try {
            return $this->pdoStatement->nextRowset();
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * returns the number of rows affected by the last SQL statement
     *
     * @return  int
     * @throws  stubDatabaseException
     * @see     http://php.net/pdostatement-rowCount
     * @see     net::stubbles::rdbms::stubDatabaseResult::count()
     */
    public function count()
    {
        try {
            return $this->pdoStatement->rowCount();
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * releases resources allocated for the specified prepared query
     * 
     * Frees up the connection to the server so that other SQL statements may
     * be issued, but leaves the statement in a state that enables it to be
     * executed again.
     *
     * @return  bool  true on success, false on failure
     * @throws  stubDatabaseException
     * @see     http://php.net/pdostatement-closeCursor
     * @see     net::stubbles::rdbms::stubDatabaseResult::free()
     */
    public function free()
    {
        try {
            return $this->pdoStatement->closeCursor();
        } catch (PDOException $pdoe) {
            throw new stubDatabaseException($pdoe->getMessage(), $pdoe);
        }
    }

    /**
     * releases resources allocated for the specified prepared query
     * 
     * Frees up the connection to the server so that other SQL statements may
     * be issued, but leaves the statement in a state that enables it to be
     * executed again.
     *
     * @return  bool  true on success, false on failure
     * @see     net::stubbles::rdbms::stubDatabaseStatement::clean()
     */
    public function clean()
    {
        $this->free();
    }
}
?><?php
/**
 * Annotation to set the column of a table in which a class property should be stored.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_annotation
 * @version     $Id: stubDBColumnAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseTableColumn'
);
/**
 * Annotation to set the column of a table in which a class property should be stored.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_annotation
 */
class stubDBColumnAnnotation extends stubAbstractAnnotation implements stubAnnotation
{
    /**
     * the db table column container
     *
     * @var  stubDatabaseTableColumn
     */
    protected $dbTableColumn;
    
    /**
     * constructor
     */
    public function __construct()
    {
        $this->dbTableColumn = new stubDatabaseTableColumn();
    }
    
    /**
     * returns the table column container
     *
     * @return  stubDatabaseTableColumn
     */
    public function getTableColumn()
    {
        return $this->dbTableColumn;
    }
    
    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_METHOD;
    }
    
    /**
     * set the order within the table
     *
     * @param  int  $order
     */
    public function setOrder($order)
    {
        $this->dbTableColumn->setOrder($order);
    }

    /**
     * sets the name of the column
     *
     * @param  string  $name
     */
    public function setName($name)
    {
        $this->dbTableColumn->setName($name);
    }

    /**
     * sets the type of the column
     *
     * @param  string  $type
     */
    public function setType($type)
    {
        $this->dbTableColumn->setType($type);
    }

    /**
     * sets the size of the column
     *
     * @param  int|string  $size
     */
    public function setSize($size)
    {
        $this->dbTableColumn->setSize($size);
    }

    /**
     * set whether the column may be null or not
     *
     * @param  bool  $isUnsigned
     */
    public function setIsUnsigned($isUnsigned)
    {
        $this->dbTableColumn->setIsUnsigned($this->castToBool($isUnsigned));
    }

    /**
     * set whether the column may be null or not
     *
     * @param  bool  $isNullable
     */
    public function setIsNullable($isNullable)
    {
        $this->dbTableColumn->setIsNullable($this->castToBool($isNullable));
    }

    /**
     * sets the default value of the column
     *
     * @param  mixed  $defaultValue
     */
    public function setDefaultValue($defaultValue)
    {
        $this->dbTableColumn->setDefaultValue($defaultValue);
    }

    /**
     * set whether the column is a primary key or not
     *
     * @param  bool  $isKey
     */
    public function setIsKey($isKey)
    {
        $this->dbTableColumn->setIsKey($this->castToBool($isKey));
    }

    /**
     * set whether the column is unique or not
     *
     * @param  bool  $isUnique
     */
    public function setIsUnique($isUnique)
    {
        $this->dbTableColumn->setIsUnique($this->castToBool($isUnique));
    }

    /**
     * set the name of the setter method
     *
     * @param  string  $setterMethod
     */
    public function setSetterMethod($setterMethod)
    {
        $this->dbTableColumn->setSetterMethod($setterMethod);
    }

    /**
     * set the character set of the table
     *
     * @param  string  $characterSet
     */
    public function setCharacterSet($characterSet)
    {
        $this->dbTableColumn->setCharacterSet($characterSet);
    }
    
    /**
     * set the collation of the table
     *
     * @param  string  $collation
     */
    public function setCollation($collation)
    {
        $this->dbTableColumn->setCollation($collation);
    }
    
    /**
     * helper method to cast a value to bool
     *
     * @param   mixed  $value
     * @return  bool
     */
    protected function castToBool($value)
    {
        if (is_string($value) == true && 'false' == $value) {
            return false;
        }
        
        return (bool) $value;
    }
}
?><?php
/**
 * Annotation to set the table in which class data should be stored.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_annotation
 * @version     $Id: stubDBTableAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseTableDescription'
);
/**
 * Annotation to set the table in which class data should be stored.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_annotation
 */
class stubDBTableAnnotation extends stubAbstractAnnotation implements stubAnnotation
{
    /**
     * the table description container
     *
     * @var  stubDatabaseTableDescription
     */
    protected $tableDescription;
    
    /**
     * constructor
     */
    public function __construct()
    {
        $this->tableDescription = new stubDatabaseTableDescription();
    }
    
    /**
     * returns the table description container
     *
     * @return  stubDatabaseTableDescription
     */
    public function getTableDescription()
    {
        return clone $this->tableDescription;
    }
    
    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_CLASS;
    }
    
    /**
     * sets the name of the table
     *
     * @param  string  $name
     */
    public function setName($name)
    {
        $this->tableDescription->setName($name);
    }

    /**
     * sets the type of the table
     *
     * @param  string  $type
     */
    public function setType($type)
    {
        $this->tableDescription->setType($type);
    }

    /**
     * sets the character set of the table
     *
     * @param  string  $characterSet
     */
    public function setCharacterSet($characterSet)
    {
        $this->tableDescription->setCharacterSet($characterSet);
    }

    /**
     * sets the collation of the table
     *
     * @param  string  $collation
     */
    public function setCollation($collation)
    {
        $this->tableDescription->setCollation($collation);
    }

    /**
     * sets the comment of the table
     *
     * @param  string  $comment
     */
    public function setComment($comment)
    {
        $this->tableDescription->setComment($comment);
    }
}
?><?php
/**
 * Annotation to mark an object as an entity.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_annotation
 * @version     $Id: stubEntityAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation'
);
/**
 * Annotation to mark an object as an entity.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_annotation
 */
class stubEntityAnnotation extends stubAbstractAnnotation implements stubAnnotation
{
    /**
     * optional: name of the entity (non-qualified class name)
     *
     * @var  string
     */
    protected $name;
    /**
     * default order by statement to be used when fetching more then one instance
     *
     * @var  string
     */
    protected $defaultOrder;

    /**
     * sets the name of the entity (non-qualified class name)
     *
     * @param  string  $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }

    /**
     * returns the name of the entity (non-qualified class name)
     *
     * @return  string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * sets the default order by statement to be used when fetching more then one instance
     *
     * @param  string  $defaultOrder
     */
    public function setDefaultOrder($defaultOrder)
    {
        $this->defaultOrder = $defaultOrder;
    }

    /**
     * checks whether a default order by statement is set
     *
     * @return  bool
     */
    public function hasDefaultOrder()
    {
        return (null !== $this->defaultOrder);
    }

    /**
     * returns the default order by statement to be used when fetching more then one instance
     *
     * @return  string
     */
    public function getDefaultOrder()
    {
        return $this->defaultOrder;
    }

    /**
     * returns the target of the annotation as bitmap
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_CLASS;
    }
}
?><?php
/**
 * Annotation to mark a primary key of an entity.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_annotation
 * @version     $Id: stubIdAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation'
);
/**
 * Annotation to mark a primary key of an entity.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_annotation
 */
class stubIdAnnotation extends stubAbstractAnnotation implements stubAnnotation
{
    /**
     * returns the target of the annotation as bitmap
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_METHOD + stubAnnotation::TARGET_PROPERTY;
    }
}
?><?php
/**
 * Annotation to mark a property as not to be persisted.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_annotation
 * @version     $Id: stubTransientAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation'
);
/**
 * Annotation to mark a property as not to be persisted.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_annotation
 */
class stubTransientAnnotation extends stubAbstractAnnotation implements stubAnnotation
{
    /**
     * returns the target of the annotation as bitmap
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_METHOD + stubAnnotation::TARGET_PROPERTY;
    }
}
?><?php
/**
 * Class for creating the table description for an entity.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_creator
 * @version     $Id: stubDatabaseCreator.php 2471 2010-01-18 16:50:55Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::stubDatabaseConnection',
                      'net::stubbles::rdbms::persistence::stubPersistenceHelper',
                      'net::stubbles::rdbms::persistence::creator::stubDatabaseCreatorException',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseQueryBuilderFactory'
);
/**
 * Class for creating the table description for an entity.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_creator
 */
class stubDatabaseCreator extends stubPersistenceHelper
{
    /**
     * creates the table description from the given entity class
     *
     * @param   stubDatabaseConnection        $connection   connection to use for creating the tables
     * @param   stubBaseReflectionClass       $entityClass  entity type to create table for
     * @throws  stubDatabaseCreatorException
     * @throws  stubPersistenceException
     */
    public function createTable(stubDatabaseConnection $connection, stubBaseReflectionClass $entityClass)
    {
        if ($entityClass->hasAnnotation('Entity') === false) {
            throw new stubPersistenceException('Class ' . $entityClass->getFullQualifiedClassName() . ' is not an entity.');
        }
        
        $tableDescription = $this->getTableDescription($entityClass);
        foreach ($this->getColumns($entityClass) as $column) {
            $tableDescription->addColumn($column);
        }
        
        try {
            $connection->query($this->databaseQueryBuilderFactory->create($connection)->createTable($tableDescription));
        } catch (stubException $se) {
            throw new stubDatabaseCreatorException('Can not create table for ' . $entityClass->getFullQualifiedClassName(), $se);
        }
    }
}
?><?php
/**
 * Exception to be thrown if a problem in the creator occurs.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_creator
 * @version     $Id: stubDatabaseCreatorException.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubChainedException');
/**
 * Exception to be thrown if a problem in the creator occurs.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_creator
 */
class stubDatabaseCreatorException extends stubChainedException
{
    // intentionally empty
}
?><?php
/**
 * Class for erasing the data of an entity object within a database.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_eraser
 * @version     $Id: stubDatabaseEraser.php 2471 2010-01-18 16:50:55Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::rdbms::stubDatabaseConnection',
                      'net::stubbles::rdbms::criteria::stubCriterion',
                      'net::stubbles::rdbms::criteria::stubAndCriterion',
                      'net::stubbles::rdbms::criteria::stubEqualCriterion',
                      'net::stubbles::rdbms::persistence::stubPersistenceHelper',
                      'net::stubbles::rdbms::persistence::eraser::stubDatabaseEraserException',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseQueryBuilderFactory'
);
/**
 * Class for erasing the data of an entity object within a database.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_eraser
 */
class stubDatabaseEraser extends stubPersistenceHelper
{
    /**
     * delete an entity from database by its primary keys
     *
     * @param   stubDatabaseConnection        $connection  connection to use for erasing the data
     * @param   stubObject                    $entity      entity to erase
     * @throws  stubIllegalArgumentException
     * @throws  stubDatabaseEraserException
     * @throws  stubPersistenceException
     */
    public function deleteByPrimaryKeys(stubDatabaseConnection $connection, stubObject $entity)
    {
        $entityClass =$entity->getClass();
        if ($entityClass->hasAnnotation('Entity') === false) {
            throw new stubPersistenceException('Class ' . $entityClass->getFullQualifiedClassName() . ' is not an entity.');
        }
        
        $table     = $this->getTableDescription($entityClass)->getName();
        $criterion = new stubAndCriterion();
        foreach ($this->getColumns($entityClass) as $method => $column) {
            if ($column->isPrimaryKey() === false) {
                continue;
            }
            
            $criterion->addCriterion(new stubEqualCriterion($column->getName(), $entity->$method(), $table));
        }
        
        if ($criterion->hasCriterion() === false) {
            throw new stubDatabaseEraserException('Can not delete instance of ' . $entityClass->getFullQualifiedClassName() . ' by its primary keys as it has no primary key.');
        }
        
        try {
            $result = $connection->query($this->databaseQueryBuilderFactory->create($connection)->createDelete($table, $criterion));
            $result->free();
        } catch (stubException $se) {
            throw new stubDatabaseEraserException('Can not delete instance of ' . $entityClass->getFullQualifiedClassName() . ' by its primary keys.', $se);
        }
    }

    /**
     * deletes all instances of an entity by given criterion
     *
     * @param   stubDatabaseConnection       $connection   connection to use for erasing the data
     * @param   stubCriterion                $criterion    the criterion that denotes all instances to delete
     * @param   stubBaseReflectionClass      $entityClass
     * @return  int                          amount of erased instances
     * @throws  stubPersistenceException
     * @throws  stubDatabaseEraserException
     */
    public function deleteByCriterion(stubDatabaseConnection $connection, stubCriterion $criterion, stubBaseReflectionClass $entityClass)
    {
        if ($entityClass->hasAnnotation('Entity') === false) {
            throw new stubPersistenceException('Class ' . $entityClass->getFullQualifiedClassName() . ' is not an entity.');
        }
        
        $table = $this->getTableDescription($entityClass)->getName();
        try {
            $result      = $connection->query($this->databaseQueryBuilderFactory->create($connection)->createDelete($table, $criterion));
            $deletedRows = $result->count();
            $result->free();
        } catch (stubDatabaseException $se) {
            throw new stubDatabaseEraserException('Can not delete any instance of ' . $entityClass->getFullQualifiedClassName() . ' by criterion ' . $criterion, $se);
        }
        
        return $deletedRows;
    }
}
?><?php
/**
 * Exception to be thrown if a problem in the eraser occurs.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_eraser
 * @version     $Id: stubDatabaseEraserException.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubChainedException');
/**
 * Exception to be thrown if a problem in the eraser occurs.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_eraser
 */
class stubDatabaseEraserException extends stubChainedException
{
    // intentionally empty
}
?><?php
/**
 * Class for finding the data of an entity object within a database.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_finder
 * @version     $Id: stubDatabaseFinder.php 2471 2010-01-18 16:50:55Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::stubDatabaseConnection',
                      'net::stubbles::rdbms::criteria::stubCriterion',
                      'net::stubbles::rdbms::criteria::stubEqualCriterion',
                      'net::stubbles::rdbms::persistence::stubPersistenceHelper',
                      'net::stubbles::rdbms::persistence::stubSetterMethodHelper',
                      'net::stubbles::rdbms::persistence::finder::stubDatabaseFinderException',
                      'net::stubbles::rdbms::persistence::finder::stubDatabaseFinderResult',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseQueryBuilderFactory',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseSelect'
);
/**
 * Class for finding the data of an entity object within a database.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_finder
 */
class stubDatabaseFinder extends stubPersistenceHelper
{
    /**
     * get an entity from database by its primary keys
     *
     * @param   stubDatabaseConnection    $connection   connection to use for finding the data
     * @param   stubBaseReflectionClass   $entityClass  class information about the entity
     * @param   array                     $primaryKeys  list of primary keys (name => value)
     * @return  object
     * @throws  stubPersistenceException
     */
    public function findByPrimaryKeys(stubDatabaseConnection $connection, stubBaseReflectionClass $entityClass, array $primaryKeys)
    {
        if ($entityClass->hasAnnotation('Entity') === false) {
            throw new stubPersistenceException('Class ' . $entityClass->getFullQualifiedClassName() . ' is not an entity.');
        }
        
        $setterMethodHelper = new stubSetterMethodHelper($entityClass->getName());
        $data               = $this->fetchData($connection, $entityClass, $setterMethodHelper, null, $primaryKeys);
        if (count($data) === 0) {
            return null;
        }
        
        $entity = $entityClass->newInstance();
        $setterMethodHelper->applySetterMethods($entity, $data);
        return $entity;
    }

    /**
     * finds all instances of $entityClass by given criterion
     *
     * @param   stubDatabaseConnection    $connection   connection to use for finding the data
     * @param   stubCriterion             $criterion    criterion to restrict search to
     * @param   string                    $entityClass  entity class to find instances of
     * @param   string                    $orderBy      optional  overrule default order of entity
     * @param   int                       $offset       optional  overrule to start selection at given offset
     * @param   int                       $amount       optional  overrule to limit selection to given amount
     * @return  stubDatabaseFinderResult  list of instances of $entityClass found with $criterion
     * @throws  stubPersistenceException
     */
    public function findByCriterion(stubDatabaseConnection $connection, stubCriterion $criterion, stubBaseReflectionClass $entityClass, $orderBy = null, $offset = null, $amount = null)
    {
        if ($entityClass->hasAnnotation('Entity') === false) {
            throw new stubPersistenceException('Class ' . $entityClass->getFullQualifiedClassName() . ' is not an entity.');
        }
        
        $setterMethodHelper = new stubSetterMethodHelper($entityClass->getName());
        $data               = $this->fetchData($connection, $entityClass, $setterMethodHelper, $criterion, null, $orderBy, $offset, $amount);
        $finderResult       = new stubDatabaseFinderResult($entityClass, $data, $setterMethodHelper);
        return $finderResult;
    }

    /**
     * finds all instances of $entityClass
     *
     * @param   stubDatabaseConnection    $connection   connection to use for finding the data
     * @param   string                    $entityClass  entity class to find instances of
     * @param   string                    $orderBy      optional  overrule default order of entity
     * @param   int                       $offset       optional  overrule to start selection at given offset
     * @param   int                       $amount       optional  overrule to limit selection to given amount
     * @return  stubDatabaseFinderResult  list of instances of $entityClass found
     * @throws  stubPersistenceException
     */
    public function findAll(stubDatabaseConnection $connection, stubBaseReflectionClass $entityClass, $orderBy = null, $offset = null, $amount = null)
    {
        if ($entityClass->hasAnnotation('Entity') === false) {
            throw new stubPersistenceException('Class ' . $entityClass->getFullQualifiedClassName() . ' is not an entity.');
        }
        
        $setterMethodHelper = new stubSetterMethodHelper($entityClass->getName());
        $data               = $this->fetchData($connection, $entityClass, $setterMethodHelper, null, null, $orderBy, $offset, $amount);
        $finderResult       = new stubDatabaseFinderResult($entityClass, $data, $setterMethodHelper);
        return $finderResult;
    }

    /**
     * helper method to retrieve the data for a given select instance
     *
     * @param   stubDatabaseConnection   $connection          connection to use for finding the data
     * @param   stubBaseReflectionClass  $entityClass
     * @param   stubSetterMethodHelper   $setterMethodHelper
     * @param   stubCriterion            $criterion           optional
     * @param   array                    $primaryKeys         optional
     * @param   string                   $orderBy             optional  overrule default order of entity
     * @param   int                      $offset              optional  overrule to start selection at given offset
     * @param   int                      $amount              optional  overrule to limit selection to given amount
     * @return  array
     * @throws  stubDatabaseFinderException
     */
    protected function fetchData(stubDatabaseConnection $connection, stubBaseReflectionClass $entityClass, stubSetterMethodHelper $setterMethodHelper, stubCriterion $criterion = null, array $primaryKeys = null, $orderBy = null, $offset = null, $amount = null)
    {
        $select = $this->createSelect($entityClass, $setterMethodHelper, ((null === $primaryKeys) ? (array()) : ($primaryKeys)));
        if (null !== $criterion) {
            $select->addCriterion($criterion);
        }
        
        if (null !== $orderBy) {
            $select->orderBy($orderBy);
        } else {
            $entityAnnotation = $entityClass->getAnnotation('Entity');
            if ($entityAnnotation->hasDefaultOrder() === true) {
                $select->orderBy($entityAnnotation->getDefaultOrder());
            }
        }
        
        $select->limitBy($offset, $amount);
        
        try {
            $result = $connection->query($this->databaseQueryBuilderFactory->create($connection)->createSelect($select));
            if (null !== $primaryKeys) {
                $data = $result->fetch();
            } else {
                $data = $result->fetchAll();
            }
            
            $result->free();
        } catch (stubDatabaseException $se) {
            $exceptionInfo = null;
            if (null !== $criterion) {
                $exceptionInfo = ' by criterion ' . $criterion;
            } elseif (null !== $primaryKeys) {
                $exceptionInfo = ' by its primary keys.';
            }
            
            throw new stubDatabaseFinderException('Can not find any instance of ' . $entityClass->getFullQualifiedClassName() . $exceptionInfo, $se);
        }
        
        if (false === $data) {
            return array();
        }
        
        return $data;
    }

    /**
     * reads annotations and returns data in a usable format
     *
     * @param   stubBaseReflectionClass      $entityClass
     * @param   stubSetterMethodHelper       $setterMethodHelper
     * @param   array                        $primaryKeys         optional
     * @return  stubDatabaseSelect
     * @throws  stubDatabaseFinderException
     */
    protected function createSelect(stubBaseReflectionClass $entityClass, stubSetterMethodHelper $setterMethodHelper, array $primaryKeys = array())
    {
        $select  = new stubDatabaseSelect($this->getTableDescription($entityClass));
        foreach ($this->getColumns($entityClass) as $method => $column) {
            if ($column->isPrimaryKey() === true && isset($primaryKeys[$this->getPropertyName($method)]) === true) {
                $select->addCriterion(new stubEqualCriterion($column->getName(), $primaryKeys[$this->getPropertyName($method)], $select->getBaseTableName()));
            } elseif ($column->isPrimaryKey() === true && isset($primaryKeys[$column->getName()]) === true) {
                $select->addCriterion(new stubEqualCriterion($column->getName(), $primaryKeys[$column->getName()], $select->getBaseTableName()));
            }
            
            $setterMethodHelper->addSetterMethod($column, $method);
        }
        
        return $select;
    }
}
?><?php
/**
 * Exception to be thrown if a problem in the finder occurs.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_finder
 * @version     $Id: stubDatabaseFinderException.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubChainedException');
/**
 * Exception to be thrown if a problem in the finder occurs.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_finder
 */
class stubDatabaseFinderException extends stubChainedException
{
    // intentionally empty
}
?><?php
/**
 * Class for iterating over selected entities from a query result.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_finder
 * @version     $Id: stubDatabaseFinderResult.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::persistence::finder::stubDatabaseFinderException',
                      'net::stubbles::reflection::stubReflectionClass'
);
/**
 * Class for iterating over selected entities from a query result.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_finder
 */
class stubDatabaseFinderResult extends stubBaseObject implements Iterator
{
    /**
     * reflection class for entity
     *
     * @var  stubBaseReflectionClass
     */
    protected $entityClass;
    /**
     * the result set from the database query
     *
     * @var  ArrayIterator
     */
    protected $resultIterator;
    /**
     * list of setter methods for entity
     *
     * @var  array
     */
    protected $setterMethodHelper;

    /**
     * constructor
     *
     * @param  stubBaseReflectionClass  $entityClass         reflection class for entity
     * @param  array                    $result              result set from the database query
     * @param  stubSetterMethodHelper   $setterMethodHelper  list of setter methods for entity
     */
    public function __construct(stubBaseReflectionClass $entityClass, array $result, stubSetterMethodHelper $setterMethodHelper)
    {
        $this->entityClass        = $entityClass;
        $this->resultIterator     = new ArrayIterator($result);
        $this->setterMethodHelper = $setterMethodHelper;
    }

    /**
     * returns reflection class for entity
     *
     * @return  stubBaseReflectionClass
     */
    public function forClass()
    {
        return $this->entityClass;
    }

    /**
     * returns amount of found entities
     *
     * @return  int
     */
    public function count()
    {
        return $this->resultIterator->count();
    }

    /**
     * returns the current entity
     *
     * @return  object
     * @throws  stubDatabaseFinderException
     */
    public function current()
    {
        try {
            $entity = $this->entityClass->newInstance();
        } catch (ReflectionException $re) {
            throw new stubDatabaseFinderException('Can not create a new instance of ' . $this->entityClass->getFullQualifiedClassName(), $re);
        }
        
        if (null === $entity) {
            throw new stubDatabaseFinderException('Can not create a new instance of ' . $this->entityClass->getFullQualifiedClassName());
        }
        
        $this->setterMethodHelper->applySetterMethods($entity, $this->resultIterator->current());
        return $entity;
    }

    /**
     * returns the current key
     *
     * @return  int
     */
    public function key()
    {
        return $this->resultIterator->key();
    }

    /**
     * moves iterator to next element
     */
    public function next()
    {
        $this->resultIterator->next();
    }

    /**
     * resets iterator to first element
     */
    public function rewind()
    {
        $this->resultIterator->rewind();
    }

    /**
     * checks whether pointer is on a valid element
     *
     * @return  bool
     */
    public function valid()
    {
        return $this->resultIterator->valid();
    }
}
?><?php
/**
 * Serializer to store objects in database tables.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_serializer
 * @version     $Id: stubDatabaseSerializer.php 2471 2010-01-18 16:50:55Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::types::stubDate',
                      'net::stubbles::rdbms::stubDatabaseConnection',
                      'net::stubbles::rdbms::criteria::stubEqualCriterion',
                      'net::stubbles::rdbms::persistence::stubPersistenceHelper',
                      'net::stubbles::rdbms::persistence::stubSetterMethodHelper',
                      'net::stubbles::rdbms::persistence::serializer::stubDatabaseSerializerException',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseQueryBuilderFactory',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseTableRow'
);
/**
 * Serializer to store objects in database tables.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence_serializer
 */
class stubDatabaseSerializer extends stubPersistenceHelper
{
    /**
     * data has been inserted
     */
    const INSERT = 'insert';
    /**
     * data has been updated
     */
    const UPDATE = 'update';

    /**
     * takes an entity and inserts it into the database
     *
     * @param   stubDatabaseConnection           $connection  connection to use for finding the data
     * @param   stubObject                       $entity
     * @return  string
     * @throws  stubIllegalArgumentException
     * @throws  stubDatabaseSerializerException
     * @throws  stubPersistenceException
     */
    public function insert(stubDatabaseConnection $connection, stubObject $entity)
    {
        $entityClass = $entity->getClass();
        if ($entityClass->hasAnnotation('Entity') === false) {
            throw new stubPersistenceException('Class ' . $entityClass->getFullQualifiedClassName() . ' is not an entity.');
        }
        
        $stuff = $this->processEntity($entityClass, $entity, self::INSERT);
        try {
            $this->processInsertQueries($connection, $this->getInsertQuery($connection, $stuff['tableRow'], $entity, $stuff['defaultValues']), $entity, array_shift($stuff['primaryKeys']));
        } catch (stubDatabaseException $dbe) {
            throw new stubDatabaseSerializerException('Can not persist ' . $entityClass->getFullQualifiedClassName() . ': a database error occured.', $dbe);
        }
        
        return self::INSERT;
    }

    /**
     * takes an entity and updates its database entry
     *
     * @param   stubDatabaseConnection           $connection   connection to use for finding the data
     * @param   stubObject                       $entity
     * @return  string
     * @throws  stubIllegalArgumentException
     * @throws  stubDatabaseSerializerException
     * @throws  stubPersistenceException
     */
    public function update(stubDatabaseConnection $connection, stubObject $entity)
    {
        $entityClass = $entity->getClass();
        if ($entityClass->hasAnnotation('Entity') === false) {
            throw new stubPersistenceException('Class ' . $entityClass->getFullQualifiedClassName() . ' is not an entity.');
        }
        
        $stuff = $this->processEntity($entityClass, $entity, self::UPDATE);
        try {
            $this->processUpdateQueries($connection, $this->getUpdateQuery($connection, $stuff['tableRow'], $stuff['defaultValues']));
        } catch (stubDatabaseException $dbe) {
            throw new stubDatabaseSerializerException('Can not persist ' . $entityClass->getFullQualifiedClassName() . ': a database error occured.', $dbe);
        }
            
        return self::UPDATE;
    }

    /**
     * takes an entity and serializes it into the database
     *
     * @param   stubDatabaseConnection           $connection   connection to use for finding the data
     * @param   stubObject                       $entity
     * @return  string
     * @throws  stubIllegalArgumentException
     * @throws  stubDatabaseSerializerException
     * @throws  stubPersistenceException
     */
    public function serialize(stubDatabaseConnection $connection, stubObject $entity)
    {
        $entityClass = $entity->getClass();
        if ($entityClass->hasAnnotation('Entity') === false) {
            throw new stubPersistenceException('Class ' . $entityClass->getFullQualifiedClassName() . ' is not an entity.');
        }
        
        $stuff = $this->processEntity($entityClass, $entity);
        if (count($stuff['primaryKeys']) > 1) {
            throw new stubDatabaseSerializerException('Persistence error for ' . $entityClass->getFullQualifiedClassName() . ': only one primary key can be null, but at least two primary keys are null: ' . join(', ', array_keys($stuff['primaryKeys'])));
        }
        
        if ($stuff['tableRow']->hasCriterion() === true) {
            try {
                $this->processUpdateQueries($connection, $this->getUpdateQuery($connection, $stuff['tableRow'], $stuff['defaultValues']));
            } catch (stubDatabaseException $dbe) {
                throw new stubDatabaseSerializerException('Can not persist ' . $entityClass->getFullQualifiedClassName() . ': a database error occured.', $dbe);
            }
            
            return self::UPDATE;
        }
        
        try {
            $this->processInsertQueries($connection, $this->getInsertQuery($connection, $stuff['tableRow'], $entity, $stuff['defaultValues']), $entity, array_shift($stuff['primaryKeys']));
        } catch (stubDatabaseException $dbe) {
            throw new stubDatabaseSerializerException('Can not persist ' . $entityClass->getFullQualifiedClassName() . ': a database error occured.', $dbe);
        }
        
        return self::INSERT;
    }

    /**
     * processes the entity: create another presentation of data
     *
     * @param   stubBaseReflectionClass  $entityClass
     * @param   object                   $entity
     * @param   string                   $type         optional
     * @return  array
     * @throws  stubDatabaseSerializerException
     */
    protected function processEntity(stubBaseReflectionClass $entityClass, $entity, $type = null)
    {
        $tableRow      = new stubDatabaseTableRow($this->getTableDescription($entityClass)->getName());
        $primaryKeys   = array();
        $defaultValues = array();
        foreach ($this->getColumns($entityClass) as $method => $column) {
            $value = $entity->$method();
            if ($value instanceof stubDate) {
                $value = $value->format('Y-m-d H:i:s');
            }
            
            if ($column->isPrimaryKey() === true) {
                if (null === $value && self::UPDATE === $type) {
                    throw new stubDatabaseSerializerException('Persistence error for ' . $entityClass->getFullQualifiedClassName() . ': should be updated, but one primary key column is null: ' . $method);
                } elseif (null === $value) {
                    $primaryKeys[$method] = array('setterMethod' => stubSetterMethodHelper::getSetterMethodName($column, $entityClass->getName(), $method),
                                                  'tableName'    => $tableRow->getTableName()
                                            );
                } elseif (self::INSERT === $type) {
                    $tableRow->setColumn($column->getName(), $value);
                } else {
                    $tableRow->addCriterion(new stubEqualCriterion($column->getName(), $value, $tableRow->getTableName()));
                }
            } elseif (null === $value) {
                $defaultValue = $column->getDefaultValue();
                if ($column->isNullable() === false && null === $defaultValue) {
                    throw new stubDatabaseSerializerException('Persistence error for ' . $entityClass->getFullQualifiedClassName() . ': column ' . $column->getName() . ' is not allowed to be null but return value from method ' . $method . ' and default value are both null.');
                }
                
                $defaultValues[] = array('setterMethod' => stubSetterMethodHelper::getSetterMethodName($column, $entityClass->getName(), $method),
                                         'value'        => $value,
                                         'defaultValue' => $defaultValue,
                                         'column'       => $column->getName()
                                   );
            } else {
                $tableRow->setColumn($column->getName(), $value);
            }
        }
        
        return array('tableRow'      => $tableRow,
                     'defaultValues' => $defaultValues,
                     'primaryKeys'   => $primaryKeys
               );
    }

    /**
     * creates the queries required to process the insert
     *
     * @param   stubDatabaseConnection  $connection     connection to use for finding the data
     * @param   stubDatabaseTableRow    $tableRow
     * @param   stubObject              $entity
     * @param   array                   $defaultValues
     * @return  array<string>
     * @throws  stubDatabaseSerializerException
     */
    protected function getInsertQuery(stubDatabaseConnection $connection, stubDatabaseTableRow $tableRow, stubObject $entity, array $defaultValues)
    {
        $queryBuilder = $this->databaseQueryBuilderFactory->create($connection);
        try {
            // fill default values into entity and table row
            foreach ($defaultValues as $defaultValue) {
                // only reset entity with default value if default value is not null
                if (null !== $defaultValue['defaultValue']) {
                    $setterMethodName = $defaultValue['setterMethod'];
                    $entity->$setterMethodName($defaultValue['defaultValue']);
                }
                
                $tableRow->setColumn($defaultValue['column'], $defaultValue['defaultValue']);
            }

            return $queryBuilder->createInsert(array($tableRow->getTableName() => $tableRow));
        } catch (stubIllegalArgumentException $iae) {
            throw new stubDatabaseSerializerException('Creating the queries failed.', $iae);
        }
    }

    /**
     * creates the queries required to process the update
     *
     * @param   stubDatabaseConnection  $connection     connection to use for finding the data
     * @param   stubDatabaseTableRow    $tableRow
     * @param   array                   $defaultValues
     * @return  array<string>
     * @throws  stubDatabaseSerializerException
     */
    protected function getUpdateQuery(stubDatabaseConnection $connection, stubDatabaseTableRow $tableRow, array $defaultValues)
    {
        $queryBuilder = $this->databaseQueryBuilderFactory->create($connection);
        try {
            foreach ($defaultValues as $defaultValue) {
                $tableRow->setColumn($defaultValue['column'], $defaultValue['value']);
            }
            
            return $queryBuilder->createUpdate(array($tableRow->getTableName() => $tableRow));
        } catch (stubIllegalArgumentException $iae) {
            throw new stubDatabaseSerializerException('Creating the queries failed.', $iae);
        }
    }

    /**
     * process insert queries
     *
     * @param   stubDatabaseConnection  $connection        connection to use for finding the data
     * @param   array<string,string>    $queries           list of queries to process
     * @param   object                  $entity            the entity to process the queries for
     * @param   array<string,string>    $singlePrimaryKey  optional  information about the single primary key
     * @throws  stubDatabaseException
     */
    protected function processInsertQueries(stubDatabaseConnection $connection, array $queries, $entity, array $singlePrimaryKey = null)
    {
        foreach ($queries as $tableName => $query) {
            $connection->exec($query);
            if (null !== $singlePrimaryKey && $singlePrimaryKey['tableName'] == $tableName) {
                $setterMethodName = $singlePrimaryKey['setterMethod'];
                $entity->$setterMethodName($connection->getLastInsertId());
            }
        }
    }

    /**
     * process update queries
     *
     * @param   stubDatabaseConnection  $connection   connection to use for finding the data
     * @param   array<string,string>    $queries      list of queries to process
     * @throws  stubDatabaseException
     */
    protected function processUpdateQueries(stubDatabaseConnection $connection, array $queries)
    {
        foreach ($queries as $tableName => $query) {
            $connection->exec($query);
        }
    }
}
?><?php
/**
 * Exception to be thrown in case the serializer locates a problem.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence
 * @version     $Id: stubDatabaseSerializerException.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::stubDatabaseException');
/**
 * Exception to be thrown in case the serializer locates a problem.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence
 */
class stubDatabaseSerializerException extends stubDatabaseException
{
    // intentionally empty
}
?><?php
/**
 * Default implementation of an entity manager to hide the classes that do the real work.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence
 * @version     $Id: stubDefaultEntityManager.php 2471 2010-01-18 16:50:55Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::stubDatabaseConnection',
                      'net::stubbles::rdbms::persistence::stubEntityManager',
                      'net::stubbles::rdbms::persistence::eraser::stubDatabaseEraser',
                      'net::stubbles::rdbms::persistence::finder::stubDatabaseFinder',
                      'net::stubbles::rdbms::persistence::serializer::stubDatabaseSerializer'
);
/**
 * Default implementation of an entity manager to hide the classes that do the real work.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence
 */
class stubDefaultEntityManager extends stubBaseObject implements stubEntityManager
{
    /**
     * connection instance to use
     *
     * @var  stubDatabaseConnection
     */
    protected $connection;
    /**
     * finder to be used for search requests
     *
     * @var  stubDatabaseFinder
     */
    protected $finder;
    /**
     * serializer to be used for storage requests
     *
     * @var  stubDatabaseSerializer
     */
    protected $serializer;
    /**
     * eraser to be used for deletion requests
     *
     * @var  stubDatabaseEraser
     */
    protected $eraser;

    /**
     * constructor
     *
     * @param  stubDatabaseConnection  $connection
     * @param  stubDatabaseFinder      $finder
     * @param  stubDatabaseSerializer  $serializer
     * @param  stubDatabaseEraser      $eraser
     */
    public function __construct(stubDatabaseConnection $connection, stubDatabaseFinder $finder, stubDatabaseSerializer $serializer, stubDatabaseEraser $eraser)
    {
        $this->connection = $connection;
        $this->finder     = $finder;
        $this->serializer = $serializer;
        $this->eraser     = $eraser;
    }

    /**
     * get an entity from database by its primary keys
     *
     * @param   stubBaseReflectionClass      $entityClass  class information about the entity
     * @param   array                        $primaryKeys  list of primary keys (name => value)
     * @return  stubObject
     * @throws  stubDatabaseFinderException
     * @throws  stubPersistenceException
     */
    public function findByPrimaryKey(stubBaseReflectionClass $entityClass, array $primaryKeys)
    {
        return $this->finder->findByPrimaryKeys($this->connection, $entityClass, $primaryKeys);
    }

    /**
     * finds all instances of $entityClass by given criterion
     *
     * @param   stubCriterion                $criterion
     * @param   string                       $entityClass  entity class to find instances of
     * @param   string                       $orderBy      optional  overrule default order of entity
     * @param   int                          $offset       optional  overrule to start selection at given offset
     * @param   int                          $amount       optional  overrule to limit selection to given amount
     * @return  stubDatabaseFinderResult     list of instances of $entityClass found with $criterion
     * @throws  stubDatabaseFinderException
     * @throws  stubPersistenceException
     */
    public function findByCriterion(stubCriterion $criterion, stubBaseReflectionClass $entityClass, $orderBy = null, $offset = null, $amount = null)
    {
        return $this->finder->findByCriterion($this->connection, $criterion, $entityClass, $orderBy, $offset, $amount);
    }

    /**
     * finds all instances of $entityClass
     *
     * @param   string                       $entityClass  entity class to find instances of
     * @param   string                       $orderBy      optional  overrule default order of entity
     * @param   int                          $offset       optional  overrule to start selection at given offset
     * @param   int                          $amount       optional  overrule to limit selection to given amount
     * @return  stubDatabaseFinderResult     list of instances of $entityClass found
     * @throws  stubDatabaseFinderException
     * @throws  stubPersistenceException
     */
    public function findAll(stubBaseReflectionClass $entityClass, $orderBy = null, $offset = null, $amount = null)
    {
        return $this->finder->findAll($this->connection, $entityClass, $orderBy, $offset, $amount);
    }

    /**
     * takes an entity and inserts it into the database
     *
     * @param   stubObject                       $entity
     * @return  string
     * @throws  stubDatabaseSerializerException
     * @throws  stubPersistenceException
     */
    public function insert(stubObject $entity)
    {
        return $this->serializer->insert($this->connection, $entity);
    }

    /**
     * takes an entity and updates the database entry
     *
     * @param   stubObject                       $entity
     * @return  string
     * @throws  stubDatabaseSerializerException
     * @throws  stubPersistenceException
     */
    public function update(stubObject $entity)
    {
        return $this->serializer->update($this->connection, $entity);
    }

    /**
     * takes an entity and serializes it into the database
     *
     * @param   stubObject                       $entity
     * @return  string
     * @throws  stubDatabaseSerializerException
     * @throws  stubPersistenceException
     */
    public function serialize(stubObject $entity)
    {
        return $this->serializer->serialize($this->connection, $entity);
    }

    /**
     * delete an entity from database by its primary keys
     *
     * @param   stubObject                   $entity
     * @throws  stubDatabaseEraserException
     * @throws  stubPersistenceException
     */
    public function deleteByPrimaryKeys(stubObject $entity)
    {
        $this->eraser->deleteByPrimaryKeys($this->connection, $entity);
    }

    /**
     * deletes all instances of an entity by given criterion
     *
     * @param   stubCriterion                $criterion    the criterion that denotes all instances to delete
     * @param   stubBaseReflectionClass      $entityClass
     * @return  int                          amount of erased instances
     * @throws  stubDatabaseEraserException
     */
    public function deleteByCriterion(stubCriterion $criterion, stubBaseReflectionClass $entityClass)
    {
        return $this->eraser->deleteByCriterion($this->connection, $criterion, $entityClass);
    }
}
?><?php
/**
 * Interface for an entity manager to hide the classes that do the real work.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence
 * @version     $Id: stubEntityManager.php 2471 2010-01-18 16:50:55Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::criteria::stubCriterion',
                      'net::stubbles::reflection::stubBaseReflectionClass'
);
/**
 * Interface for an entity manager to hide the classes that do the real work.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence
 * @ProvidedBy(net::stubbles::rdbms::ioc::stubEntityManagerProvider.class)
 */
interface stubEntityManager extends stubObject
{
    /**
     * get an entity from database by its primary keys
     *
     * @param   stubBaseReflectionClass      $entityClass  class information about the entity
     * @param   array                        $primaryKeys  list of primary keys (name => value)
     * @return  stubObject
     * @throws  stubDatabaseFinderException
     * @throws  stubPersistenceException
     */
    public function findByPrimaryKey(stubBaseReflectionClass $entityClass, array $primaryKeys);

    /**
     * finds all instances of $entityClass by given criterion
     *
     * @param   stubCriterion                $criterion
     * @param   string                       $entityClass  entity class to find instances of
     * @param   string                       $orderBy      optional  overrule default order of entity
     * @param   int                          $offset       optional  overrule to start selection at given offset
     * @param   int                          $amount       optional  overrule to limit selection to given amount
     * @return  stubDatabaseFinderResult     list of instances of $entityClass found with $criterion
     * @throws  stubDatabaseFinderException
     * @throws  stubPersistenceException
     */
    public function findByCriterion(stubCriterion $criterion, stubBaseReflectionClass $entityClass, $orderBy = null, $offset = null, $amount = null);

    /**
     * finds all instances of $entityClass
     *
     * @param   string                       $entityClass  entity class to find instances of
     * @param   string                       $orderBy      optional  overrule default order of entity
     * @param   int                          $offset       optional  overrule to start selection at given offset
     * @param   int                          $amount       optional  overrule to limit selection to given amount
     * @return  stubDatabaseFinderResult     list of instances of $entityClass found
     * @throws  stubDatabaseFinderException
     * @throws  stubPersistenceException
     */
    public function findAll(stubBaseReflectionClass $entityClass, $orderBy = null, $offset = null, $amount = null);

    /**
     * takes an entity and inserts it into the database
     *
     * @param   stubObject                        $entity
     * @return  string
     * @throws  stubDatabaseSerializerException
     * @throws  stubPersistenceException
     */
    public function insert(stubObject $entity);

    /**
     * takes an entity and updates the database entry
     *
     * @param   stubObject                       $entity
     * @return  string
     * @throws  stubDatabaseSerializerException
     * @throws  stubPersistenceException
     */
    public function update(stubObject $entity);

    /**
     * takes an entity and serializes it into the database
     *
     * @param   stubObject                       $entity
     * @return  string
     * @throws  stubDatabaseSerializerException
     * @throws  stubPersistenceException
     */
    public function serialize(stubObject $entity);

    /**
     * delete an entity from database by its primary keys
     *
     * @param   stubObject                   $entity
     * @throws  stubDatabaseEraserException
     * @throws  stubPersistenceException
     */
    public function deleteByPrimaryKeys(stubObject $entity);

    /**
     * deletes all instances of an entity by given criterion
     *
     * @param   stubCriterion                $criterion    the criterion that denotes all instances to delete
     * @param   stubBaseReflectionClass      $entityClass
     * @return  int                          amount of erased instances
     * @throws  stubDatabaseEraserException
     */
    public function deleteByCriterion(stubCriterion $criterion, stubBaseReflectionClass $entityClass);
}
?><?php
/**
 * Exception to be thrown if a problem in the finder occurs.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence
 * @version     $Id: stubPersistenceException.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Exception to be thrown if a problem in the finder occurs.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence
 */
class stubPersistenceException extends stubException
{
    // intentionally empty
}
?><?php
/**
 * Base class with helper methods for entity operations.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence
 * @version     $Id: stubPersistenceHelper.php 2471 2010-01-18 16:50:55Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::persistence::stubPersistenceException',
                      'net::stubbles::rdbms::persistence::annotation::stubDBColumnAnnotation',
                      'net::stubbles::rdbms::persistence::annotation::stubDBTableAnnotation',
                      'net::stubbles::rdbms::persistence::annotation::stubEntityAnnotation',
                      'net::stubbles::rdbms::persistence::annotation::stubIdAnnotation',
                      'net::stubbles::rdbms::persistence::annotation::stubTransientAnnotation',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseQueryBuilderFactory',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseTableDescription',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseTableColumn',
                      'net::stubbles::reflection::reflection'
);
/**
 * Base class with helper methods for entity operations.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence
 */
abstract class stubPersistenceHelper extends stubBaseObject
{
    /**
     * query builder factory
     *
     * @var  stubDatabaseQueryBuilderFactory
     */
    protected $databaseQueryBuilderFactory;
    /**
     * list of table descriptions
     *
     * @var  array<string,stubDatabaseTableDescription>
     */
    protected static $tableDescriptions = array();
    /**
     * list of classes with their persistence data
     *
     * @var  array<string,array<string,stubDatabaseTableColumn>>
     */
    protected static $columns           = array();
    /**
     * list of forbidden methods
     *
     * @var  array<string>
     */
    protected $forbiddenMethods = array('getClass',
                                        'getPackage',
                                        'getClassName',
                                        'getPackageName',
                                        'getSerialized'
                                  );

    /**
     * constructor
     *
     * @param  stubDatabaseQueryBuilderFactory  $databaseQueryBuilderFactory
     */
    public function __construct(stubDatabaseQueryBuilderFactory $databaseQueryBuilderFactory)
    {
        $this->databaseQueryBuilderFactory = $databaseQueryBuilderFactory;
    }

    /**
     * helper method to create the correct table definition
     *
     * @param   stubBaseReflectionClass       $entityClass
     * @return  stubDatabaseTableDescription
     */
    protected function getTableDescription(stubBaseReflectionClass $entityClass)
    {
        $fqClassName = $entityClass->getFullQualifiedClassName();
        if (isset(self::$tableDescriptions[$fqClassName]) === false) {
            if ($entityClass->hasAnnotation('DBTable') === true) {
                 self::$tableDescriptions[$fqClassName] = $entityClass->getAnnotation('DBTable')->getTableDescription();
            } else {
                self::$tableDescriptions[$fqClassName] = new stubDatabaseTableDescription();
                self::$tableDescriptions[$fqClassName]->setName($entityClass->getName() . 's');
            }
        }
        
        return self::$tableDescriptions[$fqClassName];
    }

    /**
     * returns list of columns and method names
     *
     * @param   stubBaseReflectionClass                $entityClass
     * @return  array<string,stubDatabaseTableColumn>
     */
    protected function getColumns(stubBaseReflectionClass $entityClass)
    {
        $fqClassName = $entityClass->getFullQualifiedClassName();
        if (isset(self::$columns[$fqClassName]) === false) {
            self::$columns[$fqClassName] = array();
            foreach ($entityClass->getMethods() as $method) {
                $column = $this->getTableColumn($method);
                if (null === $column) {
                    continue;
                }
                
                self::$columns[$fqClassName][$method->getName()] = $column;
            }
            
        }
        return self::$columns[$fqClassName];
    }

    /**
     * helper method to create the column definition
     * 
     * Returns null if the method does not return a proper definition.
     *
     * @param   stubReflectionMethod     $method
     * @return  stubDatabaseTableColumn
     * @throws  stubPersistenceException
     */
    private function getTableColumn(stubReflectionMethod $method)
    {
        if ($method->isStatic() === true || $method->isPublic() === false
                || in_array($method->getName(), $this->forbiddenMethods) === true
                || $method->hasAnnotation('Transient') === true
                || $method->getNumberOfParameters() > 0) {
            return null;
        }
        
        if ($method->hasAnnotation('DBColumn') === true) {
            $column = $method->getAnnotation('DBColumn')->getTableColumn();
        } elseif (substr($method->getName(), 0, 3) !== 'get' && substr($method->getName(), 0, 2) !== 'is') {
            return null;
        } else {
            $column = new stubDatabaseTableColumn();
            $column->setName($this->getPropertyName($method->getName()));
            $returnType = $method->getReturnType();
            if (null === $returnType) {
                // no type hint or returns null -> ignore method
                return null;
            }
            
            if ($returnType instanceof stubReflectionClass) {
                if ($returnType->getName() !== 'stubDate') {
                    // not supported yet
                    throw new stubPersistenceException('Returning classes from entity getter methods is currently not supported, except for net::stubbles::lang::types::stubDate. Sorry. :(');
                }
                
                $column->setType('DATETIME');
            } else {
                switch ($returnType->value()) {
                    case 'int':
                        $column->setType('INT');
                        $column->setSize(10);
                        break;
                    
                    case 'float':
                        $column->setType('FLOAT');
                        $column->setSize(10);
                        break;
                    
                    case 'bool':
                        $column->setType('TINYINT');
                        $column->setSize(1);
                        break;
                    
                    default:
                        $column->setType('VARCHAR');
                        $column->setSize(255);
                }
            }
        }
        
        if ($method->hasAnnotation('Id') === true) {
            $column->setIsPrimaryKey(true);
        }
        
        return $column;
    }

    /**
     * creates the property name from the name of the method
     *
     * @param   string  $methodName
     * @return  string
     */
    protected function getPropertyName($methodName)
    {
        $propertyName = str_replace('is', '', str_replace('get', '', $methodName));
        return strtolower($propertyName{0}) . substr($propertyName, 1);
    }
}
?><?php
/**
 * Helper class to work with setter methods.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence
 * @version     $Id: stubSetterMethodHelper.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::types::stubDate',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseTableColumn',
                      'net::stubbles::rdbms::persistence::stubPersistenceException'
);
/**
 * Helper class to work with setter methods.
 *
 * @package     stubbles
 * @subpackage  rdbms_persistence
 */
class stubSetterMethodHelper extends stubBaseObject
{
    /**
     * name of class to collect setter methods of
     *
     * @var  string
     */
    protected $className;
    /**
     * list of setter methods
     *
     * @var  array<string,array<string,mixed>>
     */
    protected $setterMethods = array();

    /**
     * constructor
     *
     * @param  string  $className  name of class to collect setter methods of
     */
    public function __construct($className)
    {
        $this->className = $className;
    }

    /**
     * adds a setter method for given getter method
     *
     * @param   stubDatabaseTableColumn   $dbColumn          db column annotation from getter method
     * @param   string                    $getterMethodName  name of getter method
     * @throws  stubPersistenceException
     */
    public function addSetterMethod(stubDatabaseTableColumn $dbColumn, $getterMethodName)
    {
        $this->setterMethods[$dbColumn->getName()] = array('setterMethod' => self::getSetterMethodName($dbColumn, $this->className, $getterMethodName),
                                                           'type'         => $dbColumn->getType()
                                                     );
    }

    /**
     * applies the setter methods with given data on given entity
     *
     * @param   object  $entity  entity to apply setter methods on
     * @param   array   $data    data to apply setter methods with
     * @throws  stubPersistenceException
     */
    public function applySetterMethods($entity, array $data)
    {
        if (($entity instanceof $this->className) === false) {
            throw new stubPersistenceException('Given entity must be of type ' . $this->className);
        }
        
        foreach ($this->setterMethods as $columnName => $info) {
            if (isset($data[$columnName]) === false) {
                continue;
            }
            
            if ('DATETIME' === $info['type']) {
                $data[$columnName] = new stubDate($data[$columnName]);
            }
            
            $setterMethodName = $info['setterMethod'];
            $entity->$setterMethodName($data[$columnName]);
        }
    }

    /**
     * create setter method from given annotation for given class
     *
     * @param   stubDatabaseTableColumn   $dbColumn          description of column
     * @param   string                    $className         name of class which contains the method
     * @param   string                    $getterMethodName  name of the method annotated with DBColumn
     * @return  string                    name of setter setter method
     * @throws  stubPersistenceException
     */
    public static function getSetterMethodName(stubDatabaseTableColumn $dbColumn, $className, $getterMethodName)
    {
        $setterMethodName = (($dbColumn->hasSetterMethod() == true) ? ($dbColumn->getSetterMethod()) : (str_replace('get', 'set', $getterMethodName)));
        if (in_array($setterMethodName, get_class_methods($className)) === false) {
            throw new stubPersistenceException('Public setter method ' . $className . '::' . $setterMethodName . '() for database field ' . $dbColumn->getName() . '  does not exist.');
        }
        
        return $setterMethodName;
    }
}
?><?php
/**
 * Class for creating MySQL specific queries.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 * @version     $Id: stubDatabaseMySQLQueryBuilder.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::querybuilder::stubDatabaseQueryBuilder');
/**
 * Class for creating MySQL specific queries.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 * @see         http://mysql.com/
 */
class stubDatabaseMySQLQueryBuilder extends stubBaseObject implements stubDatabaseQueryBuilder
{
    /**
     * list of text types
     *
     * @var  array<string>
     * @see  http://dev.mysql.com/doc/refman/5.0/en/string-type-overview.html
     */
    protected static $textTypes    = array('TINYTEXT',
                                           'MEDIUMTEXT',
                                           'TEXT',
                                           'LONGTEXT',
                                           'CHAR',
                                           'VARCHAR',
                                           'ENUM',
                                           'SET'
                                     );
    /**
     * list of numeric types
     *
     * @var  array<string>
     * @see  http://dev.mysql.com/doc/refman/5.0/en/numeric-type-overview.html
     */
    protected static $numericTypes = array('TINYINT',
                                           'SMALLINT',
                                           'MEDIUMINT',
                                           'INT',
                                           'INTEGER',
                                           'BIGINT',
                                           'FLOAT',
                                           'DOUBLE',
                                           'DOUBLE PRECISION',
                                           'REAL',
                                           'DECIMAL',
                                           'DEC',
                                           'NUMERIC',
                                           'FIXED'
                                     );
    /**
     * list of types that don't have a size
     *
     * @var  array<string>
     */
    protected static $noSizeTypes  = array('TEXT',
                                           'DATETIME',
                                           'DATE',
                                           'TIME',
                                           'TIMESTAMP',
                                           'YEAR'
                                     );

    /**
     * creates a select query
     *
     * @param   stubDatabaseSelect  $select
     * @return  string
     */
    public function createSelect(stubDatabaseSelect $select)
    {
        $selectQuery = 'SELECT * FROM `' . $select->getBaseTableName() . '`';
        if ($select->hasJoins() === true) {
            $joins = $select->getJoins();
            foreach ($joins as $join) {
                $selectQuery .= ' ' . $join->getType();
                $selectQuery .= (($join->getType() !== 'STRAIGHT') ? (' ') : ('_'));
                $selectQuery .= 'JOIN `' . $join->getName() . '`';
                if ($join->hasCondition() === true) {
                    $selectQuery .= ' ' . $join->getConditionType() . ' ';
                    if ($join->getConditionType() === 'USING') {
                        $selectQuery .= '(' . $join->getCondition() . ')';
                    } else {
                        $selectQuery .= $join->getCondition();
                    }
                }
            }
        }
        
        if ($select->hasCriterion() === true) {
            $selectQuery .= ' WHERE ' . $select->getCriterion()->toSQL();
        }
        
        if ($select->isOrdered() === true) {
            $selectQuery .= ' ORDER BY ' . $select->getOrderedBy();
        }
        
        if ($select->hasLimit() === true) {
            $selectQuery .= ' LIMIT ' . $select->getOffset() . ',' . $select->getAmount();
        }
        
        return $selectQuery;
    }

    /**
     * creates insert queries from a serialized value
     *
     * @param   array<string,stubDatabaseTableRow>  $tableRows
     * @return  array<string,string>
     * @throws  stubIllegalArgumentException
     */
    public function createInsert(array $tableRows)
    {
        $queries = array();
        foreach ($tableRows as $tableName => $tableRow) {
            if (($tableRow instanceof stubDatabaseTableRow) === false) {
                throw new stubIllegalArgumentException('Table row for table ' . $tableName . ' is not an instance of net::stubbles::querybuilder::stubDatabaseTableRow.');
            }
            
            $tableName = $tableRow->getTableName();
            $queries[$tableName] = 'INSERT INTO `' . $tableName . '` (`' . join('`, `', $tableRow->getColumnNames()) . '`) VALUES (';
            $counter = 0;
            foreach ($tableRow->getColumns() as $columnValue) {
                if (0 < $counter) {
                    $queries[$tableName] .= ', ';
                }
                
                if (null === $columnValue) {
                    $queries[$tableName] .= 'NULL';
                } elseif (is_int($columnValue) === true) {
                    $queries[$tableName] .= $columnValue;
                } else {
                    $queries[$tableName] .= "'" . addslashes($columnValue) . "'";
                }
                
                $counter++;
            }
            
            $queries[$tableName] .= ')';
        }
        
        return $queries;
    }

    /**
     * creates update queries from a serialized value
     *
     * @param   array<string,stubDatabaseTableRow>  $tableRows
     * @return  array<string,string>
     * @throws  stubIllegalArgumentException
     */
    public function createUpdate(array $tableRows)
    {
        $queries    = array();
        foreach ($tableRows as $tableName => $tableRow) {
            if (($tableRow instanceof stubDatabaseTableRow) === false) {
                throw new stubIllegalArgumentException('Table row for table ' . $tableName . ' is not an instance of net::stubbles::querybuilder::stubDatabaseTableRow.');
            }
            
            $tableName           = $tableRow->getTableName();
            $queries[$tableName] = 'UPDATE `' . $tableName . '` SET ';
            $counter             = 0;
            foreach ($tableRow->getColumns() as $columnName => $columnValue) {
                if (0 < $counter) {
                    $queries[$tableName] .= ', ';
                }
                
                $queries[$tableName] .= '`' . $columnName . '` = ';
                if (null === $columnValue) {
                    $queries[$tableName] .= 'NULL';
                } elseif (is_int($columnValue) === true) {
                    $queries[$tableName] .= $columnValue;
                } else {
                    $queries[$tableName] .= "'" . addslashes($columnValue) . "'";
                }
                
                $counter++;
            }
            
            if ($tableRow->hasCriterion() === true) {
                $queries[$tableName] .= ' WHERE ' . $tableRow->getCriterion()->toSQL();
            }
        }
        
        return $queries;
    }

    /**
     * creates a delete query
     *
     * @param   string         $table      the table to delete from
     * @param   stubCriterion  $criterion  the criterion to use for deletion
     * @return  string
     */
    public function createDelete($table, stubCriterion $criterion)
    {
        return 'DELETE FROM `' . $table . '` WHERE ' . $criterion->toSQL();
    }

    /**
     * creates the query to create a table for the given class
     *
     * @param   stubDatabaseTableDescription       $tableDescription
     * @return  string
     * @throws  stubDatabaseQueryBuilderException
     */
    public function createTable(stubDatabaseTableDescription $tableDescription)
    {
        $query   = 'CREATE TABLE `' . $tableDescription->getName() . "` (\n";
        $columns = $tableDescription->getColumns();
        if (count($columns) === 0) {
            throw new stubDatabaseQueryBuilderException('A table must contain at least one column, but description for table ' . $tableDescription->getName() . ' does not contain any column.');
        }
        
        $primaryKeys = array();
        $keys        = array();
        $uniques     = array();
        $counter     = 0;
        foreach ($columns as $column) {
            if (0 < $counter) {
                $query .= ",\n";
            }
            
            $counter++;
            $query   .= '  ' . $column->getName() . ' ' . strtoupper($column->getType());
            if (in_array(strtoupper($column->getType()), self::$noSizeTypes) === false) {
                $query   .= '(' . $column->getSize() . ')';
            }
            
            if ($this->isTextColumn($column->getType()) === true) {
                if ($column->hasCharacterSet() === true) {
                    $query .= ' CHARACTER SET ' . $column->getCharacterSet();
                }
                
                if ($column->hasCollation() === true) {
                    $query .= ' COLLATE ' . $column->getCollation();
                }
            } elseif ($this->isNumericColumn($column->getType()) === true) {
                if ($column->isUnsigned() == true) {
                    $query .= ' UNSIGNED';
                }
                
                if ($column->hasZerofill() == true) {
                    $query .= ' ZEROFILL';
                }
            }
            
            if ($column->isNullable() === true && $column->getDefaultValue() === null) {
                $query .= ' DEFAULT NULL';
            } else {
                if ($column->isNullable() === false) {
                    $query .= ' NOT NULL';
                }
                
                if ($column->getDefaultValue() !== null) {
                    $query .= " DEFAULT '" . $column->getDefaultValue() . "'";
                }
            }
            
            if ($column->isPrimaryKey() === true) {
                if ($this->isNumericColumn($column->getType()) === true) {
                    $query .= ' AUTO_INCREMENT';
                }
                
                $primaryKeys[] = $column->getName();
            } elseif ($column->isKey() === true) {
                $keys[] = $column->getName();
            } elseif ($column->isUnique() === true) {
                $uniques[] = $column->getName();
            }
        }
        if (count($primaryKeys) > 0) {
            if (count($primaryKeys) > 1) {
                $query = str_replace(' AUTO_INCREMENT', '', $query);
            }
            
            $query .= ",\n  PRIMARY KEY (`" . join('`, `', $primaryKeys) . '`)';
        }
        if (count($keys) > 0) {
            foreach ($keys as $key) {
                $query .= ",\n  KEY (`" . $key . '`)';
            }
        }
        
        if (count($uniques) > 0) {
            foreach ($uniques as $unique) {
                $query .= ",\n  UNIQUE (`" . $unique . '`)';
            }
        }
        
        $query .= "\n)";
        if ($tableDescription->hasType() === true) {
            $query .= ' ENGINE = ' . $tableDescription->getType();
        }
        
        if ($tableDescription->hasCharacterSet() === true) {
            $query .= ' CHARACTER SET ' . $tableDescription->getCharacterSet();
        }
        
        if ($tableDescription->hasCollation() === true) {
            $query .= ' COLLATE ' . $tableDescription->getCollation();
        }
        
        if ($tableDescription->hasComment() === true) {
            $query .= " COMMENT = '" . $tableDescription->getComment() . "'";
        }
        
        return $query;
    }

    /**
     * checks whether the given column type is a text type
     *
     * @param   string  $columnType  the type to check
     * @return  bool
     * @see     http://dev.mysql.com/doc/refman/5.0/en/string-type-overview.html
     */
    protected function isTextColumn($columnType)
    {
        return in_array(strtoupper($columnType), self::$textTypes);
    }

    /**
     * check whether the given column type is a numeric type
     *
     * @param   string  $columnType  the type to check
     * @return  bool
     * @see     http://dev.mysql.com/doc/refman/5.0/en/numeric-type-overview.html
     */
    protected function isNumericColumn($columnType)
    {
        return in_array(strtoupper($columnType), self::$numericTypes);
    }
}
?><?php
/**
 * Interface for database specific query builders.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 * @version     $Id: stubDatabaseQueryBuilder.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::rdbms::criteria::stubCriterion',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseQueryBuilderException',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseSelect',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseTableDescription',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseTableRow'
);
/**
 * Interface for database specific query builders.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 */
interface stubDatabaseQueryBuilder extends stubObject
{
    /**
     * creates a select query
     *
     * @param   stubDatabaseSelect  $select
     * @return  string
     */
    public function createSelect(stubDatabaseSelect $select);

    /**
     * creates insert queries from a serialized value
     *
     * @param   array<string,stubDatabaseTableRow>  $tableRows
     * @return  array<string,string>
     * @throws  stubIllegalArgumentException
     */
    public function createInsert(array $tableRows);

    /**
     * creates update queries from a serialized value
     *
     * @param   array<string,stubDatabaseTableRow>  $tableRows
     * @return  array<string,string>
     * @throws  stubIllegalArgumentException
     */
    public function createUpdate(array $tableRows);

    /**
     * creates a delete query
     *
     * @param   string         $table      the table to delete from
     * @param   stubCriterion  $criterion  the criterion to use for deletion
     * @return  string
     */
    public function createDelete($table, stubCriterion $criterion);

    /**
     * creates the query to create a table for the given class
     *
     * @param   stubDatabaseTableDescription       $tableDescription
     * @throws  stubDatabaseQueryBuilderException
     */
    public function createTable(stubDatabaseTableDescription $tableDescription);
}
?><?php
/**
 * Exception to be thrown if a query builder stumbles upon a failure.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 * @version     $Id: stubDatabaseQueryBuilderException.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Exception to be thrown if a query builder stumbles upon a failure.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 */
class stubDatabaseQueryBuilderException extends stubException
{
    // intentionally empty
}
?><?php
/**
 * Factory to create database specific query builders.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 * @version     $Id: stubDatabaseQueryBuilderFactory.php 2471 2010-01-18 16:50:55Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::stubDatabaseConnection',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseQueryBuilder',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseQueryBuilderException'
);
/**
 * Factory to create database specific query builders.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 */
class stubDatabaseQueryBuilderFactory extends stubBaseObject
{
    /**
     * list of created query builders
     *
     * @var  array<string,stubDatabaseQueryBuilder>
     */
    protected $instantiatedQueryBuilders = array();
    /**
     * list of available query builders
     *
     * @var  array<string,string>
     */
    protected $availableQueryBuilders    = array('mysql' => 'net::stubbles::rdbms::querybuilder::stubDatabaseMySQLQueryBuilder');

    /**
     * constructor
     *
     * @param  array<string,string>  $availableQueryBuilders  optional
     */
    public function __construct(array $availableQueryBuilders = null)
    {
        if (null !== $availableQueryBuilders) {
            $this->availableQueryBuilders = $availableQueryBuilders;
        }
    }

    /**
     * creates a query builder for the given connection
     *
     * @param   stubDatabaseConnection    $connection
     * @return  stubDatabaseQueryBuilder
     * @throws  stubDatabaseQueryBuilderException
     */
    public function create(stubDatabaseConnection $connection)
    {
        $database = strtolower($connection->getDatabase());
        if (isset($this->instantiatedQueryBuilders[$database]) == false) {
            $this->createInstance($database);
        }
        
        return $this->instantiatedQueryBuilders[$database];
    }

    /**
     * checks whether a query builder for the specified database type is available
     *
     * @param   stzring  $database  type of the database the querybuilder is registered for
     * @return  bool
     */
    public function isQueryBuilderAvailable($database)
    {
        return isset($this->availableQueryBuilders[strtolower($database)]);
    }

    /**
     * adds the query builder to use for the given database type
     *
     * @param   string                           $database     type of the database (e.g. MySQL, PostgrSQL)
     * @param   string                           $fqClassName  full qualified classname of the querybuilder
     * @return  stubDatabaseQueryBuilderFactory
     */
    public function addAvailableQueryBuilder($database, $fqClassName)
    {
        $this->availableQueryBuilders[strtolower($database)] = $fqClassName;
        return $this;
    }

    /**
     * removes a query builder from the list of available query builders
     *
     * @param   string                           $database  type of the database the querybuilder to remove is registered for
     * @return  stubDatabaseQueryBuilderFactory
     */
    public function removeAvailableQueryBuilder($database)
    {
        if (isset($this->availableQueryBuilders[strtolower($database)]) == true) {
            unset($this->availableQueryBuilders[strtolower($database)]);
        }

        return $this;
    }

    /**
     * checks whether an instance of the query builder for the specified database type exists
     *
     * @param   string  $database  type of the database the querybuilder is registered for
     * @return  bool
     */
    public function isQueryBuilderInstantiated($database)
    {
        return isset($this->instantiatedQueryBuilders[strtolower($database)]);
    }

    /**
     * adds an instantiated query builder to use for the given database type
     *
     * @param  string                           $database      type of the database (e.g. MySQL, PostgrSQL)
     * @param  stubDatabaseQueryBuilderFactory  $queryBuilder  the querybuilder to use
     */
    public function addInstantiatedQueryBuilder($database, stubDatabaseQueryBuilder $queryBuilder)
    {
        $this->instantiatedQueryBuilders[strtolower($database)] = $queryBuilder;
        $this->availableQueryBuilders[strtolower($database)]    = $queryBuilder->getClassName();
        return $this;
    }

    /**
     * removes a query builder from the list of instantiated query builders
     *
     * @param   string                           $database  type of the database the querybuilder to remove is registered for
     * @return  stubDatabaseQueryBuilderFactory
     */
    public function removeInstantiatedQueryBuilder($database)
    {
        if (isset($this->instantiatedQueryBuilders[strtolower($database)]) == true) {
            unset($this->instantiatedQueryBuilders[strtolower($database)]);
            unset($this->availableQueryBuilders[strtolower($database)]);
        }

        return $this;
    }

    /**
     * creates the instance
     *
     * @param   string  $database  type of the database (MySQL, PostgreSQL, etc.)
     * @throws  stubDatabaseQueryBuilderException
     */
    protected function createInstance($database)
    {
        if (isset($this->availableQueryBuilders[$database]) == false) {
            throw new stubDatabaseQueryBuilderException('Could not find QueryBuilder for database ' . $database);
        }
        
        $queryBuilderClassName = stubClassLoader::getNonQualifiedClassName($this->availableQueryBuilders[$database]);;
        if (class_exists($queryBuilderClassName, false) == false) {
            stubClassLoader::load($this->availableQueryBuilders[$database]);
        }
        
        $queryBuilder = new $queryBuilderClassName();
        if (($queryBuilder instanceof stubDatabaseQueryBuilder) == false) {
            throw new stubDatabaseQueryBuilderException('Configured QueryBuilder for database ' . $database . ' is not an instance of net::stubbles::rdbms::querybuilder::stubDatabaseQueryBuilder.');
        }
        
        $this->instantiatedQueryBuilders[$database] = $queryBuilder;
    }
}
?><?php
/**
 * Container for the data of a select query.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 * @version     $Id: stubDatabaseSelect.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::criteria::stubAndCriterion',
                      'net::stubbles::rdbms::criteria::stubCriterion',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseTableDescription',
                      'net::stubbles::rdbms::querybuilder::stubDatabaseTableJoin'
);
/**
 * Container for the data of a select query.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 */
class stubDatabaseSelect extends stubBaseObject
{
    /**
     * description of the main table
     * 
     * @var  stubDatabaseTableDescription
     */
    protected $table;
    /**
     * list of tables
     *
     * @var  array<string,stubDatabaseTableJoin>
     */
    protected $joins        = array();
    /**
     * the criterion for the select
     *
     * @var  stubAndCriterion
     */
    protected $criterion;
    /**
     * order by clause
     *
     * @var  string
     */
    protected $orderBy;
    /**
     * offset for limit clause
     *
     * @var  int
     */
    protected $offset;
    /**
     * amount for limit clause
     *
     * @var  int
     */
    protected $amount;

    /**
     * constructor
     * 
     * @param  stubDatabaseTableDescription  $tableDescription
     */
    public function __construct(stubDatabaseTableDescription $tableDescription)
    {
        $this->table     = $tableDescription;
        $this->criterion = new stubAndCriterion();
    }

    /**
     * returns the name of the base table
     *
     * @return  string
     */
    public function getBaseTableName()
    {
        return $this->table->getName();
    }

    /**
     * adds a table
     *
     * @param  stubDatabaseTableJoin  $tableJoin
     */
    public function addJoin(stubDatabaseTableJoin $tableJoin)
    {
        $this->joins[$tableJoin->getName()] = $tableJoin;
    }

    /**
     * check whether there are tables to join
     *
     * @return  bool
     */
    public function hasJoins()
    {
        return (count($this->joins) > 0);
    }

    /**
     * returns the list of tables
     *
     * @return  array<string,stubDatabaseTableJoin>
     */
    public function getJoins()
    {
        return $this->joins;
    }

    /**
     * adds a criterion
     *
     * @param  stubCriterion  $criterion
     */
    public function addCriterion(stubCriterion $criterion)
    {
        $this->criterion->addCriterion($criterion);
    }

    /**
     * checks whether there is any criterion
     *
     * @return  bool
     */
    public function hasCriterion()
    {
        return $this->criterion->hasCriterion();
    }

    /**
     * returns the criterion
     *
     * @return  stubAndCriterion
     */
    public function getCriterion()
    {
        return $this->criterion;
    }

    /**
     * sets the order by clause
     *
     * @param   string              $orderBy
     * @return  stubDatabaseSelect
     */
    public function orderBy($orderBy)
    {
        $this->orderBy = $orderBy;
        return $this;
    }

    /**
     * checks whether an order by clause is set
     *
     * @return  bool
     */
    public function isOrdered()
    {
        return (null !== $this->orderBy);
    }

    /**
     * returns the order by clause
     *
     * @return  string
     */
    public function getOrderedBy()
    {
        return  $this->orderBy;
    }

    /**
     * limits query to start at given offset and contain only given amount of results
     *
     * @param   int                 $offset
     * @param   int                 $amount
     * @return  stubDatabaseSelect
     */
    public function limitBy($offset, $amount)
    {
        $this->offset = ((null === $offset) ? (null) : ((int) $offset));
        $this->amount = ((null === $amount) ? (null) : ((int) $amount));
        return $this;
    }

    /**
     * checks if select has a limit
     *
     * @return  bool
     */
    public function hasLimit()
    {
        return (null !== $this->offset && null !== $this->amount);
    }

    /**
     * returns offset for limit clause
     *
     * @return  int
     */
    public function getOffset()
    {
        return $this->offset;
    }

    /**
     * returns amount for limit clause
     *
     * @return  int
     */
    public function getAmount()
    {
        return $this->amount;
    }
}
?><?php
/**
 * Class that contains the description for a database table column.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 * @version     $Id: stubDatabaseTableColumn.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Class that contains the description for a database table column.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 */
class stubDatabaseTableColumn extends stubBaseObject
{
    /**
     * order of column within table
     *
     * @var  int
     */
    protected $order        = 0;
    /**
     * name of the table
     *
     * @var  string
     */
    protected $name         = '';
    /**
     * type of the table
     *
     * @var  string
     */
    protected $type         = '';
    /**
     * size of the field
     *
     * @var  int|string
     */
    protected $size;
    /**
     * character set of the table
     *
     * @var  string
     */
    protected $characterSet;
    /**
     * collation of the table
     *
     * @var  string
     */
    protected $collation;
    /**
     * switch whether column is unsigned or not
     *
     * @var  bool
     */
    protected $isUnsigned   = false;
    /**
     * switch whether column values are zerofilled or not
     *
     * @var  bool
     */
    protected $hasZerofill  = false;
    /**
     * switch whether the column can be null or not
     *
     * @var  bool
     */
    protected $isNullable   = true;
    /**
     * default value of the column
     *
     * @var  mixed
     */
    protected $defaultValue = null;
    /**
     * switch whether column is a primary key or not
     *
     * @var  bool
     */
    protected $isPrimaryKey = false;
    /**
     * switch whether column is a key or not
     *
     * @var  bool
     */
    protected $isKey        = false;
    /**
     * switch whether column is unique or not
     *
     * @var  bool
     */
    protected $isUnique     = false;
    /**
     * the name of the setter method to use for restoring the value from database
     *
     * @var  string
     */
    protected $setterMethod = null;

    /**
     * set the order within the table
     *
     * @param  int  $order
     */
    public function setOrder($order)
    {
        $this->order = $order;
    }

    /**
     * returns the order within the table
     *
     * @return  int
     */
    public function getOrder()
    {
        return $this->order;
    }

    /**
     * set the name of the table
     *
     * @param  string  $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }

    /**
     * return the name of the table
     *
     * @return  string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * set the type of the table
     *
     * @param  string  $type
     */
    public function setType($type)
    {
        $this->type = $type;
    }

    /**
     * get the type of the table
     *
     * @return  string
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * sets the size of the column
     *
     * @param  int|string  $size
     */
    public function setSize($size)
    {
        $this->size = $size;
    }

    /**
     * returns the size of the column
     *
     * @return  int|string
     */
    public function getSize()
    {
        return $this->size;
    }

    /**
     * set the character set of the table
     *
     * @param  string  $characterSet
     */
    public function setCharacterSet($characterSet)
    {
        $this->characterSet = $characterSet;
    }

    /**
     * check whether the table has a character set
     *
     * @return  bool
     */
    public function hasCharacterSet()
    {
        return (null != $this->characterSet);
    }

    /**
     * return the character set of the table
     *
     * @return  string
     */
    public function getCharacterSet()
    {
        return $this->characterSet;
    }

    /**
     * set the collation of the table
     *
     * @param  string  $collation
     */
    public function setCollation($collation)
    {
        $this->collation = $collation;
    }

    /**
     * check whether the table has a collation
     *
     * @return  bool
     */
    public function hasCollation()
    {
        return (null != $this->collation);
    }

    /**
     * return the collation of the table
     *
     * @return  string
     */
    public function getCollation()
    {
        return $this->collation;
    }

    /**
     * set whether the column may be null or not
     *
     * @param  bool  $isUnsigned
     */
    public function setIsUnsigned($isUnsigned)
    {
        $this->isUnsigned = $isUnsigned;
    }

    /**
     * check whether the column may be null or not
     *
     * @return  bool
     */
    public function isUnsigned()
    {
        return (strstr(strtoupper($this->type), 'INT') == true && true == $this->isUnsigned);
    }

    /**
     * set whether the column values are zerofilled or not
     *
     * @param  bool  $hasZerofill
     */
    public function setHasZerofill($hasZerofill)
    {
        $this->hasZerofill = $hasZerofill;
    }

    /**
     * check whether the column values are zerofilled or not
     *
     * @return  bool
     */
    public function hasZerofill()
    {
        return (strstr(strtoupper($this->type), 'INT') == true && true == $this->hasZerofill);
    }

    /**
     * set whether the column may be null or not
     *
     * @param  bool  $isNullable
     */
    public function setIsNullable($isNullable)
    {
        $this->isNullable = $isNullable;
    }

    /**
     * check whether the column may be null or not
     *
     * @return  bool
     */
    public function isNullable()
    {
        return (false == $this->isPrimaryKey && true == $this->isNullable);
    }

    /**
     * sets the default value of the column
     *
     * @param  mixed  $defaultValue
     */
    public function setDefaultValue($defaultValue)
    {
        $this->defaultValue = $defaultValue;
    }

    /**
     * returns the default value of the column
     *
     * @return  mixed
     */
    public function getDefaultValue()
    {
        return $this->defaultValue;
    }

    /**
     * set whether the column is a primary key or not
     *
     * @param  bool  $isPrimaryKey
     */
    public function setIsPrimaryKey($isPrimaryKey)
    {
        $this->isPrimaryKey = $isPrimaryKey;
    }

    /**
     * check whether the column is a primary key or not
     *
     * @return  bool
     */
    public function isPrimaryKey()
    {
        return $this->isPrimaryKey;
    }

    /**
     * set whether the column is a primary key or not
     *
     * @param  bool  $isKey
     */
    public function setIsKey($isKey)
    {
        $this->isKey = $isKey;
    }

    /**
     * check whether the column is a primary key or not
     *
     * @return  bool
     */
    public function isKey()
    {
        return (false == $this->isPrimaryKey && true == $this->isKey);
    }

    /**
     * set whether the column is unique or not
     *
     * @param  bool  $isUnique
     */
    public function setIsUnique($isUnique)
    {
        $this->isUnique = $isUnique;
    }

    /**
     * check whether the column is unique or not
     *
     * @return  bool
     */
    public function isUnique()
    {
        return (false == $this->isPrimaryKey && true == $this->isUnique);
    }

    /**
     * set the name of the setter method
     *
     * @param  string  $setterMethod
     */
    public function setSetterMethod($setterMethod)
    {
        $this->setterMethod = $setterMethod;
    }

    /**
     * checks whether the name of the setter method is known
     *
     * @return  bool
     */
    public function hasSetterMethod()
    {
        return (null !== $this->setterMethod);
    }

    /**
     * returns the name of the setter method
     *
     * @return  string
     */
    public function getSetterMethod()
    {
        return $this->setterMethod;
    }
}
?><?php
/**
 * Class that contains the description for a database table.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 * @version     $Id: stubDatabaseTableDescription.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::querybuilder::stubDatabaseTableColumn',
                      'net::stubbles::rdbms::stubDatabaseException'
);
/**
 * Class that contains the description for a database table.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 */
class stubDatabaseTableDescription extends stubBaseObject
{
    /**
     * name of the table
     *
     * @var  string
     */
    protected $name             = '';
    /**
     * type of the table
     *
     * @var  string
     */
    protected $type;
    /**
     * character set of the table
     *
     * @var  string
     */
    protected $characterSet;
    /**
     * collation of the table
     *
     * @var  string
     */
    protected $collation;
    /**
     * comment for the table
     *
     * @var  string
     */
    protected $comment;
    /**
     * columns of the table
     *
     * @var  array<int,stubDatabaseTableColumn>
     */
    protected $columns          = array();
    /**
     * columns of table sorted by name
     *
     * @var  array<string>
     */
    protected $columnNames      = array();
    /**
     * the column order counter
     *
     * @var  int
     */
    protected $columnOrder      = 1;

    /**
     * set the name of the table
     *
     * @param  string  $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }

    /**
     * return the name of the table
     *
     * @return  string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * set the type of the table
     *
     * @param  string  $type
     */
    public function setType($type)
    {
        $this->type = $type;
    }

    /**
     * check whether the table has a type
     *
     * @return  bool
     */
    public function hasType()
    {
        return (null != $this->type);
    }

    /**
     * get the type of the table
     *
     * @return  string
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * set the character set of the table
     *
     * @param  string  $characterSet
     */
    public function setCharacterSet($characterSet)
    {
        $this->characterSet = $characterSet;
    }

    /**
     * check whether the table has a character set
     *
     * @return  bool
     */
    public function hasCharacterSet()
    {
        return (null != $this->characterSet);
    }

    /**
     * return the character set of the table
     *
     * @return  string
     */
    public function getCharacterSet()
    {
        return $this->characterSet;
    }

    /**
     * set the collation of the table
     *
     * @param  string  $collation
     */
    public function setCollation($collation)
    {
        $this->collation = $collation;
    }

    /**
     * check whether the table has a collation
     *
     * @return  bool
     */
    public function hasCollation()
    {
        return (null != $this->collation);
    }

    /**
     * return the collation of the table
     *
     * @return  string
     */
    public function getCollation()
    {
        return $this->collation;
    }

    /**
     * set the comment for the table
     *
     * @param  string  $comment
     */
    public function setComment($comment)
    {
        $this->comment = $comment;
    }

    /**
     * check whether the table has a comment
     *
     * @return  bool
     */
    public function hasComment()
    {
        return (null != $this->comment);
    }

    /**
     * return the comment for the table
     *
     * @return  string
     */
    public function getComment()
    {
        return $this->comment;
    }

    /**
     * add a column to the table
     *
     * @param   stubDatabaseTableColumn  $column
     * @throws  stubDatabaseException
     */
    public function addColumn(stubDatabaseTableColumn $column)
    {
        if (in_array($column->getName(), $this->columnNames) == true) {
            throw new stubDatabaseException('The column ' . $column->getName() . ' already exists in table ' . $this->getName());
        }
        
        $this->columnNames[] = $column->getName();
        $order = $column->getOrder();
        if (0 == $order) {
            $order = $this->columnOrder;
            $this->columnOrder++;
        }
        
        if (isset($this->columns[$order]) == true) {
            throw new stubDatabaseException('Can not add column ' . $column->getName() . ' with order ' . $order . ', there is already column ' . $this->columns[$order]->getName() . ' at this place.');
        }
        
        $this->columns[$order] = $column;
    }

    /**
     * return the list of columns of the table
     *
     * @return  array<string,stubDatabaseTableColumn>
     */
    public function getColumns()
    {
        ksort($this->columns);
        return $this->columns;
    }
}
?><?php
/**
 * Class that contains the description for a database table.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 * @version     $Id: stubDatabaseTableJoin.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException');
/**
 * Class that contains the description for a database table.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 */
class stubDatabaseTableJoin extends stubBaseObject
{
    /**
     * name of the table which is joined
     *
     * @var  string
     */
    protected $name          = '';
    /**
     * list of allowed join types
     *
     * @var  array<string>
     */
    protected static $types  = array('LEFT', 'RIGHT', 'INNER', 'OUTER', 'CROSS', 'STRAIGHT', 'NATURAL');
    /**
     * type of the table
     *
     * @var  string
     */
    protected $type          = '';
    /**
     * the condition type (ON|USING)
     *
     * @var  string
     */
    protected $conditionType = '';
    /**
     * the join condition
     *
     * @var  string
     */
    protected $condition     = null;

    /**
     * set the name of the table which is joined
     *
     * @param  string  $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }

    /**
     * return the name of the table which is joined
     *
     * @return  string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * set the type of the table
     *
     * @param   string  $type
     * @throws  stubIllegalArgumentException
     */
    public function setType($type)
    {
        $type  = strtoupper($type);
        $types = explode(' ', $type);
        foreach ($types as $typeTest) {
            if (in_array($typeTest, self::$types) === false) {
                throw new stubIllegalArgumentException('The given join type ' . $type . ' is not an allowed join type. Allowed join types are ' . join(', ', self::$types));
            }
        }

        $this->type = $type;
    }

    /**
     * get the type of the table
     *
     * @return  string
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * sets the condition type
     *
     * @param   string  $conditionType
     * @throws  stubIllegalArgumentException
     */
    public function setConditionType($conditionType)
    {
        $conditionTypes = array('ON', 'USING');
        $conditionType  = strtoupper($conditionType);
        if (in_array($conditionType, $conditionTypes) === false) {
            throw new stubIllegalArgumentException('The given join condition type ' . $conditionType . ' is not an allowed join type. Allowed join condition types are ' . join(', ', $conditionTypes));
        }

        $this->conditionType = $conditionType;
    }

    /**
     * returns the condition type
     *
     * @return  string
     */
    public function getConditionType()
    {
        return $this->conditionType;
    }

    /**
     * sets the join condition
     *
     * @param  string  $condition
     */
    public function setCondition($condition)
    {
        $this->condition = $condition;
    }

    /**
     * checks whether the join has a condition
     *
     * @return  string
     */
    public function hasCondition()
    {
        return (null != $this->condition);
    }

    /**
     * returns the join condition
     *
     * @return  string
     */
    public function getCondition()
    {
        return $this->condition;
    }
}
?><?php
/**
 * Class that represents a row within a table.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 * @version     $Id: stubDatabaseTableRow.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::criteria::stubCriterion',
                      'net::stubbles::rdbms::criteria::stubAndCriterion'
);
/**
 * Class that represents a row within a table.
 *
 * @package     stubbles
 * @subpackage  rdbms_querybuilder
 */
class stubDatabaseTableRow extends stubBaseObject
{
    /**
     * name of the table the row is from
     *
     * @var  string
     */
    protected $tableName = '';
    /**
     * the list of values of the row
     *
     * @var  array<string,scalar>
     */
    protected $columns   = array();
    /**
     * the criterion that identifies this row uniquely
     *
     * @var  stubAndCriterion
     */
    protected $criterion;

    /**
     * constructor
     * 
     * @param  string  $tableName  name of the table where this row is from
     */
    public function __construct($tableName)
    {
        $this->tableName = $tableName;
        $this->criterion = new stubAndCriterion();
    }

    /**
     * returns the name of the table the row is from
     *
     * @return  string
     */
    public function getTableName()
    {
        return $this->tableName;
    }

    /**
     * sets the value of a column
     *
     * @param  string       $name   name of the column to set
     * @param  scalar|null  $value  value the column should have
     */
    public function setColumn($name, $value)
    {
        $this->columns[$name] = $value;
    }

    /**
     * returns a list of all column names
     *
     * @return  array<string>
     */
    public function getColumnNames()
    {
        return array_keys($this->columns);
    }
    
    /**
     * returns a hash map of columns
     *
     * @return  array<string,scalar>
     */
    public function getColumns()
    {
        return $this->columns;
    }

    /**
     * adds a criterion to the and criterion
     *
     * @param  stubCriterion  $criterion
     */
    public function addCriterion(stubCriterion $criterion)
    {
        $this->criterion->addCriterion($criterion);
    }

    /**
     * checks whether there is any criterion
     *
     * @return  bool
     */
    public function hasCriterion()
    {
        return $this->criterion->hasCriterion();
    }

    /**
     * returns the criterion
     *
     * @return  stubAndCriterion
     */
    public function getCriterion()
    {
        return $this->criterion;
    }
}
?><?php
/**
 * Interface for database connections.
 *
 * @package     stubbles
 * @subpackage  rdbms
 * @version     $Id: stubDatabaseConnection.php 2501 2010-02-04 15:52:40Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::stubDatabaseConnectionData',
                      'net::stubbles::rdbms::stubDatabaseException',
                      'net::stubbles::rdbms::stubDatabaseResult',
                      'net::stubbles::rdbms::stubDatabaseStatement'
);
/**
 * Interface for database connections.
 *
 * @package     stubbles
 * @subpackage  rdbms
 * @ProvidedBy(net::stubbles::rdbms::ioc::stubDatabaseConnectionProvider.class)
 */
interface stubDatabaseConnection extends stubObject
{
    /**
     * constructor
     *
     * @param  stubDatabaseConnectionData  $connectionData  container that contains the data required to establish the connection
     */
    #public function __construct(stubDatabaseConnectionData $connectionData);

    /**
     * establishes the connection
     *
     * @throws  stubDatabaseException
     */
    public function connect();

    /**
     * disconnects the database
     */
    public function disconnect();

    /**
     * returns the connection data used for the connection
     *
     * @return  stubDatabaseConnectionData
     */
    public function getConnectionData();

    /**
     * start a transaction
     *
     * @return  bool
     * @throws  stubDatabaseException
     */
    public function beginTransaction();

    /**
     * commit a transaction
     *
     * @return  bool
     * @throws  stubDatabaseException
     */
    public function commit();

    /**
     * rollback a transaction
     *
     * @return  bool
     * @throws  stubDatabaseException
     */
    public function rollback();

    /**
     * creates a prepared statement
     * 
     * @param   string  $statement      SQL statement
     * @param   array   $driverOptions  optional  one or more key=>value pairs to set attribute values for the Statement object
     * @return  stubDatabaseStatement
     * @throws  stubDatabaseException
     */
    public function prepare($statement, array $driverOptions = array());

    /**
     * executes a SQL statement
     * 
     * @param   string  $sql            the sql query to use
     * @param   array   $driverOptions  optional  one or more driver specific options for the call to query()
     * @return  stubDatabaseResult
     * @throws  stubDatabaseException
     */
    public function query($sql, array $driverOptions = array());

    /**
     * execute an SQL statement and return the number of affected rows
     *
     * @param   string  $statement      the sql statement to execute
     * @param   array   $driverOptions  optional  one or more driver specific options for the call to query()
     * @return  int     number of effected rows
     * @throws  stubDatabaseException
     */
    public function exec($statement, array $driverOptions = array());

    /**
     * returns the last insert id
     *
     * @param   string  $name  optional  identifier to where to retrieve the last insert id from
     * @return  int
     * @throws  stubDatabaseException
     */
    public function getLastInsertId($name = null);

    /**
     * returns the database name (e.g. MySQL or PostgreSQL)
     *
     * @return  string
     */
    public function getDatabase();
}
?><?php
/**
 * Container for database connection data.
 *
 * @package     stubbles
 * @subpackage  rdbms
 * @version     $Id: stubDatabaseConnectionData.php 2471 2010-01-18 16:50:55Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubConfigurationException');
/**
 * Container for database connection data.
 *
 * @package     stubbles
 * @subpackage  rdbms
 */
class stubDatabaseConnectionData extends stubSerializableObject
{
    /**
     * id of the default connection
     */
    const DEFAULT_ID         = 'default';
    /**
     * id to use for the connection
     *
     * @var  string
     */
    protected $id            = self::DEFAULT_ID;
    /**
     * the full qualified name of the class to use for the connection
     *
     * @var  string
     */
    protected $fqClassName   = 'net::stubbles::rdbms::pdo::stubDatabasePDOConnection';
    /**
     * Data Source Name, or DSN, contains the information required to connect to the database
     *
     * @var  string
     */
    protected $dsn           = '';
    /**
     * user name
     *
     * @var  string
     */
    protected $userName      = '';
    /**
     * password
     *
     * @var  string
     */
    protected $password      = '';
    /**
     * a key=>value array of driver-specific connection options
     *
     * @var  array
     */
    protected $driverOptions = array();
    /**
     * initial query to be executed after commit
     *
     * @var  string
     */
    protected $initialQuery;

    /**
     * create connection data instance from an array
     *
     * Please note that this method does not support driver options. Driver
     * options must be set separately.
     *
     * @param   array<string,string>        $properties
     * @param   string                      $id          optional
     * @return  stubDatabaseConnectionData
     * @since   1.1.0
     */
    public static function fromArray(array $properties, $id = null)
    {
        $self = new self();
        if (null != $id) {
            $self->setId($id);
        }
        
        if (isset($properties['dsn']) === false) {
            throw new stubConfigurationException('Missing dsn property.');
        }

        $self->setDSN($properties['dsn']);
        if (isset($properties['username']) === true) {
            $self->setUserName($properties['username']);
        }

        if (isset($properties['password']) === true) {
            $self->setPassword($properties['password']);
        }

        if (isset($properties['initialQuery']) === true) {
            $self->setInitialQuery($properties['initialQuery']);
        }

        if (isset($properties['connectionClassName']) === true) {
            $self->setConnectionClassName($properties['connectionClassName']);
        }

        return $self;
    }

    /**
     * set the id to use for the connection
     * 
     * Warning: two instances will be the same if they have the same id,
     * regardless whether the concrete connection data is differant or not.
     * You should never use the same id for differant connection datasets.
     *
     * @param  string  $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }

    /**
     * return the id to use for the connection
     *
     * @return  string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * checks whether a value is equal to the class
     * 
     * Warning: two instances will be the same if they have the same id,
     * regardless whether the concrete connection data is differant or not.
     * You should never use the same id for differant connection datasets.
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if ($compare instanceof self) {
            return ($this->getId() == $compare->getId());
        }
        
        return false;
    }

    /**
     * sets the full qualified name of the class to use for the connection
     *
     * @param  string  $fqClassName
     */
    public function setConnectionClassName($fqClassName)
    {
        $this->fqClassName = $fqClassName;
    }

    /**
     * returns the full qualified name of the class to use for the connection
     *
     * @return  string
     */
    public function getConnectionClassName()
    {
        return $this->fqClassName;
    }

    /**
     * sets the Data Source Name
     *
     * @param  string  $dsn
     */
    public function setDSN($dsn)
    {
        $this->dsn = $dsn;
    }

    /**
     * returns the Data Source Name
     *
     * @return  string
     */
    public function getDSN()
    {
        return $this->dsn;
    }

    /**
     * sets the user name
     *
     * @param  string  $userName
     */
    public function setUserName($userName)
    {
        $this->userName = $userName;
    }

    /**
     * returns the user name
     *
     * @return  string
     */
    public function getUserName()
    {
        return $this->userName;
    }

    /**
     * sets the password
     *
     * @param  string  $password
     */
    public function setPassword($password)
    {
        $this->password = $password;
    }

    /**
     * returns the user password
     *
     * @return  string
     */
    public function getPassword()
    {
        return $this->password;
    }

    /**
     * sets a key=>value array of driver-specific connection options
     *
     * @param  array  $driverOptions
     */
    public function setDriverOptions(array $driverOptions)
    {
        $this->driverOptions = $driverOptions;
    }

    /**
     * returns a key=>value array of driver-specific connection options
     *
     * @return  array
     */
    public function getDriverOptions()
    {
        return $this->driverOptions;
    }

    /**
     * sets initial query to be send after establishing the connection
     *
     * @param  string  $initialQuery
     */
    public function setInitialQuery($initialQuery)
    {
        $this->initialQuery = $initialQuery;
    }

    /**
     * checks if an initial query should be send
     *
     * @return  string
     */
    public function hasInitialQuery()
    {
        return (null != $this->initialQuery);
    }

    /**
     * returns initial query to be send after establishing the connection
     *
     * @return  string
     */
    public function getInitialQuery()
    {
        return $this->initialQuery;
    }
}
?><?php
/**
 * Exception for general database problems.
 *
 * @package     stubbles
 * @subpackage  rdbms
 * @version     $Id: stubDatabaseException.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubChainedException');
/**
 * Exception for general database problems.
 *
 * @package     stubbles
 * @subpackage  rdbms
 */
class stubDatabaseException extends stubChainedException
{
    // intentionally empty
}
?><?php
/**
 * Interface for database initializers.
 * 
 * @package     stubbles
 * @subpackage  rdbms
 * @version     $Id: stubDatabaseInitializer.php 2471 2010-01-18 16:50:55Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::initializer::stubInitializer');
/**
 * Interface for database initializers.
 *
 * @package     stubbles
 * @subpackage  rdbms
 * @ImplementedBy(net::stubbles::rdbms::stubPropertyBasedDatabaseInitializer.class)
 */
interface stubDatabaseInitializer extends stubInitializer
{
    /**
     * sets the descriptor to be used
     *
     * @param   string                   $descriptor
     * @return  stubDatabaseInitializer
     */
    public function setDescriptor($descriptor);

    /**
     * checks whether connection data for given id exists
     *
     * @param   string  $id
     * @return  bool
     */
    public function hasConnectionData($id);

    /**
     * returns connection data with given id
     *
     * @param   string                      $id
     * @return  stubDatabaseConnectionData
     */
    public function getConnectionData($id);
}
?><?php
/**
 * Interface for database query results.
 *
 * @package     stubbles
 * @subpackage  rdbms
 * @version     $Id: stubDatabaseResult.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::stubDatabaseException');
/**
 * Interface for database query results.
 *
 * @package     stubbles
 * @subpackage  rdbms
 */
interface stubDatabaseResult extends stubObject
{
    /**
     * bind a result column to a variable
     *
     * @param   int|string  $column     column number or name to bind the variable to
     * @param   mixed       &$variable  the variable to bind to the column
     * @param   int|string  $type       optional  type of the binded variable
     * @return  bool        true on success, false on failure
     * @throws  stubDatabaseException
     */
    public function bindColumn($column, &$variable, $type = null);
    
    /**
     * fetch a result
     *
     * @param   int    $fetchMode      optional  the mode to use for fetching the data
     * @param   array  $driverOptions  optional  driver specific arguments
     * @return  mixed
     * @throws  stubDatabaseException
     */
    public function fetch($fetchMode = null, array $driverOptions = array());
    
    /**
     * fetch single column from the next row from a result set
     *
     * @param   int     $columnNumber  optional  the column number to fetch, default is first column
     * @return  string
     * @throws  stubDatabaseException
     */
    public function fetchOne($columnNumber = 0);
    
    /**
     * returns an array containing all of the result set rows
     *
     * @param   int    $fetchMode      optional  the mode to use for fetching the data
     * @param   array  $driverOptions  optional  driver specific arguments
     * @return  array
     * @throws  stubDatabaseException
     */
    public function fetchAll($fetchMode = null, array $driverOptions = array());
    
    /**
     * moves the internal result pointer to the next result row
     *
     * @return  bool  true on success, false on failure
     * @throws  stubDatabaseException
     */
    public function next();
    
    /**
     * returns the number of rows affected by the last SQL statement
     *
     * @return  int
     * @throws  stubDatabaseException
     */
    public function count();
    
    /**
     * releases resources allocated of the result set
     *
     * @return  bool  true on success, false on failure
     * @throws  stubDatabaseException
     */
    public function free();
}
?><?php
/**
 * Interface for database statements.
 *
 * @package     stubbles
 * @subpackage  rdbms
 * @version     $Id: stubDatabaseStatement.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::rdbms::stubDatabaseException');
/**
 * Interface for database statements.
 *
 * @package     stubbles
 * @subpackage  rdbms
 */
interface stubDatabaseStatement extends stubObject
{
    /**
     * bind a parameter of a prepared query to the specified variable
     * 
     * The binding will be via reference, so it is evaluated at the time when
     * the prepared statement is executed meaning that in opposite to
     * bindValue() the value of the variable at the time of execution will be
     * used, not the value at the time when this method is called.
     *
     * @param   int|string  $param      the order number of the parameter or its name
     * @param   mixed       &$variable  the variable to bind to the parameter
     * @param   int|string  $type       optional  type of the parameter
     * @param   int         $length     optional  length of the data type
     * @return  bool        true on success, false on failure
     * @throws  stubDatabaseException
     */
    public function bindParam($param, &$variable, $type = null, $length = null);
    
    /**
     * bind a value to the parameter of a prepared query
     * 
     * In opposite to bindParam() this will use the value as it is at the time
     * when this method is called.
     * 
     * @param   int|string  $param  the order number of the parameter or its name
     * @param   mixed       $value  the value to bind
     * @param   int|string  $type   optional  type of the parameter
     * @return  bool        true on success, false on failure
     * @throws  stubDatabaseException
     */
    public function bindValue($param, $value, $type = null);
    
    /**
     * executes a prepared statement
     *
     * @param   array  $values  optional  specifies all necessary information for bindParam()
     *                                    the array elements must use keys corresponding to the
     *                                    number of the position or name of the parameter
     * @return  stubDatabaseResult
     * @throws  stubDatabaseException
     */
    public function execute(array $values = array());
    
    /**
     * releases resources allocated for the specified prepared query
     * 
     * Frees up the connection to the server so that other SQL statements may
     * be issued, but leaves the statement in a state that enables it to be
     * executed again.
     *
     * @return  bool  true on success, false on failure
     * @throws  stubDatabaseException
     */
    public function clean();
}
?><?php
/**
 * Creates connection data instances based on property files.
 *
 * @package     stubbles
 * @subpackage  rdbms
 * @version     $Id: stubPropertyBasedDatabaseInitializer.php 2471 2010-01-18 16:50:55Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::stubProperties',
                      'net::stubbles::lang::exceptions::stubConfigurationException',
                      'net::stubbles::rdbms::stubDatabaseConnectionData',
                      'net::stubbles::rdbms::stubDatabaseInitializer'
);
/**
 * Creates connection data instances based on property files.
 *
 * @package     stubbles
 * @subpackage  rdbms
 * @since       1.1.0
 */
class stubPropertyBasedDatabaseInitializer extends stubBaseObject implements stubDatabaseInitializer
{
    /**
     * path to config files
     *
     * @var  string
     */
    protected $configPath;
    /**
     * descriptor to be used
     *
     * @var  string
     */
    protected $descriptor   = 'rdbms';
    /**
     * properties for database connections
     *
     * @var  stubProperties
     */
    protected $dbProperties;

    /**
     * constructor
     *
     * @param  string  $configPath
     * @Inject
     * @Named('net.stubbles.config.path')
     */
    public function  __construct($configPath)
    {
        $this->configPath = $configPath;
    }

    /**
     * sets the descriptor to be used
     *
     * @param   string                                $descriptor
     * @return  stubPropertyBasedDatabaseInitializer
     * @Inject(optional=true)
     * @Named('net.stubbles.rdbms.descriptor')
     */
    public function setDescriptor($descriptor)
    {
        $this->descriptor = $descriptor;
        return $this;
    }

    /**
     * initializing method
     *
     * @return  stubPropertyBasedDatabaseInitializer
     */
    public function init()
    {
        $this->dbProperties = stubProperties::fromFile($this->configPath . '/' . $this->descriptor . '.ini');
        return $this;
    }

    /**
     * checks whether connection data for given id exists
     *
     * @param   string  $id
     * @return  bool
     */
    public function hasConnectionData($id)
    {
        if (null === $this->dbProperties) {
            $this->init();
        }

        return $this->dbProperties->hasSection($id);
    }

    /**
     * returns connection data with given id
     *
     * @param   string                      $id
     * @return  stubDatabaseConnectionData
     * @throws  stubConfigurationException
     */
    public function getConnectionData($id)
    {
        if (null === $this->dbProperties) {
            $this->init();
        }

        if ($this->dbProperties->hasSection($id) === false) {
            throw new stubConfigurationException('No connection defined for id ' . $id);
        }

        return stubDatabaseConnectionData::fromArray($this->dbProperties->getSection($id), $id);
    }
}
?><?php
/**
 * Abstract base class for annotion parser states
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 * @version     $Id: stubAnnotationAbstractState.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Abstract base class for annotion parser states
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 */
abstract class stubAnnotationAbstractState extends stubBaseObject
{
    /**
     * the parser this state belongs to
     *
     * @var  stubAnnotationParser
     */
    protected $parser;

    /**
     * constructor
     *
     * @param  stubAnnotationParser  $parser
     */
    public function __construct(stubAnnotationParser $parser)
    {
        $this->parser = $parser;
    }

    /**
     * mark this state as the currently used state
     */
    public function selected()
    {
        // intentionally empty
    }
}
?><?php
/**
 * Parser is inside the annotation
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 * @version     $Id: stubAnnotationAnnotationState.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::parser::state::stubAnnotationAbstractState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationState'
);
/**
 * Parser is inside the annotation
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 */
class stubAnnotationAnnotationState extends stubAnnotationAbstractState implements stubAnnotationState
{
    /**
     * processes a token
     *
     * @param  string  $token
     */
    public function process($token)
    {
        if ("\n" === $token) {
            $this->parser->changeState(stubAnnotationState::DOCBLOCK);
            return;
        }
        
        if ('{' === $token) {
            $this->parser->changeState(stubAnnotationState::ARGUMENT);
            return;
        }
        
        if ('[' === $token) {
            $this->parser->changeState(stubAnnotationState::ANNOTATION_TYPE);
            return;
        }
        
        if ('(' === $token) {
            $this->parser->changeState(stubAnnotationState::PARAMS);
            return;
        }
    }
}
?><?php
/**
 * Parser is inside the annotation argument.
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 * @version     $Id: stubAnnotationArgumentState.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::parser::state::stubAnnotationAbstractState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationState'
);
/**
 * Parser is inside the annotation argument.
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 */
class stubAnnotationArgumentState extends stubAnnotationAbstractState implements stubAnnotationState
{
    /**
     * argument for which the annotation stands for
     *
     * @var  string
     */
    private $argument = '';

    /**
     * returns the type
     *
     * @return  string
     */
    public function getArgument()
    {
        return $this->argument;
    }

    /**
     * mark this state as the currently used state
     */
    public function selected()
    {
        parent::selected();
        $this->argument = '';
    }

    /**
     * processes a token
     *
     * @param   string  $token
     * @throws  ReflectionException
     */
    public function process($token)
    {
        if ('}' === $token) {
            if (strlen($this->argument) > 0) {
                if (preg_match('/^[a-zA-Z_]{1}[a-zA-Z_0-9]*$/', $this->argument) == false) {
                    throw new ReflectionException('Annotation argument may contain letters, underscores and numbers, but contains an invalid character.');
                }
                
                $this->parser->setAnnotationForArgument($this->argument);
            }
            
            $this->parser->changeState(stubAnnotationState::ANNOTATION);
            return;
        }

        $this->argument .= $token;
    }
}
?><?php
/**
 * Docblock state
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 * @version     $Id: stubAnnotationDocblockState.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::parser::state::stubAnnotationAbstractState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationState'
);
/**
 * Docblock state
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 */
class stubAnnotationDocblockState extends stubAnnotationAbstractState implements stubAnnotationState
{
    /**
     * processes a token
     *
     * @param   string  $token
     * @throws  ReflectionException
     */
    public function process($token)
    {
        if ('@' === $token) {
            $this->parser->changeState(stubAnnotationState::ANNOTATION_NAME);
            return;
        }
        
        // all character except * and space and line breaks
        if (' ' !== $token && '*' !== $token && "\n" !== $token && "\t" !== $token) {
            $this->parser->changeState(stubAnnotationState::TEXT);
        }
    }
}
?><?php
/**
 * Parser is inside the annotation name
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 * @version     $Id: stubAnnotationNameState.php 2140 2009-03-20 14:50:50Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::parser::state::stubAnnotationAbstractState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationState'
);
/**
 * Parser is inside the annotation name
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 */
class stubAnnotationNameState extends stubAnnotationAbstractState implements stubAnnotationState
{
    /**
     * list of forbidden annotation names
     *
     * @var  array<string>
     */
    protected $forbiddenAnnotationNames = array('deprecated',
                                                'example',
                                                'ignore',
                                                'internal',
                                                'link',
                                                'method',
                                                'package',
                                                'param',
                                                'property',
                                                'property-read',
                                                'property-write',
                                                'return',
                                                'see',
                                                'since',
                                                'static',
                                                'subpackage',
                                                'throws',
                                                'todo',
                                                'uses',
                                                'var',
                                                'version'
                                          );
    /**
     * name of the annotation
     *
     * @var  string
     */
    private $name = '';

    /**
     * returns the name of the annotation
     *
     * @return  string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * mark this state as the currently used state
     */
    public function selected()
    {
        parent::selected();
        $this->name = '';
    }

    /**
     * processes a token
     *
     * @param   string  $token
     * @throws  ReflectionException
     */
    public function process($token)
    {
        if (' ' === $token) {
            if (strlen($this->name) == 0) {
                $this->changeState(stubAnnotationState::DOCBLOCK);
                return;
            }
            
            $this->checkName();
            $this->parser->registerAnnotation($this->name);
            $this->changeState(stubAnnotationState::ANNOTATION);
            return;
        }
        
        if ("\n" === $token || "\r" === $token) {
            if (strlen($this->name) > 0) {
                $this->checkName();
                $this->parser->registerAnnotation($this->name);
            }
            
            $this->changeState(stubAnnotationState::DOCBLOCK);
            return;
        }
        
        if ('{' === $token) {
            if (strlen($this->name) == 0) {
                throw new ReflectionException('Annotation name can not be empty');
            }
            
            $this->checkName();
            $this->parser->registerAnnotation($this->name);
            $this->changeState(stubAnnotationState::ARGUMENT);
            return;
        }
        
        if ('[' === $token) {
            if (strlen($this->name) == 0) {
                throw new ReflectionException('Annotation name can not be empty');
            }
            
            $this->checkName();
            $this->parser->registerAnnotation($this->name);
            $this->changeState(stubAnnotationState::ANNOTATION_TYPE);
            return;
        }

        if ('(' === $token) {
            if (strlen($this->name) == 0) {
                throw new ReflectionException('Annotation name can not be empty');
            }
            
            $this->checkName();
            $this->parser->registerAnnotation($this->name);
            $this->changeState(stubAnnotationState::PARAMS);
            return;
        }
        
        $this->name .= $token;
    }

    /**
     * check if the name is valid
     *
     * @throws  ReflectionException
     */
    protected function checkName()
    {
        if (preg_match('/^[a-zA-Z_]{1}[a-zA-Z_0-9]*$/', $this->name) == false) {
            throw new ReflectionException('Annotation parameter name may contain letters, underscores and numbers, but contains an invalid character.');
        }
    }
    
    /**
     * helper method to change state to another parsing state only if annotation
     * name is not forbidden, if it is forbidden change back to docblock state
     *
     * @param  int  $targetState  original target state
     */
    protected function changeState($targetState)
    {
        if (in_array($this->name, $this->forbiddenAnnotationNames) === true) {
            $targetState = stubAnnotationState::DOCBLOCK;
        }
        
        $this->parser->changeState($targetState);
    }
}
?><?php
/**
 * Parser is inside an annotation param name
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 * @version     $Id: stubAnnotationParamNameState.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::parser::state::stubAnnotationAbstractState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationState'
);
/**
 * Parser is inside an annotation param name
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 */
class stubAnnotationParamNameState extends stubAnnotationAbstractState implements stubAnnotationState
{
    /**
     * name of the param
     *
     * @var  string
     */
    private $name = '';

    /**
     * returns the name of the annotation
     *
     * @return  string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * mark this state as the currently used state
     */
    public function selected()
    {
        parent::selected();
        $this->name = '';
    }

    /**
     * processes a token
     *
     * @param   string  $token
     * @throws  ReflectionException
     */
    public function process($token)
    {
        if ("'" === $token || '"' === $token) {
            if (strlen($this->name) > 0) {
                throw new ReflectionException('Annotation parameter name may contain letters, underscores and numbers, but contains ' . $token . '. Probably an equal sign is missing.');
            }
            
            $this->parser->registerAnnotationParam('value');
            $this->parser->changeState(stubAnnotationState::PARAM_VALUE, $token);
            return;
        }
        
        if ('=' === $token) {
            if (strlen($this->name) == 0) {
                throw new ReflectionException('Annotation parameter name has to start with a letter or underscore, but starts with =');
            } elseif (preg_match('/^[a-zA-Z_]{1}[a-zA-Z_0-9]*$/', $this->name) == false) {
                throw new ReflectionException('Annotation parameter name may contain letters, underscores and numbers, but contains an invalid character.');
            }
            
            $this->parser->registerAnnotationParam($this->name);
            $this->parser->changeState(stubAnnotationState::PARAM_VALUE);
            return;
        }
        
        if (')' === $token) {
            if (strlen($this->name) > 0) {
                $this->parser->registerSingleAnnotationParam($this->name, false);
            }
            
            $this->parser->changeState(stubAnnotationState::DOCBLOCK);
            return;
        }
            
        $this->name .= $token;
    }
}
?><?php
/**
 * Parser is inside the annotation params
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 * @version     $Id: stubAnnotationParamsState.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::parser::state::stubAnnotationAbstractState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationState'
);
/**
 * Parser is inside the annotation params
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 */
class stubAnnotationParamsState extends stubAnnotationAbstractState implements stubAnnotationState
{
    /**
     * list of tokens that lead to no actions in this state
     * 
     * @var  array<string>
     */
    protected $doNothingTokens = array(',', ' ', "\r", "\n", "\t", '*');

    /**
     * processes a token
     *
     * @param  string  $token
     */
    public function process($token)
    {
        if (')' === $token) {
            $this->parser->changeState(stubAnnotationState::DOCBLOCK);
            return;
        }
        
        if (in_array($token, $this->doNothingTokens) == true) {
            return;
        }
        
        $this->parser->changeState(stubAnnotationState::PARAM_NAME, $token);
    }
}
?><?php
/**
 * Parser is inside an annotation param value
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 * @version     $Id: stubAnnotationParamValueState.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::parser::state::stubAnnotationAbstractState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationState'
);
/**
 * Parser is inside an annotation param value
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 */
class stubAnnotationParamValueState extends stubAnnotationAbstractState implements stubAnnotationState
{
    /**
     * character in which the value is enclosed
     *
     * @var  string
     */
    private $enclosed   = null;
    /**
     * whether the value is a string or not
     *
     * @var  bool
     */
    private $isString   = false;
    /**
     * the extracted value
     *
     * @var  string
     */
    private $value      = '';
    /**
     * switch whether the next token is escaped or not
     *
     * @var  bool
     */
    private $escapeNext = false;
    
    /**
     * returns the value
     *
     * @return  string
     */
    public function getValue()
    {
        return $this->value;
    }
    
    /**
     * checks whether the value is a string or not
     *
     * @return  bool
     */
    public function isString()
    {
        return $this->isString;
    }
    
    /**
     * checks if the next token is escaped
     *
     * @return  bool
     */
    public function isNextCharacterEscaped()
    {
        return $this->escapeNext;
    }
    
    /**
     * returns the character in which the value is enclosed
     *
     * @return  string
     */
    public function getEnclosed()
    {
        return $this->enclosed;
    }

    /**
     * mark this state as the currently used state
     */
    public function selected()
    {
        parent::selected();
        $this->value      = '';
        $this->enclosed   = null;
        $this->isString   = false;
        $this->escapeNext = false;
    }

    /**
     * processes a token
     *
     * @param  string  $token
     */
    public function process($token)
    {
        if (true === $this->escapeNext) {
            $this->value     .= $token;
            $this->escapeNext = false;
            return;
        }
        
        if (null === $this->enclosed) {
            if ("'" === $token || '"' === $token) {
                if (strlen($this->value) > 0) {
                    $this->value .= $token;
                } else {
                    $this->enclosed = $token;
                    $this->isString = true;
                }
                
                return;
            }
            
            if (',' === $token) {
                $this->parser->setAnnotationParamValue($this->value, $this->isString);
                $this->parser->changeState(stubAnnotationState::PARAMS);
                return;
            }
            
            if (')' === $token) {
                $this->parser->setAnnotationParamValue($this->value, $this->isString);
                $this->parser->changeState(stubAnnotationState::DOCBLOCK);
                return;
            }
        } else {
            if ($this->enclosed === $token) {
                $this->enclosed = null;
                $this->parser->setAnnotationParamValue($this->value, $this->isString);
                $this->parser->changeState(stubAnnotationState::PARAMS);
                return;
            }
            
            if ('\\' === $token) {
                $this->escapeNext = true;
                return;
            }
        }
        
        $this->value .= $token;
    }
}
?><?php
/**
 * Interface for an annotation parser state
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 * @version     $Id: stubAnnotationState.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::parser::stubAnnotationParser');
/**
 * Interface for an annotation parser state
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 */
interface stubAnnotationState
{
    /**
     * parser is inside the standard docblock
     */
    const DOCBLOCK        = 0;
    /**
     * parser is inside a text within the docblock
     */
    const TEXT            = 1;
    /**
     * parser is inside an annotation
     */
    const ANNOTATION      = 2;
    /**
     * parser is inside an annotation name
     */
    const ANNOTATION_NAME = 3;
    /**
     * parser is inside an annotation type
     */
    const ANNOTATION_TYPE = 4;
    /**
     * parser is inside the annotation params
     */
    const PARAMS          = 5;
    /**
     * parser is inside an annotation param name
     */
    const PARAM_NAME      = 6;
    /**
     * parser is inside an annotation param value
     */
    const PARAM_VALUE     = 7;
    /**
     * parser is inside a argument declaration
     */
    const ARGUMENT        = 8;

    /**
     * constructor
     *
     * @param  stubAnnotationParser  $parser
     */
    public function __construct(stubAnnotationParser $parser);

    /**
     * mark this state as the currently used state
     */
    public function selected();

    /**
     * processes a token
     *
     * @param   string  $token
     * @throws  ReflectionException
     */
    public function process($token);
}
?><?php
/**
 * Text within a docblock state.
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 * @version     $Id: stubAnnotationTextState.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::parser::state::stubAnnotationAbstractState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationState'
);
/**
 * Text within a docblock state.
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 */
class stubAnnotationTextState extends stubAnnotationAbstractState implements stubAnnotationState
{
    /**
     * processes a token
     *
     * @param   string  $token
     * @throws  ReflectionException
     */
    public function process($token)
    {
        if ("\n" === $token) {
            $this->parser->changeState(stubAnnotationState::DOCBLOCK);
        }
    }
}
?><?php
/**
 * Parser is inside the annotation type
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 * @version     $Id: stubAnnotationTypeState.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::parser::state::stubAnnotationAbstractState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationState'
);
/**
 * Parser is inside the annotation type
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser_state
 */
class stubAnnotationTypeState extends stubAnnotationAbstractState implements stubAnnotationState
{
    /**
     * type of the annotation
     *
     * @var  string
     */
    private $type = '';

    /**
     * returns the type
     *
     * @return  string
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * mark this state as the currently used state
     */
    public function selected()
    {
        parent::selected();
        $this->type = '';
    }

    /**
     * processes a token
     *
     * @param   string  $token
     * @throws  ReflectionException
     */
    public function process($token)
    {
        if (']' === $token) {
            if (strlen($this->type) > 0) {
                if (preg_match('/^[a-zA-Z_]{1}[a-zA-Z_0-9]*$/', $this->type) == false) {
                    throw new ReflectionException('Annotation type may contain letters, underscores and numbers, but contains an invalid character.');
                }
                
                $this->parser->setAnnotationType($this->type);
            }
            
            $this->parser->changeState(stubAnnotationState::ANNOTATION);
            return;
        }

        $this->type .= $token;
    }
}
?><?php
/**
 * Interface for parsers to parse Java-Style annotations.
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser
 * @version     $Id: stubAnnotationParser.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Interface for parsers to parse Java-Style annotations.
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser
 */
interface stubAnnotationParser
{
    /**
     * change the current state
     *
     * @param  int     $state
     * @param  string  $token  token that should be processed by the state
     */
    public function changeState($state, $token = null);

    /**
     * parse a docblock and return all annotations found
     *
     * @param   string  $docBlock
     * @return  array
     */
    public function parse($docBlock);

    /**
     * register a new annotation
     *
     * @param  string  $name
     */
    public function registerAnnotation($name);

    /**
     * register a new annotation param
     *
     * @param  string  $name
     */
    public function registerAnnotationParam($name);

    /**
     * register single annotation param
     *
     * @param   string  $value     the value of the param
     * @param   bool    $asString  whether the value is a string or not
     * @throws  ReflectionException
     */
    public function registerSingleAnnotationParam($value, $asString = false);

    /**
     * set the annoation param value for the current annotation
     *
     * @param   string  $value     the value of the param
     * @param   bool    $asString  whether the value is a string or not
     * @throws  ReflectionException
     */
    public function setAnnotationParamValue($value, $asString = false);

    /**
     * set the type of the current annotation
     *
     * @param  string  $type  type of the annotation
     */
    public function setAnnotationType($type);

    /**
     * sets the argument for which the annotation is declared
     *
     * @param  string  $argument  name of the argument
     */
    public function setAnnotationForArgument($argument);
}
?><?php
/**
 * Parser to parse Java-Style annotations.
 *
 * @author      Stephan Schmidt <schst@stubbles.net>
 * @author      Frank Kleine <mikey@stubbles.net>
 * @package     stubbles
 * @subpackage  reflection_annotations_parser
 */
stubClassLoader::load('net::stubbles::reflection::stubReflectionClass',
                      'net::stubbles::reflection::annotations::parser::stubAnnotationParser',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationArgumentState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationDocblockState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationAnnotationState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationNameState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationParamNameState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationParamsState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationParamValueState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationTextState',
                      'net::stubbles::reflection::annotations::parser::state::stubAnnotationTypeState'
);
/**
 * Parser to parse Java-Style annotations.
 *
 * @package     stubbles
 * @subpackage  reflection_annotations_parser
 */
class stubAnnotationStateParser extends stubBaseObject implements stubAnnotationParser
{
    /**
     * possible states
     *
     * @var  array
     */
    private $states             = array();
    /**
     * the current state
     *
     * @var  stubAnnotationParserState
     */
    private $currentState       = null;
    /**
     * the name of the current annotation
     *
     * @var  string
     */
    private $currentAnnotation  = null;
    /**
     * the name of the current annotation parameter
     *
     * @var  string
     */
    private $currentParam       = null;
    /**
     * all parsed annotations
     *
     * @var  array
     */
    private $annotations        = array();

    /**
     * constructor
     */
    public function __construct()
    {
        $this->states[stubAnnotationState::DOCBLOCK]        = new stubAnnotationDocblockState($this);
        $this->states[stubAnnotationState::TEXT]            = new stubAnnotationTextState($this);
        $this->states[stubAnnotationState::ANNOTATION]      = new stubAnnotationAnnotationState($this);
        $this->states[stubAnnotationState::ANNOTATION_NAME] = new stubAnnotationNameState($this);
        $this->states[stubAnnotationState::ANNOTATION_TYPE] = new stubAnnotationTypeState($this);
        $this->states[stubAnnotationState::ARGUMENT]        = new stubAnnotationArgumentState($this);
        $this->states[stubAnnotationState::PARAMS]          = new stubAnnotationParamsState($this);
        $this->states[stubAnnotationState::PARAM_NAME]      = new stubAnnotationParamNameState($this);
        $this->states[stubAnnotationState::PARAM_VALUE]     = new stubAnnotationParamValueState($this);
    }

    /**
     * change the current state
     *
     * @param   int     $state
     * @param   string  $token  token that should be processed by the state
     * @throws  ReflectionException
     */
    public function changeState($state, $token = null)
    {
        if (isset($this->states[$state]) == false) {
            throw new ReflectionException('Unknown state ' . $state);
        }

        $this->currentState = $this->states[$state];
        $this->currentState->selected();
        if (null != $token) {
            $this->currentState->process($token);
        }
    }

    /**
     * parse a docblock and return all annotations found
     *
     * @param   string  $docBlock
     * @return  array
     * @throws  ReflectionException
     */
    public function parse($docBlock)
    {
        $this->annotations = null;
        $this->changeState(stubAnnotationState::DOCBLOCK);
        $len = strlen($docBlock);
        for ($i = 0; $i < $len; $i++) {
            $this->currentState->process($docBlock{$i});
        }

        if (($this->currentState instanceof stubAnnotationDocblockState) == false
          && ($this->currentState instanceof stubAnnotationTextState) == false) {
            throw new ReflectionException('Annotation parser finished in wrong state, last annotation probably closed incorrectly, last state was ' . $this->currentState->getClassName());
        }

        return $this->annotations;
    }

    /**
     * register a new annotation
     *
     * @param  string  $name
     */
    public function registerAnnotation($name)
    {
        $this->annotations[$name] = array('type'     => $name,
                                          'params'   => array(),
                                          'argument' => null
                                    );
        $this->currentAnnotation  = $name;
    }

    /**
     * register a new annotation param
     *
     * @param  string  $name
     */
    public function registerAnnotationParam($name)
    {
        $this->currentParam = trim($name);
    }

    /**
     * register single annotation param
     *
     * @param   string  $value     the value of the param
     * @param   bool    $asString  whether the value is a string or not
     * @throws  ReflectionException
     */
    public function registerSingleAnnotationParam($value, $asString = false)
    {
        $value = $this->convertAnnotationValue($value, $asString);
        if (count($this->annotations[$this->currentAnnotation]['params']) > 0) {
            throw new ReflectionException('Error parsing annotation ' . $this->currentAnnotation);
        }

        $this->annotations[$this->currentAnnotation]['params']['value'] = $value;
    }

    /**
     * set the annoation param value for the current annotation
     *
     * @param  string  $value     the value of the param
     * @param  bool    $asString  whether the value is a string or not
     */
    public function setAnnotationParamValue($value, $asString = false)
    {
        $this->annotations[$this->currentAnnotation]['params'][$this->currentParam] = $this->convertAnnotationValue($value, $asString);
    }

    /**
     * set the type of the current annotation
     *
     * @param  string  $type  type of the annotation
     */
    public function setAnnotationType($type)
    {
        $this->annotations[$this->currentAnnotation]['type'] = $type;
    }

    /**
     * sets the argument for which the annotation is declared
     *
     * @param  string  $argument  name of the argument
     */
    public function setAnnotationForArgument($argument)
    {
        $this->annotations[$this->currentAnnotation . '#' . $argument] = $this->annotations[$this->currentAnnotation];
        unset($this->annotations[$this->currentAnnotation]);
        $this->currentAnnotation .= '#' . $argument;
        $this->annotations[$this->currentAnnotation]['argument'] = $argument;
    }

    /**
     * convert an annotation value
     *
     * @param   string   $value     the value to convert
     * @param   boolean  $asString  whether value should be treated as string or not
     * @return  mixed
     */
    protected function convertAnnotationValue($value, $asString)
    {
        if (true == $asString) {
            return (string) $value;
        }

        if ('true' === $value) {
            return true;
        }

        if ('false' === $value) {
            return false;
        }

        if ('null' === strtolower($value)) {
            return null;
        }

        if (preg_match('/^[+-]?[0-9]+$/', $value) != false) {
            return (integer) $value;
        }

        if (preg_match('/^[+-]?[0-9]+\.[0-9]+$/', $value) != false) {
            return (double) $value;
        }

        $matches = array();
        if (preg_match('/^([a-zA-Z_]{1}[a-zA-Z0-9_:]*)\.class/', $value, $matches) != false) {
            return new stubReflectionClass($matches[1]);
        }

        $matches = array();
        if (preg_match('/^([a-zA-Z_]{1}[a-zA-Z0-9_:]*)::\$([a-zA-Z_]{1}[a-zA-Z0-9_]*)/', $value, $matches) != false) {
            stubClassLoader::load('net::stubbles::lang::stubEnum');
            try {
                return stubEnum::forName(new stubReflectionClass($matches[1]), $matches[2]);
            } catch (Exception $e) {
                echo $e->getMessage();
                return null;
            }
        }
        
        if (defined($value) == true) {
            return constant($value);
        }

        return (string) $value;
    }
}
?><?php
/**
 * Abstract base class for annotations
 *
 * @package     stubbles
 * @subpackage  reflection_annotations
 * @version     $Id: stubAbstractAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation');
/**
 * Abstract base class for annotations
 *
 * @package     stubbles
 * @subpackage  reflection_annotations
 */
abstract class stubAbstractAnnotation extends stubSerializableObject implements stubAnnotation
{
    /**
     * The name of the annotation
     *
     * @var  string
     */
    protected $annotationName;
    /**
     * a list of reflected class instances used in the annotation
     * 
     * This property should only be used by this class. We can not make this
     * property private because the serializung mechanism will not work then.
     *
     * @var  array<string,string>
     */
    protected $reflectedClasses = array();

    /**
     * Sets the name under which the annotation is stored.
     *
     * @param  string  $name
     */
    public function setAnnotationName($name)
    {
        $this->annotationName = $name;
    }

    /**
     * Returns the name under which the annotation is stored.
     *
     * @return  string
     */
    public function getAnnotationName()
    {
        return $this->annotationName;
    }

    /**
     * do some last operations after all values have been set
     * 
     * This method may check if all required values have been set and throw
     * an exception if values are missing.
     *
     * @throws  ReflectionException
     */
    public function finish()
    {
        // intentionally empty
    }

    /**
     * assure that a clone clones all properties of type object as well
     */
    public function __clone()
    {
        foreach (get_object_vars($this) as $name => $value) {
            if ($value instanceof stubClonable) {
                $this->$name = clone $this->$name;
            }
        }
    }

    /**
     * template method to hook into __sleep()
     *
     * @return  array<string>  list of property names that should not be serialized
     */
    protected function __doSleep()
    {
        $this->reflectedClasses = array();
        return array();
    }

    /**
     * takes care of serializing the value
     *
     * @param  array   &$propertiesToSerialize  list of properties to serialize
     * @param  string  $name                    name of the property to serialize
     * @param  mixed   $value                   value to serialize
     */
    protected function __doSerialize(&$propertiesToSerialize, $name, $value)
    {
        if ($value instanceof stubReflectionClass) {
            $this->reflectedClasses[$name] = $value->getFullQualifiedClassName();
            return;
        }
        
        parent::__doSerialize($propertiesToSerialize, $name, $value);
    }

    /**
     * template method to hook into __wakeup()
     */
    protected function __doWakeUp()
    {
        foreach ($this->reflectedClasses as $propertyName => $reflectedClasses) {
            $this->$propertyName = new stubReflectionClass($reflectedClasses);
        }
        
        $this->reflectedClasses = array();
    }
}
?><?php
/**
 * Interface for reflected structures that may have annotations.
 *
 * @package     stubbles
 * @subpackage  reflection_annotations
 * @version     $Id: stubAnnotatable.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Interface for reflected structures that may have annotations.
 *
 * @package     stubbles
 * @subpackage  reflection_annotations
 */
interface stubAnnotatable
{
    /**
     * check whether the class has the given annotation or not
     *
     * @param   string  $annotationName
     * @return  bool
     */
    public function hasAnnotation($annotationName);

    /**
     * return the specified annotation
     *
     * @param   string          $annotationName
     * @return  stubAnnotation
     * @throws  ReflectionException
     */
    public function getAnnotation($annotationName);
}
?><?php
/**
 * Interface for an annotation.
 *
 * @package     stubbles
 * @subpackage  reflection_annotations
 * @version     $Id: stubAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::stubClonable');
/**
 * Interface for an annotation.
 *
 * @package     stubbles
 * @subpackage  reflection_annotations
 */
interface stubAnnotation extends stubSerializable, stubClonable
{
    /**
     * annotation is applicable for classes
     */
    const TARGET_CLASS    = 1;
    /**
     * annotation is applicable for properties
     */
    const TARGET_PROPERTY = 2;
    /**
     * annotation is applicable for methods
     */
    const TARGET_METHOD   = 4;
    /**
     * annotation is applicable for functions
     */
    const TARGET_FUNCTION = 8;
    /**
     * annotation is applicable for parameters
     */
    const TARGET_PARAM    = 16;
    /**
     * annotation is applicable for classes, properties, methods and functions
     */
    const TARGET_ALL      = 31;

    /**
     * Sets the name under which the annotation is stored.
     *
     * @param  string  $name
     */
    public function setAnnotationName($name);

    /**
     * Returns the name under which the annotation is stored.
     *
     * @return  string
     */
    public function getAnnotationName();

    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget();

    /**
     * do some last operations after all values have been set
     *
     * This method may check if all required values have been set and throw
     * an exception if values are missing.
     *
     * @throws  ReflectionException
     */
    public function finish();
}
?><?php
/**
 * Static cache for annotations
 *
 * @package     stubbles
 * @subpackage  reflection_annotations
 * @version     $Id: stubAnnotationCache.php 2365 2009-10-30 13:19:05Z mikey $
 */
/**
 * Static cache for annotations
 *
 * @package     stubbles
 * @subpackage  reflection_annotations
 * @static
 */
class stubAnnotationCache
{
    /**
     * Property to store annotations
     *
     * @var  array<string,array>
     */
    private static $annotations  = array(stubAnnotation::TARGET_CLASS    => array(),
                                         stubAnnotation::TARGET_FUNCTION => array(),
                                         stubAnnotation::TARGET_METHOD   => array(),
                                         stubAnnotation::TARGET_PROPERTY => array()
                                   );
    /**
     * flag whether cache contents changed
     *
     * @var  bool
     */
    private static $cacheChanged = false;

    /**
     * static initializer
     */
    // @codeCoverageIgnoreStart
    public static function __static()
    {
        if (file_exists(stubPathRegistry::getCachePath() . '/annotations.cache') == true) {
            self::$annotations = unserialize(file_get_contents(stubPathRegistry::getCachePath() . '/annotations.cache'));
        }
        
        register_shutdown_function(array(__CLASS__, '__shutdown'));
    }
    // @codeCoverageIgnoreEnd

    /**
     * static shutdown
     */
    public static function __shutdown()
    {
        if (true === self::$cacheChanged) {
            file_put_contents(stubPathRegistry::getCachePath() . '/annotations.cache', serialize(self::$annotations));
        }
    }

    /**
     * refreshes cache data
     */
    public static function refresh()
    {
        file_put_contents(stubPathRegistry::getCachePath() . '/annotations.cache', serialize(self::$annotations));
        self::$annotations  = unserialize(file_get_contents(stubPathRegistry::getCachePath() . '/annotations.cache'));
        self::$cacheChanged = false;
    }

    /**
     * flushes all contents from cache
     */
    public static function flush()
    {
        self::$annotations  = array(stubAnnotation::TARGET_CLASS    => array(),
                                    stubAnnotation::TARGET_FUNCTION => array(),
                                    stubAnnotation::TARGET_METHOD   => array(),
                                    stubAnnotation::TARGET_PROPERTY => array()
                              );
        self::$cacheChanged = true;
    }

    /**
     * store an annotation in the cache
     *
     * @param  int             $target          target of the annotation
     * @param  string          $targetName      name of the target
     * @param  string          $annotationName  name of the annotation
     * @param  stubAnnotation  $annotation      optional  the annotation to store
     */
    public static function put($target, $targetName, $annotationName, stubAnnotation $annotation = null)
    {
        if (isset(self::$annotations[$target][$targetName]) === false) {
            self::$annotations[$target][$targetName] = array();
        }
        
        if (null !== $annotation) {
            $clone = clone $annotation;
            self::$annotations[$target][$targetName][$annotationName] = $clone->getSerialized();
        } else {
            self::$annotations[$target][$targetName][$annotationName] = '';
        }
        
        self::$cacheChanged = true;
    }

    /**
     * removes an annotation from the cache
     *
     * @param  int             $target          target of the annotation
     * @param  string          $targetName      name of the target
     * @param  string          $annotationName  name of the annotation
     */
    public static function remove($target, $targetName, $annotationName)
    {
        if (isset(self::$annotations[$target][$targetName]) === false || isset(self::$annotations[$target][$targetName][$annotationName]) === false) {
            return;
        }
        
        unset(self::$annotations[$target][$targetName][$annotationName]);
        self::$cacheChanged = true;
    }

    /**
     * check, whether an annotation is available in the cache
     *
     * @param   int     $target          target of the annotation
     * @param   string  $targetName      name of the target
     * @param   string  $annotationName  name of the annotation
     * @return  bool
     */
    public static function has($target, $targetName, $annotationName)
    {
        if (isset(self::$annotations[$target][$targetName]) === false) {
            return false;
        }
        
        if (isset(self::$annotations[$target][$targetName][$annotationName]) === false) {
            return false;
        }
        
        return self::$annotations[$target][$targetName][$annotationName] !== '';
    }

    /**
     * check, whether an annotation is available in the cache
     *
     * @param   int     $target          target of the annotation
     * @param   string  $targetName      name of the target
     * @param   string  $annotationName  name of the annotation
     * @return  bool
     */
    public static function hasNot($target, $targetName, $annotationName)
    {
        if (isset(self::$annotations[$target][$targetName]) == false) {
            return false;
        }
        
        if (isset(self::$annotations[$target][$targetName][$annotationName]) == false) {
            return false;
        }
        
        return self::$annotations[$target][$targetName][$annotationName] === '';
    }

    /**
     * fetch an annotation from the cache
     *
     * @param   int             $target          target of the annotation
     * @param   string          $targetName      name of the target
     * @param   string          $annotationName  name of the annotation
     * @return  stubAnnotation
     */
    public static function get($target, $targetName, $annotationName)
    {
        if (self::has($target, $targetName, $annotationName) === true) {
            return clone self::$annotations[$target][$targetName][$annotationName]->getUnserialized();
        }
        
        return null;
    }
}
?><?php
/**
 * Factory to create annotations.
 *
 * @package     stubbles
 * @subpackage  reflection_annotations
 * @version     $Id: stubAnnotationFactory.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAnnotationCache'
);
/**
 * Factory to create annotations.
 *
 * @static
 * @package     stubbles
 * @subpackage  reflection_annotations
 */
class stubAnnotationFactory
{
    /**
     * Prefixes that can be prepended to class names
     *
     * @var  array
     */
    private static $prefixes    = array('stub', '');
    /**
     * instance of the annotation parser
     *
     * @var  stubAnnotationStateParser
     */
    private static $parser      = null;
    /**
     * list of annotation data
     *
     * @var  array<string,array<string,array<string,array<string,string>>>>
     */
    private static $annotations = array();

    /**
     * Creates an annotation from the given docblock comment.
     *
     * @param   string          $comment          the docblock comment that contains the annotation data
     * @param   string          $annotationName   name of the annotation to create
     * @param   int             $target           the target for which the annotation should be created
     * @param   string          $targetName       the name of the target (property, class, method or function name)
     * @param   string          $fileName         the file where the target resides
     * @return  stubAnnotation
     * @throws  ReflectionException
     */
    public static function create($comment, $annotationName, $target, $targetName, $fileName)
    {
        if (stubAnnotationCache::has($target, $fileName . '::' . $targetName, $annotationName) === true) {
            return stubAnnotationCache::get($target, $fileName . '::' . $targetName, $annotationName);
        }
        
        if (stubAnnotationCache::hasNot($target, $fileName . '::' . $targetName, $annotationName) === true) {
            throw new ReflectionException('Can not find annotation ' . $annotationName);
        }

        $hash = md5($fileName . $comment . $targetName);
        if (isset(self::$annotations[$hash]) === false) {
            if (null === self::$parser) {
                stubClassLoader::load('net::stubbles::reflection::annotations::parser::stubAnnotationStateParser');
                self::$parser = new stubAnnotationStateParser();
            }
            
            self::$annotations[$hash] = self::$parser->parse($comment);
        }

        if (isset(self::$annotations[$hash][$annotationName]) === false) {
            // put null into cache to save that the annotation does not exist
            stubAnnotationCache::put($target, $fileName . '::' . $targetName, $annotationName);
            throw new ReflectionException('Can not find annotation ' . $annotationName);
        }
        
        $annotationClass = self::findAnnotationClass(self::$annotations[$hash][$annotationName]['type']);
        $annotation      = new $annotationClass();

        if (($annotation instanceof stubAnnotation) === false) {
            throw new ReflectionException('The annotation: ' . $annotationName . ' is not an instance of net::stubbles::reflection::annotations::stubAnnotation.');
        }
        
        if (strpos($annotationName, '#') !== false) {
            $realAnnotationName = substr($annotationName, 0, strpos($annotationName, '#'));
        } else {
            $realAnnotationName = $annotationName;
        }

        if (self::$annotations[$hash][$annotationName]['type'] !== $realAnnotationName) {
            $annotationType = self::findAnnotationClass($realAnnotationName, true);
            if (($annotation instanceof $annotationType) === false) {
                throw new ReflectionException('The annotation: ' . $annotationName . ' is not an instance of ' . $annotationType . '.');
            }
        }
        
        if (self::isApplicable($annotation, $target) === false) {
            throw new ReflectionException('The annotation: ' . $annotationName . ' is not applicable for the given type.');
        }
        
        self::build($annotation, self::$annotations[$hash][$annotationName]['params']);
        $annotation->setAnnotationName($annotationName);
        stubAnnotationCache::put($target, $fileName . '::' . $targetName, $annotationName, $annotation);
        return $annotation;
    }

    /**
     * Checks whether an annotation is applicable for the given type or not.
     *
     * @param   stubAnnotation  $annotation  the annotation to check
     * @param   int             $target      the type to check if annotation is applicable for
     * @return  bool
     */
    public static function isApplicable(stubAnnotation $annotation, $target)
    {
        return (($annotation->getAnnotationTarget() & $target) !== 0);
    }

    /**
     * builds the annotation by setting its values from given data
     *
     * @param   stubAnnotation  $annotation  the annotation to build
     * @param   array           $data        data for annotation
     * @throws  ReflectionException  in case setting a data value fails
     */
    public static function build(stubAnnotation $annotation, array $data)
    {
        $refClass = new ReflectionClass($annotation);
        foreach ($data as $name => $value) {
            if ($refClass->hasMethod('set' . ucfirst($name)) === true) {
                $refClass->getMethod('set' . ucfirst($name))->invoke($annotation, $value);
            } elseif ($refClass->hasProperty($name) === true) {
                $refClass->getProperty($name)->setValue($annotation, $value);
            } else {
                throw new ReflectionException('Annotation value for "' . $name . '" can not be set: no public setter and no public property exists with this name.');
            }
        }
        
        $annotation->finish();
    }

    /**
     * Checks whether the given docblock has the requested annotation
     *
     * @param   string  $comment         the docblock comment that contains the annotation data
     * @param   string  $annotationName  name of the annotation to check for
     * @param   int     $target          the target for which the annotation should be created
     * @param   string  $targetName      the name of the target (property, class, method or function name)
     * @param   string  $fileName        the file where the target resides
     * @return  bool
     */
    public static function has($comment, $annotationName, $target, $targetName, $fileName)
    {
        try {
            $annotation = self::create($comment, $annotationName, $target, $targetName, $fileName);
        } catch (ReflectionException $e) {
            $annotation = null;
        }

        return (null != $annotation);
    }

    /**
     * Add a new annotation prefix
     *
     * @param  string  $prefix
     */
    public static function addAnnotationPrefix($prefix)
    {
        self::$prefixes[] = $prefix;
    }

    /**
     * Try to find the annotation class
     *
     * This method checks, whether there is a class named exactly as the annotation class
     * or a method that has one of the prefixes defined in $prefixes and the postfix 'Annotation'.
     *
     * @param   string  $annotationClass
     * @param   bool    $allowInterface
     * @return  string
     * @throws  ReflectionException
     * @see     addAnnotationPrefix()
     */
    private static function findAnnotationClass($annotationClass, $allowInterface = false)
    {
        if (class_exists($annotationClass, false) === true) {
            return $annotationClass;
        }
        
        if (true === $allowInterface && interface_exists($annotationClass, false) === true) {
            return $annotationClass;
        }
        
        $annotationClassname = $annotationClass  . 'Annotation';
        foreach (self::$prefixes as $prefix) {
            if (class_exists($prefix . $annotationClassname) === true) {
                return $prefix . $annotationClassname;
            }
            
            if (true === $allowInterface && interface_exists($prefix . $annotationClassname, false) === true) {
                return $prefix . $annotationClassname;
            }
        }
        
        throw new ReflectionException('Error parsing annotation: Class ' . $annotationClass . ' does not exist');
    }
}
?><?php
/**
 * Interface for matching methods.
 * 
 * @package     stubbles
 * @subpackage  reflection_matcher
 * @version     $Id: stubMethodMatcher.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Interface for matching methods.
 * 
 * @package     stubbles
 * @subpackage  reflection_matcher
 */
interface stubMethodMatcher extends stubObject
{
    /**
     * checks whether the matcher is satisfied with the given method
     *
     * @param   ReflectionMethod  $method
     * @return  bool
     */
    public function matchesMethod(ReflectionMethod $method);

    /**
     * checks whether the matcher is satisfied with the given method
     *
     * @param   stubReflectionMethod  $method
     * @return  bool
     */
    public function matchesAnnotatableMethod(stubReflectionMethod $method);
}
?><?php
/**
 * Interface for matching properties.
 * 
 * @package     stubbles
 * @subpackage  reflection_matcher
 * @version     $Id: stubPropertyMatcher.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Interface for matching properties.
 * 
 * @package     stubbles
 * @subpackage  reflection_matcher
 */
interface stubPropertyMatcher extends stubObject
{
    /**
     * checks whether the matcher is satisfied with the given property
     *
     * @param   ReflectionProperty  $property
     * @return  bool
     */
    public function matchesProperty(ReflectionProperty $property);

    /**
     * checks whether the matcher is satisfied with the given property
     *
     * @param   stubReflectionProperty  $property
     * @return  bool
     */
    public function matchesAnnotatableProperty(stubReflectionProperty $property);
}
?><?php
/**
 * Extended Reflection class for classes that allows usage of annotations.
 * 
 * @package     stubbles
 * @subpackage  reflection
 * @version     $Id: reflection.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation',
                      'net::stubbles::reflection::annotations::stubAnnotationFactory',
                      'net::stubbles::reflection::stubBaseReflectionClass',
                      'net::stubbles::reflection::stubReflectionClass',
                      'net::stubbles::reflection::stubReflectionExtension',
                      'net::stubbles::reflection::stubReflectionFunction',
                      'net::stubbles::reflection::stubReflectionMethod',
                      'net::stubbles::reflection::stubReflectionObject',
                      'net::stubbles::reflection::stubReflectionPackage',
                      'net::stubbles::reflection::stubReflectionParameter',
                      'net::stubbles::reflection::stubReflectionPrimitive',
                      'net::stubbles::reflection::stubReflectionProperty',
                      'net::stubbles::reflection::stubReflectionType'
);
?><?php
/**
 * Marker interface for stubReflectionClass and stubReflectionObject.
 * 
 * @package     stubbles
 * @subpackage  reflection
 * @version     $Id: stubBaseReflectionClass.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotatable',
                      'net::stubbles::reflection::stubReflectionType',
                      'net::stubbles::reflection::matcher::stubMethodMatcher',
                      'net::stubbles::reflection::matcher::stubPropertyMatcher'
);
/**
 * Marker interface for stubReflectionClass and stubReflectionObject.
 * 
 * This interface allows to use
 * net::stubbles::reflection::stubReflectionClass and
 * net::stubbles::reflection::stubReflectionObject on
 * the same argument when the argument is typehinted with this interface.
 * 
 * @package     stubbles
 * @subpackage  reflection
 */
interface stubBaseReflectionClass extends stubReflectionType, stubAnnotatable
{
    /**
     * returns the full qualified class name of the reflected class
     * 
     * If the class has not been loaded with stubClassLoader the non qualified
     * class name will be returned.
     *
     * @return  string
     */
    public function getFullQualifiedClassName();

    /**
     * returns the constructor or null if none exists
     * 
     * Warning: PHP4-style constructors are not supported! If you have one use
     * getMethod($className) instead to retrieve the constructor reflection method.
     *
     * @return  stubReflectionMethod
     */
    public function getConstructor();

    /**
     * returns the specified method or null if it does not exist
     *
     * @param   string                $name  name of method to return
     * @return  stubReflectionMethod
     */
    public function getMethod($name);

    /**
     * returns a list of all methods
     *
     * @return  array<stubReflectionMethod>
     */
    public function getMethods();

    /**
     * returns a list of all methods which satify the given matcher
     *
     * @param   stubMethodMatcher            $methodMatcher
     * @return  array<stubReflectionMethod>
     */
    public function getMethodsByMatcher(stubMethodMatcher $methodMatcher);

    /**
     * returns the specified property or null if it does not exist
     *
     * @param   string                  $name  name of property to return
     * @return  stubReflectionProperty
     */
    public function getProperty($name);

    /**
     * returns a list of all properties
     *
     * @return  array<stubReflectionProperty>
     */
    public function getProperties();

    /**
     * returns a list of all properties which satify the given matcher
     *
     * @param   stubPropertyMatcher            $propertyMatcher
     * @return  array<stubReflectionProperty>
     */
    public function getPropertiesByMatcher(stubPropertyMatcher $propertyMatcher);

    /**
     * returns a list of all interfaces
     *
     * @return  array<stubReflectionClass>
     */
    public function getInterfaces();

    /**
     * returns a list of all interfaces
     *
     * @return  stubReflectionClass
     */
    public function getParentClass();

    /**
     * returns the extension to where this class belongs too
     *
     * @return  stubReflectionExtension
     */
    public function getExtension();

    /**
     * returns the package where the class belongs to
     *
     * @return  stubReflectionPackage
     */
    public function getPackage();

    /**
     * checks whether class implements a certain interface
     *
     * @param   string  $interface
     * @return  bool
     */
    public function implementsInterface($interface);
}
?><?php
/**
 * Extended Reflection class for classes that allows usage of annotations.
 * 
 * @package     stubbles
 * @subpackage  reflection
 * @version     $Id: stubReflectionClass.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotationFactory',
                      'net::stubbles::reflection::stubBaseReflectionClass',
                      'net::stubbles::reflection::stubReflectionExtension',
                      'net::stubbles::reflection::stubReflectionMethod',
                      'net::stubbles::reflection::stubReflectionProperty'
);
/**
 * Extended Reflection class for classes that allows usage of annotations.
 * 
 * @package     stubbles
 * @subpackage  reflection
 */
class stubReflectionClass extends ReflectionClass implements stubBaseReflectionClass
{
    /**
     * name of the reflected class
     *
     * @var  string
     */
    protected $className;

    /**
     * constructor
     *
     * @param   string  $className  name of class to reflect
     * @throws  ReflectionException
     */
    public function __construct($className)
    {
        if (strstr($className, '::') !== false || strstr($className, '.') !== false) {
            $nqClassName = stubClassLoader::getNonQualifiedClassName($className);
            if (class_exists($nqClassName, false) === false) {
                stubClassLoader::load($className);
            }
            
            $className = $nqClassName;
        } elseif (class_exists($className, false) === false && interface_exists($className, false) === false) {
            // prevent autoload from being called by the internal reflection class
            throw new ReflectionException('Class ' . $className . ' does not exist');
        }
        
        $this->className = $className;
        parent::__construct($className);
    }

    /**
     * check whether the class has the given annotation or not
     *
     * @param   string  $annotationName
     * @return  bool
     */
    public function hasAnnotation($annotationName)
    {
        return stubAnnotationFactory::has($this->getDocComment(), $annotationName, stubAnnotation::TARGET_CLASS, $this->className, $this->getFileName());
    }

    /**
     * return the specified annotation
     *
     * @param   string          $annotationName
     * @return  stubAnnotation
     * @throws  ReflectionException
     */
    public function getAnnotation($annotationName)
    {
        return stubAnnotationFactory::create($this->getDocComment(), $annotationName, stubAnnotation::TARGET_CLASS, $this->className, $this->getFileName());
    }

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if ($compare instanceof self) {
            return ($compare->className == $this->className);
        }
        
        return false;
    }

    /**
     * returns a string representation of the class
     * 
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * 'net::stubbles::reflection::stubReflectionClass['[name-of-reflected-class]']  {}'
     * <code>
     * net::stubbles::reflection::stubReflectionClass[MyClass] {
     * }
     * </code>
     *
     * @return  string
     */
    public function __toString()
    {
        return 'net::stubbles::reflection::stubReflectionClass[' . $this->className . "] {\n}\n";
    }

    /**
     * returns the full qualified class name of the reflected class
     * 
     * If the class has not been loaded with stubClassLoader the non qualified
     * class name will be returned.
     *
     * @return  string
     */
    public function getFullQualifiedClassName()
    {
        $fqClassName = stubClassLoader::getFullQualifiedClassName($this->className);
        if (null == $fqClassName) {
            return $this->className;
        }
        
        return $fqClassName;
    }

    /**
     * returns the constructor or null if none exists
     * 
     * Warning: PHP4-style constructors are not supported! If you have one use
     * getMethod($className) instead to retrieve the constructor reflection method.
     *
     * @return  stubReflectionMethod
     */
    public function getConstructor()
    {
        return $this->getMethod('__construct');
    }

    /**
     * returns the specified method or null if it does not exist
     *
     * @param   string                $name  name of method to return
     * @return  stubReflectionMethod
     */
    public function getMethod($name)
    {
        if (parent::hasMethod($name) == false) {
            return null;
        }
        
        $stubRefMethod = new stubReflectionMethod($this, $name);
        return $stubRefMethod;
    }

    /**
     * returns a list of all methods
     *
     * @return  array<stubReflectionMethod>
     */
    public function getMethods()
    {
        $methods    = parent::getMethods();
        $stubMethods = array();
        foreach ($methods as $method) {
            $stubMethods[] = new stubReflectionMethod($this, $method->getName());
        }
        
        return $stubMethods;
    }

    /**
     * returns a list of all methods which satify the given matcher
     *
     * @param   stubMethodMatcher            $methodMatcher
     * @return  array<stubReflectionMethod>
     */
    public function getMethodsByMatcher(stubMethodMatcher $methodMatcher)
    {
        $methods     = parent::getMethods();
        $stubMethods = array();
        foreach ($methods as $method) {
            if ($methodMatcher->matchesMethod($method) === true) {
                $stubMethod = new stubReflectionMethod($this, $method->getName());
                if ($methodMatcher->matchesAnnotatableMethod($stubMethod) === true) {
                    $stubMethods[] = $stubMethod;
                }
            }
        }
        
        return $stubMethods;
    }

    /**
     * returns the specified property or null if it does not exist
     *
     * @param   string                  $name  name of property to return
     * @return  stubReflectionProperty
     */
    public function getProperty($name)
    {
        if (parent::hasProperty($name) == false) {
            return null;
        }
        
        $stubRefProperty = new stubReflectionProperty($this, $name);
        return $stubRefProperty;
    }

    /**
     * returns a list of all properties
     *
     * @return  array<stubReflectionProperty>
     */
    public function getProperties()
    {
        $properties     = parent::getProperties();
        $stubProperties = array();
        foreach ($properties as $property) {
            $stubProperties[] = new stubReflectionProperty($this, $property->getName());
        }
        
        return $stubProperties;
    }

    /**
     * returns a list of all properties which satify the given matcher
     *
     * @param   stubPropertyMatcher            $propertyMatcher
     * @return  array<stubReflectionProperty>
     */
    public function getPropertiesByMatcher(stubPropertyMatcher $propertyMatcher)
    {
        $properties     = parent::getProperties();
        $stubProperties = array();
        foreach ($properties as $property) {
            if ($propertyMatcher->matchesProperty($property) === true) {
                $stubProperty = new stubReflectionProperty($this, $property->getName());
                if ($propertyMatcher->matchesAnnotatableProperty($stubProperty) === true) {
                    $stubProperties[] = $stubProperty;
                }
            }
        }
        
        return $stubProperties;
    }

    /**
     * returns a list of all interfaces
     *
     * @return  array<stubReflectionClass>
     */
    public function getInterfaces()
    {
        $interfaces     = parent::getInterfaces();
        $stubRefClasses = array();
        foreach ($interfaces as $interface) {
            $stubRefClasses[] = new self($interface->getName());
        }
        
        return $stubRefClasses;
    }

    /**
     * returns a list of all interfaces
     *
     * @return  stubReflectionClass
     */
    public function getParentClass()
    {
        $parentClass  = parent::getParentClass();
        if (null === $parentClass || false === $parentClass) {
            return null;
        }
        
        $stubRefClass = new self($parentClass->getName());
        return $stubRefClass;
    }

    /**
     * returns the extension to where this class belongs too
     *
     * @return  stubReflectionExtension
     */
    public function getExtension()
    {
        $extensionName  = $this->getExtensionName();
        if (null === $extensionName || false === $extensionName) {
            return null;
        }
        
        $stubRefExtension = new stubReflectionExtension($extensionName);
        return $stubRefExtension;
    }

    /**
     * returns the package where the class belongs to
     *
     * @return  stubReflectionPackage
     */
    public function getPackage()
    {
        $refPackage = new stubReflectionPackage(stubClassLoader::getPackageName($this->getFullQualifiedClassName()));
        return $refPackage;
    }

    /**
     * checks whether the type is an object
     *
     * @return  bool
     */
    public function isObject()
    {
        return true;
    }

    /**
     * checks whether the type is a primitive
     *
     * @return  bool
     */
    public function isPrimitive()
    {
        return false;
    }
}
?><?php
/**
 * Extended Reflection class for extensions.
 * 
 * @package     stubbles
 * @subpackage  reflection
 * @version     $Id: stubReflectionExtension.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::stubReflectionClass',
                      'net::stubbles::reflection::stubReflectionFunction'
);
/**
 * Extended Reflection class for extensions.
 * 
 * @package     stubbles
 * @subpackage  reflection
 */
class stubReflectionExtension extends ReflectionExtension
{
    /**
     * name of reflected extension
     *
     * @var  string
     */
    protected $extensionName;
    
    /**
     * constructor
     *
     * @param  string  $extensionName  name of extension to reflect
     */
    public function __construct($extensionName)
    {
        $this->extensionName = $extensionName;
        parent::__construct($extensionName);
    }
    
    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if ($compare instanceof self) {
            return ($compare->extensionName == $this->extensionName);
        }
        
        return false;
    }
    
    /**
     * returns a string representation of the class
     * 
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * 'net::stubbles::reflection::stubReflectionExtension['[name-of-reflected-extension]']  {}'
     * <code>
     * net::stubbles::reflection::stubReflectionExtension[spl] {
     * }
     * </code>
     *
     * @return  string
     */
    public function __toString()
    {
        return 'net::stubbles::reflection::stubReflectionExtension[' . $this->extensionName . "] {\n}\n";
    }

    /**
     * returns a list of all functions
     *
     * @return  array<stubReflectionFunction>
     */
    public function getFunctions()
    {
        $functions        = parent::getFunctions();
        $stubRefFunctions = array();
        foreach ($functions as $function) {
            $stubRefFunctions[] = new stubReflectionFunction($function->getName());
        }
        
        return $stubRefFunctions;
    }

    /**
     * returns a list of all classes
     *
     * @return  array<stubReflectionClass>
     */
    public function getClasses()
    {
        $classes        = parent::getClasses();
        $stubRefClasses = array();
        foreach ($classes as $class) {
            $stubRefClasses[] = new stubReflectionClass($class->getName());
        }
        
        return $stubRefClasses;
    }
}
?><?php
/**
 * Extended Reflection class for functions that allows usage of annotations.
 * 
 * @package     stubbles
 * @subpackage  reflection
 * @version     $Id: stubReflectionFunction.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotatable',
                      'net::stubbles::reflection::annotations::stubAnnotationFactory',
                      'net::stubbles::reflection::stubReflectionClass',
                      'net::stubbles::reflection::stubReflectionParameter',
                      'net::stubbles::reflection::stubReflectionPrimitive',
                      'net::stubbles::reflection::stubReflectionRoutine'
);
/**
 * Extended Reflection class for functions that allows usage of annotations.
 * 
 * @package     stubbles
 * @subpackage  reflection
 */
class stubReflectionFunction extends ReflectionFunction implements stubReflectionRoutine
{
    /**
     * name of the reflected function
     *
     * @var  string
     */
    protected $functionName;
    /**
     * docblock comment for this class
     *
     * @var  string
     */
    protected $docComment;

    /**
     * constructor
     *
     * @param  string  $functionName  name of function to reflect
     */
    public function __construct($functionName)
    {
        $this->functionName = $functionName;
        parent::__construct($functionName);
        $this->docComment = $this->getDocComment();
    }

    /**
     * check whether the class has the given annotation or not
     *
     * @param   string  $annotationName
     * @return  bool
     */
    public function hasAnnotation($annotationName)
    {
        return stubAnnotationFactory::has($this->docComment, $annotationName, stubAnnotation::TARGET_FUNCTION, $this->functionName, $this->getFileName());
    }

    /**
     * return the specified annotation
     *
     * @param   string          $annotationName
     * @return  stubAnnotation
     * @throws  ReflectionException
     */
    public function getAnnotation($annotationName)
    {
        return stubAnnotationFactory::create($this->docComment, $annotationName, stubAnnotation::TARGET_FUNCTION, $this->functionName, $this->getFileName());
    }

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if ($compare instanceof self) {
            return ($compare->functionName === $this->functionName);
        }
        
        return false;
    }

    /**
     * returns a string representation of the class
     * 
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * 'net::stubbles::reflection::stubReflectionFunction['[name-of-reflected-function]'()]  {}'
     * <code>
     * net::stubbles::reflection::stubReflectionFunction[fopen()] {
     * }
     * </code>
     *
     * @return  string
     */
    public function __toString()
    {
        return 'net::stubbles::reflection::stubReflectionFunction[' . $this->functionName . "()] {\n}\n";
    }

    /**
     * returns a list of all parameters
     *
     * @return  array<stubReflectionParameter>
     */
    public function getParameters()
    {
        $parameters     = parent::getParameters();
        $stubParameters = array();
        foreach ($parameters as $parameter) {
            $stubParameters[] = new stubReflectionParameter($this, $parameter->getName());
        }
        
        return $stubParameters;
    }

    /**
     * returns information about the return type of a function
     * 
     * If the return type is a class the return value is an instance of
     * stubReflectionClass (if the class is unknown a
     * stubClassNotFoundException will be thrown), if it is a scalar type the
     * return value is an instance of stubReflectionPrimitive, and if the
     * method does not have a return value this method returns null.
     * Please be aware that this is guessing from the doc block with which the
     * function is documented. If the doc block is missing or incorrect the
     * return value of this method may be wrong. This is due to missing type
     * hints for return values in PHP itself.
     *
     * @return  stubReflectionType
     */
    public function getReturnType()
    {
        $returnPart = strstr($this->docComment, '@return');
        if (false === $returnPart) {
            return null;
        }
        
        $returnParts = explode(' ', trim(str_replace('@return', '', $returnPart)));
        $returnType  = trim($returnParts[0]);
        try {
            $reflectionType = stubReflectionPrimitive::forName(new ReflectionClass('stubReflectionPrimitive'), $returnType);
        } catch (stubIllegalArgumentException $iae) {
            $reflectionType = new stubReflectionClass($returnType);
        }
        
        return $reflectionType;
    }
}
?><?php
/**
 * Extended Reflection class for class methods that allows usage of annotations.
 * 
 * @package     stubbles
 * @subpackage  reflection
 * @version     $Id: stubReflectionMethod.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotatable',
                      'net::stubbles::reflection::annotations::stubAnnotationFactory',
                      'net::stubbles::reflection::stubReflectionClass',
                      'net::stubbles::reflection::stubReflectionParameter',
                      'net::stubbles::reflection::stubReflectionPrimitive',
                      'net::stubbles::reflection::stubReflectionRoutine'
);
/**
 * Extended Reflection class for class methods that allows usage of annotations.
 * 
 * @package     stubbles
 * @subpackage  reflection
 */
class stubReflectionMethod extends ReflectionMethod implements stubReflectionRoutine
{
    /**
     * name of the reflected class
     *
     * @var  string
     */
    protected $className;
    /**
     * declaring class
     *
     * @var  stubBaseReflectionClass
     */
    protected $refClass;
    /**
     * name of the reflected method
     *
     * @var  string
     */
    protected $methodName;

    /**
     * constructor
     *
     * @param  string|stubBaseReflectionClass  $class       name of class to reflect
     * @param  string                          $methodName  name of method to reflect
     */
    public function __construct($class, $methodName)
    {
        if ($class instanceof stubBaseReflectionClass) {
            $this->refClass   = $class;
            $this->className  = $this->refClass->getName();
        } else {
            $this->className  = $class;
        }
        
        $this->methodName = $methodName;
        parent::__construct($this->className, $methodName);
    }

    /**
     * check whether the class has the given annotation or not
     *
     * @param   string  $annotationName
     * @return  bool
     */
    public function hasAnnotation($annotationName)
    {
        return stubAnnotationFactory::has($this->getDocComment(), $annotationName, stubAnnotation::TARGET_METHOD, $this->className . '::' . $this->methodName . '()', $this->getFileName());
    }

    /**
     * return the specified annotation
     *
     * @param   string          $annotationName
     * @return  stubAnnotation
     * @throws  ReflectionException
     */
    public function getAnnotation($annotationName)
    {
        return stubAnnotationFactory::create($this->getDocComment(), $annotationName, stubAnnotation::TARGET_METHOD, $this->className . '::' . $this->methodName . '()', $this->getFileName());
    }

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if ($compare instanceof self) {
            return ($compare->className === $this->className && $compare->methodName === $this->methodName);
        }
        
        return false;
    }

    /**
     * returns a string representation of the class
     * 
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * 'net::stubbles::reflection::stubReflectionMethod['[name-of-reflected-class]'::'[name-of-reflected-method]'()]  {}'
     * <code>
     * net::stubbles::reflection::stubReflectionMethod[MyClass::myMethod()] {
     * }
     * </code>
     *
     * @return  string
     */
    public function __toString()
    {
        return 'net::stubbles::reflection::stubReflectionMethod[' . $this->className . '::' . $this->methodName . "()] {\n}\n";
    }

    /**
     * returns the class that declares this method
     *
     * @return  stubBaseReflectionClass
     */
    public function getDeclaringClass()
    {
        $refClass = parent::getDeclaringClass();
        if ($refClass->getName() === $this->className) {
            if (null === $this->refClass) {
                $this->refClass = new stubReflectionClass($this->className);
            }
            
            return $this->refClass;
        }
        
        $stubRefClass = new stubReflectionClass($refClass->getName());
        return $stubRefClass;
    }

    /**
     * returns a list of all parameters
     *
     * @return  array<stubReflectionParameter>
     */
    public function getParameters()
    {
        $parameters     = parent::getParameters();
        $stubParameters = array();
        foreach ($parameters as $parameter) {
            $stubParameters[] = new stubReflectionParameter($this, $parameter->getName());
        }
        
        return $stubParameters;
    }

    /**
     * returns information about the return type of a method
     * 
     * If the return type is a class the return value is an instance of
     * stubReflectionClass (if the class is unknown a
     * stubClassNotFoundException will be thrown), if it is a scalar type the
     * return value is an instance of stubReflectionPrimitive, and if the
     * method does not have a return value this method returns null.
     * Please be aware that this is guessing from the doc block with which the
     * method is documented. If the doc block is missing or incorrect the return
     * value of this method may be wrong. This is due to missing type hints for
     * return values in PHP itself.
     *
     * @return  stubReflectionType
     */
    public function getReturnType()
    {
        $returnPart = strstr($this->getDocComment(), '@return');
        if (false === $returnPart) {
            return null;
        }
        
        $returnParts = explode(' ', trim(str_replace('@return', '', $returnPart)));
        $returnType  = trim($returnParts[0]);
        try {
            $reflectionType = stubReflectionPrimitive::forName(new ReflectionClass('stubReflectionPrimitive'), $returnType);
        } catch (stubIllegalArgumentException $iae) {
            $reflectionType = new stubReflectionClass($returnType);
        }
        
        return $reflectionType;
    }
}
?><?php
/**
 * Extended Reflection class for classes that allows usage of annotations.
 * 
 * @package     stubbles
 * @subpackage  reflection
 * @version     $Id: stubReflectionObject.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::stubReflectionClass',
                      'net::stubbles::reflection::annotations::stubAnnotationFactory',
                      'net::stubbles::reflection::stubBaseReflectionClass',
                      'net::stubbles::reflection::stubReflectionExtension',
                      'net::stubbles::reflection::stubReflectionMethod',
                      'net::stubbles::reflection::stubReflectionProperty'
);
/**
 * Extended Reflection class for classes that allows usage of annotations.
 * 
 * @package     stubbles
 * @subpackage  reflection
 */
class stubReflectionObject extends ReflectionObject implements stubBaseReflectionClass
{
    /**
     * name of the reflected class
     *
     * @var  string
     */
    protected $className;
    /**
     * instance of the reflected class
     *
     * @var  object
     */
    protected $classObject;

    /**
     * constructor
     *
     * @param  object  $classObject  instance of class to reflect
     */
    public function __construct($classObject)
    {
        $this->className   = get_class($classObject);
        $this->classObject = $classObject;
        parent::__construct($classObject);
    }

    /**
     * check whether the class has the given annotation or not
     *
     * @param   string  $annotationName
     * @return  bool
     */
    public function hasAnnotation($annotationName)
    {
        return stubAnnotationFactory::has($this->getDocComment(), $annotationName, stubAnnotation::TARGET_CLASS, $this->className, $this->getFileName());
    }

    /**
     * return the specified annotation
     *
     * @param   string          $annotationName
     * @return  stubAnnotation
     * @throws  ReflectionException
     */
    public function getAnnotation($annotationName)
    {
        return stubAnnotationFactory::create($this->getDocComment(), $annotationName, stubAnnotation::TARGET_CLASS, $this->className, $this->getFileName());
    }

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if (($compare instanceof self) == false) {
            return false;
        }
        
        if ($compare->classObject instanceof stubObject) {
            $compareHashCode = $compare->classObject->hashCode();
        } else {
            $compareHashCode = spl_object_hash($compare->classObject);
        }
        
        if ($this->classObject instanceof stubObject) {
            $classHashCode = $this->classObject->hashCode();
        } else {
            $classHashCode = spl_object_hash($this->classObject);
        }
        
        return ($compare->className == $this->className && $compareHashCode == $classHashCode);
    }

    /**
     * returns a string representation of the class
     * 
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * 'net::stubbles::reflection::stubReflectionObject['[name-of-reflected-class]']  {}'
     * <code>
     * net::stubbles::reflection::stubReflectionObject[MyClass] {
     * }
     * </code>
     *
     * @return  string
     */
    public function __toString()
    {
        return 'net::stubbles::reflection::stubReflectionObject[' . $this->className . "] {\n}\n";
    }

    /**
     * returns the full qualified class name of the reflected class
     * 
     * If the class has not been loaded with stubClassLoader the non qualified
     * class name will be returned.
     *
     * @return  string
     */
    public function getFullQualifiedClassName()
    {
        $fqClassName = stubClassLoader::getFullQualifiedClassName($this->className);
        if (null == $fqClassName) {
            return $this->className;
        }
        
        return $fqClassName;
    }

    /**
     * returns the instance of the class with with this reflection instance was created
     *
     * @return  object
     */
    public function getObjectInstance()
    {
        return $this->classObject;
    }

    /**
     * returns the constructor or null if none exists
     * 
     * Warning: PHP4-style constructors are not supported! If you have one use
     * getMethod($className) instead to retrieve the constructor reflection method.
     *
     * @return  stubReflectionMethod
     */
    public function getConstructor()
    {
        return $this->getMethod('__construct');
    }

    /**
     * returns the specified method or null if it does not exist
     *
     * @param   string                $name  name of method to return
     * @return  stubReflectionMethod
     */
    public function getMethod($name)
    {
        if (parent::hasMethod($name) == false) {
            return null;
        }
        
        $stubRefMethod = new stubReflectionMethod($this, $name);
        return $stubRefMethod;
    }

    /**
     * returns a list of all methods
     *
     * @return  array<stubReflectionMethod>
     */
    public function getMethods()
    {
        $methods    = parent::getMethods();
        $stubMethods = array();
        foreach ($methods as $method) {
            $stubMethods[] = new stubReflectionMethod($this, $method->getName());
        }
        
        return $stubMethods;
    }

    /**
     * returns a list of all methods which satify the given matcher
     *
     * @param   stubMethodMatcher            $methodMatcher
     * @return  array<stubReflectionMethod>
     */
    public function getMethodsByMatcher(stubMethodMatcher $methodMatcher)
    {
        $methods     = parent::getMethods();
        $stubMethods = array();
        foreach ($methods as $method) {
            if ($methodMatcher->matchesMethod($method) === true) {
                $stubMethod = new stubReflectionMethod($this, $method->getName());
                if ($methodMatcher->matchesAnnotatableMethod($stubMethod) === true) {
                    $stubMethods[] = $stubMethod;
                }
            }
        }
        
        return $stubMethods;
    }

    /**
     * returns the specified property or null if it does not exist
     *
     * @param   string                  $name  name of property to return
     * @return  stubReflectionProperty
     */
    public function getProperty($name)
    {
        if (parent::hasProperty($name) == false) {
            return null;
        }
        
        $stubRefProperty = new stubReflectionProperty($this, $name);
        return $stubRefProperty;
    }

    /**
     * returns a list of all properties
     *
     * @return  array<stubReflectionProperty>
     */
    public function getProperties()
    {
        $properties     = parent::getProperties();
        $stubProperties = array();
        foreach ($properties as $property) {
            $stubProperties[] = new stubReflectionProperty($this, $property->getName());
        }
        
        return $stubProperties;
    }

    /**
     * returns a list of all properties which satify the given matcher
     *
     * @param   stubPropertyMatcher            $propertyMatcher
     * @return  array<stubReflectionProperty>
     */
    public function getPropertiesByMatcher(stubPropertyMatcher $propertyMatcher)
    {
        $properties     = parent::getProperties();
        $stubProperties = array();
        foreach ($properties as $property) {
            if ($propertyMatcher->matchesProperty($property) === true) {
                $stubProperty = new stubReflectionProperty($this, $property->getName());
                if ($propertyMatcher->matchesAnnotatableProperty($stubProperty) === true) {
                    $stubProperties[] = $stubProperty;
                }
            }
        }
        
        return $stubProperties;
    }

    /**
     * returns a list of all interfaces
     *
     * @return  array<stubReflectionClass>
     */
    public function getInterfaces()
    {
        $interfaces     = parent::getInterfaces();
        $stubRefClasses = array();
        foreach ($interfaces as $interface) {
            $stubRefClasses[] = new stubReflectionClass($interface->getName());
        }
        
        return $stubRefClasses;
    }

    /**
     * returns a list of all interfaces
     *
     * @return  stubReflectionClass
     */
    public function getParentClass()
    {
        $parentClass  = parent::getParentClass();
        if (null === $parentClass || false === $parentClass) {
            return null;
        }
        
        $stubRefClass = new stubReflectionClass($parentClass->getName());
        return $stubRefClass;
    }

    /**
     * returns the extension to where this class belongs too
     *
     * @return  stubReflectionExtension
     */
    public function getExtension()
    {
        $extensionName  = $this->getExtensionName();
        if (null === $extensionName || false === $extensionName) {
            return null;
        }
        
        $stubRefExtension = new stubReflectionExtension($extensionName);
        return $stubRefExtension;
    }

    /**
     * returns the package where the class belongs to
     *
     * @return  stubReflectionPackage
     */
    public function getPackage()
    {
        $refPackage = new stubReflectionPackage(stubClassLoader::getPackageName($this->getFullQualifiedClassName()));
        return $refPackage;
    }

    /**
     * checks whether the type is an object
     *
     * @return  bool
     */
    public function isObject()
    {
        return true;
    }

    /**
     * checks whether the type is a primitive
     *
     * @return  bool
     */
    public function isPrimitive()
    {
        return false;
    }
}
?><?php
/**
 * Extended Reflection class for packages.
 *
 * @package     stubbles
 * @subpackage  reflection
 * @version     $Id: stubReflectionPackage.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::stubBaseReflectionClass',
                      'net::stubbles::reflection::stubReflectionClass'
);
/**
 * Extended Reflection class for packages.
 *
 * @package     stubbles
 * @subpackage  reflection
 */
class stubReflectionPackage
{
    /**
     * the package separator character
     */
    const SEPARATOR = '::';
    /**
     * name of the reflected package
     *
     * @var  string
     */
    protected $packageName;

    /**
     * constructor
     *
     * @param  string  $packageName  name of package to reflect
     */
    public function __construct($packageName)
    {
        $this->packageName = $packageName;
    }

    /**
     * checks whether a value is equal to the package
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if ($compare instanceof self) {
            return ($compare->packageName == $this->packageName);
        }

        return false;
    }

    /**
     * returns a string representation of the class
     *
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * 'net::stubbles::reflection::stubReflectionPackage['[name-of-reflected-package]']  {}'
     * <code>
     * net::stubbles::reflection::stubReflectionPackage[mypackage] {
     * }
     * </code>
     *
     * @return  string
     */
    public function __toString()
    {
        return 'net::stubbles::reflection::stubReflectionPackage[' . $this->packageName . "] {\n}\n";
    }

    /**
     * returns the full qualified class name of the reflected package
     *
     * @return  string
     */
    public function getName()
    {
        return $this->packageName;
    }

    /**
     * checks whether the package has a class with the given name
     *
     * @param   string  $nqClassName  non qualified name of class to check
     * @return  bool
     */
    public function hasClass($nqClassName)
    {
        $classNames = stubClassLoader::getClassNames($this->packageName, false);
        return in_array($this->packageName . self::SEPARATOR . $nqClassName, $classNames);
    }

    /**
     * returns the specified class
     *
     * @param   string               $nqClassName  non qualified name of class to return
     * @return  stubReflectionClass
     * @throws  stubClassNotFoundException
     */
    public function getClass($nqClassName)
    {
        $stubRefClass = new stubReflectionClass($this->packageName . self::SEPARATOR . $nqClassName);
        return $stubRefClass;
    }

    /**
     * returns a list of all class names within the package
     *
     * @param   bool           $recursive  optional  true if classes of subpackages should be included
     * @return  array<string>
     */
    public function getClassNames($recursive = false)
    {
        return stubClassLoader::getClassNames($this->packageName, $recursive);
    }

    /**
     * returns a list of all classes within the package
     *
     * @param   bool                        $recursive  optional  true if classes of subpackages should be included
     * @return  array<stubReflectionClass>
     */
    public function getClasses($recursive = false)
    {
        $classes = array();
        $classNames = stubClassLoader::getClassNames($this->packageName, $recursive);
        foreach ($classNames as $fqClassName) {
            $classes[] = new stubReflectionClass($fqClassName);
        }

        return $classes;
    }

    /**
     * check whether the package contains a subpackage with the given name
     *
     * @param   string  $name  name of subpackage
     * @return  bool
     */
    public function hasPackage($name)
    {
        return in_array($name, $this->getPackageNames(true));
    }

    /**
     * returns the subpackage
     *
     * @param   string                 $name  name of subpackage (without name of current package)
     * @return  stubReflectionPackage
     */
    public function getPackage($name)
    {
        return new self($this->packageName . self::SEPARATOR . $name);
    }

    /**
     * returns a list of all subpackage names
     *
     * @param   bool           $recursive  optional  true if subpackages of subpackages should be included
     * @return  array<string>
     */
    public function getPackageNames($recursive = false)
    {
        $packages   = array();
        $classNames = stubClassLoader::getClassNames($this->packageName, true);
        foreach ($classNames as $fqClassName) {
            $packageName = stubClassLoader::getPackageName($fqClassName);
            if ($packageName == $this->packageName) {
                continue;
            }

            $shortName = str_replace($this->packageName . self::SEPARATOR, '', $packageName);
            if (strstr($shortName, self::SEPARATOR) !== false && false === $recursive) {
                continue;
            }

            $packages[$shortName] = $shortName;
        }

        $return = array_keys($packages);
        sort($return);
        return $return;
    }

    /**
     * returns a list of all subpackages
     *
     * @param   bool                          $recursive  optional  true if subpackages of subpackages should be included
     * @return  array<stubReflectionPackage>
     */
    public function getPackages($recursive = false)
    {
        $packages    = $this->getPackageNames($recursive);
        $refPackages = array();
        foreach ($packages as $package) {
            $refPackages[] = new self($this->packageName . self::SEPARATOR . $package);
        }

        return $refPackages;
    }
}
?><?php
/**
 * Extended Reflection class for parameters.
 * 
 * @package     stubbles
 * @subpackage  reflection
 * @version     $Id: stubReflectionParameter.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotatable',
                      'net::stubbles::reflection::annotations::stubAnnotationFactory',
                      'net::stubbles::reflection::stubReflectionFunction',
                      'net::stubbles::reflection::stubReflectionClass'
);
/**
 * Extended Reflection class for parameters.
 * 
 * @package     stubbles
 * @subpackage  reflection
 */
class stubReflectionParameter extends ReflectionParameter implements stubAnnotatable
{
    /**
     * name of reflected routine
     *
     * @var  string
     */
    protected $routineName;
    /**
     * reflection instance of routine containing this parameter
     *
     * @var  stubReflectionRoutine
     */
    protected $refRoutine;
    /**
     * name of reflected parameter
     *
     * @var  string
     */
    protected $paramName;

    /**
     * constructor
     *
     * @param  string|array|stubReflectionRoutine  $routine    name or reflection instance of routine
     * @param  string                              $paramName  name of parameter to reflect
     */
    public function __construct($routine, $paramName)
    {
        if ($routine instanceof stubReflectionMethod) {
            $this->refRoutine  = $routine;
            $this->routineName = array($routine->getDeclaringClass()->getName(), $routine->getName());
        } elseif ($routine instanceof stubReflectionFunction) {
            $this->refRoutine  = $routine;
            $this->routineName = $routine->getName();
        } else {
            $this->routineName = $routine;
        }
        
        $this->paramName = $paramName;
        parent::__construct($this->routineName, $paramName);
    }

    /**
     * check whether the class has the given annotation or not
     *
     * @param   string  $annotationName
     * @return  bool
     */
    public function hasAnnotation($annotationName)
    {
        $refRoutine = $this->getRefRoutine();
        $targetName = ((is_array($this->routineName) === true) ? ($this->routineName[0] . '::' . $this->routineName[1] . '()') : ($this->routineName));
        return stubAnnotationFactory::has($refRoutine->getDocComment(), $annotationName . '#' . $this->paramName, stubAnnotation::TARGET_PARAM, $targetName, $refRoutine->getFileName());
    }

    /**
     * return the specified annotation
     *
     * @param   string          $annotationName
     * @return  stubAnnotation
     * @throws  ReflectionException
     */
    public function getAnnotation($annotationName)
    {
        $refRoutine = $this->getRefRoutine();
        $targetName = ((is_array($this->routineName) === true) ? ($this->routineName[0] . '::' . $this->routineName[1] . '()') : ($this->routineName));
        return stubAnnotationFactory::create($refRoutine->getDocComment(), $annotationName . '#' . $this->paramName, stubAnnotation::TARGET_PARAM, $targetName, $refRoutine->getFileName());
    }

    /**
     * helper method to return the reflection routine defining this parameter
     *
     * @return  stubReflectionRoutine
     * @todo    replace by getDeclaringFunction() as soon as Stubbles requires at least PHP 5.2.3
     */
    protected function getRefRoutine()
    {
        if (null === $this->refRoutine) {
            if (is_array($this->routineName) === true) {
                $this->refRoutine = new stubReflectionMethod($this->routineName[0], $this->routineName[1]);
            } else {
                $this->refRoutine = new stubReflectionFunction($this->routineName);
            }
        }
        
        return $this->refRoutine;
    }

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if (($compare instanceof self) == false) {
            return false;
        }
        
        $class        = $this->getDeclaringClass();
        $compareClass = $compare->getDeclaringClass();
        if ((null == $class && null != $compareClass) || null != $class && null == $compareClass) {
            return false;
        }
        
        if (null == $class) {
            return ($compare->routineName == $this->routineName && $compare->paramName == $this->paramName);
        }
        
        return ($compareClass->getName() == $class->getName() && $compare->routineName == $this->routineName && $compare->paramName == $this->paramName);
    }

    /**
     * returns a string representation of the class
     * 
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * 'net::stubbles::reflection::stubReflectionParameter['[name-of-reflected-class]'::'[name-of-reflected-function]'(): Argument '[name-of-reflected-argument]']  {}'
     * <code>
     * net::stubbles::reflection::stubReflectionParameter[MyClass::myMethod(): Argument foo] {
     * }
     * net::stubbles::reflection::stubReflectionParameter[myFunction(): Argument bar] {
     * }
     * </code>
     *
     * @return  string
     */
    public function __toString()
    {
        if (is_array($this->routineName) == false) {
            return 'net::stubbles::reflection::stubReflectionParameter[' . $this->routineName . '(): Argument ' . $this->paramName . "] {\n}\n";
        }
        
        return 'net::stubbles::reflection::stubReflectionParameter[' . $this->routineName[0] . '::' . $this->routineName[1] . '(): Argument ' . $this->paramName . "] {\n}\n";
    }

    /**
     * returns the function that declares this parameter
     *
     * @return  stubReflectionFunction
     */
    # well, manual says its there, its even in php cvs, but calling
    # ReflectionParameter::getDeclaringFunction() results in a fatal error
    # with message "Call to undefined method"
    #public function getDeclaringFunction()
    #{
    #    $refFunction     = parent::getDeclaringFunction();
    #    $stubRefFunction = new stubReflectionFunction($refFunction->getName());
    #    return $stubRefFunction;
    #}

    /**
     * returns the class that declares this parameter
     *
     * @return  stubReflectionClass
     */
    public function getDeclaringClass()
    {
        if (is_array($this->routineName) === false) {
            return null;
        }
        
        $refClass     = parent::getDeclaringClass();
        $stubRefClass = new stubReflectionClass($refClass->getName());
        return $stubRefClass;
    }

    /**
     * returns the type (class) hint for this parameter
     *
     * @return  stubReflectionClass
     */
    public function getClass()
    {
        $refClass = parent::getClass();
        if (null === $refClass) {
            return null;
        }
        
        $stubRefClass = new stubReflectionClass($refClass->getName());
        return $stubRefClass;
    }
}
?><?php
/**
 * Type reference for primitives.
 *
 * @author      Frank Kleine <mikey@stubbles.net>
 * @package     stubbles
 * @subpackage  reflection
 */
stubClassLoader::load('net::stubbles::lang::stubEnum',
                      'net::stubbles::reflection::stubReflectionType'
);
/**
 * Type reference for primitives.
 *
 * @author      Frank Kleine <mikey@stubbles.net>
 * @package     stubbles
 * @subpackage  reflection
 */
class stubReflectionPrimitive extends stubEnum implements stubReflectionType
{
    /**
     * primitive of type string
     *
     * @var  stubReflectionPrimitive
     */
    public static $STRING;
    /**
     * primitive of type int
     *
     * @var  stubReflectionPrimitive
     */
    public static $INT;
    /**
     * primitive of type int, marked as integer
     *
     * @var  stubReflectionPrimitive
     */
    public static $INTEGER;
    /**
     * primitive of type float
     *
     * @var  stubReflectionPrimitive
     */
    public static $FLOAT;
    /**
     * primitive of type double, equal to float
     *
     * @var  stubReflectionPrimitive
     */
    public static $DOUBLE;
    /**
     * primitive of type bool
     *
     * @var  stubReflectionPrimitive
     */
    public static $BOOL;
    /**
     * primitive of type bool, marked as boolean
     *
     * @var  stubReflectionPrimitive
     */
    public static $BOOLEAN;
    /**
     * primitive of type array
     *
     * @var  stubReflectionPrimitive
     */
    public static $ARRAY;

    /**
     * static initializing
     */
    // @codeCoverageIgnoreStart
    public static function __static()
    {
        self::$STRING  = new self('string', 'string');
        self::$INT     = new self('int', 'int');
        self::$INTEGER = new self('integer', 'int');
        self::$FLOAT   = new self('float', 'float');
        self::$DOUBLE  = new self('double', 'float');
        self::$BOOL    = new self('bool', 'bool');
        self::$BOOLEAN = new self('boolean', 'bool');
        self::$ARRAY   = new self('array', 'array');
    }
    // @codeCoverageIgnoreEnd

    /**
     * returns the enum instance of given class identified by its name
     *
     * @param   ReflectionClass  $enum
     * @param   string           $name
     * @return  stubEnum
     */
    public static function forName(ReflectionClass $enum, $name)
    {
        if (substr(strtolower($name), 0, 5) == 'array') {
            return stubEnum::forName($enum, 'ARRAY');
        }
        
        return stubEnum::forName($enum, $name);
    }

    /**
     * returns the name of the type
     *
     * @return  string
     */
    public function getName()
    {
        return $this->name();
    }

    /**
     * checks whether the type is an object
     *
     * @return  bool
     */
    public function isObject()
    {
        return false;
    }

    /**
     * checks whether the type is a primitive
     *
     * @return  bool
     */
    public function isPrimitive()
    {
        return true;
    }

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if ($compare instanceof self) {
            return ($compare->value == $this->value);
        }
        
        return false;
    }

    /**
     * returns a string representation of the class
     *
     * @return  string
     */
    public function __toString()
    {
        return 'net::stubbles::reflection::stubReflectionPrimitive[' . $this->value . "] {\n}\n";
    }
}
?><?php
/**
 * Extended Reflection class for class properties that allows usage of annotations.
 * 
 * @package     stubbles
 * @subpackage  reflection
 * @version     $Id: stubReflectionProperty.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotatable',
                      'net::stubbles::reflection::annotations::stubAnnotationFactory',
                      'net::stubbles::reflection::stubReflectionClass'
);
/**
 * Extended Reflection class for class properties that allows usage of annotations.
 * 
 * @package     stubbles
 * @subpackage  reflection
 */
class stubReflectionProperty extends ReflectionProperty implements stubAnnotatable
{
    /**
     * Name of the class
     *
     * @var  string
     */
    protected $className;
    /**
     * reflection instance for class declaring this property
     *
     * @var  stubBaseReflectionClass
     */
    protected $refClass;
    /**
     * Name of the property
     *
     * @var  string
     */
    protected $propertyName;

    /**
     * constructor
     *
     * @param  string|stubBaseReflectionClass  $class         name of class to reflect
     * @param  string                          $propertyName  name of property to reflect
     */
    public function __construct($class, $propertyName)
    {
        if ($class instanceof stubBaseReflectionClass) {
            $this->refClass  = $class;
            $this->className = $class->getName();
        } else {
            $this->className = $class;
        }
        
        $this->propertyName = $propertyName;
        parent::__construct($this->className, $propertyName);
    }

    /**
     * check whether the class has the given annotation or not
     *
     * @param   string  $annotationName
     * @return  bool
     */
    public function hasAnnotation($annotationName)
    {
        return stubAnnotationFactory::has($this->getDocComment(), $annotationName, stubAnnotation::TARGET_PROPERTY, $this->className . '::' . $this->propertyName, $this->getDeclaringClass()->getFileName());
    }

    /**
     * return the specified annotation
     *
     * @param   string          $annotationName
     * @return  stubAnnotation
     * @throws  ReflectionException
     */
    public function getAnnotation($annotationName)
    {
        return stubAnnotationFactory::create($this->getDocComment(), $annotationName, stubAnnotation::TARGET_PROPERTY, $this->className . '::' . $this->propertyName, $this->getDeclaringClass()->getFileName());
    }

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if ($compare instanceof self) {
            return ($compare->className == $this->className && $compare->propertyName == $this->propertyName);
        }
        
        return false;
    }

    /**
     * returns a string representation of the class
     * 
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * 'net::stubbles::reflection::stubReflectionProperty['[name-of-reflected-class]'::'[name-of-reflected-property]']  {}'
     * <code>
     * net::stubbles::reflection::stubReflectionProperty[MyClass::myProperty] {
     * }
     * </code>
     *
     * @return  string
     */
    public function __toString()
    {
        return 'net::stubbles::reflection::stubReflectionProperty[' . $this->className . '::' . $this->propertyName . "] {\n}\n";
    }

    /**
     * returns the class that declares this parameter
     *
     * @return  stubBaseReflectionClass
     */
    public function getDeclaringClass()
    {
        $refClass = parent::getDeclaringClass();
        if ($refClass->getName() === $this->className) {
            if (null === $this->refClass) {
                $this->refClass = new stubReflectionClass($this->className);
            }
            
            return $this->refClass;
        }
        
        $stubRefClass = new stubReflectionClass($refClass->getName());
        return $stubRefClass;
    }
}
?><?php
/**
 * Common base interface for methods and functions.
 * 
 * @package     stubbles
 * @subpackage  reflection
 * @version     $Id: stubReflectionRoutine.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotatable');
/**
 * Common base interface for methods and functions.
 * 
 * @package     stubbles
 * @subpackage  reflection
 */
interface stubReflectionRoutine extends stubAnnotatable
{
    /**
     * returns name of the routine
     *
     * @return  string
     */
    public function getName();

    /**
     * checks whether routine was declared by PHP or not
     *
     * @return  bool
     */
    public function isInternal();

    /**
     * checks whether routine was declared by user or not
     *
     * @return  bool
     */
    public function isUserDefined();

    /**
     * returns name of file where routine was declared
     *
     * @return  string
     */
    public function getFileName();

    /**
     * returns line where routine declaration starts
     *
     * @return  int
     */
    public function getStartLine();

    /**
     * returns line where routine declaration ends
     *
     * @return  int
     */
    public function getEndLine();

    /**
     * returns doc comment for routine
     *
     * @return  string
     */
    public function getDocComment();

    /**
     * returns a list of static variables declared in the routine
     *
     * @return  array
     */
    public function getStaticVariables();

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare);

    /**
     * returns a string representation of the class
     * 
     * The result is a short but informative representation about the class and
     * its values. Per default, this method returns:
     * 'net::stubbles::reflection::stubReflectionMethod['[name-of-reflected-class]'::'[name-of-reflected-method]'()]  {}'
     * <code>
     * net::stubbles::reflection::stubReflectionMethod[MyClass::myMethod()] {
     * }
     * </code>
     *
     * @return  string
     */
    public function __toString();

    /**
     * returns a list of all parameters
     *
     * @return  array<stubReflectionParameter>
     */
    public function getParameters();

    /**
     * returns the number of parameters of the routine
     *
     * @return  int
     */
    public function getNumberOfParameters();

    /**
     * returns the number of parameters of the routine
     *
     * @return  int
     */
    public function getNumberOfRequiredParameters();

    /**
     * checks whether return value is returned by reference or not
     *
     * @return  bool
     */
    public function returnsReference();

    /**
     * returns information about the return type of a method
     * 
     * If the return type is a class the return value is an instance of
     * stubReflectionClass (if the class is unknown a
     * stubClassNotFoundException will be thrown), if it is a scalar type the
     * return value is an instance of stubReflectionPrimitive, and if the
     * method does not have a return value this method returns null.
     * Please be aware that this is guessing from the doc block with which the
     * method is documented. If the doc block is missing or incorrect the return
     * value of this method may be wrong. This is due to missing type hints for
     * return values in PHP itself.
     *
     * @return  stubReflectionType
     */
    public function getReturnType();
}
?><?php
/**
 * Basic interface for type references.
 *
 * @package     stubbles
 * @subpackage  reflection
 * @version     $Id: stubReflectionType.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Basic interface for type references.
 *
 * @package     stubbles
 * @subpackage  reflection
 */
interface stubReflectionType
{
    /**
     * returns the name of the type
     *
     * @return  string
     */
    public function getName();

    /**
     * checks whether the type is an object
     *
     * @return  bool
     */
    public function isObject();

    /**
     * checks whether the type is a primitive
     *
     * @return  bool
     */
    public function isPrimitive();

    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare);

    /**
     * returns a string representation of the class
     *
     * @return  string
     */
    public function __toString();
}
?><?php
/**
 * Annotation to mark a method as a service method
 *
 * @package     stubbles
 * @subpackage  service_annotations
 * @version     $Id: stubWebMethodAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation'
);
/**
 * Annotation to mark a method as a service method
 *
 * Use this annotation, if you do not want a property to be serialized.
 *
 * @package     stubbles
 * @subpackage  service_annotations
 */
class stubWebMethodAnnotation extends stubAbstractAnnotation implements stubAnnotation
{
    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_METHOD;
    }
}
?><?php
/**
 * Sends the given data to the FirePHP Firefox Extension (v0.1.2).
 *
 * @package     stubbles
 * @subpackage  service_debug
 * @version     $Id: stubFirebugLogger.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::response::stubBaseResponse');
/**
 * Sends the given data to the FirePHP Firefox Extension (v0.1.2).
 * The data can be displayed in the Firebug Console or in the
 * "Server" request tab (in Firebug: "Network > GET Request > Server tab").
 *
 * For more informtion see: http://www.firephp.org/
 *
 * This is not the original implementation of FirePHP Core but an
 * adapted implementation to our needs of FirePHP Core (v0.1.2).
 *
 * TRACE and TABLE aren't implemented yet.
 *
 * @package     stubbles
 * @subpackage  service_debug
 * @link        http://www.firephp.org/Wiki/Reference/Protocol
 */
class stubFirebugLogger
{
    /**
     * The FirePHP headers which have to be set.
     *
     * @var  array<string,string>
     */
    protected $headers;
    /**
     * The response which contains the headers.
     *
     * @var  stubResponse
     */
    protected $response;
    /**
     * Counter for unique HeaderIds.
     * 
     * Initialise with 2 because of header frame.
     *
     * @var  int
     */
    protected static $msgCount = 2;
    /**
     * Log level constant.
     */
    const LOG        = 'LOG';
    /**
     * Info level constant.
     */
    const INFO       = 'INFO';
    /**
     * Warn level constant.
     */
    const WARN       = 'WARN';
    /**
     * Error level constant.
     */
    const ERROR      = 'ERROR';
    /**
     * Dump constant.
     */
    const DUMP       = 'DUMP';
    /**
     * Exception constant.
     */
    const EXCEPTION  = 'EXCEPTION';
    /**
     * Amount of header fields without leading '2' (DUMP messages) or '3' (LOG messages).
     */
    const PAD_SLOTS = 11;

    /**
     * constructor
     *
     * @param  stubResponse  $response
     */
    public function __construct(stubResponse $response = null)
    {
        // header frame
        $this->headers['100000000001'] = '{';
        $this->headers['999999999999'] = '"__SKIP__":"__SKIP__"}';

        $this->response = ($response !== null) ? $response : new stubBaseResponse();
    }

    /**
     * Send headers finally.
     *
     * @param  array<string,string>  $headers
     */
    protected function sendHeaders($headers)
    {
        foreach ($headers as $numIndex => $jsonSnippet) {
            // skip normal headers
            if(strlen($numIndex) !== 12) {
                continue;
            }

            $this->response->addHeader('X-FirePHP-Data-'.$numIndex, $jsonSnippet);
        }
        $this->response->send();
    }

    /**
     * Processes logging messages.
     *
     * @param  mixed   $obj
     * @param  string  $level
     * @param  string  $label
     */
    protected function logWithLevel($obj, $level, $label = '')
    {
        $jsonString = $this->encodeToJson($obj);

        switch($level) {
            case self::DUMP:
                $numIndex = $this->indexCalculator('2');
                $this->headers[$numIndex] = '"'.$label.'":'.$jsonString.',';
                break;

            default:
                $numIndex = $this->indexCalculator('3');
                $level = (gettype($obj) === 'object' && $obj instanceof Exception) ? self::EXCEPTION : $level;
                $this->headers[$numIndex]  = '["'.$level.'",';
                $this->headers[$numIndex] .= ($label === '') ? $jsonString.'],' : '["'.$label.'",'.$jsonString.']],';
                break;
        }

        $this->setHeadersFor($level);
        $this->sendHeaders($this->headers);
    }

    /**
     * Encodes objects and adheres to the FirePHP protocol.
     *
     * @param   mixed   $obj
     * @return  string  json string
     */
    protected function encodeToJson($obj)
    {
        if(gettype($obj) === 'object') {
            if ($obj instanceof Exception) {
                $temp['Class']   = get_class($obj);
                $temp['Message'] = $obj->getMessage();
                $temp['File']    = str_replace('\\\\', '\\', $obj->getFile());
                $temp['Line']    = $obj->getLine();
                $temp['Type']    = 'throw';
                $temp['Trace']   = 'not implemented';
                $jsonString = json_encode($temp);
            } else {                                                 // get rid of leading '{'
                $jsonString = '{"__className":"'.get_class($obj).'",'.substr(json_encode($obj), 1);
            }
        } else {
            $jsonString = json_encode($obj);
        }
        return $jsonString;
    }

    /**
     * Sets the header frames for LOG or DUMP messages.
     *
     * @param  string  $dumpOrLog
     */
    protected function setHeadersFor($dumpOrLog)
    {
        switch($dumpOrLog) {
            case self::DUMP:
                $this->headers['200000000001'] = '"FirePHP.Dump":{';
                $this->headers['299999999999'] = '"__SKIP__":"__SKIP__"},';
                break;

            case self::LOG:
            case self::INFO:
            case self::WARN:
            case self::ERROR:
            case self::EXCEPTION:
            default:
                $this->headers['300000000001'] = '"FirePHP.Firebug.Console":[';
                $this->headers['399999999999'] = '["__SKIP__"]],';
                break;
        }
    }

    /**
     * Calculates the index number for a header message.
     * Provide the prefixed number (2 or 3).
     *
     * @param   string  $prefixedNumber
     * @return  string  e.g. '200000000003'
     */
    protected function indexCalculator($prefixedNumber)
    {
        $padding  = self::PAD_SLOTS - strlen(self::$msgCount);
        $numIndex = $prefixedNumber . str_pad('', $padding, '0') . self::$msgCount;
        self::$msgCount++;
        return $numIndex;
    }

    /**
     * Log a messagage with the 'log' level.
     *
     * @param  mixed   $obj
     * @param  string  $label
     */
    public function log($obj, $label = '')
    {
        $this->logWithLevel($obj, self::LOG, $label);
    }

    /**
     * Log a messagage with the 'info' level.
     *
     * @param  mixed   $obj
     * @param  string  $label
     */
    public function info($obj, $label = '')
    {
        $this->logWithLevel($obj, self::INFO, $label);
    }

    /**
     * Log a messagage with the 'warn' level.
     *
     * @param  mixed   $obj
     * @param  string  $label
     */
    public function warn($obj, $label = '')
    {
        $this->logWithLevel($obj, self::WARN, $label);
    }

    /**
     * Log a messagage with the 'error' level.
     *
     * @param  mixed   $obj
     * @param  string  $label
     */
    public function error($obj, $label = '')
    {
        $this->logWithLevel($obj, self::ERROR, $label);
    }

    /**
     * Log a messagage with the 'dump' level.
     *
     * @param  mixed   $obj
     * @param  string  $label
     */
    public function dump($obj, $label = 'unknown')
    {
        $this->logWithLevel($obj, self::DUMP, $label);
    }

    /**
     * Sets the processorURL for the FirePHP Firefox Extension.
     *
     * "The purpose of the Processor is to take the data and manipulate
     *  it after each request is complete. [...] The default Processor
     *  inserts log data into the Firebug Console."
     *
     * @param  string  $URL
     * @link   http://www.firephp.org/Wiki/Reference/CustomizeDisplay
     */
    public function setProcessorUrl($URL)
    {
        $this->headers['X-FirePHP-ProcessorURL'] = $URL;
    }

    /**
     * Sets the rendererURL for the FirePHP Firefox Extension.
     *
     * "The purpose of the Renderer is to generate the HTML to be inserted into
     *  the "Server" tab of requests in the Firebug Console and Net tabs.
     *  The Default Renderer that ships with FirePHP takes the debug data
     *  and generates a variable tree similar to the print_r() function in PHP.
     *
     * @param  string  $URL
     */
    public function setRendererUrl($URL)
    {
        $this->headers['X-FirePHP-RendererURL'] = $URL;
    }

    /**
     * Gets the headers for FirePHP as array or as json.
     *
     * @param   bool  $asJSON
     * @return  array<string,string>|string
     */
    public function getHeaders($asJSON = false)
    {
        ksort($this->headers);
        $headers = ($asJSON === true) ? join($this->headers) : $this->headers;
        return $headers;
    }
}
?><?php
/**
 * JSON-RPC processor (generic proxy for web services).
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc
 * @version     $Id: stubJsonRpcProcessor.php 2851 2011-01-05 13:18:02Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjector',
                      'net::stubbles::lang::stubProperties',
                      'net::stubbles::websites::processors::stubAbstractProcessor'
);
/**
 * JSON-RPC processor (generic proxy for web services).
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc
 * @link        http://json-rpc.org/wiki/specification
 */
class stubJsonRpcProcessor extends stubAbstractProcessor
{
    /**
     * injector
     *
     * @var  stubInjector $injector
     */
    protected $injector;
    /**
     * configuration with list of client classes
     *
     * @var  stubProperties
     */
    protected $config;

    /**
     * constructor
     *
     * @param   stubRequest   $request     current request
     * @param   stubSession   $session     current session
     * @param   stubResponse  $response    current response
     * @param   stubInjector  $injector    injector instance
     * @param   string        $configPath  path to config file
     * @throws  stubFileNotFoundException
     * @Inject
     * @Named{configPath}('net.stubbles.config.path')
     */
    public function __construct(stubRequest $request, stubSession $session, stubResponse $response, stubInjector $injector, $configPath)
    {
        $this->config   = stubProperties::fromFile($configPath . DIRECTORY_SEPARATOR . 'json-rpc-service.ini');
        $this->injector = $injector;
        parent::__construct($request, $session, $response);
    }

    /**
     * returns the name of the current route
     *
     * @return  string
     */
    public function getRouteName()
    {
        return null;
    }

    /**
     * processes the request
     *
     * This method only dispatches the request to different subprocessors.
     *
     * @return  stubProcessor
     */
    public function process()
    {
        $fqClassName = $this->getSubProcessorClassName();
        $nqClassName = stubClassLoader::getNonQualifiedClassName($fqClassName);
        if (class_exists($nqClassName, false) === false) {
            stubClassLoader::load($fqClassName);
        }

        $subProcessor = new $nqClassName();
        $this->response->addHeader('Content-Type', $this->config->parseString('config', 'content-type', 'application/json'));
        $subProcessor->process($this->request, $this->session, $this->response, $this->injector, $this->config);
        return $this;
    }

    /**
     * returns the subprocessor class to be used
     *
     * @return  string
     */
    protected function getSubProcessorClassName()
    {
        if ($this->request->getMethod() === 'post') {
            return 'net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcPostSubProcessor';
        } elseif ($this->request->hasParam('__generateProxy') === true) {
            return 'net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcGenerateProxiesSubProcessor';
        } elseif ($this->request->hasParam('__smd') === true) {
            return 'net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcGenerateSmdSubProcessor';
        }

        return 'net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcGetSubProcessor';
    }
}
?><?php
/**
 * Utility class for creates json data.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc
 * @version     $Id: stubJsonRpcWriter.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::php::string::stubRecursiveStringEncoder',
                      'net::stubbles::php::string::stubUTF8Encoder'
);
/**
 * Utility class for creates json data.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc
 * @link        http://json-rpc.org/wiki/specification
 * @static
 */
class stubJsonRpcWriter extends stubBaseObject
{
    /**
     * encoder instancer
     *
     * @var  stubStringEncoder
     */
    protected static $encoder;

    /**
     * static initializing
     */
    // @codeCoverageIgnoreStart
    public static function __static()
    {
        self::$encoder = new stubRecursiveStringEncoder(new stubUTF8Encoder());
    }
    // @codeCoverageIgnoreEnd

    /**
     * send a json fault
     *
     * @param   string  $reqId    request id
     * @param   string  $message  fault message
     * @return  string
     */
    public static function writeFault($reqId, $message)
    {
        $fault = array('id'     => $reqId,
                       'result' => null,
                       'error'  => self::$encoder->encode($message)
                 );
        return json_encode($fault);
    }

    /**
     * send a json response
     *
     * @param   string  $reqId    request id
     * @param   string  $result
     * @return  string
     */
    public static function writeResponse($reqId, $result)
    {
        $response = array('id'     => $reqId,
                          'result' => self::$encoder->encode($result),
                          'error'  => null
                    );
        return json_encode($response);
    }
}
?><?php
/**
 * Basic JSON-RPC sub processor with helper methods for dynamic proxy generation.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_subprocessors
 * @version     $Id: stubJsonRpcAbstractGenerateSubProcessor.php 2632 2010-08-13 18:31:42Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjector',
                      'net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcSubProcessor'
);
/**
 * Basic JSON-RPC sub processor with helper methods for dynamic proxy generation.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_subprocessors
 */
abstract class stubJsonRpcAbstractGenerateSubProcessor extends stubBaseObject implements stubJsonRpcSubProcessor
{
    /**
     * default javascript namespace
     *
     * @var  string
     */
    protected $jsNamespace = 'stubbles.json.proxy';

    /**
     * helper method to detect the service url
     *
     * @param   stubRequest  $request
     * @return  string
     */
    protected function getServiceUrl(stubRequest $request)
    {
        $tmp        = parse_url($request->getURI());
        $serviceUrl = '//' . $tmp['path'];
        if ($request->hasParam('processor') === true) {
            $serviceUrl .= '?processor=' . $request->readParam('processor')->unsecure();
        }
        
        return $serviceUrl;
    }

    /**
     * helper method to handle an exception
     *
     * @param  stubInjector  $injector
     * @param  Exception     $exception
     * @param  stubResponse  $response
     * @param  string        $introduction
     */
    protected function handleException(stubInjector $injector, Exception $exception, stubResponse $response, $introduction)
    {
        if ($injector->hasExplicitBinding('stubMode') === false || $injector->getInstance('stubMode')->name() === 'PROD') {
            return;
        }
        
        stubClassLoader::load('net::stubbles::service::jsonrpc::util::stubFirebugEncoder');
        $firebugEncoder = new stubFirebugEncoder();
        $response->write($firebugEncoder->encode($introduction));
        $response->write($firebugEncoder->encode($exception->__toString()));
    }
}
?><?php
/**
 * JSON-RPC sub processor with basic invocation helper methods.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_subprocessors
 * @version     $Id: stubJsonRpcAbstractInvokingSubProcessor.php 2643 2010-08-17 11:59:37Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::reflection',
                      'net::stubbles::service::annotations::stubWebMethodAnnotation',
                      'net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcSubProcessor'
);
/**
 * JSON-RPC sub processor with basic invocation helper methods.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_subprocessors
 */
abstract class stubJsonRpcAbstractInvokingSubProcessor extends stubBaseObject implements stubJsonRpcSubProcessor
{
    /**
     * Regexp to validate method param
     */
    const CLASS_AND_METHOD_PATTERN = '/^[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+$/';

    /**
     * creates the method to call
     *
     * @param   array   $classMap
     * @param   string  $methodName
     * @param   string  $className   optional  if used with dojo's SMD
     * @return  array
     * @throws  stubException
     */
    protected function getClassAndMethod(array $classMap, $methodName, $className = null)
    {
        if (null === $className) {
            if (!preg_match(self::CLASS_AND_METHOD_PATTERN, $methodName)) {
                throw new stubException('Invalid request: method-Pattern has to be <className>.<methodName> '
                                       .'or service property has to be set.');
            }

            list($className, $methodName) = explode('.', $methodName);
        }

        if (isset($classMap[$className]) === false) {
            throw new stubException('Unknown class ' . $className . '.');
        }

        $clazz = new stubReflectionClass($classMap[$className]);
        if ($clazz->hasMethod($methodName) === false) {
            throw new stubException('Unknown method ' . $className . '.' . $methodName . '.');
        }

        $method = $clazz->getMethod($methodName);
        if ($method->hasAnnotation('WebMethod') === false) {
            throw new stubException('Method ' . $className . '.' . $methodName . ' is not a WebMethod.');
        }

        return array('class' => $clazz, 'method' => $method);
    }

    /**
     * invoke the requested method
     *
     * @param   stubInjector          $injector
     * @param   stubReflectionClass   $class
     * @param   stubReflectionMethod  $method
     * @param   array                 $params
     * @return  mixed
     * @throws  stubException
     */
    protected function invokeServiceMethod(stubInjector $injector, stubReflectionClass $class, stubReflectionMethod $method, array $params)
    {
        if ($method->getNumberOfRequiredParameters() > count($params)) {
            throw new stubException('Invalid amount of parameters passed.');
        }

        return $method->invokeArgs($injector->getInstance($class->getName()), $params);
    }
}
?><?php
/**
 * JSON-RPC sub processor that handles dynamic proxy generation.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_subprocessors
 * @version     $Id: stubJsonRpcGenerateProxiesSubProcessor.php 2626 2010-08-12 17:05:15Z mikey $
 */
stubClassLoader::load('net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcAbstractGenerateSubProcessor',
                      'net::stubbles::service::jsonrpc::util::stubJsonRpcProxyGenerator'
);
/**
 * JSON-RPC sub processor that handles dynamic proxy generation.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_subprocessors
 */
class stubJsonRpcGenerateProxiesSubProcessor extends stubJsonRpcAbstractGenerateSubProcessor
{
    /**
     * does the processing of the subtask
     *
     * @param  stubRequest     $request   current request
     * @param  stubSession     $session   current session
     * @param  stubResponse    $response  current response
     * @param  stubInjector    $injector  injector instance
     * @param  stubProperties  $config    json-rpc config
     */
    public function process(stubRequest $request, stubSession $session, stubResponse $response, stubInjector $injector, stubProperties $config)
    {
        $namespace = $config->getValue('config', 'namespace', $this->jsNamespace);
        $classes   = $request->readParam('__generateProxy')->ifSatisfiesRegex('/^[A-Za-z,0-9_\.]+$/');
        if ('__all' !== $classes) {
            $classes = explode(',', $classes);
        }
            
        $response->write($namespace . " = {};\n\n");
        $generator = $this->getProxyGenerator();
        foreach ($config->getSection('classmap') as $jsClass => $fqClassName) {
            if (is_array($classes) === false || in_array($jsClass, $classes) === true) {
                try {
                    $response->write($generator->generateJavascriptProxy($fqClassName, $jsClass, $namespace));
                } catch (Exception $e) {
                    $this->handleException($injector, $e, $response, 'Generation of proxy for ' . $fqClassName . ' failed.');
                }
            }
        }
    }

    /**
     * helper method to create the proxy generator
     *
     * @return  stubJsonRpcProxyGenerator
     */
    // @codeCoverageIgnoreStart
    protected function getProxyGenerator()
    {
        return new stubJsonRpcProxyGenerator();
    }
    // @codeCoverageIgnoreEnd
}
?><?php
/**
 * JSON-RPC sub processor that handles dynamic smd generation.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_subprocessors
 * @version     $Id: stubJsonRpcGenerateSmdSubProcessor.php 2626 2010-08-12 17:05:15Z mikey $
 */
stubClassLoader::load('net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcAbstractGenerateSubProcessor',
                      'net::stubbles::service::jsonrpc::util::stubSmdGenerator'
);
/**
 * JSON-RPC sub processor that handles dynamic smd generation.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_subprocessors
 */
class stubJsonRpcGenerateSmdSubProcessor extends stubJsonRpcAbstractGenerateSubProcessor
{
    /**
     * does the processing of the subtask
     *
     * @param  stubRequest     $request   current request
     * @param  stubSession     $session   current session
     * @param  stubResponse    $response  current response
     * @param  stubInjector    $injector  injector instance
     * @param  stubProperties  $config    json-rpc config
     */
    public function process(stubRequest $request, stubSession $session, stubResponse $response, stubInjector $injector, stubProperties $config)
    {
        $namespace = $config->getValue('config', 'namespace', $this->jsNamespace);
        $class     = $request->readParam('__smd')->ifSatisfiesRegex('/^[A-Za-z0-9_\.]+$/');
        $generator = $this->getSmdGenerator($this->getServiceUrl($request) . '&__class=' . $class);
        // get rid of namespace for class matching
        $class     = preg_replace('/' . preg_quote($namespace) . '\./', '', $class);
        try {
            $response->write($generator->generateSmd($config->getValue('classmap', $class), $class));
        } catch (Exception $e) {
            $this->handleException($injector, $e, $response, 'Generation of SMD for ' . $config->getValue('classmap', $class) . ' failed.');
        }
    }

    /**
     * creates the smd generator
     *
     * @param   string            $serviceUrl
     * @return  stubSmdGenerator
     */
    // @codeCoverageIgnoreStart
    protected function getSmdGenerator($serviceUrl)
    {
        return new stubSmdGenerator($serviceUrl);
    }
    // @codeCoverageIgnoreEnd
}
?><?php
/**
 * JSON-RPC sub processor that handles get requests.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_subprocessors
 * @version     $Id: stubJsonRpcGetSubProcessor.php 2626 2010-08-12 17:05:15Z mikey $
 */
stubClassLoader::load('net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcAbstractInvokingSubProcessor',
                      'net::stubbles::service::jsonrpc::stubJsonRpcWriter'
);
/**
 * JSON-RPC sub processor that handles get requests.
 *
 * This is mainly used for debugging purposes.
 *
 * http://localhost/stubbles/docroot/json.php?
 * <paramName>=2
 * [&<paramName>=3]*
 * &method=<classname>.<methodname>
 * &id=186252
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_subprocessors
 */
class stubJsonRpcGetSubProcessor extends stubJsonRpcAbstractInvokingSubProcessor
{
    /**
     * Regexp to validate param param
     */
    const PARAM_PATTERN = '/^[a-zA-Z0-9_]+$/';
    /**
     * Regexp to validate id param
     */
    const ID_PATTERN    = '/^\d{6,7}$/';

    /**
     * does the processing of the subtask
     *
     * @param  stubRequest     $request   current request
     * @param  stubSession     $session   current session
     * @param  stubResponse    $response  current response
     * @param  stubInjector    $injector  injector instance
     * @param  stubProperties  $config    json-rpc config
     */
    public function process(stubRequest $request, stubSession $session, stubResponse $response, stubInjector $injector, stubProperties $config)
    {
        $requestId = $request->readParam('id')->ifSatisfiesRegex(self::ID_PATTERN);
        if (null === $requestId) {
            $response->write(stubJsonRpcWriter::writeFault($requestId, 'Invalid request: No id given.'));
            return;
        }
        
        $method = $request->readParam('method')->unsecure();
        if (null === $method) {
            $response->write(stubJsonRpcWriter::writeFault($requestId, 'Invalid request: No method given.'));
            return;
        }
        
        try {
            $reflect   = $this->getClassAndMethod($config->getSection('classmap'), $method);
            $params    = $this->retrieveGETParams($request, $reflect['method']);
            $result    = $this->invokeServiceMethod($injector, $reflect['class'], $reflect['method'], $params);
            $response->write(stubJsonRpcWriter::writeResponse($requestId, $result));
        } catch (Exception $e) {
            $response->write(stubJsonRpcWriter::writeFault($requestId, $e->getMessage()));
        }
    }

    /**
     * Get the parameters from the GET request
     *
     * @param   stubRequest           $request
     * @param   stubReflectionMethod  $method
     * @return  array
     * @throws  stubException
     */
    protected function retrieveGETParams(stubRequest $request, stubReflectionMethod $method)
    {
        $paramValues  = array();
        foreach ($method->getParameters() as $param) {
            $paramName  = $param->getName();
            $paramValue = $request->readParam($paramName)->ifSatisfiesRegex(self::PARAM_PATTERN);
            if (null === $paramValue) {
                throw new stubException('Param '. $paramName . ' is missing.');
            }

            array_push($paramValues, $paramValue);
        }

        return $paramValues;
    }
}
?><?php
/**
 * JSON-RPC sub processor that handles post requests.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_subprocessors
 * @version     $Id: stubJsonRpcPostSubProcessor.php 2636 2010-08-13 19:23:30Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::types::stubDate',
                      'net::stubbles::service::jsonrpc::stubJsonRpcWriter',
                      'net::stubbles::service::jsonrpc::subprocessors::stubJsonRpcAbstractInvokingSubProcessor'
);
/**
 * JSON-RPC sub processor that handles post requests.
 *
 * Supports also (JSON-RPC) Notifictaions. Sends an JSON-RPC response in every case,
 * i.e. also when the request was no valid JSON-RPC request.
 *
 * The qooxdoo Server Implementation has some limitations as the specification is concerned:
 *  - Only client requests via XMLHttpRequest (MIME-Type: 'application/json') are supported
 *    and as consequence there is no MIME-Type checking (necessary).
 *  - Currently is no error object implemented. Errors are just simple strings.
 *    This could change in the future.
 *  - The order of the properties in a JSON-RPC response is not standard compliant, but this should be no problem.
 *  - The test methods which the spec suggests are availible but not activated in the json-rpc config.
 *    They reside in org::stubbles::examples::service::QooxdooSpecTestService.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_subprocessors
 * @link        http://qooxdoo.org/documentation/0.8/rpc                                                         Client API / Basic Infos
 * @link        http://qooxdoo.org/documentation/0.8/rpc_server_writer_guide                                     Server (Impl.) Specification
 * @link        http://qooxdoo-contrib.svn.sourceforge.net/viewvc/qooxdoo-contrib/trunk/qooxdoo-contrib/RpcPhp/  PHP4 Implementation (RI)
 */
class stubJsonRpcPostSubProcessor extends stubJsonRpcAbstractInvokingSubProcessor
{
    /**
     * Constant for decode mode.
     */
    const MODE_DECODE = 1;
    /**
     * Constant for encode mode.
     */
    const MODE_ENCODE = 2;

    /**
     * does the processing of the subtask
     *
     * @param  stubRequest     $request   current request
     * @param  stubSession     $session   current session
     * @param  stubResponse    $response  current response
     * @param  stubInjector    $injector  injector instance
     * @param  stubProperties  $config    json-rpc config
     */
    public function process(stubRequest $request, stubSession $session, stubResponse $response, stubInjector $injector, stubProperties $config)
    {
        $phpJsonObj = null;

        try {
            $phpJsonObj = $request->readBody()->asJson();
        } catch (stubIllegalArgumentException $e) {
            $response->write(stubJsonRpcWriter::writeFault(null, $e->getMessage()));
            return;
        }

        // check json-rpc structure
        if ($this->isValidJsonRpcRequest($phpJsonObj) === false) {
            $errorMessage = "Invalid JSON-RPC request. "
                          . "Should have this form: {['service':...,]'method':...,'params':...,'id':...} "
                          . "(with double instead of single quotation marks)";
            $id = (property_exists($phpJsonObj, 'id') === true) ? $phpJsonObj->id : null;
            $response->write(stubJsonRpcWriter::writeFault($id, $errorMessage));
            return;
        }

        // dateString2stubDate conversion
        $this->walkForDateAndProcess($phpJsonObj->params, self::MODE_DECODE);

        $className = null;

        // discover class name
        if ($request->hasParam('__class') === true) {
            $className = $request->readParam('__class')->unsecure();
        } elseif (property_exists($phpJsonObj, 'service') === true) {
            $className = $phpJsonObj->service;
        }

        try {
            // invoke web method
            $reflect = $this->getClassAndMethod($config->getSection('classmap'), $phpJsonObj->method, $className);
            $result  = $this->invokeServiceMethod($injector, $reflect['class'], $reflect['method'], $phpJsonObj->params);
        } catch (Exception $e) {
            $response->write(stubJsonRpcWriter::writeFault($phpJsonObj->id, $e->getMessage()));
            return;
        }

        // just a json-rpc notification?
        if ($phpJsonObj->id === null) {
            return;
        }

        // stubDate2dateString conversion
        $this->walkForDateAndProcess($result, self::MODE_ENCODE);

        // send result back
        $response->write(stubJsonRpcWriter::writeResponse($phpJsonObj->id, $result));
    }

    /**
     * Checks if the decoded JSON string is a valid JSON-RPC request.
     *
     * @param   string  $phpJsonObj
     * @return  bool
     */
    public function isValidJsonRpcRequest($phpJsonObj)
    {
        if (null === $phpJsonObj) {
            return false;
        }

        if (property_exists($phpJsonObj, 'method') === false) {
            return false;
        }

        if (property_exists($phpJsonObj, 'params') === false) {
            return false;
        }

        if (property_exists($phpJsonObj, 'id') === false) {
            return false;
        }

        return true;
    }

    /**
     * Looks (at every level, i.e.  recursive) for date strings in the given array|object
     * and (en|de)codes them using a stubDate object or a dateString format.
     *
     * The first parameter has to be called by reference cause
     * arrays won't get change without although they are called by reference.
     *
     * The reference Operator in the foreach is needed because:
     * "Unless the array is referenced, foreach operates on a copy
     *  of the specified array and not the array itself."
     *
     * @param   array<mixed>|mixed  &$arrayOrObjectOrScalar  (stdClass when called recursivly (decoding) and mixed when scalar (encoding))
     * @param   string              $mode
     * @return  array<mixed>
     * @see     http://de.php.net/foreach
     */
    public function walkForDateAndProcess(&$arrayOrObjectOrScalar, $mode)
    {
        // nothing to do
        if (is_scalar($arrayOrObjectOrScalar) === true || null === $arrayOrObjectOrScalar) {
            return;
        }

        // stubDate obj
        if ($arrayOrObjectOrScalar instanceof stubDate) {
            $arrayOrObjectOrScalar = $this->encodeDate($arrayOrObjectOrScalar);
            return;
        }

        // nested?
        foreach ($arrayOrObjectOrScalar as $key => &$param) {
            if (is_scalar($param) === false
              && ($param instanceof stubDate) === false) {
                return $this->walkForDateAndProcess($param, $mode);
            }

            $validModes = array(self::MODE_DECODE, self::MODE_ENCODE);
            if (in_array($mode, $validModes) === true) {
                $encOrDecVal = ($mode === self::MODE_DECODE)
                                        ? $this->decodeDate($param)
                                        : $this->encodeDate($param);
            }

            // set value
            if (is_object($arrayOrObjectOrScalar) === true) {
                $arrayOrObjectOrScalar->$key = $encOrDecVal;
            } elseif (is_array($arrayOrObjectOrScalar) === true) {
                $param = $encOrDecVal;
            }
        }
    }

    /**
     * Decodes a datestring (datestring2StubDate).
     *
     * Note: Milliseconds currently get cut off.
     *
     * @param   string          $value
     * @return  stubDate|mixed  (given value without adaptions)
     */
    public function decodeDate($value)
    {
        $success = sscanf($value,
                          'new Date(Date.UTC(%d,%d,%d,%d,%d,%d,%d))',
                           $year, $month, $day, $hour, $minute, $sec, $millisec
        );
        if (7 === $success) {
            $dateTime = $year .'-' . $month . '-' . $day . ' ' . $hour . ':' . $minute . ':' . $sec;
            return new stubDate($dateTime, null);
        }

        return $value;
    }

    /**
     * Encodes stubDate objects using a date string (stubDate2datestring).
     *
     * JSON defines no date format, so we use the date format the qooxdoo team
     * defined. Qooxdoo dates are represented by a string which looks like this:
     * "new Date(Date.UTC(2006,5,20,22,18,42,223))"
     *
     * TODO: Test if a date in a request is also without a daylight saving time
     * addition and cutting off is also valid in a response.
     *
     * @param   mixed         $value
     * @return  string|mixed  (given value without adaptions)
     */
    public function encodeDate($value)
    {
        if ($value instanceof stubDate) {
            // there is no character for min and sec without leading zeros
            $dateTime = str_replace(',0', ',', $value->format('Y,n,j,G,i,s'));
            return 'new Date(Date.UTC(' . $dateTime . ',000))';
         }

         return $value;
    }
}
?><?php
/**
 * Interface for JSON-RPC sub processors.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_subprocessors
 * @version     $Id: stubJsonRpcSubProcessor.php 2222 2009-06-09 21:55:06Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjector',
                      'net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::response::stubResponse',
                      'net::stubbles::ipo::session::stubSession',
                      'net::stubbles::lang::stubProperties'
);
/**
 * Interface for JSON-RPC sub processors.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_subprocessors
 */
interface stubJsonRpcSubProcessor extends stubObject
{
    /**
     * does the processing of the subtask
     *
     * @param  stubRequest     $request   current request
     * @param  stubSession     $session   current session
     * @param  stubResponse    $response  current response
     * @param  stubInjector    $injector  injector instance
     * @param  stubProperties  $config    json-rpc config
     */
    public function process(stubRequest $request, stubSession $session, stubResponse $response, stubInjector $injector, stubProperties $config);
}
?><?php
/**
 * Encoder for firebug console messages.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_util
 * @version     $Id: stubFirebugEncoder.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubMethodNotSupportedException',
                      'net::stubbles::php::string::stubAbstractStringEncoder'
);
/**
 * Encoder for firebug console messages.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_util
 */
class stubFirebugEncoder extends stubAbstractStringEncoder
{
    /**
     * the debug level
     *
     * @var  string
     */
    protected $level = 'error';

    /**
     * sets the debug level
     *
     * @param  string  $level
     */
    public function setLevel($level)
    {
        $this->level = $level;
    }

    /**
     * returns the debug level
     *
     * @return  string
     */
    public function getLevel()
    {
        return $this->level;
    }

    /**
     * encodes a string
     *
     * @param   string  $string
     * @return  string
     */
    public function encode($string)
    {
        $result = '';
        $lines  = explode("\n", $string);
        foreach ($lines as $line) {
            $result .= "console.{$this->level}('" . addslashes($line) . "');\n";
        }

        return $result;
    }

    /**
     * decodes a string
     *
     * @param   string  $string
     * @return  string
     * @throws  stubMethodNotSupportedException
     */
    public function decode($string)
    {
        throw new stubMethodNotSupportedException('Decoding a firebug-encoded string is not supported.');
    }

    /**
     * checks whether an encoding is reversible or not
     *
     * @return  bool
     */
    public function isReversible()
    {
        return false;
    }
}
?><?php
/**
 * Class to generate JSON-RPC proxies
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_util
 * @version     $Id: stubJsonRpcProxyGenerator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::service::annotations::stubWebMethodAnnotation',
                      'net::stubbles::reflection::reflection'
);
/**
 * Class to generate JSON-RPC proxies
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_util
 */
class stubJsonRpcProxyGenerator extends stubBaseObject
{
    /**
     * generate JS proxy for a specified class
     *
     * @param   string  $className    name of the class to generate the proxy from
     * @param   string  $jsClass      optional  name of the generated javascript proxy
     * @param   string  $jsNamespace  optional  custom javascript namespace
     * @return  string
     * @throws  stubClassNotFoundException
     */
    public function generateJavascriptProxy($className, $jsClass = null, $jsNamespace = 'stubbles.json.proxy')
    {
        $clazz = new stubReflectionClass($className);
        if (null === $jsClass) {
            $jsClass = $clazz->getName();
        }

        $jsCode  = "{$jsNamespace}.{$jsClass} = function(clientObj) {\n";
        $jsCode .= "    this.dispatcher = new stubbles.json.rpc.Client(clientObj);\n";
        $jsCode .= "};\n";

        foreach ($clazz->getMethods() as $method) {
            if ($method->hasAnnotation('WebMethod') === true) {
                $methodName = $method->getName();
                $jsCode    .= "{$jsNamespace}.{$jsClass}.prototype.{$methodName} = function() {\n";
                $jsCode    .= "    return this.dispatcher.doCall('{$jsClass}.{$methodName}', arguments);\n";
                $jsCode    .= "};\n";
            }
        }
        
        return $jsCode;
    }
}
?><?php
/**
 * Class to generate service method descriptions for JSON-RPC proxies.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_util
 * @version     $Id: stubSmdGenerator.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::service::annotations::stubWebMethodAnnotation',
                      'net::stubbles::reflection::reflection'
);
/**
 * Class to generate service method descriptions for JSON-RPC proxies.
 *
 * @package     stubbles
 * @subpackage  service_jsonrpc_util
 */
class stubSmdGenerator extends stubBaseObject
{
    /**
     * URL of the service
     *
     * @var  string
     */
    protected $serviceUrl;

    /**
     * create a new generator
     *
     * @param  string  $serviceUrl
     */
    public function __construct($serviceUrl)
    {
        $this->serviceUrl = $serviceUrl;
    }

    /**
     * generate JS proxy for a specified class
     *
     * @param   string  $className  name of the class to generate the proxy from
     * @param   string  $jsClass    optional  name of the generated javascript proxy
     * @return  string
     */
    public function generateSmd($className, $jsClass = null)
    {
        $smdData = new stdClass();
        $smdData->SMDVersion  = 1;
        $smdData->serviceType = 'JSON-RPC';
        $smdData->serviceURL  = $this->serviceUrl;
        $smdData->methods     = array();
        if (null !== $jsClass) {
            $smdData->objectName = $jsClass;
        }

        $clazz = new stubReflectionClass($className);
        foreach ($clazz->getMethods() as $method) {
            if ($method->hasAnnotation('WebMethod') === true) {
                $methodDef             = new stdClass();
                $methodDef->name       = $method->getName();
                $methodDef->parameters = array();
                $smdData->methods[]    = $methodDef;
                foreach ($method->getParameters() as $parameter) {
                    $paramDef = new stdClass();
                    $paramDef->name = $parameter->getName();
                    $methodDef->parameters[] = $paramDef;
                }
            }
        }
        
        return json_encode($smdData);
    }
}
?><?php
/**
 * Annotation for setting up ReST methods.
 *
 * @package     stubbles
 * @subpackage  service_rest_annotation
 * @version     $Id: stubRestMethodAnnotation.php 2462 2010-01-18 15:32:49Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::reflection::stubBaseReflectionClass',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation'
);
/**
 * Annotation for setting up ReST methods.
 *
 * @package     stubbles
 * @subpackage  service_rest_annotation
 * @since       1.1.0
 */
class stubRestMethodAnnotation extends stubAbstractAnnotation
{
    /**
     * request method
     *
     * @var  string
     */
    protected $requestMethod;
    /**
     * special path to apply method to
     *
     * @var  string
     */
    protected $path;
    /**
     * separator which splits path parts into arguments
     *
     * @var  string
     */
    protected $pathSeparator  = '/';
    /**
     * class to be used for formatting output
     *
     * @var  stubBaseReflectionClass
     */
    protected $formatterClass;
    /**
     * class to be used for formatting error message output
     *
     * @var  stubBaseReflectionClass
     */
    protected $errorFormatterClass;

    /**
     * sets request method
     *
     * @param  string  $requestMethod
     */
    public function setRequestMethod($requestMethod)
    {
        $this->requestMethod = $requestMethod;
    }

    /**
     * returns request method
     *
     * @return  string
     */
    public function getRequestMethod()
    {
        return $this->requestMethod;
    }

    /**
     * set path to apply method to
     *
     * @param  string  $path
     */
    public function setPath($path)
    {
        $this->path = $path;
    }

    /**
     * checks whether a path to apply method to is set
     *
     * @return  bool
     */
    public function hasPath()
    {
        return (null != $this->path);
    }

    /**
     * returns path to apply method to
     *
     * @return  string
     */
    public function getPath()
    {
        return $this->path;
    }

    /**
     * sets separator which splits path parts into arguments
     *
     * @param  string  $pathSeparator
     */
    public function setPathSeparator($pathSeparator)
    {
        $this->pathSeparator = $pathSeparator;
    }

    /**
     * returns separator which splits path parts into arguments
     *
     * @return  string
     */
    public function getPathSeparator()
    {
        return $this->pathSeparator;
    }

    /**
     * sets the formatter class to be used for the result
     *
     * @param   stubBaseReflectionClass  $formatterClass
     * @throws  stubIllegalArgumentException
     */
    public function setFormatter(stubBaseReflectionClass $formatterClass)
    {
        if ($formatterClass->implementsInterface('stubFormatter') === false) {
            throw new stubIllegalArgumentException('Formatter class ' . $formatterClass->getFullQualifiedClassName() . ' is not an instance of net::stubbles::rest::format::stubFormatter');
        }

        $this->formatterClass = $formatterClass;
    }

    /**
     * returns name of formatter class to be used for the result
     *
     * @return  string
     */
    public function getFormatterClassName()
    {
        if (null === $this->formatterClass) {
            return null;
        }

        return $this->formatterClass->getFullQualifiedClassName();
    }

    /**
     * sets the formatter class to be used for the result
     *
     * @param   stubBaseReflectionClass  $errorFormatterClass
     * @throws  stubIllegalArgumentException
     */
    public function setErrorFormatter(stubBaseReflectionClass $errorFormatterClass)
    {
        if ($errorFormatterClass->implementsInterface('stubErrorFormatter') === false) {
            throw new stubIllegalArgumentException('Error formatter class ' . $errorFormatterClass->getFullQualifiedClassName() . ' is not an instance of net::stubbles::rest::format::stubErrorFormatter');
        }

        $this->errorFormatterClass = $errorFormatterClass;
    }

    /**
     * returns name of error formatter class to be used for error messages
     *
     * @return  string
     */
    public function getErrorFormatterClassName()
    {
        if (null === $this->errorFormatterClass) {
            return null;
        }

        return $this->errorFormatterClass->getFullQualifiedClassName();
    }

    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_METHOD;
    }
}
?><?php
/**
 * Interface for error formatter which writes error messages.
 *
 * @package     stubbles
 * @subpackage  service_rest_format
 * @version     $Id: stubErrorFormatter.php 2399 2009-12-01 13:14:07Z mikey $
 */
stubClassLoader::load('net::stubbles::service::rest::format::stubFormatContentType');
/**
 * Interface for error formatter which writes error messages.
 *
 * @package     stubbles
 * @subpackage  service_rest_format
 * @since       1.1.0
 */
interface stubErrorFormatter extends stubFormatContentType
{
    /**
     * write error message about 404 Not Found error
     *
     * @return  string
     */
    public function formatNotFoundError();

    /**
     * write error message about 405 Method Not Allowed error
     *
     * @param   string         $requestMethod   original request method
     * @param   array<string>  $allowedMethods  list of allowed methods
     * @return  string
     */
    public function formatMethodNotAllowedError($requestMethod, array $allowedMethods);

    /**
     * write error message about 500 Internal Server error
     *
     * @param   Exception  $e
     * @return  string
     */
    public function formatInternalServerError(Exception $e);
}
?><?php
/**
 * Common base interface for formatters.
 *
 * @package     stubbles
 * @subpackage  service_rest_format
 * @version     $Id: stubFormatContentType.php 2399 2009-12-01 13:14:07Z mikey $
 */
/**
 * Common base interface for formatters.
 *
 * @package     stubbles
 * @subpackage  service_rest_format
 * @since       1.1.0
 */
interface stubFormatContentType extends stubObject
{
    /**
     * returns content type of formatted result
     *
     * @return  string
     */
    public function getContentType();
}
?><?php
/**
 * Interface for ReST result formatters.
 *
 * @package     stubbles
 * @subpackage  service_rest_format
 * @version     $Id: stubFormatter.php 2399 2009-12-01 13:14:07Z mikey $
 */
stubClassLoader::load('net::stubbles::service::rest::format::stubFormatContentType');
/**
 * Interface for ReST result formatters.
 *
 * @package     stubbles
 * @subpackage  service_rest_format
 * @since       1.1.0
 */
interface stubFormatter extends stubFormatContentType
{
    /**
     * formats result for response
     *
     * @param   mixed   $result
     * @return  string
     */
    public function format($result);
}
?><?php
/**
 * ReST result formatters for JSON.
 *
 * @package     stubbles
 * @subpackage  service_rest_format
 * @version     $Id: stubJsonFormatter.php 2399 2009-12-01 13:14:07Z mikey $
 */
stubClassLoader::load('net::stubbles::service::rest::format::stubErrorFormatter',
                      'net::stubbles::service::rest::format::stubFormatter'
);
/**
 * ReST result formatters for JSON.
 *
 * @package     stubbles
 * @subpackage  service_rest_format
 * @since       1.1.0
 */
class stubJsonFormatter extends stubBaseObject implements stubFormatter, stubErrorFormatter
{
    /**
     * returns content type of formatted result
     *
     * @return  string
     */
    public function getContentType()
    {
        return 'application/json';
    }

    /**
     * formats result for response
     *
     * @param   mixed   $result
     * @return  string
     */
    public function format($result)
    {
        return json_encode($result);
    }

    /**
     * write error message about 404 Not Found error
     *
     * @return  string
     */
    public function formatNotFoundError()
    {
        return json_encode(array('error' => 'Given resource could not be found.'));
    }

    /**
     * write error message about 405 Method Not Allowed error
     *
     * @param   string         $requestMethod   original request method
     * @param   array<string>  $allowedMethods  list of allowed methods
     * @return  string
     */
    public function formatMethodNotAllowedError($requestMethod, array $allowedMethods)
    {
        return json_encode(array('error' => 'The given request method ' . strtoupper($requestMethod) . ' is not valid. Please use ' . join(', ', $allowedMethods) . '.'));
    }

    /**
     * write error message about 500 Internal Server error
     *
     * @param   Exception  $e
     * @return  string
     */
    public function formatInternalServerError(Exception $e)
    {
        return json_encode(array('error' => 'Internal Server Error: ' . $e->getMessage()));
    }
}
?><?php
/**
 * ReST result formatters for plain text.
 *
 * @package     stubbles
 * @subpackage  service_rest_format
 * @version     $Id: stubPlainTextFormatter.php 2568 2010-05-26 11:04:25Z mikey $
 */
stubClassLoader::load('net::stubbles::service::rest::format::stubErrorFormatter',
                      'net::stubbles::service::rest::format::stubFormatter'
);
/**
 * ReST result formatters for JSON.
 *
 * @package     stubbles
 * @subpackage  service_rest_format
 * @since       1.1.2
 */
class stubPlainTextFormatter extends stubBaseObject implements stubFormatter, stubErrorFormatter
{
    /**
     * returns content type of formatted result
     *
     * @return  string
     */
    public function getContentType()
    {
        return 'text/plain';
    }

    /**
     * formats result for response
     *
     * @param   mixed   $result
     * @return  string
     */
    public function format($result)
    {
        if (is_object($result) === true && method_exists($result, '__toString') === true) {
            return (string) $result;
        } elseif (is_object($result) === true || is_array($result) === true) {
            return var_export($result, true);
        } elseif (is_bool($result) === true && true === $result) {
            return 'true';
        } elseif (is_bool($result) === true && false === $result) {
            return 'false';
        }

        return (string) $result;
    }

    /**
     * write error message about 404 Not Found error
     *
     * @return  string
     */
    public function formatNotFoundError()
    {
        return 'Given resource could not be found.';
    }

    /**
     * write error message about 405 Method Not Allowed error
     *
     * @param   string         $requestMethod   original request method
     * @param   array<string>  $allowedMethods  list of allowed methods
     * @return  string
     */
    public function formatMethodNotAllowedError($requestMethod, array $allowedMethods)
    {
        return 'The given request method ' . strtoupper($requestMethod) . ' is not valid. Please use ' . join(', ', $allowedMethods) . '.';
    }

    /**
     * write error message about 500 Internal Server error
     *
     * @param   Exception  $e
     * @return  string
     */
    public function formatInternalServerError(Exception $e)
    {
        return 'Internal Server Error: ' . $e->getMessage();
    }
}
?><?php
/**
 * ReST result formatters which returns empty content.
 *
 * @package     stubbles
 * @subpackage  service_rest_format
 * @version     $Id: stubVoidFormatter.php 2436 2010-01-05 16:38:36Z mikey $
 */
stubClassLoader::load('net::stubbles::service::rest::format::stubErrorFormatter',
                      'net::stubbles::service::rest::format::stubFormatter'
);
/**
 * ReST result formatters which returns empty content.
 *
 * @package     stubbles
 * @subpackage  service_rest_format
 * @since       1.1.0
 */
class stubVoidFormatter extends stubBaseObject implements stubFormatter, stubErrorFormatter
{
    /**
     * returns content type of formatted result
     *
     * @return  string
     */
    public function getContentType()
    {
        return 'text/plain';
    }

    /**
     * formats result for response
     *
     * @param   mixed   $result
     * @return  string
     */
    public function format($result)
    {
        return '';
    }

    /**
     * write error message about 404 Not Found error
     *
     * @return  string
     */
    public function formatNotFoundError()
    {
        return '';
    }

    /**
     * write error message about 405 Method Not Allowed error
     *
     * @param   string         $requestMethod   original request method
     * @param   array<string>  $allowedMethods  list of allowed methods
     * @return  string
     */
    public function formatMethodNotAllowedError($requestMethod, array $allowedMethods)
    {
        return '';
    }

    /**
     * write error message about 500 Internal Server error
     *
     * @param   Exception  $e
     * @return  string
     */
    public function formatInternalServerError(Exception $e)
    {
        return '';
    }
}
?><?php
/**
 * ReST result formatters for XML.
 *
 * @package     stubbles
 * @subpackage  service_rest_format
 * @version     $Id: stubXmlFormatter.php 2436 2010-01-05 16:38:36Z mikey $
 */
stubClassLoader::load('net::stubbles::service::rest::format::stubErrorFormatter',
                      'net::stubbles::service::rest::format::stubFormatter',
                      'net::stubbles::xml::serializer::stubXmlSerializerFacade'
);
/**
 * ReST result formatters for XML.
 *
 * The XML formatter uses the XML serializer provided by Stubbles. This allows
 * to customize XML serialization of result objects with annotations from the
 * XML serializer package.
 *
 * @package     stubbles
 * @subpackage  service_rest_format
 * @since       1.1.0
 */
class stubXmlFormatter extends stubBaseObject implements stubFormatter, stubErrorFormatter
{
    /**
     * serializer to be used
     *
     * @var  stubXmlSerializerFacade
     */
    protected $xmlSerializerFacade;

    /**
     * constructor
     *
     * @param  stubXmlSerializerFacade  $xmlSerializerFacade
     * @Inject
     */
    public function __construct(stubXmlSerializerFacade $xmlSerializerFacade)
    {
        $this->xmlSerializerFacade = $xmlSerializerFacade;
    }

    /**
     * returns content type of formatted result
     *
     * @return  string
     */
    public function getContentType()
    {
        return 'text/xml';
    }

    /**
     * formats result for response
     *
     * @param   mixed   $result
     * @return  string
     */
    public function format($result)
    {
        return $this->xmlSerializerFacade->serializeToXml($result);
    }

    /**
     * write error message about 404 Not Found error
     *
     * @return  string
     */
    public function formatNotFoundError()
    {
        return $this->xmlSerializerFacade->serializeToXml(array('error' => 'Given resource could not be found.'));
    }

    /**
     * write error message about 405 Method Not Allowed error
     *
     * @param   string         $requestMethod   original request method
     * @param   array<string>  $allowedMethods  list of allowed methods
     * @return  string
     */
    public function formatMethodNotAllowedError($requestMethod, array $allowedMethods)
    {
        return $this->xmlSerializerFacade->serializeToXml(array('error' => 'The given request method ' . strtoupper($requestMethod) . ' is not valid. Please use ' . join(', ', $allowedMethods) . '.'));
    }

    /**
     * write error message about 500 Internal Server error
     *
     * @param   Exception  $e
     * @return  string
     */
    public function formatInternalServerError(Exception $e)
    {
        return $this->xmlSerializerFacade->serializeToXml(array('error' => 'Internal Server Error: ' . $e->getMessage()));
    }
}
?><?php
/**
 * Exception to be thrown if something goes wrong while handling a ReST request.
 *
 * @package     stubbles
 * @subpackage  service_rest
 * @version     $Id: stubRestHandlerException.php 2403 2009-12-04 15:16:53Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubChainedException');
/**
 * Exception to be thrown if something goes wrong while handling a ReST request.
 *
 * @package     stubbles
 * @subpackage  service_rest
 */
class stubRestHandlerException extends stubChainedException
{
    /**
     * status code
     *
     * @var  int
     */
    protected $statusCode;
    /**
     * status message
     *
     * @var  string
     */
    protected $statusMessage;

    /**
     * constructor
     *
     * @param  int               $statusCode     status code
     * @param  string            $statusMessage  status message
     * @param  string|Exception  $cause          exception that caused this exception or a message
     */
    public function __construct($statusCode, $statusMessage, $cause)
    {
        $this->statusCode    = $statusCode;
        $this->statusMessage = $statusMessage;
        if ($cause instanceof Exception) {
            parent::__construct($cause->getMessage(), $cause);
        } else {
            parent::__construct($cause);
        }
    }

    /**
     * returns status code
     *
     * @return  int
     */
    public function getStatusCode()
    {
        return $this->statusCode;
    }

    /**
     * returns status message
     *
     * @return  string
     */
    public function getStatusMessage()
    {
        return $this->statusMessage;
    }
}
?><?php
/**
 * Method matcher to match only public methods annotated with @RestMethod.
 *
 * @package     stubbles
 * @subpackage  service_rest
 * @version     $Id: stubRestMethodsMatcher.php 2436 2010-01-05 16:38:36Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::matcher::stubMethodMatcher',
                      'net::stubbles::service::rest::annotation::stubRestMethodAnnotation'
);
/**
 * Method matcher to match only public methods annotated with @RestMethod.
 *
 * @package     stubbles
 * @subpackage  service_rest
 * @since       1.1.0
 */
class stubRestMethodsMatcher extends stubBaseObject implements stubMethodMatcher
{
    /**
     * checks whether the matcher is satisfied with the given method
     *
     * @param   ReflectionMethod  $method
     * @return  bool
     */
    public function matchesMethod(ReflectionMethod $method)
    {
        return $method->isPublic();
    }

    /**
     * checks whether the matcher is satisfied with the given method
     *
     * @param   stubReflectionMethod  $method
     * @return  bool
     */
    public function matchesAnnotatableMethod(stubReflectionMethod $method)
    {
        return $method->hasAnnotation('RestMethod');
    }
}
?><?php
/**
 * Processor for ReST interfaces.
 *
 * @package     stubbles
 * @subpackage  service_rest
 * @version     $Id: stubRestProcessor.php 2899 2011-01-12 02:06:32Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjector',
                      'net::stubbles::ipo::request::broker::annotations::stubBoolFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubDateFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubFloatFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubHTTPURLFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubIntegerFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubMailFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubPasswordFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubPreselectFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubStringFilterAnnotation',
                      'net::stubbles::ipo::request::broker::annotations::stubTextFilterAnnotation',
                      'net::stubbles::lang::stubProperties',
                      'net::stubbles::peer::http::stubAcceptHeader',
                      'net::stubbles::service::rest::stubRestHandlerException',
                      'net::stubbles::service::rest::stubRestMethodsMatcher',
                      'net::stubbles::service::rest::format::stubErrorFormatter',
                      'net::stubbles::service::rest::format::stubVoidFormatter',
                      'net::stubbles::websites::processors::stubAbstractProcessor',
                      'net::stubbles::websites::processors::stubProcessorException'
);
/**
 * Processor for ReST interfaces.
 *
 * @package     stubbles
 * @subpackage  service_rest
 * @since       1.1.0
 */
class stubRestProcessor extends stubAbstractProcessor
{
    /**
     * injector
     *
     * @var  stubInjector
     */
    protected $injector;
    /**
     * rest configuration
     *
     * @var  stubProperties
     */
    protected $restProperties;
    /**
     * name of rest handler to be executed
     *
     * @var  string
     */
    protected $routeName;
    /**
     * rest handler instance
     *
     * @var  stubObject
     */
    protected $restHandler;

    /**
     * constructor
     *
     * @param   stubRequest   $request     current request
     * @param   stubSession   $session     current session
     * @param   stubResponse  $response    current response
     * @param   stubInjector  $injector    injector instance
     * @param   string        $configPath  path to config files
     * @throws  stubProcessorException
     * @Inject
     * @Named{configPath}('net.stubbles.config.path')
     */
    public function __construct(stubRequest $request, stubSession $session, stubResponse $response, stubInjector $injector, $configPath)
    {
        $this->request        = $request;
        $this->response       = $response;
        $this->injector       = $injector;
        $this->restProperties = stubProperties::fromFile($configPath . '/rest.ini');
        $this->routeName      = $this->request->readParam('handler')
                                              ->ifIsOneOf($this->restProperties->getSectionKeys('handler'));
        if (null === $this->routeName) {
            $this->request->cancel();
            $formatter = $this->getFormatter('errorFormatter');
            $this->response->write($formatter->formatNotFoundError());
            throw new stubProcessorException(404, 'Not Found');
        }

        $session->putValue('net.stubbles.websites.lastPage', $this->request->getMethod() . ':' . $this->routeName);
    }

    /**
     * returns the name of the current route
     *
     * @return  string
     */
    public function getRouteName()
    {
        return $this->routeName;
    }

    /**
     * operations to be done before the request is processed
     *
     * @return  stubProcessor
     */
    public function startup()
    {
        $this->restHandler = $this->injector->getInstance($this->restProperties->getValue('handler', $this->routeName));
        return $this;
    }

    /**
     * processes the request
     *
     * @return  stubProcessor
     */
    public function process()
    {
        $dispatch = $this->request->readParam('dispatch')->unsecure();
        $method   = $this->findMethod($dispatch);
        if (null === $method) {
            $this->response->setStatusCode(405);
            $allowedMethods = $this->listMethods();
            $this->response->addHeader('Allow', join(',', $allowedMethods));
            $formatter = $this->getFormatter('errorFormatter');
            $this->response->write($formatter->formatMethodNotAllowedError($this->request->getMethod(), $allowedMethods));
            return $this;
        }

        try {
            $formatter = $this->getFormatter('formatter', $method);
            $result    = $method->invokeArgs($this->restHandler,
                                             $this->extractArguments($dispatch, $method)
                         );
            $result    = $formatter->format($result);
        } catch (stubRestHandlerException $rhe) {
            $this->response->setStatusCode($rhe->getStatusCode());
            $formatter = $this->getFormatter('errorFormatter', $method);
            $result    = $formatter->formatInternalServerError($rhe);
        } catch (Exception $e) {
            $this->response->setStatusCode(500);
            $formatter = $this->getFormatter('errorFormatter', $method);
            $result    = $formatter->formatInternalServerError($e);
        }

        $this->response->write($result);
        return $this;
    }

    /**
     * finds method to be called
     *
     * Returns null if no suitable method could be found. For comparison
     * purposes the request method strings are transformed to lower case to
     * circumvent problems because of different notations.
     * If a handler has more than one method to respond to a request method the
     * method to be executed will be selected as follows:
     * 1. Method with best path match, where best path match means the first
     *    method where its path matches the beginning of $dispatch.
     * 2. Method which has no special path defined
     *
     * @param   string                $dispatch
     * @return  stubReflectionMethod
     */
    protected function findMethod($dispatch)
    {
        $dispatchCount = strlen($dispatch);
        $requestMethod = strtolower($this->request->getMethod());
        $foundedMethod = null;
        foreach ($this->restHandler->getClass()->getMethodsByMatcher(new stubRestMethodsMatcher()) as $method) {
            /* @var  $method  stubReflectionMethod */
            $restMethodAnnotation = $method->getAnnotation('RestMethod');
            /* @var  $restMethodAnnotation  stubRestMethodAnnotation */
            if (strtolower($restMethodAnnotation->getRequestMethod()) !== $requestMethod) {
                continue;
            }

            if (0 === $dispatchCount || $restMethodAnnotation->hasPath() === false) {
                $foundedMethod = $method;
            } else {
                $path = $restMethodAnnotation->getPath();
                if (substr($dispatch, 0, strlen($path)) === $path) {
                    return $method;
                }
            }
        }

        return $foundedMethod;
    }

    /**
     * extracts arguments from dispatch data
     *
     * All parts in $dispatch which are not in the method request path will be
     * extracted as arguments.
     *
     * @param   string                $dispatch
     * @param   stubReflectionMethod  $method
     * @return  array<string>
     * @throws  stubRestHandlerException
     */
    protected function extractArguments($dispatch, stubReflectionMethod $method)
    {
        if (strlen($dispatch) === 0) {
            if ($method->getNumberOfRequiredParameters() > 0) {
                throw new stubRestHandlerException(400, 'Bad Request', 'A required parameter is missing.');
            }

            return array();
        }

        $restMethodAnnotation = $method->getAnnotation('RestMethod');
        $pathSeparator        = $restMethodAnnotation->getPathSeparator();
        $args = str_replace($restMethodAnnotation->getPath(), '', $dispatch);
        if (substr($args, 0, 1) === $pathSeparator) {
            $args = explode($pathSeparator, substr($args, 1));
        } else {
            $args = explode($pathSeparator, $args);
        }

        if ($method->getNumberOfRequiredParameters() > count($args)) {
            throw new stubRestHandlerException(400, 'Bad Request', 'A required parameter is missing.');
        }

        return $this->filterArguments($args, $method);
    }

    /**
     * filters arguments using filter annotations on method parameters
     *
     * @param   array<string>         $arguments
     * @param   stubReflectionMethod  $method
     * @return  array<mixed>
     * @since   1.3.0
     */
    protected function filterArguments(array $arguments, stubReflectionMethod $method)
    {
        $parameters   = $method->getParameters();
        $filteredArgs = array();
        foreach ($arguments as $position => $argument) {
            if (isset($parameters[$position]) === false) {
                return $filteredArgs; // more arguments than method parameters, return only required ones
            }

            if ($parameters[$position]->hasAnnotation('Filter') === false) {
                $filteredArgs[] = $argument;
            } else {
                try {
                    $filteredArgs[] = $parameters[$position]->getAnnotation('Filter')
                                                            ->getFilter()
                                                            ->execute($argument);
                } catch (stubFilterException $fe) {
                    throw new stubRestHandlerException(400,
                                                       'Bad Request',
                                                       'Error on argument ' . $parameters[$position]->getName() . ': ' . $fe->getMessage()
                    );
                }
            }
        }

        return $filteredArgs;
    }

    /**
     * creates a list of all methods available on current rest handler
     *
     * @return  array<string>
     */
    protected function listMethods()
    {
        $methods = array();
        foreach ($this->restHandler->getClass()->getMethodsByMatcher(new stubRestMethodsMatcher()) as $method) {
            /* @var  $method  stubReflectionMethod */
            $methods[] = strtoupper($method->getAnnotation('RestMethod')
                                           ->getRequestMethod()
            );
        }
        
        return array_values(array_unique($methods));
    }

    /**
     * creates formatter based on different sources
     *
     * Formatter is selected based on the following order:
     * 1. Formatter class defined within the RestMethod annotation of the method
     *    to call.
     * 2. First match of Accept header.
     * 3. First configured formatter from rest.ini.
     *
     * @param   string                $type    'formatter' or 'errorFormatter'
     * @param   stubReflectionMethod  $method  optional  called method
     * @return  stubFormatter
     */
    protected function getFormatter($type, stubReflectionMethod $method = null)
    {
        $formatterClass  = null;
        $wishedFormatter = null;
        if (null !== $method) {
            if ('formatter' === $type) {
                $formatterClass  = $method->getAnnotation('RestMethod')->getFormatterClassName();
            } else {
                $formatterClass  = $method->getAnnotation('RestMethod')->getErrorFormatterClassName();
            }
        }

        if (null !== $formatterClass) {
            $wishedFormatter = $this->injector->getInstance($formatterClass);
        }

        return $this->getFormatterInComplianceWithAcceptHeader($type, $wishedFormatter);
    }

    /**
     * tries to return formatter in accordance with accept header
     *
     * @param   string                            $type             'formatter' or 'errorFormatter'
     * @param   stubFormatContentType             $wishedFormatter  optional
     * @return  stubFormatter|stubErrorFormatter
     */
    protected function getFormatterInComplianceWithAcceptHeader($type, stubFormatContentType $wishedFormatter = null)
    {
        $acceptedMimeTypes = $this->getAcceptedMimeTypes();
        // return given formatter if it is acceptable for given list of accepted mime
        if (null !== $wishedFormatter && ($acceptedMimeTypes->priorityFor($wishedFormatter->getContentType()) > 0 || ($wishedFormatter instanceof stubVoidFormatter))) {
            return $this->setContentTypeHeader($wishedFormatter);
        }

        // if no mime type restrictions are given use first configured formatter
        if (count($acceptedMimeTypes) === 0) {
            return $this->setContentTypeHeader($this->injector->getInstance(array_shift($this->restProperties->getSection($type))));
        }

        if ($acceptedMimeTypes->hasSharedAcceptables($this->restProperties->getSectionKeys($type)) === false) {
            if ($this->restProperties->hasValue($type, '*/*') === false) {
                // no match found, force 406 Not Acceptable
                $supportedMimeTypes = join(',', $this->restProperties->getSectionKeys($type));
                if (null !== $wishedFormatter) {
                    $supportedMimeTypes .= ',' . $wishedFormatter->getContentType();
                }

                $this->response->setStatusCode(406);
                if ('void' !== $supportedMimeTypes) {
                    $this->response->addHeader('X-Acceptable', str_replace('void,', '', $supportedMimeTypes));
                }
            }
            
            return new stubVoidFormatter();
        }

        return $this->setContentTypeHeader($this->injector->getInstance($this->restProperties->getValue($type,
                                                                                                        $acceptedMimeTypes->findMatchWithGreatestPriority($this->restProperties->getSectionKeys($type))
                                                                                               )
                                                            )
               );
    }

    /**
     * helper method to set the content type header
     *
     * @param   stubFormatContentType             $formatter
     * @return  stubFormatter|stubErrorFormatter
     */
    protected function setContentTypeHeader(stubFormatContentType $formatter)
    {
        if (($formatter instanceof stubVoidFormatter) === false) {
            $this->response->addHeader('Content-type', $formatter->getContentType());
        }

        return $formatter;
    }

    /**
     * returns list of by user agent accepted mime types
     *
     * @return  stubAcceptHeader
     */
    protected function getAcceptedMimeTypes()
    {
        if ($this->request->hasHeader('HTTP_ACCEPT') === true) {
            try {
                return stubAcceptHeader::parse($this->request->readHeader('HTTP_ACCEPT')->unsecure());
            } catch (stubIllegalArgumentException $iae) {
                // do nothing, treat this as if no Accept header was set
            }
        }

        return new stubAcceptHeader();
    }
}
?><?php
/**
 * Binding module for SOAP clients.
 *
 * @package     stubbles
 * @subpackage  service_soap_ioc
 * @version     $Id: stubSoapBindingModule.php 2882 2011-01-11 20:54:26Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::module::stubBindingModule');
/**
 * Binding module for SOAP clients.
 *
 * @package     stubbles
 * @subpackage  service_soap_ioc
 */
class stubSoapBindingModule extends stubBaseObject implements stubBindingModule
{
    /**
     * list of available drivers
     *
     * @var  array<string,string|ReflectionClass>
     */
    protected $clients = array();

    /**
     * static constructor
     *
     * @param   array<string,string|ReflectionClass>  $clients
     * @return  stubSoapBindingModule
     */
    public static function create(array $clients)
    {
        $self = new self();
        $self->clients = $clients;
        return $self;
    }

    /**
     * configure the binder
     *
     * @param  stubBinder  $binder
     */
    public function configure(stubBinder $binder)
    {
        if (count($this->clients) === 0) {
            // initialize lazy only of required
            $binder->bind('stubSoapClientGenerator')
                   ->to('net::stubbles::service::soap::stubSoapClientGenerator')
                   ->asSingleton();
        } else {
            stubClassLoader::load('net::stubbles::service::soap::stubSoapClientGenerator');
            $soapClientGenerator = new stubSoapClientGenerator();
            $soapClientGenerator->setAvailableClients($this->clients);
            $binder->bind('stubSoapClientGenerator')
                   ->toInstance($soapClientGenerator);
        }
        
    }
}
?><?php
/**
 * Implementation of a SOAP client using PHP's native SOAPClient class.
 *
 * @package     stubbles
 * @subpackage  service_soap_native
 * @version     $Id: stubNativeSoapClient.php 2437 2010-01-05 22:22:26Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::lang::exceptions::stubRuntimeException',
                      'net::stubbles::service::soap::stubAbstractSoapClient',
                      'net::stubbles::service::soap::stubSoapFault'
);
/**
 * Implementation of a SOAP client using PHP's native SOAPClient class.
 *
 * @package     stubbles
 * @subpackage  service_soap_native
 * @see         http://php.net/soap
 */
class stubNativeSoapClient extends stubAbstractSoapClient
{
    /**
     * constructor
     *
     * @param   stubSoapClientConfiguration  $config
     * @throws  stubRuntimeException
     * @throws  stubIllegalArgumentException
     */
    public function __construct(stubSoapClientConfiguration $config)
    {
        if (extension_loaded('soap') === false) {
            throw new stubRuntimeException('net::stubbles::service::soap::native::stubNativeSoapClient requires PHP extension soap.');
        }
        
        $version = $config->getVersion();
        if (null !== $version && SOAP_1_1 !== $version && SOAP_1_2 !== $version) {
            throw new stubIllegalArgumentException('Configuration error: version must be one of SOAP_1_1 or SOAP_1_2.');
        }
        
        $requestStyle = $config->getRequestStyle();
        if (null === $requestStyle) {
            $config->setRequestStyle(SOAP_RPC);
        } elseif (SOAP_RPC !== $requestStyle && SOAP_DOCUMENT !== $requestStyle) {
            throw new stubIllegalArgumentException('Configuration error: request style must be one of SOAP_RPC or SOAP_DOCUMENT.');
        }
        
        $usage = $config->getUsage();
        if (null === $usage) {
            $config->setUsage(SOAP_ENCODED);
        } elseif (SOAP_ENCODED !== $usage && SOAP_LITERAL !== $usage) {
            throw new stubIllegalArgumentException('Configuration error: usage must be one of SOAP_ENCODED or SOAP_LITERAL.');
        }
        
        parent::__construct($config);
    }

    /**
     * checks whether the client supports WSDL or not
     *
     * @return  bool
     */
    public function supportsWsdl()
    {
        return true;
    }

    /**
     * returns a list of functions provided by the soap service
     *
     * @return  array<string>
     */
    public function getFunctions()
    {
        return $this->createClient()->__getFunctions();
    }

    /**
     * returns a list of types the soap service uses for interaction
     *
     * @return  array<string>
     */
    public function getTypes()
    {
        return $this->createClient()->__getTypes();
    }

    /**
     * invoke method call
     *
     * Options for the invocation handling include:
     *  - asParameters: if set to true the parameters will be passed as array under the given key
     *  - parseFromStdClass: if set this will be used as name of the stdClass property to parse result from
     *
     * @param   string  $method   name of method to invoke
     * @param   array   $args     optional  list of arguments for method
     * @param   array   $options  optional  options for the invocation handling
     * @return  mixed
     * @throws  stubSoapException
     */
    public function invoke($method, array $args = array(), array $options = array())
    {
        $client = $this->createClient();
        if (isset($options['asParameters']) === false) {
            $args = array_values($args);
        } else {
            $args = array($options['asParameters'] => $args);
        }
        
        $result          = $client->__soapCall($method, $args);
        $this->debugData = array('endPoint'           => $this->config->getEndPoint()->get(true),
                                 'usedWsdl'           => $this->config->usesWsdl(),
                                 'lastMethod'         => $method,
                                 'lastArgs'           => $args,
                                 'lastRequestHeader'  => $client->__getLastRequestHeaders(),
                                 'lastRequest'        => $client->__getLastRequest(),
                                 'lastResponseHeader' => $client->__getLastResponseHeaders(),
                                 'lastResponse'       => $client->__getLastResponse()
                           );
        if (is_soap_fault($result) === false) {
            if (isset($options['parseFromStdClass']) === true) {
                $propertyName = $options['parseFromStdClass'];
                if ($result instanceof stdClass && isset($result->$propertyName) === true) {
                    return $result->$propertyName;
                }
            }
            
            return $result;
        }
        
        throw new stubSoapException(new stubSoapFault($result->faultcode,
                                                      $result->faultstring,
                                                      (isset($result->faultactor) === false) ? (null) : ($result->faultactor),
                                                      (isset($result->detail) === false) ? (null) : ($result->detail)
                                        )
                  );
    }

    /**
     * helper method to create the client
     *
     * @return  SoapClient
     */
    protected function createClient()
    {
        $options = array('exceptions'         => false,
                         'trace'              => true,
                         'encoding'           => $this->config->getDataEncoding(),
                         'connection_timeout' => $this->timeout
                   );
        if (null !== $this->config->getVersion()) {
            $options['version'] = $this->config->getVersion();
        }
        
        if ($this->config->hasClassMapping() === true) {
            $options['classmap'] = $this->config->getClassMapping();
        }
        
        $endPoint = $this->config->getEndPoint();
        $user     = $endPoint->getUser();
        if (null !== $user) {
            $options['login'] = $user;
        }
        
        $password = $endPoint->getPassword();
        if (null !== $password) {
            $options['password'] = $password;
        }
        
        if (true === $this->config->usesWsdl()) {
            if ($this->config->hasLocation() === true) {
                $options['location'] = $this->config->getLocation()->get(true);
            }
            
            $client = $this->createClientInstance($endPoint->get(true), $options);
        } else {
            $options['location'] = $endPoint->get(true);
            $options['uri']      = $this->config->getUri();
            $options['style']    = $this->config->getRequestStyle();
            $options['use']      = $this->config->getUsage();
            $client              = $this->createClientInstance(null, $options);
        }
        
        return $client;
    }

    /**
     * creates the client
     *
     * @param   string               $url
     * @param   array<string,mixed>  $options
     * @return  SoapClient
     */
    // @codeCoverageIgnoreStart
    protected function createClientInstance($url, $options)
    {
        return new SoapClient($url, $options);
    }
    // @codeCoverageIgnoreEnd
}
?><?php
/**
 * Basic implementation for SOAP clients.
 *
 * @package     stubbles
 * @subpackage  service_soap
 * @version     $Id: stubAbstractSoapClient.php 2437 2010-01-05 22:22:26Z mikey $
 */
stubClassLoader::load('net::stubbles::service::soap::stubSoapClient');
/**
 * Basic implementation for SOAP clients.
 *
 * @package     stubbles
 * @subpackage  service_soap
 */
abstract class stubAbstractSoapClient extends stubBaseObject implements stubSoapClient
{
    /**
     * configuration data for client
     *
     * @var  stubSoapClientConfiguration
     */
    protected $config;
    /**
     * timeout for soap calls in seconds
     *
     * @var  int
     */
    protected $timeout   = 2;
    /**
     * debug data for last call to invoke()
     *
     * @var  array<string,mixed>
     */
    protected $debugData = array();

    /**
     * constructor
     *
     * @param  stubSoapClientConfiguration  $config
     */
    public function __construct(stubSoapClientConfiguration $config)
    {
        $this->config = $config;
    }

    /**
     * returns the configuration
     *
     * @return  stubSoapClientConfiguration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * sets the timeout for soap calls using this client in seconds
     *
     * @param   int             $timeout
     * @return  stubSoapClient
     * @since   1.1.0
     */
    public function timeout($timeout)
    {
        $this->timeout = $timeout;
        return $this;
    }

    /**
     * returns data about last invoke() call usable for debugging
     *
     * @return  array<string,mixed>
     */
    public function getDebugData()
    {
        return $this->debugData;
    }
}
?><?php
/**
 * Interface for SOAP clients.
 *
 * @package     stubbles
 * @subpackage  service_soap
 * @version     $Id: stubSoapClient.php 2437 2010-01-05 22:22:26Z mikey $
 */
stubClassLoader::load('net::stubbles::service::soap::stubSoapClientConfiguration',
                      'net::stubbles::service::soap::stubSoapException'
);
/**
 * Interface for SOAP clients.
 *
 * @package     stubbles
 * @subpackage  service_soap
 */
interface stubSoapClient extends stubObject
{
    /**
     * returns the configuration
     *
     * @return  stubSoapClientConfiguration
     */
    public function getConfig();

    /**
     * checks whether the client supports WSDL or not
     *
     * @return  bool
     */
    public function supportsWsdl();

    /**
     * returns a list of functions provided by the soap service
     *
     * @return  array<string>
     */
    public function getFunctions();

    /**
     * returns a list of types the soap service uses for interaction
     *
     * @return  array<string>
     */
    public function getTypes();

    /**
     * sets the timeout for soap calls using this client in seconds
     *
     * @param   int             $timeout
     * @return  stubSoapClient
     * @since   1.1.0
     */
    public function timeout($timeout);

    /**
     * invoke method call
     *
     * @param   string  $method  name of method to invoke
     * @param   array   $args    list of arguments for method
     * @return  mixed
     * @throws  stubSoapException
     */
    public function invoke($method, array $args = array());

    /**
     * returns data about last invoke() call usable for debugging
     *
     * @return  array<string,mixed>
     */
    public function getDebugData();
}
?><?php
/**
 * Configuration container for SOAP clients.
 *
 * @package     stubbles
 * @subpackage  service_soap
 * @version     $Id: stubSoapClientConfiguration.php 2149 2009-03-30 20:02:46Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::peer::http::stubHTTPURL'
);
/**
 * Configuration container for SOAP clients.
 *
 * @package     stubbles
 * @subpackage  service_soap
 */
class stubSoapClientConfiguration extends stubBaseObject
{
    /**
     * the url where the SOAP service can be reached at
     *
     * @var  stubHTTPURLContainer
     */
    protected $endPoint;
    /**
     * the uri to use
     *
     * @var  string
     */
    protected $uri;
    /**
     * real location if wsdl does not contain the real location url to call
     *
     * @var  stubHTTPURLContainer
     */
    protected $location;
    /**
     * whether to use WSDL mode or not
     *
     * @var  bool
     */
    protected $useWsdl      = true;
    /**
     * the SOAP version to use
     *
     * @var  string
     */
    protected $version      = null;
    /**
     * encoding of the data
     *
     * @var  string
     */
    protected $dataEncoding = 'iso-8859-1';
    /**
     * style of the request
     *
     * @var  string
     */
    protected $requestStyle = null;
    /**
     * the usage
     *
     * @var  string
     */
    protected $usage        = null;
    /**
     * list of wsdl type to class mapping
     *
     * @var  array<string,string>
     */
    protected $classMapping = array();

    /**
     * constructor
     *
     * @param   string|stubHTTPURLContainer  $endPoint
     * @param   string                       $uri
     * @throws  stubIllegalArgumentException
     */
    public function __construct($endPoint, $uri)
    {
        if (is_string($endPoint) === true) {
            $endPoint = stubHTTPURL::fromString($endPoint);
            if (null === $endPoint) {
                throw new stubIllegalArgumentException('Endpoint must be a string denoting an URL or an instance of net::stubbles::peer::http::stubHTTPURLContainer.');
            }
        } elseif (($endPoint instanceof stubHTTPURLContainer) === false) {
            throw new stubIllegalArgumentException('Endpoint must be a string denoting an URL or an instance of net::stubbles::peer::http::stubHTTPURLContainer.');
        }
        
        $this->endPoint = $endPoint;
        $this->uri      = $uri;
    }

    /**
     * static constructor
     *
     * @param   string|stubHTTPURLContainer  $endPoint
     * @param   string                       $uri
     * @return  stubSoapClientConfiguration
     */
    public static function create($endPoint, $uri)
    {
        return new self($endPoint, $uri);
    }

    /**
     * returns url where the SOAP service can be reached at
     *
     * @return  stubHTTPURLContainer
     */
    public function getEndpoint()
    {
        return $this->endPoint;
    }

    /**
     * returns the uri to use
     *
     * @return  string
     */
    public function getUri()
    {
        return $this->uri;
    }

    /**
     * sets the real location
     *
     * @param   string|stubHTTPURLContainer $location
     * @return  stubSoapClientConfiguration
     * @throws  stubIllegalArgumentException
     */
    public function setLocation($location)
    {
        if (is_string($location) === true) {
            $location = stubHTTPURL::fromString($location);
            if (null === $location) {
                throw new stubIllegalArgumentException('Location must be a string denoting an URL or an instance of net::stubbles::peer::http::stubHTTPURLContainer.');
            }
        } elseif (($location instanceof stubHTTPURLContainer) === false) {
            throw new stubIllegalArgumentException('Location must be a string denoting an URL or an instance of net::stubbles::peer::http::stubHTTPURLContainer.');
        }
        
        $this->location = $location;
        return $this;
    }

    /**
     * checks if a location is set
     *
     * @return  bool
     */
    public function hasLocation()
    {
        return (null != $this->location);
    }

    /**
     * returns location
     *
     * @return  stubHTTPURLContainer
     */
    public function getLocation()
    {
        return $this->location;
    }

    /**
     * switch whether to use WSDL mode or not
     *
     * @param   bool                         $useWsdl
     * @return  stubSoapClientConfiguration
     */
    public function useWsdl($useWsdl)
    {
        $this->useWsdl = (bool) $useWsdl;
        return $this;
    }

    /**
     * checks whether to use WSDL mode or not
     *
     * @return  bool
     */
    public function usesWsdl()
    {
        return $this->useWsdl;
    }

    /**
     * sets the SOAP version
     *
     * @param   string                       $version
     * @return  stubSoapClientConfiguration
     */
    public function setVersion($version)
    {
        $this->version = $version;
        return $this;
    }

    /**
     * returns the SOAP version
     *
     * @return  string
     */
    public function getVersion()
    {
        return $this->version;
    }

    /**
     * sets the encoding of the data
     *
     * @param   string                       $dataEncoding
     * @return  stubSoapClientConfiguration
     */
    public function setDataEncoding($dataEncoding)
    {
        $this->dataEncoding = $dataEncoding;
        return $this;
    }

    /**
     * returns the encoding of the data
     *
     * @return  string
     */
    public function getDataEncoding()
    {
        return $this->dataEncoding;
    }

    /**
     * sets the style of the request
     *
     * @param   string                       $requestStyle
     * @return  stubSoapClientConfiguration
     */
    public function setRequestStyle($requestStyle)
    {
        $this->requestStyle = $requestStyle;
        return $this;
    }

    /**
     * returns the style of the request
     *
     * @return  string
     */
    public function getRequestStyle()
    {
        return $this->requestStyle;
    }

    /**
     * sets the usage
     *
     * @param   string                       $usage
     * @return  stubSoapClientConfiguration
     */
    public function setUsage($usage)
    {
        $this->usage = $usage;
        return $this;
    }

    /**
     * returns the usage
     *
     * @return  string
     */
    public function getUsage()
    {
        return $this->usage;
    }

    /**
     * registers a class mapping
     *
     * @param   string                       $wsdlType
     * @param   ReflectionClass              $class
     * @return  stubSoapClientConfiguration
     */
    public function registerClassMapping($wsdlType, ReflectionClass $class)
    {
        $this->classMapping[$wsdlType] = $class->getName();
        return $this;
    }

    /**
     * checks whether at least one class mapping exists
     *
     * @return  bool
     */
    public function hasClassMapping()
    {
        return (count($this->classMapping) > 0);
    }

    /**
     * returns the class mapping
     *
     * @return  array<string,string>
     */
    public function getClassMapping()
    {
        return $this->classMapping;
    }
}
?><?php
/**
 * Factory for SOAP clients.
 *
 * @package     stubbles
 * @subpackage  service_soap
 * @version     $Id: stubSoapClientGenerator.php 2463 2010-01-18 15:38:00Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::lang::exceptions::stubRuntimeException',
                      'net::stubbles::reflection::stubReflectionClass',
                      'net::stubbles::service::soap::stubSoapClient',
                      'net::stubbles::service::soap::stubSoapClientConfiguration'
);
/**
 * Factory for SOAP clients.
 *
 * @package     stubbles
 * @subpackage  service_soap
 */
class stubSoapClientGenerator extends stubBaseObject
{
    /**
     * list of available drivers
     *
     * @var  array<string,string|ReflectionClass>
     */
    protected $clients = array();

    /**
     * constructor
     */
    public function __construct()
    {
        if (extension_loaded('soap') === true) {
            $this->clients['net::stubbles::service::soap::native::stubNativeSoapClient'] = 'net::stubbles::service::soap::native::stubNativeSoapClient';
        }
    }

    /**
     * adds a client to list of drivers
     *
     * @param   ReflectionClass  $clientClass
     * @throws  stubIllegalArgumentException
     */
    public function addClient(ReflectionClass $clientClass)
    {
        if ($clientClass->implementsInterface('stubSoapClient') === false) {
            throw new stubIllegalArgumentException('Client class must implement interface net::stubbles::service::soap::stubSoapClient.');
        }
        
        $this->clients[$clientClass->getName()] = $clientClass;
    }

    /**
     * sets the available clients
     *
     * @param  array<string,string|ReflectionClass>  $clients
     */
    public function setAvailableClients(array $clients)
    {
        $this->clients = $clients;
    }

    /**
     * returns a list of available clients
     *
     * @return  array<string,string|ReflectionClass>
     */
    public function getAvailableClients()
    {
        return $this->clients;
    }

    /**
     * removes a client class from list of drivers
     *
     * @param  string  $clientClassName
     */
    public function removeClient($clientClassName)
    {
        if (isset($this->clients[$clientClassName]) === true) {
            unset($this->clients[$clientClassName]);
        }
    }

    /**
     * creates a client for given config
     *
     * If no valid or suitable client can be found a stubRuntimeException will
     * be thrown.
     *
     * @param   stubSoapClientConfiguration  $config
     * @param   bool                         $mustUseWsdl  optional
     * @return  stubSoapClient
     * @throws  stubRuntimeException
     */
    public function forConfig(stubSoapClientConfiguration $config, $mustUseWsdl = false)
    {
        foreach ($this->clients as $clientClass) {
            if (is_string($clientClass) === true) {
                $clientClass = new stubReflectionClass($clientClass);
            }
            
            try {
                if ($clientClass->getConstructor() !== null && $clientClass->getConstructor()->getNumberOfParameters() > 0) {
                    $client = $clientClass->newInstanceArgs(array($config));
                } else {
                    $client = $clientClass->newInstance();
                }
            } catch (Exception $e) {
                continue;
            }
            
            if (true === $mustUseWsdl && $client->supportsWsdl() === false && $config->usesWsdl() === true) {
                continue;
            }
            
            return $client;
        }
        
        throw new stubRuntimeException('No suitable SOAP client found.');
    }
}
?><?php
/**
 * Exception to be thrown on failed SOAP operations.
 *
 * @package     stubbles
 * @subpackage  service_soap
 * @version     $Id: stubSoapException.php 2142 2009-03-27 13:47:27Z mikey $
 */
stubClassLoader::load('net::stubbles::service::soap::stubSoapFault');
/**
 * Exception to be thrown on failed SOAP operations.
 *
 * @package     stubbles
 * @subpackage  service_soap
 */
class stubSoapException extends stubException
{
    /**
     * information about the error
     *
     * @var  stubSoapFault
     */
    protected $soapFault;

    /**
     * constructor
     *
     * @param  stubSoapFault  $soapFault
     */
    public function __construct(stubSoapFault $soapFault)
    {
        $this->soapFault = $soapFault;
        parent::__construct($soapFault->getFaultString());
    }

    /**
     * returns more information about the error
     *
     * @return  stubSoapFault
     */
    public function getSoapFault()
    {
        return $this->soapFault;
    }
}
?><?php
/**
 * Container for SOAP fault data.
 *
 * @package     stubbles
 * @subpackage  service_soap
 * @version     $Id: stubSoapFault.php 2142 2009-03-27 13:47:27Z mikey $
 */
/**
 * Container for SOAP fault data.
 *
 * @package     stubbles
 * @subpackage  service_soap
 */
class stubSoapFault extends stubBaseObject
{
    /**
     * error code
     *
     * @var  string
     */
    protected $faultCode;
    /**
     * error message
     *
     * @var  string
     */
    protected $faultString;
    /**
     * what caused the error
     *
     * @var  string
     */
    protected $faultActor;
    /**
     * more details about the error
     *
     * @var  mixed
     */
    protected $detail;

    /**
     * constructor
     *
     * @param  string  $faultCode    error code
     * @param  string  $faultString  error message
     * @param  string  $faultActor   optional  what caused the error
     * @param  mixed   $detail       optional  more details about the error
     */
    public function __construct($faultCode, $faultString, $faultActor = null, $detail = null)
    {
        $this->faultCode   = $faultCode;
        $this->faultString = $faultString;
        $this->faultActor  = $faultActor;
        $this->detail      = $detail;
    }

    /**
     * returns the error code
     *
     * @return  string
     */
    public function getFaultCode()
    {
        return $this->faultCode;
    }

    /**
     * returns the error message
     *
     * @return  string
     */
    public function getFaultString()
    {
        return $this->faultString;
    }

    /**
     * returns what caused the error
     *
     * @return  string
     */
    public function getFaultActor()
    {
        return $this->faultActor;
    }

    /**
     * returns more details about the error
     *
     * @return  mixed
     */
    public function getDetail()
    {
        return $this->detail;
    }
}
?><?php
/**
 * Class for file based input streams.
 *
 * @package     stubbles
 * @subpackage  streams
 * @version     $Id: stubFileInputStream.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::lang::exceptions::stubIllegalStateException',
                      'net::stubbles::lang::exceptions::stubIOException',
                      'net::stubbles::streams::stubResourceInputStream',
                      'net::stubbles::streams::stubSeekable'
);
/**
 * Class for file based input streams.
 *
 * @package     stubbles
 * @subpackage  streams
 */
class stubFileInputStream extends stubResourceInputStream implements stubSeekable
{
    /**
     * name of the file
     *
     * @var  string
     */
    protected $fileName;

    /**
     * constructor
     *
     * @param   string|resource  $file
     * @param   string           $mode  option  opening mode if $file is a filename
     * @throws  stubIOException
     * @throws  stubIllegalArgumentException
     */
    public function __construct($file, $mode = 'rb')
    {
        if (is_string($file) === true) {
            $fp = @fopen($file, $mode);
            if (false === $fp) {
                throw new stubIOException('Can not open file ' . $file . ' with mode ' . $mode);
            }
            
            $this->fileName = $file;
        } elseif (is_resource($file) === true && get_resource_type($file) === 'stream') {
            $fp = $file;
        } else {
            throw new stubIllegalArgumentException('File must either be a filename or an already opened file/stream resource.');
        }
        
        $this->setHandle($fp);
    }

    /**
     * destructor
     */
    public function __destruct()
    {
        $this->close();
    }

    /**
     * helper method to retrieve the length of the resource
     *
     * Not all stream wrappers support (f)stat - the extending class then
     * needs to take care to deliver the correct resource length then.
     *
     * @return  int
     */
    protected function getResourceLength()
    {
        if (null === $this->fileName) {
            return parent::getResourceLength();
        }
        
        if (substr($this->fileName, 0, 16) === 'compress.zlib://') {
            return filesize(substr($this->fileName, 16));
        } elseif (substr($this->fileName, 0, 17) === 'compress.bzip2://') {
            return filesize(substr($this->fileName, 17));
        }
    }

    /**
     * seek to given offset
     *
     * @param   int  $offset
     * @param   int  $whence  one of stubSeekable::SET, stubSeekable::CURRENT or stubSeekable::END
     * @throws  stubIllegalStateException
     */
    public function seek($offset, $whence = stubSeekable::SET)
    {
        if (null === $this->handle) {
            throw new stubIllegalStateException('Can not read from closed input stream.');
        }

        fseek($this->handle, $offset, $whence);
    }

    /**
     * return current position
     *
     * @return  int
     * @throws  stubIllegalStateException
     * @throws  stubIOException
     */
    public function tell()
    {
        if (null === $this->handle) {
            throw new stubIllegalStateException('Can not read from closed input stream.');
        }

        $position = ftell($this->handle);
        if (false === $position) {
            throw new stubIOException('Can not read current position in file.');
        }

        return $position;
    }
}
?><?php
/**
 * Class for file based output streams.
 *
 * @package     stubbles
 * @subpackage  streams
 * @version     $Id: stubFileOutputStream.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubResourceOutputStream',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::lang::exceptions::stubIOException'
);
/**
 * Class for file based output streams.
 *
 * @package     stubbles
 * @subpackage  streams
 */
class stubFileOutputStream extends stubResourceOutputStream
{
    /**
     * name of file
     *
     * @var  string
     */
    protected $file;
    /**
     * opening mode
     *
     * @var  string
     */
    protected $mode;

    /**
     * constructor
     *
     * The delayed param only works in conjunction with the $file param being a
     * string. If set to true and the file does not exist creation of the file
     * will be delayed until first bytes should be written to the output stream.
     *
     * @param   string|resource  $file
     * @param   string           $mode     optional  opening mode if $file is a filename
     * @param   bool             $delayed  optional
     * @throws  stubIllegalArgumentException
     */
    public function __construct($file, $mode = 'wb', $delayed = false)
    {
        if (is_string($file) === true) {
            if (false === $delayed) {
                $this->setHandle($this->openFile($file, $mode));
            } else {
                $this->file = $file;
                $this->mode = $mode;
            }
        } elseif (is_resource($file) === true && get_resource_type($file) === 'stream') {
            $this->setHandle($file);
        } else {
            throw new stubIllegalArgumentException('File must either be a filename or an already opened file/stream resource.');
        }
    }

    /**
     * destructor
     */
    public function __destruct()
    {
        $this->close();
    }

    /**
     * writes given bytes
     *
     * @param   string  $bytes
     * @return  int     amount of written bytes
     */
    public function write($bytes)
    {
        // delayed file creation?
        if (null === $this->handle && null != $this->file) {
            $this->setHandle($this->openFile($this->file, $this->mode));
        }
        
        return parent::write($bytes);
    }

    /**
     * helper method to open a file handle
     *
     * @param   string            $file
     * @param   string            $mode
     * @return  resource<stream>
     * @throws  stubIOException
     */
    protected function openFile($file, $mode)
    {
        $fp = @fopen($file, $mode);
        if (false === $fp) {
            throw new stubIOException('Can not open file ' . $file . ' with mode ' . $mode);
        }
        
        return $fp;
    }
}
?><?php
/**
 * Factory for file streams.
 *
 * @package     stubbles
 * @subpackage  streams_file
 * @version     $Id: stubFileStreamFactory.php 2324 2009-09-16 11:50:14Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubStreamFactory',
                      'net::stubbles::streams::file::stubFileInputStream',
                      'net::stubbles::streams::file::stubFileOutputStream'
);
/**
 * Factory for file streams.
 *
 * @package     stubbles
 * @subpackage  streams_file
 */
class stubFileStreamFactory extends stubBaseObject implements stubStreamFactory
{
    /**
     * default file mode if directory for output stream should be created
     *
     * @var  int
     */
    protected $fileMode;

    /**
     * constructor
     *
     * @param  int  $fileMode  default file mode if directory for output stream should be created
     * @Inject(optional=true)
     * @Named('net.stubbles.filemode')
     */
    public function __construct($fileMode = 0700)
    {
        $this->fileMode = 0700;
    }

    /**
     * creates an input stream for given source
     *
     * @param   mixed                $source   source to create input stream from
     * @param   array<string,mixed>  $options  list of options for the input stream
     * @return  stubInputStream
     */
    public function createInputStream($source, array $options = array())
    {
        if (isset($options['filemode']) === true) {
            return new stubFileInputStream($source, $options['filemode']);
        }
        
        return new stubFileInputStream($source);
    }

    /**
     * creates an output stream for given target
     *
     * @param   mixed                $target   target to create output stream for
     * @param   array<string,mixed>  $options  list of options for the output stream
     * @return  stubOutputStream
     */
    public function createOutputStream($target, array $options = array())
    {
        if (isset($options['createDirIfNotExists']) === true && true === $options['createDirIfNotExists']) {
            $dir = dirname($target);
            if (file_exists($dir) === false) {
                $filemode = ((isset($options['dirPermissions']) === false) ? ($this->fileMode) : ($options['dirPermissions']));
                mkdir($dir, $filemode, true);
            }
        }
        
        $filemode = (isset($options['filemode']) === false) ? ('wb') : ($options['filemode']);
        $delayed  = (isset($options['delayed']) === false) ? (false) : ($options['delayed']);
        return new stubFileOutputStream($target, $filemode, $delayed);
    }
}
?><?php
/**
 * Composite to combine a list of stream filters.
 *
 * @package     stubbles
 * @subpackage  streams_filter
 * @version     $Id: stubCompositeStreamFilter.php 2297 2009-08-21 15:22:25Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::filter::stubStreamFilter');
/**
 * Composite to combine a list of stream filters.
 *
 * @package     stubbles
 * @subpackage  streams_filter
 */
class stubCompositeStreamFilter extends stubBaseObject implements stubStreamFilter
{
    /**
     * list of stream filters to apply
     *
     * @var  array<stubStreamFilter>
     */
    protected $streamFilter = array();

    /**
     * add a stream filter
     *
     * @param   stubStreamFilter           $streamFilter
     * @return  stubCompositeStreamFilter
     */
    public function addStreamFilter(stubStreamFilter $streamFilter)
    {
        $this->streamFilter[] = $streamFilter;
        return $this;
    }

    /**
     * Decides whether data should be filtered or not.
     *
     * @param   string  $data
     * @return  bool
     */
    public function shouldFilter($data)
    {
        foreach ($this->streamFilter as $streamFilter) {
            if ($streamFilter->shouldFilter($data) === true) {
                return true;
            }
        }
        
        return false;
    }
}
?><?php
/**
 * Input stream applying a filter on data read before returning to requestor.
 *
 * @package     stubbles
 * @subpackage  streams_filter
 * @version     $Id: stubFilteredInputStream.php 2295 2009-08-20 21:18:51Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubAbstractDecoratedInputStream',
                      'net::stubbles::streams::filter::stubStreamFilter'
);
/**
 * Input stream applying a filter on data read before returning to requestor.
 *
 * @package     stubbles
 * @subpackage  streams_filter
 */
class stubFilteredInputStream extends stubAbstractDecoratedInputStream
{
    /**
     * stream filter to be applied
     *
     * @var  stubStreamFilter
     */
    protected $streamFilter;

    /**
     * constructor
     *
     * @param  stubInputStream   $inputStream   input stream to filter
     * @param  stubStreamFilter  $streamFilter  stream filter to be applied
     */
    public function __construct(stubInputStream $inputStream, stubStreamFilter $streamFilter)
    {
        parent::__construct($inputStream);
        $this->streamFilter = $streamFilter;
    }

    /**
     * reads given amount of bytes
     *
     * @param   int     $length  optional  max amount of bytes to read
     * @return  string
     */
    public function read($length = 8192)
    {
        while ($this->inputStream->eof() === false) {
            $data = $this->inputStream->read($length);
            if ($this->streamFilter->shouldFilter($data) === false) {
                return $data;
            }
        }
        
        return '';
    }

    /**
     * reads given amount of bytes or until next line break
     *
     * @param   int     $length  optional  max amount of bytes to read
     * @return  string
     */
    public function readLine($length = 8192)
    {
        while ($this->inputStream->eof() === false) {
            $data = $this->inputStream->readLine($length);
            if ($this->streamFilter->shouldFilter($data) === false) {
                return $data;
            }
        }
        
        return '';
    }
}
?><?php
/**
 * Output stream applying a filter on data to write.
 *
 * @package     stubbles
 * @subpackage  streams_filter
 * @version     $Id: stubFilteredOutputStream.php 2324 2009-09-16 11:50:14Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubAbstractDecoratedOutputStream',
                      'net::stubbles::streams::filter::stubStreamFilter'
);
/**
 * Output stream applying a filter on data to write.
 *
 * @package     stubbles
 * @subpackage  streams_filter
 */
class stubFilteredOutputStream extends stubAbstractDecoratedOutputStream
{
    /**
     * stream filter to be applied
     *
     * @var  stubStreamFilter
     */
    protected $streamFilter;

    /**
     * constructor
     *
     * @param  stubOutputStream  $outputStream  stream to apply filter onto
     * @param  stubStreamFilter  $streamFilter  stream filter to be applied
     */
    public function __construct(stubOutputStream $outputStream, stubStreamFilter $streamFilter)
    {
        parent::__construct($outputStream);
        $this->streamFilter = $streamFilter;
    }

    /**
     * writes given bytes
     *
     * @param   string  $bytes
     * @return  int     amount of written bytes
     */
    public function write($bytes)
    {
        if ($this->streamFilter->shouldFilter($bytes) === false) {
            return $this->outputStream->write($bytes);
        }
        
        return 0;
    }

    /**
     * writes given bytes and appends a line break
     *
     * @param   string  $bytes
     * @return  int     amount of written bytes excluding line break
     */
    public function writeLine($bytes)
    {
        if ($this->streamFilter->shouldFilter($bytes) === false) {
            return $this->outputStream->writeLine($bytes);
        }
        
        return 0;
    }
}
?><?php
/**
 * Interface for stream filters.
 *
 * @package     stubbles
 * @subpackage  streams_filter
 * @version     $Id: stubStreamFilter.php 2296 2009-08-20 22:17:45Z mikey $
 */
/**
 * Interface for stream filters.
 *
 * @package     stubbles
 * @subpackage  streams_filter
 */
interface stubStreamFilter extends stubObject
{
    /**
     * Decides whether data should be filtered or not.
     *
     * @param   string  $data
     * @return  bool
     */
    public function shouldFilter($data);
}
?><?php
/**
 * Class to stream data from memory.
 *
 * @package     stubbles
 * @subpackage  streams_memory
 * @version     $Id: stubMemoryInputStream.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::streams::stubInputStream',
                      'net::stubbles::streams::stubSeekable'
);
/**
 * Class to stream data from memory.
 *
 * @package     stubbles
 * @subpackage  streams_memory
 */
class stubMemoryInputStream extends stubBaseObject implements stubInputStream, stubSeekable
{
    /**
     * written data
     *
     * @var  string
     */
    protected $buffer   = '';
    /**
     * current position in buffer
     *
     * @var  int
     */
    protected $position = 0;

    /**
     * constructor
     *
     * @param  string  $buffer
     */
    public function __construct($buffer)
    {
        $this->buffer = $buffer;
    }

    /**
     * reads given amount of bytes
     *
     * @param   int     $length  optional  max amount of bytes to read
     * @return  string
     */
    public function read($length = 8192)
    {
        $bytes           = substr($this->buffer, $this->position, $length);
        $this->position += strlen($bytes);
        return $bytes;
    }

    /**
     * reads given amount of bytes or until next line break
     *
     * @param   int     $length  optional  max amount of bytes to read
     * @return  string
     */
    public function readLine($length = 8192)
    {
        $bytes        = substr($this->buffer, $this->position, $length);
        $linebreakpos = strpos($bytes, "\n");
        if (false !== $linebreakpos) {
            $line = substr($bytes, 0, $linebreakpos);
            $this->position += strlen($line) + 1;
        } else {
            $line = $bytes;
            $this->position += strlen($line);
        }
        
        return $line;
    }

    /**
     * returns the amount of byted left to be read
     *
     * @return  int
     */
    public function bytesLeft()
    {
        return strlen($this->buffer) - $this->position;
    }

    /**
     * returns true if the stream pointer is at EOF
     *
     * @return  bool
     */
    public function eof()
    {
        return (strlen($this->buffer) === $this->position);
    }

    /**
     * closes the stream
     */
    public function close()
    {
        // intentionally empty
    }

    /**
     * seek to given offset
     *
     * @param   int  $offset  new position or amount of bytes to seek
     * @param   int  $whence  optional  one of stubSeekable::SET, stubSeekable::CURRENT or stubSeekable::END
     * @throws  stubIllegalArgumentException
     */
    public function seek($offset, $whence = stubSeekable::SET)
    {
        switch ($whence) {
            case stubSeekable::SET:
                $this->position = $offset;
                break;
            
            case stubSeekable::CURRENT:
                $this->position += $offset;
                break;
            
            case stubSeekable::END:
                $this->position = strlen($this->buffer) + $offset;
                break;
            
            default:
                throw new stubIllegalArgumentException('Wrong value for $whence, must be one of stubSeekable::SET, stubSeekable::CURRENT or stubSeekable::END.');
        }
    }

    /**
     * return current position
     *
     * @return  int
     */
    public function tell()
    {
        return $this->position;
    }
}
?><?php
/**
 * Class to stream data into memory.
 *
 * @package     stubbles
 * @subpackage  streams_memory
 * @version     $Id: stubMemoryOutputStream.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubOutputStream');
/**
 * Class to stream data into memory.
 *
 * @package     stubbles
 * @subpackage  streams_memory
 */
class stubMemoryOutputStream extends stubBaseObject implements stubOutputStream
{
    /**
     * written data
     *
     * @var  string
     */
    protected $buffer = '';

    /**
     * writes given bytes
     *
     * @param   string  $bytes
     * @return  int     amount of written bytes
     */
    public function write($bytes)
    {
        $this->buffer .= $bytes;
        return strlen($bytes);
    }

    /**
     * writes given bytes and appends a line break
     *
     * @param   string  $bytes
     * @return  int     amount of written bytes excluding line break
     */
    public function writeLine($bytes)
    {
        return $this->write($bytes . "\n");
    }

    /**
     * closes the stream
     */
    public function close()
    {
        // intentionally empty
    }

    /**
     * returns written contents
     *
     * @return  string
     */
    public function getBuffer()
    {
        return $this->buffer;
    }
}
?><?php
/**
 * Factory for memory streams.
 *
 * @package     stubbles
 * @subpackage  streams_memory
 * @version     $Id: stubMemoryStreamFactory.php 2324 2009-09-16 11:50:14Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubStreamFactory',
                      'net::stubbles::streams::memory::stubMemoryInputStream',
                      'net::stubbles::streams::memory::stubMemoryOutputStream'
);
/**
 * Factory for memory streams.
 *
 * @package     stubbles
 * @subpackage  streams_memory
 */
class stubMemoryStreamFactory extends stubBaseObject implements stubStreamFactory
{
    /**
     * creates an input stream for given source
     *
     * @param   mixed                $source   source to create input stream from
     * @param   array<string,mixed>  $options  list of options for the input stream
     * @return  stubInputStream
     */
    public function createInputStream($source, array $options = array())
    {
        return new stubMemoryInputStream($source);
    }

    /**
     * creates an output stream for given target
     *
     * @param   mixed                $target   target to create output stream for
     * @param   array<string,mixed>  $options  list of options for the output stream
     * @return  stubOutputStream
     */
    public function createOutputStream($target, array $options = array())
    {
        return new stubMemoryOutputStream();
    }
}
?><?php
/**
 * Stream wrapper to read and write data from/into memory via file functions.
 *
 * @package     stubbles
 * @subpackage  streams_memory
 * @version     $Id: stubMemoryStreamWrapper.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubRuntimeException');
/**
 * Stream wrapper to read and write data from/into memory via file functions.
 *
 * A memory stream is useful when you want to pass contents to a class that
 * expects the contents to be in a file because it uses PHP's file functions
 * to read the data from a file. With the memory stream wrapper you can fool
 * this class by writing the contents to memory://mydata, now you just need
 * to get the class to read the data from this URL. Example:
 * 
 * $xmlUnserializer = new stubXMLUnserializer();
 * $data = $xmlUnserializer->unserializeFile('memory://mydata');
 *
 * @package     stubbles
 * @subpackage  streams_memory
 */
class stubMemoryStreamWrapper extends stubBaseObject
{
    /**
     * scheme used by the stream wrapper
     */
    const SCHEME               = 'memory';
    /**
     * switch whether class has already been registered as stream wrapper or not
     *
     * @var  bool
     */
    private static $registered = false;
    /**
     * data of different memory contents
     *
     * @var  array<string,string>
     */
    protected static $buffer   = array();
    /**
     * current key
     *
     * @var  string
     */
    protected $key;
    /**
     * current position in buffer
     *
     * @var  int
     */
    protected $position = 0;

    /**
     * static initializing
     *
     * @throws  stubRuntimeException
     */
    // @codeCoverageIgnoreStart
    public static function __static()
    {
        if (true === self::$registered) {
            return;
        }

        if (stream_wrapper_register(self::SCHEME, __CLASS__) === false) {
            throw new stubRuntimeException('A handler has already been registered for the ' . self::SCHEME . ' protocol.');
        }

        self::$registered = true;
    }
    // @codeCoverageIgnoreEnd

    /**
     * open the stream
     *
     * @param   string  $path         the path to open
     * @param   string  $mode         mode for opening
     * @param   string  $options      options for opening
     * @param   string  $opened_path  full path that was actually opened
     * @return  bool
     */
    public function stream_open($path, $mode, $options, $opened_path)
    {
        $this->key = self::parsePath($path);
        switch (str_replace('t', '', str_replace('b', '', $mode))) {
            case 'r':
                // break omitted
            
            case 'r+':
                if (isset(self::$buffer[$this->key]) === false) {
                    return false;
                }
                
                $this->position = 0;
                break;
            
            case 'w':
                // break omitted
            
            case 'w+':
                self::$buffer[$this->key] = '';
                $this->position           = 0;
                break;
            
            case 'a':
                // break omitted
            
            case 'a+':
                if (isset(self::$buffer[$this->key]) === false) {
                    self::$buffer[$this->key] = '';
                }
                
                $this->position = strlen(self::$buffer[$this->key]);
                break;
                
            case 'x':
                // break omitted
            
            case 'x+':
                if (isset(self::$buffer[$this->key]) === true) {
                    return false;
                }
                
                self::$buffer[$this->key] = '';
                $this->position           = 0;
                break;
            
            default:
                if (isset(self::$buffer[$this->key]) === false) {
                    self::$buffer[$this->key] = '';
                }
                
                $this->position = 0;
        }
        
        return true;
    }

    /**
     * closes the stream
     */
    public function stream_close()
    {
        // nothing to do
    }

    /**
     * read the stream up to $count bytes
     *
     * @param   int     $count  amount of bytes to read
     * @return  string
     */
    public function stream_read($count)
    {
        $bytes           = substr(self::$buffer[$this->key], $this->position, $count);
        $this->position += strlen($bytes);
        return $bytes;
    }

    /**
     * checks whether stream is at end of stream
     *
     * @return  bool
     */
    public function stream_eof()
    {
        return (strlen(self::$buffer[$this->key]) === $this->position);
    }

    /**
     * writes data into the stream
     *
     * @param   string  $data
     * @return  int     amount of bytes written
     */
    public function stream_write($data)
    {
        $dataLen                  = strlen($data);
        self::$buffer[$this->key] = substr(self::$buffer[$this->key], 0, $this->position) . $data . substr(self::$buffer[$this->key], $this->position + $dataLen);
        $this->position          += $dataLen;
        return $dataLen;
    }

    /**
     * returns the current position of the stream
     *
     * @return  int
     */
    public function stream_tell()
    {
        return $this->position;
    }

    /**
     * seeks to the given offset
     *
     * @param   int   $offset
     * @param   int   $whence
     * @return  bool
     */
    public function stream_seek($offset, $whence)
    {
        switch ($whence) {
            case SEEK_SET:
                $this->position = $offset;
                return true;
            
            case SEEK_CUR:
                $this->position += $offset;
                return true;
            
            case SEEK_END:
                $this->position = strlen(self::$buffer[$this->key]) + $offset;
                return true;
            
            default:
                // intentionally empty
        }
        
        return false;
    }

    /**
     * remove the data under the given path
     *
     * @param   string  $path
     * @return  bool
     */
    public function unlink($path)
    {
        $key = self::parsePath($path);
        if (isset(self::$buffer[$key]) === true) {
            unset(self::$buffer[$key]);
            clearstatcache();
            return true;
        }
        
        return false;
    }

    /**
     * returns status of stream
     *
     * @return  array
     */
    public function stream_stat()
    {
        return array(2      => 0100000 + octdec(0777),
                     4      => 0,
                     5      => 0,
                     7      => strlen(self::$buffer[$this->key]),
                     'mode' => 0100000 + octdec(0777),
                     'uid'  => 0,
                     'gid'  => 0,
                     'size' => strlen(self::$buffer[$this->key])
               );
    }

    /**
     * returns status of url
     *
     * @param   string      $path  path of url to return status for
     * @return  array|bool  false if $path does not exist, else
     */
    public function url_stat($path)
    {
        
        $key = self::parsePath($path);
        if (isset(self::$buffer[$key]) === true) {
            return array(2      => 0100000,
                         4      => 0,
                         5      => 0,
                         7      => strlen(self::$buffer[$key]),
                         'mode' => 0100000,
                         'uid'  => 0,
                         'gid'  => 0,
                         'size' => strlen(self::$buffer[$key])
                   );
        }
        
        return false;
    }

    /**
     * parses buffer key out of path
     *
     * @param   string  $path
     * @return  string
     */
    protected static function parsePath($path)
    {
        list($key) = sscanf($path, self::SCHEME . '://%s');
        return $key;
    }
}
?><?php
/**
 * Abstract base class for decorated input streams.
 *
 * @package     stubbles
 * @subpackage  streams
 * @version     $Id: stubAbstractDecoratedInputStream.php 2291 2009-08-20 20:14:44Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubDecoratedInputStream');
/**
 * Abstract base class for decorated input streams.
 *
 * @package     stubbles
 * @subpackage  streams
 */
abstract class stubAbstractDecoratedInputStream extends stubBaseObject implements stubDecoratedInputStream
{
    /**
     * input stream to encode into internal encoding
     *
     * @var  stubInputStream
     */
    protected $inputStream;

    /**
     * constructor
     *
     * @param  stubInputStream  $inputStream
     */
    public function __construct(stubInputStream $inputStream)
    {
        $this->inputStream = $inputStream;
    }

    /**
     * replace current enclosed input stream
     *
     * @param   stubInputStream                   $inputStream
     * @return  stubAbstractDecoratedInputStream
     */
    public function setEnclosedInputStream(stubInputStream $inputStream)
    {
        $this->inputStream = $inputStream;
        return $this;
    }

    /**
     * returns enclosed input stream
     *
     * @return  stubInputStream
     */
    public function getEnclosedInputStream()
    {
        return $this->inputStream;
    }

    /**
     * reads given amount of bytes
     *
     * @param   int     $length  optional  max amount of bytes to read
     * @return  string
     */
    public function read($length = 8192)
    {
        return $this->inputStream->read($length);
    }

    /**
     * reads given amount of bytes or until next line break
     *
     * @param   int     $length  optional  max amount of bytes to read
     * @return  string
     */
    public function readLine($length = 8192)
    {
        return $this->inputStream->readLine($length);
    }

    /**
     * returns the amount of byted left to be read
     *
     * @return  int
     */
    public function bytesLeft()
    {
        return $this->inputStream->bytesLeft();
    }

    /**
     * returns true if the stream pointer is at EOF
     *
     * @return  bool
     */
    public function eof()
    {
        return $this->inputStream->eof();
    }

    /**
     * closes the stream
     */
    public function close()
    {
        $this->inputStream->close();
    }
}
?><?php
/**
 * Abstract base class for decorated output streams.
 *
 * @package     stubbles
 * @subpackage  streams
 * @version     $Id: stubAbstractDecoratedOutputStream.php 2291 2009-08-20 20:14:44Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubDecoratedOutputStream');
/**
 * Abstract base class for decorated output streams.
 *
 * @package     stubbles
 * @subpackage  streams
 */
abstract class stubAbstractDecoratedOutputStream extends stubBaseObject implements stubDecoratedOutputStream
{
    /**
     * input stream to encode into internal encoding
     *
     * @var  stubOutputStream
     */
    protected $outputStream;

    /**
     * constructor
     *
     * @param  stubOutputStream  $outputStream
     */
    public function __construct(stubOutputStream $outputStream)
    {
        $this->outputStream = $outputStream;
    }

    /**
     * replace current enclosed output stream
     *
     * @param   stubOutputStream                   $outputStream
     * @return  stubAbstractDecoratedOutputStream
     */
    public function setEnclosedOutputStream(stubOutputStream $outputStream)
    {
        $this->outputStream = $outputStream;
        return $this;
    }

    /**
     * returns enclosed output stream
     *
     * @return  stubOutputStream
     */
    public function getEnclosedOutputStream()
    {
        return $this->outputStream;
    }

    /**
     * writes given bytes
     *
     * @param   string  $bytes
     * @return  int     amount of written bytes
     */
    public function write($bytes)
    {
        return $this->outputStream->write($bytes);
    }

    /**
     * writes given bytes and appends a line break
     *
     * @param   string  $bytes
     * @return  int     amount of written bytes excluding line break
     */
    public function writeLine($bytes)
    {
        return $this->outputStream->writeLine($bytes);
    }

    /**
     * closes the stream
     */
    public function close()
    {
        $this->outputStream->close();
    }
}
?><?php
/**
 * Decodes input stream into internal charset.
 *
 * @package     stubbles
 * @subpackage  streams
 * @version     $Id: stubDecodingInputStream.php 2292 2009-08-20 20:23:56Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubAbstractDecoratedInputStream');
/**
 * Decodes input stream into internal charset.
 *
 * @package     stubbles
 * @subpackage  streams
 */
class stubDecodingInputStream extends stubAbstractDecoratedInputStream
{
    /**
     * input stream to encode into internal encoding
     *
     * @var  stubInputStream
     */
    protected $inputStream;
    /**
     * charset of input stream
     *
     * @var  string
     */
    protected $charset;

    /**
     * constructor
     *
     * @param  stubInputStream  $inputStream
     * @param  string           $charset      charset of input stream
     */
    public function __construct(stubInputStream $inputStream, $charset)
    {
        $this->inputStream = $inputStream;
        $this->charset     = $charset;
    }

    /**
     * returns charset of input stream
     *
     * @return  string
     */
    public function getCharset()
    {
        return $this->charset;
    }

    /**
     * reads given amount of bytes
     *
     * @param   int     $length  optional  max amount of bytes to read
     * @return  string
     */
    public function read($length = 8192)
    {
        return iconv($this->charset, 'UTF-8', $this->inputStream->read($length));
    }

    /**
     * reads given amount of bytes or until next line break
     *
     * @param   int     $length  optional  max amount of bytes to read
     * @return  string
     */
    public function readLine($length = 8192)
    {
        return iconv($this->charset, 'UTF-8', $this->inputStream->readLine($length));
    }
}
?><?php
/**
 * Interface for decorated input streams.
 *
 * @package     stubbles
 * @subpackage  streams
 * @version     $Id: stubDecoratedInputStream.php 2291 2009-08-20 20:14:44Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubInputStream');
/**
 * Interface for decorated input streams.
 *
 * @package     stubbles
 * @subpackage  streams
 */
interface stubDecoratedInputStream extends stubInputStream
{
    /**
     * replace current enclosed input stream
     *
     * @param  stubInputStream  $inputStream
     */
    public function setEnclosedInputStream(stubInputStream $inputStream);

    /**
     * returns enclosed input stream
     *
     * @return  stubInputStream
     */
    public function getEnclosedInputStream();
}
?><?php
/**
 * Interface for decorated output streams.
 *
 * @package     stubbles
 * @subpackage  streams
 * @version     $Id: stubDecoratedOutputStream.php 2324 2009-09-16 11:50:14Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubOutputStream');
/**
 * Interface for decorated output streams.
 *
 * @package     stubbles
 * @subpackage  streams
 */
interface stubDecoratedOutputStream extends stubOutputStream
{
    /**
     * replace current enclosed output stream
     *
     * @param  stubOutputStream  $outputStream
     */
    public function setEnclosedOutputStream(stubOutputStream $outputStream);

    /**
     * returns enclosed output stream
     *
     * @return  stubOutputStream
     */
    public function getEnclosedOutputStream();
}
?><?php
/**
 * Encodes internal encoding into output charset.
 *
 * @package     stubbles
 * @subpackage  streams
 * @version     $Id: stubEncodingOutputStream.php 2292 2009-08-20 20:23:56Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubAbstractDecoratedOutputStream');
/**
 * Encodes internal encoding into output charset.
 *
 * @package     stubbles
 * @subpackage  streams
 */
class stubEncodingOutputStream extends stubAbstractDecoratedOutputStream
{
    /**
     * input stream to encode into internal encoding
     *
     * @var  stubOutputStream
     */
    protected $outputStream;
    /**
     * charset of output stream
     *
     * @var  string
     */
    protected $charset;

    /**
     * constructor
     *
     * @param  stubOutputStream  $outputStream
     * @param  string            $charset       charset of output stream
     */
    public function __construct(stubOutputStream $outputStream, $charset)
    {
        $this->outputStream = $outputStream;
        $this->charset      = $charset;
    }

    /**
     * returns charset of output stream
     *
     * @return  string
     */
    public function getCharset()
    {
        return $this->charset;
    }

    /**
     * writes given bytes
     *
     * @param   string  $bytes
     * @return  int     amount of written bytes
     */
    public function write($bytes)
    {
        return $this->outputStream->write(iconv('UTF-8', $this->charset, $bytes));
    }

    /**
     * writes given bytes and appends a line break
     *
     * @param   string  $bytes
     * @return  int     amount of written bytes excluding line break
     */
    public function writeLine($bytes)
    {
        return $this->outputStream->writeLine(iconv('UTF-8', $this->charset, $bytes));
    }
}
?><?php
/**
 * Interface for input streams.
 *
 * @package     stubbles
 * @subpackage  streams
 * @version     $Id: stubInputStream.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Interface for input streams.
 *
 * @package     stubbles
 * @subpackage  streams
 */
interface stubInputStream extends stubObject
{
    /**
     * reads given amount of bytes
     *
     * @param   int     $length  optional  max amount of bytes to read
     * @return  string
     */
    public function read($length = 8192);

    /**
     * reads given amount of bytes or until next line break
     *
     * @param   int     $length  optional  max amount of bytes to read
     * @return  string
     */
    public function readLine($length = 8192);

    /**
     * returns the amount of byted left to be read
     *
     * @return  int
     */
    public function bytesLeft();

    /**
     * returns true if the stream pointer is at EOF
     *
     * @return  bool
     */
    public function eof();

    /**
     * closes the stream
     */
    public function close();
}
?><?php
/**
 * Interface for output streams.
 *
 * @package     stubbles
 * @subpackage  streams
 * @version     $Id: stubOutputStream.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Interface for output streams.
 *
 * @package     stubbles
 * @subpackage  streams
 */
interface stubOutputStream extends stubObject
{
    /**
     * writes given bytes
     *
     * @param   string  $bytes
     * @return  int     amount of written bytes
     */
    public function write($bytes);

    /**
     * writes given bytes and appends a line break
     *
     * @param   string  $bytes
     * @return  int     amount of written bytes excluding line break
     */
    public function writeLine($bytes);

    /**
     * closes the stream
     */
    public function close();
}
?><?php
/**
 * Stream factory which prefixes source and target before calling another stream factory.
 *
 * @package     stubbles
 * @subpackage  streams
 * @version     $Id: stubPrefixedStreamFactory.php 2324 2009-09-16 11:50:14Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubStreamFactory');
/**
 * Stream factory which prefixes source and target before calling another stream factory.
 *
 * @package     stubbles
 * @subpackage  streams
 */
class stubPrefixedStreamFactory extends stubBaseObject implements stubStreamFactory
{
    /**
     * decorated stream factory
     *
     * @var  stubStreamFactory
     */
    protected $streamFactory;
    /**
     * prefix to add for source and target before calling decorated stream factory
     *
     * @var  string
     */
    protected $prefix;

    /**
     * constructor
     *
     * @param  stubStreamFactory  $streamFactory
     * @param  string             $prefix
     */
    public function __construct(stubStreamFactory $streamFactory, $prefix)
    {
        $this->streamFactory = $streamFactory;
        $this->prefix        = $prefix;
    }

    /**
     * creates an input stream for given source
     *
     * @param   mixed                $source   source to create input stream from
     * @param   array<string,mixed>  $options  list of options for the input stream
     * @return  stubInputStream
     */
    public function createInputStream($source, array $options = array())
    {
        return $this->streamFactory->createInputStream($this->prefix . $source, $options);
    }

    /**
     * creates an output stream for given target
     *
     * @param   mixed                $target   target to create output stream for
     * @param   array<string,mixed>  $options  list of options for the output stream
     * @return  stubOutputStream
     */
    public function createOutputStream($target, array $options = array())
    {
        return $this->streamFactory->createOutputStream($this->prefix . $target, $options);
    }
}
?><?php
/**
 * Class for resource based input streams.
 *
 * @package     stubbles
 * @subpackage  streams
 * @version     $Id: stubResourceInputStream.php 2101 2009-02-13 13:38:17Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubInputStream',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::lang::exceptions::stubIllegalStateException',
                      'net::stubbles::lang::exceptions::stubIOException'
);
/**
 * Class for resource based input streams.
 *
 * @package     stubbles
 * @subpackage  streams
 */
abstract class stubResourceInputStream extends stubBaseObject implements stubInputStream
{
    /**
     * the descriptor for the stream
     *
     * @var  int
     */
    protected $handle;

    /**
     * sets the resource to be used
     *
     * @param   resource  $handle
     * @throws  stubIllegalArgumentException
     */
    protected function setHandle($handle)
    {
        if (is_resource($handle) === false) {
            throw new stubIllegalArgumentException('Handle needs to be a stream resource.');
        }

        $this->handle = $handle;
    }

    /**
     * reads given amount of bytes
     *
     * @param   int     $length  optional  max amount of bytes to read
     * @return  string
     * @throws  stubIllegalStateException
     * @throws  stubIOException
     */
    public function read($length = 8192)
    {
        if (null === $this->handle) {
            throw new stubIllegalStateException('Can not read from closed input stream.');
        }

        $data = @fread($this->handle, $length);
        if (false === $data) {
            if (@feof($this->handle) === false) {
                throw new stubIOException('Can not read from input stream.');
            }
            
            return '';
        }

        return $data;
    }

    /**
     * reads given amount of bytes or until next line break and removes line break
     *
     * @param   int     $length  optional  max amount of bytes to read
     * @return  string
     * @throws  stubIllegalStateException
     * @throws  stubIOException
     */
    public function readLine($length = 8192)
    {
        if (null === $this->handle) {
            throw new stubIllegalStateException('Can not read from closed input stream.');
        }

        $data = @fgets($this->handle, $length);
        if (false === $data) {
            if (@feof($this->handle) === false) {
                throw new stubIOException('Can not read from input stream.');
            }
            
            return '';
        }

        return rtrim($data, "\r\n");
    }

    /**
     * returns the amount of bytes left to be read
     *
     * @return  int
     * @throws  stubIllegalStateException
     */
    public function bytesLeft()
    {
        if (null === $this->handle || is_resource($this->handle) === false) {
            throw new stubIllegalStateException('Can not read from closed input stream.');
        }

        $bytesRead = ftell($this->handle);
        if (is_int($bytesRead) === false) {
            return 0;
        }

        return $this->getResourceLength() - $bytesRead;
    }

    /**
     * returns true if the stream pointer is at EOF
     *
     * @return  bool
     */
    public function eof()
    {
        return feof($this->handle);
    }

    /**
     * helper method to retrieve the length of the resource
     *
     * Not all stream wrappers support (f)stat - the extending class then
     * needs to take care to deliver the correct resource length then.
     *
     * @return  int
     */
    protected function getResourceLength()
    {
        $fileData = fstat($this->handle);
        return $fileData['size'];
    }

    /**
     * closes the stream
     */
    public function close()
    {
        if (null !== $this->handle) {
            fclose($this->handle);
            $this->handle = null;
        }
    }
}
?><?php
/**
 * Class for resource based output streams.
 *
 * @package     stubbles
 * @subpackage  streams
 * @version     $Id: stubResourceOutputStream.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubOutputStream',
                      'net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::lang::exceptions::stubIllegalStateException',
                      'net::stubbles::lang::exceptions::stubIOException'
);
/**
 * Class for resource based output streams.
 *
 * @package     stubbles
 * @subpackage  streams
 */
abstract class stubResourceOutputStream extends stubBaseObject implements stubOutputStream
{
    /**
     * the descriptor for the stream
     *
     * @var  int
     */
    protected $handle;

    /**
     * sets the resource to be used
     *
     * @param   resource  $handle
     * @throws  stubIllegalArgumentException
     */
    protected function setHandle($handle)
    {
        if (is_resource($handle) === false) {
            throw new stubIllegalArgumentException('Handle needs to be a stream resource.');
        }
        
        $this->handle = $handle;
    }

    /**
     * writes given bytes
     *
     * @param   string  $bytes
     * @return  int     amount of written bytes
     * @throws  stubIllegalStateException
     * @throws  stubIOException
     */
    public function write($bytes)
    {
        if (null === $this->handle) {
            throw new stubIllegalStateException('Can not write to closed output stream.');
        }
        
        $length = @fwrite($this->handle, $bytes);
        if (false === $length) {
            throw new stubIOException('Can not write to output stream.');
        }
        
        return $length;
    }

    /**
     * writes given bytes and appends a line break
     *
     * @param   string  $bytes
     * @return  int     amount of written
     */
    public function writeLine($bytes)
    {
        return $this->write($bytes . "\r\n");
    }

    /**
     * closes the stream
     */
    public function close()
    {
        if (null !== $this->handle) {
            fclose($this->handle);
            $this->handle = null;
        }
    }
}
?><?php
/**
 * A seekable stream may be altered in its position to read data.
 *
 * @package     stubbles
 * @subpackage  streams
 * @version     $Id: stubSeekable.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * A seekable stream may be altered in its position to read data.
 *
 * @package     stubbles
 * @subpackage  streams
 */
interface stubSeekable extends stubObject
{
    /**
     * set position equal to offset  bytes
     */
    const SET     = SEEK_SET;
    /**
     * set position to current location plus offset
     */
    const CURRENT = SEEK_CUR;
    /**
     * set position to end-of-file plus offset
     */
    const END     = SEEK_END;

    /**
     * seek to given offset
     *
     * @param  int  $offset
     * @param  int  $whence  one of stubSeekable::SET, stubSeekable::CURRENT or stubSeekable::END
     */
    public function seek($offset, $whence = stubSeekable::SET);

    /**
     * return current position
     *
     * @return  int
     */
    public function tell();
}
?><?php
/**
 * Interface for stream factories.
 *
 * @package     stubbles
 * @subpackage  streams
 * @version     $Id: stubStreamFactory.php 2324 2009-09-16 11:50:14Z mikey $
 */
stubClassLoader::load('net::stubbles::streams::stubInputStream',
                      'net::stubbles::streams::stubOutputStream'
);
/**
 * Interface for stream factories.
 *
 * @package     stubbles
 * @subpackage  streams
 */
interface stubStreamFactory extends stubObject
{
    /**
     * creates an input stream for given source
     *
     * @param   mixed                $source   source to create input stream from
     * @param   array<string,mixed>  $options  list of options for the input stream
     * @return  stubInputStream
     */
    public function createInputStream($source, array $options = array());

    /**
     * creates an output stream for given target
     *
     * @param   mixed                $target   target to create output stream for
     * @param   array<string,mixed>  $options  list of options for the output stream
     * @return  stubOutputStream
     */
    public function createOutputStream($target, array $options = array());
}
?><?php
/**
 * This class gives you more power!
 * 
 * @package     stubbles
 * @subpackage  util
 * @version     $Id: Binford.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::interceptors::stubPostInterceptor',
                      'net::stubbles::ipo::request::filter::stubFilter',
                      'net::stubbles::ipo::request::validator::stubValidator',
                      'net::stubbles::ipo::response::stubResponse'
);
/**
 * This class gives you more power!
 * 
 * @package     stubbles
 * @subpackage  util
 * @see         http://binford.de/
 */
final class Binford extends stubBaseObject implements stubValidator, stubFilter, stubPostInterceptor
{
    /**
     * this is the power of this class
     */
    const POWER = 6100;
    
    /**
     * validate the given value
     *
     * @param   mixed  $value
     * @return  bool   true if value is ok, else false
     */
    public function validate($value)
    {
        if (self::POWER == $value || 'Binford' == $value || ('Binford ' . self::POWER) == $value) {
            return true;
        }
        
        return false;
    }
    
    /**
     * returns a list of criteria for the validator
     *
     * <code>
     * array('allowedValues' => array(6100, 'Binford', 'Binford 6100');
     * </code>
     * 
     * @return  array<string,mixed>  key is criterion name, value is criterion value
     */
    public function getCriteria()
    {
        return array('allowedValues' => array(self::POWER, 'Binford', 'Binford ' . self::POWER));
    }

    /**
     * execute the filter
     *
     * @param   mixed                $value  value to filter
     * @return  mixed                filtered value
     * @throws  stubFilterException  in case $value has errors
     */
    public function execute($value)
    {
        if ($this->validate($value) == true) {
            return $value;
        }
        
        return $this->getDefaultValue();
    }


    /**
     * returns a default value in case the value to filter is not set
     *
     * @return  mixed
     */
    public function getDefaultValue()
    {
        return 'Binford ' . self::POWER;
    }

    /**
     * does the postprocessing stuff
     *
     * @param  stubRequest   $request   access to request data
     * @param  stubSession   $session   access to session data
     * @param  stubResponse  $response  access to response data
     */
    public function postProcess(stubRequest $request, stubSession $session, stubResponse $response)
    {
        $response->addHeader('X-Binford', self::POWER);
    }
    
    /**
     * returns a unique hash code for the class
     *
     * @return  string
     */
    public function hashCode()
    {
        return self::POWER;
    }
    
    /**
     * checks whether a value is equal to the class
     *
     * @param   mixed  $compare
     * @return  bool
     */
    public function equals($compare)
    {
        if ($compare instanceof self) {
            return true;
        }
        
        return false;
    }
    
    /**
     * returns a string representation of the class
     * 
     * The result is a short but informative representation about the class and
     * its values.
     * <code>
     * net::stubbles::util::Binford {
     *     POWER(integer): 6100
     * }
     * </code>
     *
     * @return  string
     */
    public function __toString()
    {
        return $this->getClassName() . " {\n    POWER(integer): " . self::POWER . "\n}\n";
    }
}
?><?php
/**
 * Binding module for cache containers.
 *
 * @package     stubbles
 * @subpackage  util_cache_ioc
 * @version     $Id: stubCacheBindingModule.php 2489 2010-01-25 20:29:28Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::module::stubBindingModule',
                      'net::stubbles::util::cache::stubDefaultCacheStrategy'
);
/**
 * Binding module for cache containers.
 *
 * @package     stubbles
 * @subpackage  util_cache_ioc
 */
class stubCacheBindingModule extends stubBaseObject implements stubBindingModule
{
    /**
     * path to cache directory
     *
     * @var  string
     */
    protected $cachePath;
    /**
     * cache strategy to be used
     *
     * @var  stubCacheStrategy
     */
    protected $cacheStrategy;
    /**
     * provider class for creating the cache container instances
     *
     * @var  string
     */
    protected $cacheContainerProviderClass = 'net::stubbles::util::cache::ioc::stubCacheProvider';
    /**
     * configure values for default cache strategy
     *
     * @var  array<string,double>
     */
    protected $defaultStrategyValues       = array('ttl'           => 86400,
                                                   'maxSize'       => -1,
                                                   'gcProbability' => 10
                                             );

    /**
     * constructor
     *
     * Please note that the cache path is only optional if it is bound by
     * another module.
     *
     * @param  string  $cachePath                    optional  path to cache directory
     * @param  string  $cacheContainerProviderClass  optional  provider implementation which creates cache container instances
     */
    public function __construct($cachePath = null, $cacheContainerProviderClass = null)
    {
        if (null != $cachePath) {
            $this->cachePath = $cachePath;
        }
        
        if (null != $cacheContainerProviderClass) {
            $this->cacheContainerProviderClass = $cacheContainerProviderClass;
        }
    }

    /**
     * static constructor
     *
     * Please note that the cache path is only optional if it is bound by
     * another module.
     *
     * @param   string                  $cachePath                    optional  path to cache directory
     * @param   string                  $cacheContainerProviderClass  optional  provider implementation which creates cache container instances
     * @return  stubCacheBindingModule
     */
    public static function create($cachePath = null, $cacheContainerProviderClass = null)
    {
        return new self($cachePath, $cacheContainerProviderClass);
    }

    /**
     * sets cache strategy to be used
     *
     * @param   stubCacheStrategy       $cacheStrategy
     * @return  stubCacheBindingModule
     */
    public function setCacheStrategy(stubCacheStrategy $cacheStrategy)
    {
        $this->cacheStrategy = $cacheStrategy;
        return $this;
    }

    /**
     * sets config values for default cache strategy
     *
     * @param   int                     $ttl            maximum time to live for cache entries
     * @param   int                     $maxSize        maximum size of cache in bytes (-1 means indefinite)
     * @param   double                  $gcProbability  probability of a garbage collection run between 0 and 1
     * @return  stubCacheBindingModule
     */
    public function setDefaultStrategyValues($ttl, $maxSize, $gcProbability)
    {
        $this->defaultStrategyValues['ttl']           = $ttl;
        $this->defaultStrategyValues['maxSize']       = $maxSize;
        $this->defaultStrategyValues['gcProbability'] = $gcProbability;
        return $this;
    }

    /**
     * configure the binder
     *
     * @param  stubBinder  $binder
     */
    public function configure(stubBinder $binder)
    {
        if (null != $this->cachePath) {
            $binder->bindConstant()
                   ->named('net.stubbles.cache.path')
                   ->to($this->cachePath);
        }
        
        $binder->bind('stubCacheStrategy')
               ->toInstance($this->createStrategy());
        $binder->bind('stubCacheContainer')
               ->toProviderClass($this->cacheContainerProviderClass);
    }

    /**
     * creates the cache strategy to be used
     *
     * @return  stubCacheStrategy
     */
    protected function createStrategy()
    {
        if (null !== $this->cacheStrategy) {
            return $this->cacheStrategy;
        }

        $this->cacheStrategy = new stubDefaultCacheStrategy();
        return $this->cacheStrategy->setTimeToLive($this->defaultStrategyValues['ttl'])
                                   ->setMaxCacheSize($this->defaultStrategyValues['maxSize'])
                                   ->setGcProbability($this->defaultStrategyValues['gcProbability']);
    }
}
?><?php
/**
 * Provider for cache containers.
 *
 * @package     stubbles
 * @subpackage  util_cache_ioc
 * @version     $Id: stubCacheProvider.php 2490 2010-01-25 20:53:20Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjectionProvider',
                      'net::stubbles::util::cache::stubCacheStrategy',
                      'net::stubbles::util::cache::stubFileCacheContainer'
);
/**
 * Provider for cache containers.
 *
 * @package     stubbles
 * @subpackage  util_cache_ioc
 */
class stubCacheProvider extends stubBaseObject implements stubInjectionProvider
{
    /**
     * default name
     */
    const DEFAULT_NAME        = '__default';
    /**
     * default cache strategy to be used
     *
     * @var  stubCacheStrategy
     */
    protected $cacheStrategy;
    /**
     * directory to store cache files
     *
     * @var  string
     */
    protected $cachePath;
    /**
     * list of available cache containers
     *
     * @var  array<string,stubCacheContainer>
     */
    protected $cacheContainer = array();
    /**
     * mode for new files and directories
     *
     * @var  int
     */
    protected $fileMode       = 0700;

    /**
     * constructor
     *
     * Please make sure that the given directory does exist.
     *
     * @param  stubCacheStrategy  $strategy   strategy regarding caching
     * @param  string             $cachePath  where to store cache files
     * @Inject
     * @Named{cachePath}('net.stubbles.cache.path')
     */
    public function __construct(stubCacheStrategy $strategy, $cachePath)
    {
        $this->strategy  = $strategy;
        $this->cachePath = $cachePath;
    }

    /**
     * sets the mode for new files and directories
     *
     * @param   int                $fileMode
     * @return  stubCacheProvider
     * @Inject(optional=true)
     * @Named('net.stubbles.util.cache.filemode')
     */
    public function setFileMode($fileMode)
    {
        $this->fileMode = $fileMode;
        return $this;
    }

    /**
     * returns the requested cache container
     *
     * If no special cache container is requested or the cache container with
     * the requested name does not exist it will try to return the default
     * cache container.
     *
     * @param   string              $name  optional  name of requested cache container
     * @return  stubCacheContainer
     */
    public function get($name = null)
    {
        if (null == $name) {
            $name      = self::DEFAULT_NAME;
            $cachePath = $this->cachePath;
        } else {
            $cachePath = $this->cachePath . DIRECTORY_SEPARATOR . $name;
        }
        
        if (isset($this->cacheContainer[$name]) === false) {
            $this->cacheContainer[$name] = new stubFileCacheContainer($this->strategy,
                                                                      $cachePath,
                                                                      $this->fileMode
                                           );
        }
        
        return $this->cacheContainer[$name]->gc();
    }
}
?><?php
/**
 * Abstract base class for cache containers.
 *
 * @package     stubbles
 * @subpackage  util_cache
 * @version     $Id: stubAbstractCacheContainer.php 2060 2009-01-26 12:57:25Z mikey $
 */
stubClassLoader::load('net::stubbles::util::cache::stubCacheContainer');
/**
 * Abstract base class for cache containers.
 *
 * @package     stubbles
 * @subpackage  util_cache
 */
abstract class stubAbstractCacheContainer extends stubBaseObject implements stubCacheContainer
{
    /**
     * the strategy used for decisions about caching
     *
     * @var  stubCacheStrategy
     */
    protected $strategy;
    /**
     * unix timestamp when last run of garbage collection happened
     *
     * @var  int
     */
    protected $lastGcRun = null;

    /**
     * puts date into the cache
     *
     * Returns amount of cached bytes or false if caching failed.
     *
     * @param   string    $key   key under which the data should be stored
     * @param   string    $data  data that should be cached
     * @return  int|bool
     */
    public function put($key, $data)
    {
        if ($this->strategy->isCachable($this, $key, $data) === false) {
            return false;
        }
        
        return $this->doPut($key, $data);
    }

    /**
     * puts date into the cache
     *
     * Returns amount of cached bytes or false if caching failed.
     *
     * @param   string    $key   key under which the data should be stored
     * @param   string    $data  data that should be cached
     * @return  int|bool
     */
    protected abstract function doPut($key, $data);

    /**
     * checks whether data is cached under the given key
     *
     * @param   string  $key
     * @return  bool
     */
    public function has($key)
    {
        if ($this->strategy->isExpired($this, $key) === true) {
            return false;
        }
        
        return $this->doHas($key);
    }

    /**
     * checks whether data is cached under the given key
     *
     * @param   string  $key
     * @return  bool
     */
    protected abstract function doHas($key);

    /**
     * checks whether cache data is expired
     *
     * @param   string  $key   key under which the data is stored
     * @return  bool
     */
    public function isExpired($key)
    {
        return $this->strategy->isExpired($this, $key);
    }

    /**
     * fetches data from the cache
     * 
     * Returns null if no data is cached under the given key.
     *
     * @param   string  $key
     * @return  string
     */
    public function get($key)
    {
        if ($this->strategy->isExpired($this, $key) === true) {
            return null;
        }
        
        return $this->doGet($key);
    }

    /**
     * fetches data from the cache
     * 
     * Returns null if no data is cached under the given key.
     *
     * @param   string  $key
     * @return  string
     */
    protected abstract function doGet($key);

    /**
     * returns the allocated space of the data associated with $key in bytes
     *
     * @param   string  $key
     * @return  int
     */
    public function getSize($key)
    {
        if ($this->has($key) === true) {
            return $this->doGetSize($key);
        }
        
        return 0;
    }
    
    /**
     * returns the allocated space of the data associated with $key in bytes
     *
     * @param   string  $key
     * @return  int
     */
    protected abstract function doGetSize($key);

    /**
     * returns the unix timestamp of the last run of the garbage collection
     *
     * @return  int
     */
    public function lastGcRun()
    {
        return $this->lastGcRun;
    }

    /**
     * runs the garbage collection
     *
     * @return  stubCacheContainer
     */
    public function gc()
    {
        if ($this->strategy->shouldRunGc($this) === true) {
            $this->doGc();
            $this->lastGcRun = time();
        }
        
        return $this;
    }

    /**
     * runs the garbage collection
     */
    protected abstract function doGc();
}
?><?php
/**
 * Interface for cache containers.
 *
 * @package     stubbles
 * @subpackage  util_cache
 * @version     $Id: stubCacheContainer.php 2491 2010-01-25 20:59:40Z mikey $
 */
stubClassLoader::load('net::stubbles::util::cache::stubCacheStrategy');
/**
 * Interface for cache containers.
 *
 * @package     stubbles
 * @subpackage  util_cache
 * @ProvidedBy(net::stubbles::util::cache::ioc::stubCacheProvider.class)
 */
interface stubCacheContainer extends stubObject
{
    /**
     * puts date into the cache
     *
     * Returns amount of cached bytes or false if caching failed.
     *
     * @param   string    $key   key under which the data should be stored
     * @param   string    $data  data that should be cached
     * @return  int|bool
     */
    public function put($key, $data);

    /**
     * checks whether data is cached under the given key
     *
     * @param   string  $key
     * @return  bool
     */
    public function has($key);

    /**
     * checks whether cache data is expired
     *
     * @param   string  $key   key under which the data is stored
     * @return  bool
     */
    public function isExpired($key);

    /**
     * fetches data from the cache
     * 
     * Returns null if no data is cached under the given key.
     *
     * @param   string  $key
     * @return  string
     */
    public function get($key);

    /**
     * returns the time in seconds how long the data associated with $key is cached
     *
     * @param   string  $key
     * @return  int
     */
    public function getLifeTime($key);

    /**
     * returns the timestamp when data associated with $key is cached
     *
     * @param   string  $key
     * @return  int
     */
    public function getStoreTime($key);

    /**
     * returns the allocated space of the data associated with $key in bytes
     *
     * @param   string  $key
     * @return  int
     */
    public function getSize($key);

    /**
     * returns the amount of bytes the cache data requires
     *
     * @return  int
     */
    public function getUsedSpace();

    /**
     * returns a list of all keys that are stored in the cache
     *
     * @return  array<string>
     */
    public function getKeys();

    /**
     * returns the unix timestamp of the last run of the garbage collection
     *
     * @return  int
     */
    public function lastGcRun();

    /**
     * runs the garbage collection
     *
     * @return  stubCacheContainer
     */
    public function gc();
}
?><?php
/**
 * Interface for caching strategies.
 *
 * @package     stubbles
 * @subpackage  util_cache
 * @version     $Id: stubCacheStrategy.php 2489 2010-01-25 20:29:28Z mikey $
 */
stubClassLoader::load('net::stubbles::util::cache::stubCacheContainer');
/**
 * Interface for caching strategies.
 *
 * @package     stubbles
 * @subpackage  util_cache
 * @ImplementedBy(net::stubbles::util::cache::stubDefaultCacheStrategy.class)
 */
interface stubCacheStrategy extends stubObject
{
    /**
     * checks whether an item is cacheable or not
     *
     * @param   stubCacheContainer  $container  the container to cache the data in
     * @param   string              $key        the key to cache the data under
     * @param   string              $data       data to cache
     * @return  bool
     */
    public function isCachable(stubCacheContainer $container, $key, $data);

    /**
     * checks whether a cached item is expired
     *
     * @param   stubCacheContainer  $container  the container that contains the cached data
     * @param   string              $key        the key where the data is cached under
     * @return  bool
     */
    public function isExpired(stubCacheContainer $container, $key);

    /**
     * checks whether the garbage collection should be run
     *
     * @param   stubCacheContainer $container
     * @return  bool
     */
    public function shouldRunGc(stubCacheContainer $container);
}
?><?php
/**
 * Default caching strategy.
 *
 * @package     stubbles
 * @subpackage  util_cache
 * @version     $Id: stubDefaultCacheStrategy.php 2492 2010-01-25 21:08:15Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::util::cache::stubCacheContainer'
);
/**
 * Default caching strategy.
 *
 * @package     stubbles
 * @subpackage  util_cache
 */
class stubDefaultCacheStrategy extends stubBaseObject implements stubCacheStrategy
{
    /**
     * time to live for single cached data
     *
     * @var  int
     */
    protected $timeToLive    = 86400;
    /**
     * maximum size of cache
     * 
     * To allow an infinite size set this to -1.
     *
     * @var  string
     */
    protected $maxSize       = -1;
    /**
     * probability of a garbage collection run
     * 
     * Should be a value between 0 and 100 where 0 means never and 100 means always.
     *
     * @var  int
     */
    protected $gcProbability = 10;

    /**
     * sets the time to live for cache entries in seconds
     *
     * @param   int                       $timeToLive
     * @return  stubDefaultCacheStrategy
     * @throws  stubIllegalArgumentException
     * @since   1.1.0
     * @Inject(optional=true)
     * @Named('net.stubbles.util.cache.timeToLive')
     */
    public function setTimeToLive($timeToLive)
    {
        settype($timeToLive, 'integer');
        if (0 > $timeToLive) {
            throw new stubIllegalArgumentException('timeToLive should not be negative');
        }

        $this->timeToLive = $timeToLive;
        return $this;
    }

    /**
     * sets the maximum cache size in bytes
     *
     * Setting the size to -1 means unlimited.
     *
     * @param   int                       $maxSize
     * @return  stubDefaultCacheStrategy
     * @since   1.1.0
     * @Inject(optional=true)
     * @Named('net.stubbles.util.cache.maxSize')
     */
    public function setMaxCacheSize($maxSize)
    {
        $this->maxSize = (int) $maxSize;
        return $this;
    }

    /**
     * sets the probability of a garbage collection run
     *
     * @param   int                       $gcProbability  probability that a garbage collection is run, between 0 and 100
     * @return  stubDefaultCacheStrategy
     * @throws  stubIllegalArgumentException
     * @since   1.1.0
     * @Inject(optional=true)
     * @Named('net.stubbles.util.cache.gcProbability')
     */
    public function setGcProbability($gcProbability)
    {
        settype($gcProbability, 'integer');
        if (0 > $gcProbability || 100 < $gcProbability) {
            throw new stubIllegalArgumentException('gcProbability must be between 0 and 100');
        }

        $this->gcProbability = $gcProbability;
        return $this;
    }

    /**
     * checks whether an item is cacheable or not
     *
     * @param   stubCacheContainer  $container  the container to cache the data in
     * @param   string              $key        the key to cache the data under
     * @param   string              $data       data to cache
     * @return  bool
     */
    public function isCachable(stubCacheContainer $container, $key, $data)
    {
        if (-1 == $this->maxSize) {
            return true;
        }
        
        if (($container->getUsedSpace() + strlen($data) - $container->getSize($key)) > $this->maxSize) {
            return false;
        }
        
        return true;
    }

    /**
     * checks whether a cached item is expired
     *
     * @param   stubCacheContainer  $container  the container that contains the cached data
     * @param   string              $key        the key where the data is cached under
     * @return  bool
     */
    public function isExpired(stubCacheContainer $container, $key)
    {
        return ($container->getLifeTime($key) > $this->timeToLive);
    }

    /**
     * checks whether the garbage collection should be run
     *
     * @param   stubCacheContainer  $container
     * @return  bool
     */
    public function shouldRunGc(stubCacheContainer $container)
    {
        if (rand(1, 100) < $this->gcProbability) {
            return true;
        }
        
        return false;
    }
}
?><?php
/**
 * Cache container using files.
 *
 * @package     stubbles
 * @subpackage  util_cache
 * @version     $Id: stubFileCacheContainer.php 2124 2009-03-06 15:14:54Z mikey $
 */
stubClassLoader::load('net::stubbles::util::cache::stubAbstractCacheContainer',
                      'net::stubbles::util::cache::stubCacheContainer'
);
/**
 * Cache container using files.
 *
 * @package     stubbles
 * @subpackage  util_cache
 */
class stubFileCacheContainer extends stubAbstractCacheContainer implements stubCacheContainer
{
    /**
     * the directory to store the cache files in
     *
     * @var  string
     */
    protected $cacheDirectory;
    /**
     * list of keys
     *
     * @var  array<string,string>
     */
    protected $keys           = null;
    /**
     * size of cache entries
     *
     * @var  array<string,int>
     */
    protected $size           = null;

    /**
     * constructor
     *
     * If the directory does exist it will be created with the given file mode.
     *
     * @param  stubCacheStrategy  $strategy        strategy regarding caching
     * @param  string             $cacheDirectory  where to store cache files
     * @param  int                $fileMode        optional  rights for caching directory
     */
    public function __construct(stubCacheStrategy $strategy, $cacheDirectory, $fileMode = 0700)
    {
        if (file_exists($cacheDirectory) === false) {
            mkdir($cacheDirectory, $fileMode, true);
        }
        
        $this->strategy       = $strategy;
        $this->cacheDirectory = $cacheDirectory;
    }

    /**
     * puts date into the cache
     * 
     * Returns amount of cached bytes or false if caching failed.
     *
     * @param   string    $key   key under which the data should be stored
     * @param   string    $data  data that should be cached
     * @return  int|bool
     */
    protected function doPut($key, $data)
    {
        $bytes = file_put_contents($this->getCacheFileName($key), $data);
        if (false === $bytes) {
            return false;
        }
        
        if (null !== $this->keys) {
            $this->keys[$key] = $key;
        }
        
        if (null !== $this->size) {
            $this->size[$key] = $bytes;
        }
        
        return $bytes;
    }

    /**
     * checks whether data is cached under the given key
     *
     * @param   string  $key
     * @return  bool
     */
    protected function doHas($key)
    {
        return file_exists($this->getCacheFileName($key));
    }

    /**
     * fetches data from the cache
     * 
     * Returns null if no data is cached under the given key.
     *
     * @param   string  $key
     * @return  string
     */
    protected function doGet($key)
    {
        if ($this->doHas($key) == true) {
            return file_get_contents($this->getCacheFileName($key));
        }
        
        return null;
    }

    /**
     * returns the time in seconds how long the data associated with $key is cached
     *
     * @param   string  $key
     * @return  int
     */
    public function getLifeTime($key)
    {
        if ($this->doHas($key) == true) {
            return (time() - filemtime($this->getCacheFileName($key)));
        }
        
        return 0;
    }

    /**
     * returns the timestamp when data associated with $key is cached
     *
     * @param   string  $key
     * @return  int
     */
    public function getStoreTime($key)
    {
        if ($this->doHas($key) == true) {
            return filemtime($this->getCacheFileName($key));
        }
        
        return 0;
    }

    /**
     * returns the allocated space of the data associated with $key in bytes
     *
     * @param   string  $key
     * @return  int
     */
    protected function doGetSize($key)
    {
        if (null !== $this->size) {
            return $this->size[$key];
        }
        
        return filesize($this->getCacheFileName($key));
    }

    /**
     * returns the amount of bytes the cache data requires
     *
     * @return  int
     */
    public function getUsedSpace()
    {
        if (null === $this->size) {
            $this->size = array();
            $dirIt      = new DirectoryIterator($this->cacheDirectory);
            foreach ($dirIt as $file) {
                if ($file->isDot() == true || $file->isDir() == true) {
                    continue;
                }
                
                $key              = str_replace('.cache', '', $file->getFilename());
                $this->size[$key] = filesize($this->cacheDirectory . DIRECTORY_SEPARATOR . $key . '.cache');
            }
        }
        
        return array_sum($this->size);
    }

    /**
     * returns a list of all keys that are stored in the cache
     *
     * @return  array<string>
     */
    public function getKeys()
    {
        if (null === $this->keys) {
            $this->keys  = array();
            $dirIt = new DirectoryIterator($this->cacheDirectory);
            foreach ($dirIt as $file) {
                if ($file->isDot() == true || $file->isDir() == true) {
                    continue;
                }
                
                $key = str_replace('.cache', '', $file->getFilename());
                if ($this->strategy->isExpired($this, $key) == true) {
                    continue;
                }
                
                $this->keys[$key] = $key;
            }
        } else {
            foreach ($this->keys as $key) {
                if ($this->strategy->isExpired($this, $key) == true) {
                    unset($this->keys[$key]);
                    if (null !== $this->size) {
                        unset($this->size[$key]);
                    }
                }
            }
        }
        
        return $this->keys;
    }

    /**
     * runs the garbage collection
     */
    protected function doGc()
    {
        $dirIt = new DirectoryIterator($this->cacheDirectory);
        foreach ($dirIt as $file) {
            if ($file->isDot() == true || $file->isDir() == true) {
                continue;
            }
            
            $key = str_replace('.cache', '', $file->getFilename());
            if ($this->strategy->isExpired($this, $key) == true) {
                unlink($this->cacheDirectory . DIRECTORY_SEPARATOR . $key . '.cache');
                if (null !== $this->size) {
                    unset($this->size[$key]);
                }
            }
        }
    }

    /**
     * returns name of the cache file for cache entry with given key
     *
     * @param   string  $key
     * @return  string
     */
    protected function getCacheFileName($key)
    {
        return $this->cacheDirectory . DIRECTORY_SEPARATOR . str_replace(DIRECTORY_SEPARATOR, '', $key) . '.cache';
    }
}
?><?php
/**
 * Interface for the date span classes.
 *
 * @package     stubbles
 * @subpackage  util_datespan
 * @version     $Id: stubDateSpan.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::types::stubDate');
/**
 * Interface for the date span classes.
 *
 * @package     stubbles
 * @subpackage  util_datespan
 */
interface stubDateSpan extends stubObject, stubSerializable
{
    /**
     * datespan interval: day
     */
    const INTERVAL_DAY   = 'day';
    /**
     * datespan interval: week
     */
    const INTERVAL_WEEK  = 'week';
    /**
     * datespan interval: month
     */
    const INTERVAL_MONTH = 'month';

    /**
     * returns the start date
     *
     * @return  stubDate
     */
    public function getStartDate();

    /**
     * returns the end date
     *
     * @return  stubDate
     */
    public function getEndDate();

    /**
     * returns the spans between the start date and the end date
     *
     * @return  array<stubDateSpan>
     */
    public function getDateSpans();

    /**
     * returns a string representation of the date object
     *
     * @return  string
     */
    public function asString();

    /**
     * checks whether the DateSpan is in the future
     *
     * @return  bool
     */
    public function isFuture();

    /**
     * checks whether the span contains the given date
     *
     * @param   stubDate  $date
     * @return  bool
     */
    public function contains(stubDate $date);
}
?><?php
/**
 * Datespan with a custom start and end date.
 *
 * @package     stubbles
 * @subpackage  util_datespan
 * @version     $Id: stubDateSpanCustom.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::util::datespan::stubDateSpan');
/**
 * Datespan with a custom start and end date.
 *
 * @package     stubbles
 * @subpackage  util_datespan
 */
class stubDateSpanCustom extends stubSerializableObject implements stubDateSpan
{
    /**
     * start date of the span
     *
     * @var  stubDate
     */
    protected $from;
    /**
     * end date of the span
     *
     * @var  stubDate
     */
    protected $to;
    /**
     * The interval of the span (e.g. day, week, month)
     *
     * @var  string
     * @see  DateSpan::INTERVAL_*
     */
    protected $interval;

    /**
     * constructor
     *
     * @param  string|stubDate  $from      start date of the span
     * @param  string|stubDate  $to        end date of the span
     * @param  string           $interval  optional  interval of the span
     */
    public function __construct($from, $to, $interval = stubDateSpan::INTERVAL_DAY)
    {
        if (($from instanceof stubDate) === false) {
            $from = new stubDate($from);
        }

        if (($to instanceof stubDate) === false) {
            $to = new stubDate($to);
        }

        $this->from     = $from;
        $this->to       = $to;
        $this->interval = $interval;
    }

    /**
     * returns the start date
     *
     * @return  stubDate
     */
    public function getStartDate()
    {
        return $this->from;
    }

    /**
     * returns the end date
     *
     * @return  stubDate
     */
    public function getEndDate()
    {
        return $this->to;
    }

    /**
     * returns the spans between the start date and the end date
     *
     * @return  array<stubDateSpan>
     */
    public function getDateSpans()
    {
        $spans = array();
        switch ($this->interval) {
            case stubDateSpan::INTERVAL_DAY:
                stubClassLoader::load('net::stubbles::util::datespan::stubDateSpanDay');
                $day   = $this->from;
                $end   = $this->to->format('U');
                while ($day->format('U') <= $end) {
                    $spans[] = new stubDateSpanDay(clone $day);
                    $day = $day->changeTo('+1 day');
                }
                break;

            case stubDateSpan::INTERVAL_WEEK:
                stubClassLoader::load('net::stubbles::util::datespan::stubDateSpanWeek');
                $day   = $this->from;
                $end   = $this->to->format('U');
                while ($day->format('U') <= $end) {
                    $spans[] = new stubDateSpanWeek(clone $day);
                    $day = $day->changeTo('+7 days');
                }
                break;

            case stubDateSpan::INTERVAL_MONTH:
                stubClassLoader::load('net::stubbles::util::datespan::stubDateSpanMonth');
                $day = $this->from;
                $end = $this->to->format('U');
                while ($day->format('U') <= $end) {
                    $spans[] = new stubDateSpanMonth($day->format('Y'), $day->format('m'));
                    $day = $day->changeTo('+1 month');
                }
                break;

            default:
                // intentionally empty
        }

        return $spans;
    }

    /**
     * returns a string representation of the date object
     *
     * @return  string
     */
    public function asString()
    {
        return $this->from->format('d.m.Y') . ' - ' . $this->to->format('d.m.Y');
    }

    /**
     * checks whether the DateSpan is in the future
     *
     * @return  bool
     */
    public function isFuture()
    {
        $today = mktime(23, 59, 59, date('m'), date('d'), date('Y'));
        if ($this->from->format('U') > $today) {
            return true;
        }

        return false;
    }

    /**
     * checks whether the span contains the given date
     *
     * @param   stubDate  $date
     * @return  bool
     */
    public function contains(stubDate $date)
    {
        if ($this->from->isBefore($date) === false && $this->from->equals($date) === false) {
            return false;
        }

        if ($this->to->isAfter($date) === false && $this->to->equals($date) === false) {
            return false;
        }

        return true;
    }

    /**
     * takes care of serializing the value
     *
     * @param  array   &$propertiesToSerialize  list of properties to serialize
     * @param  string  $name                    name of the property to serialize
     * @param  mixed   $value                   value to serialize
     */
    protected function __doSerialize(&$propertiesToSerialize, $name, $value)
    {
        if ('from' == $name || 'to' == $name) {
            $this->_serializedProperties[$name] = $value->format('c');
            return;
        }

        parent::__doSerialize($propertiesToSerialize, $name, $value);
    }

    /**
     * takes care of unserializing the value
     *
     * @param  string  $name             name of the property
     * @param  mixed   $serializedValue  value of the property
     */
    protected function __doUnserialize($name, $serializedValue)
    {
        if ('from' == $name || 'to' == $name) {
            $this->$name = new stubDate($serializedValue);
            return;
        }

        parent::__doUnserialize($name, $serializedValue);
    }
}
?><?php
/**
 * Datespan that represents a single day.
 *
 * @package     stubbles
 * @subpackage  util_datespan
 * @version     $Id: stubDateSpanDay.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::util::datespan::stubDateSpanCustom');
/**
 * Datespan that represents a single day.
 *
 * @package     stubbles
 * @subpackage  util_datespan
 */
class stubDateSpanDay extends stubDateSpanCustom implements stubDateSpan
{
    /**
     * constructor
     *
     * @param  string|stubDate  $day  optional  day that the span covers
     */
    public function __construct($day = null)
    {
        if (null === $day) {
            $day = stubDate::now();
        } elseif ('yesterday' === $day) {
            $day = new stubDate($day);
        }

        parent::__construct($day, $day);
    }

    /**
     * returns the spans between the start date and the end date
     *
     * @return  array<stubDateSpan>
     */
    public function getDateSpans()
    {
        return array($this);
    }

    /**
     * returns a string representation of the date object
     *
     * @return  string
     */
    public function asString()
    {
        return $this->from->format('l, d.m.Y');
    }
}
?><?php
/**
 * Datespan that represents a month.
 *
 * @package     stubbles
 * @subpackage  util_datespan
 * @version     $Id: stubDateSpanMonth.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::util::datespan::stubDateSpanCustom');
/**
 * Datespan that represents a month.
 *
 * @package     stubbles
 * @subpackage  util_datespan
 */
class stubDateSpanMonth extends stubDateSpanCustom implements stubDateSpan
{
    /**
     * constructor
     *
     * If no value for the year is supplied the current year will be used.
     *
     * If no value for the month is supplied the current month will be used.
     * However, if the current day is the first of a month, the datespan will
     * cover the last month. If today is the first of january, then the
     * datespan will cover the december of last year.
     *
     * @param  int     $year      optional  year of the span
     * @param  int     $month     optional  month of the span
     * @param  string  $interval  optional  interval of the span
     */
    public function __construct($year = null, $month = null, $interval = stubDateSpan::INTERVAL_DAY)
    {
        if (null === $year) {
            $year = (int) date('Y');
        }

        if (null === $month) {
            $month = (int) date('m');
            $day   = (int) date('d');
            // if today is first day of the month use previous month
            if (1 === $day) {
                // if month is January set $month to December of the last year, else decrease month
                if (1 === $month) {
                    $month = 12;
                    $year--;
                } else {
                    $month--;
                }
            }
        }

        $start = new DateTime();
        $start->setDate($year, $month, 1);
        $start->setTime(0, 0, 0);
        $end = new DateTime();
        $end->setDate($year, $month, $start->format('t'));
        $end->setTime(23, 59, 59);
        parent::__construct(new stubDate($start), new stubDate($end), $interval);
    }

    /**
     * returns a string representation of the date object
     *
     * @return  string
     */
    public function asString()
    {
        return $this->from->format('Y-m');
    }
}
?><?php
/**
 * Datespan that represents a week.
 *
 * @package     stubbles
 * @subpackage  util_datespan
 * @version     $Id: stubDateSpanWeek.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::util::datespan::stubDateSpanCustom');
/**
 * Datespan that represents a week.
 *
 * @package     stubbles
 * @subpackage  util_datespan
 */
class stubDateSpanWeek extends stubDateSpanCustom implements stubDateSpan
{
    /**
     * constructor
     *
     * @param  string|stubDate  $date      start date of the week
     * @param  string           $interval  optional  interval of the span
     */
    public function __construct($date, $interval = stubDateSpan::INTERVAL_DAY)
    {
        if (($date instanceof stubDate) == false) {
            $date = new stubDate($date);
        }

        $end = $date->changeTo('+ 6 days');
        parent::__construct($date, $end, $interval);
    }

    /**
     * returns a string representation of the date object
     *
     * @return  string
     */
    public function asString()
    {
        return $this->from->format('W');
    }
}
?><?php
/**
 * Datespan that represents yesterday.
 *
 * @package     stubbles
 * @subpackage  util_datespan
 * @version     $Id: stubDateSpanYesterday.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::util::datespan::stubDateSpanDay');
/**
 * Datespan that represents yesterday.
 *
 * @package     stubbles
 * @subpackage  util_datespan
 */
class stubDateSpanYesterday extends stubDateSpanDay
{
    /**
     * constructor
     */
    public function __construct()
    {
        parent::__construct('yesterday');
    }
}
?><?php
/**
 * Class loader that loads classes from PEAR.
 *
 * @package     stubbles
 * @subpackage  util_ext
 * @version     $Id: stubPearClassLoader.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Class loader that loads classes from PEAR.
 *
 * @package     stubbles
 * @subpackage  util_ext
 * @see         http://pear.php.net/
 */
class stubPearClassLoader extends stubBaseObject implements stubForeignClassLoader
{
    /**
     * namespace where this classloader is responsible for
     *
     * @var  string
     */
    protected $namespace = 'net::php::pear';

    /**
     * sets the namespace where this classloader is responsible for
     *
     * @param  string $namespace
     */
    public function setNamespace($namespace)
    {
        $this->namespace = $namespace;
    }
    
    /**
     * returns the namespace where this classloader is responsible for
     *
     * @return  string
     */
    public function getNamespace()
    {
        return $this->namespace;
    }
    
    /**
     * loads the given class
     *
     * @param   string  $fqClassName  the full qualified class name of the class to load
     * @throws  Exception
     */
    public function load($fqClassName)
    {
        $nqClassName = stubClassLoader::getNonQualifiedClassName($fqClassName);
        if (class_exists($nqClassName, false) == true) {
            return;
        }
        
        require str_replace('::', DIRECTORY_SEPARATOR, str_replace($this->namespace . '::', '', $fqClassName)) . '.php';
    }
}
?><?php
/**
 * Class loader that loads classes from the PHP-Tools project.
 *
 * @package     stubbles
 * @subpackage  util_ext
 * @version     $Id: stubPhpToolsClassLoader.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Class loader that loads classes from the PHP-Tools project.
 *
 * @package     stubbles
 * @subpackage  util_ext
 * @link        http://php-tools.net/
 */
class stubPhpToolsClassLoader extends stubBaseObject implements stubForeignClassLoader
{
    /**
     * namespace where this classloader is responsible for
     *
     * @var  string
     */
    protected $namespace = 'net::php-tools';
    /**
     * path to pat classes
     *
     * @var  string
     */
    protected $path;

    /**
     * constructor
     *
     * @param  string  $path  path to pat classes
     */
    public function __construct($path)
    {
        $this->path = $path;
    }

    /**
     * sets the namespace where this classloader is responsible for
     *
     * @param  string $namespace
     */
    public function setNamespace($namespace)
    {
        $this->namespace = $namespace;
    }
    
    /**
     * returns the namespace where this classloader is responsible for
     *
     * @return  string
     */
    public function getNamespace()
    {
        return $this->namespace;
    }
    
    /**
     * loads the given class
     *
     * @param   string  $fqClassName  the full qualified class name of the class to load
     * @throws  stubClassNotFoundException
     */
    public function load($fqClassName)
    {
        $nqClassName = stubClassLoader::getNonQualifiedClassName($fqClassName);
        if (class_exists($nqClassName, false) == true) {
            return;
        }
        
        $fileName = $this->path . DIRECTORY_SEPARATOR . str_replace('::', DIRECTORY_SEPARATOR, str_replace($this->namespace . '::', '', $fqClassName)) . '.php';
        if (file_exists($fileName) == false) {
            throw new stubClassNotFoundException($fqClassName, true);
        }
        
        require $fileName;
    }
}
?><?php
/**
 * A log appenders that writes log entries to files.
 *
 * @package     stubbles
 * @subpackage  util_log_appender
 * @version     $Id: stubFileLogAppender.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::util::log::appender::stubLogAppender');
/**
 * A log appenders that writes log entries to files.
 * 
 * This log appender writes the log entries into a logfile using the error_log()
 * function of PHP. The logfile name will be [target]-[Y-m-d].log where target
 * is the return value of stubLogEntry::getTarget().
 *
 * @package     stubbles
 * @subpackage  util_log_appender
 * @uses        http://php.net/error_log
 */
class stubFileLogAppender extends stubBaseObject implements stubLogAppender
{
    /**
     * the directory to write the logfiles into
     *
     * @var  string
     */
    protected $logDir = '';
    /**
     * mode for new directories
     *
     * @var  int
     */
    protected $mode   = 0700;

    /**
     * constructor
     *
     * @param  string  $logDir  optional  directory to write the logfiles into
     */
    public function __construct($logDir)
    {
        $this->logDir = $logDir;
    }

    /**
     * returns the directory to write the logfiles into
     *
     * @return  string
     */
    public function getLogDir()
    {
        return $this->logDir;
    }

    /**
     * sets the mode for new log directories
     *
     * @param   int                  $mode
     * @return  stubFileLogAppender
     */
    public function setMode($mode)
    {
        $this->mode = $mode;
        return $this;
    }

    /**
     * returns the mode for new log directories
     *
     * @return  int
     */
    public function getMode()
    {
        return $this->mode;
    }

    /**
     * append the log entry to the log file
     * 
     * The basename of the logfile will be [target]-[Y-m-d].log where target
     * is the return value of $logEntry->getTarget().
     *
     * @param   stubLogEntry     $logEntry
     * @return  stubLogAppender
     */
    public function append(stubLogEntry $logEntry)
    {
        if (file_exists($this->logDir) === false) {
            mkdir($this->logDir, $this->mode, true);
        }
        
        error_log($logEntry->get() . "\n",
                  3,
                  $this->logDir . DIRECTORY_SEPARATOR . $logEntry->getTarget() . '-' . date('Y-m-d') . '.log'
        );
        return $this;
    }

    /**
     * finalize the log target
     */
    public function finalize()
    {
        // nothing to do, therefore intentionelly left blank
    }
}
?><?php
/**
 * Interface for log appenders.
 *
  * @package     stubbles
 * @subpackage  util_log_appender
 * @version     $Id: stubLogAppender.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::util::log::stubLogEntry');
/**
 * Interface for log appenders.
 * 
 * A log appender takes log entries and writes them to the target. The target
 * can be a file, a database or anything else.
 *
 * @package     stubbles
 * @subpackage  util_log_appender
 */
interface stubLogAppender extends stubObject
{
    /**
     * append the log entry to the log target
     *
     * @param   stubLogEntry     $logEntry
     * @return  stubLogAppender
     */
    public function append(stubLogEntry $logEntry);

    /**
     * finalize the log target
     * 
     * This will be called in case a logger is destroyed and can be used
     * to close file or database handlers or to write the log data if
     * append() just collects the data.
     */
    public function finalize();
}
?><?php
/**
 * A log appenders that sends log data to a mail address.
 *
 * @package     stubbles
 * @subpackage  util_log_appender
 * @version     $Id: stubMailLogAppender.php 2060 2009-01-26 12:57:25Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubRuntimeException',
                      'net::stubbles::util::log::appender::stubLogAppender'
);
/**
 * A log appenders that sends log data to a mail address.
 *
 * This log appender writes the log data into a mail which will be send to
 * the configured mail address.
 *
 * @package     stubbles
 * @subpackage  util_log_appender
 */
class stubMailLogAppender extends stubBaseObject implements stubLogAppender
{
    /**
     * mail address to send the log data to
     *
     * @var  string
     */
    protected $mailAddress = null;
    /**
     * name to appear as sender
     *
     * @var  string
     */
    protected $senderName  = 'stubDebugger';
    /**
     * the collected log data
     *
     * @var  array<stubLogEntry>
     */
    protected $logEntries  = array();

    /**
     * constructor
     *
     * @param  string  $mailAddress  mail address to send the log data to
     * @param  string  $senderName   optional  name to appear as sender
     */
    public function __construct($mailAddress, $senderName = 'stubDebugger')
    {
        $this->mailAddress = $mailAddress;
        $this->senderName  = $senderName;
    }

    /**
     * returns mail address to send the log data to
     *
     * @return  string
     */
    public function getMailAddress()
    {
        return $this->mailAddress;
    }

    /**
     * returns name to appear as sender
     *
     * @return  string
     */
    public function getSenderName()
    {
        return $this->senderName;
    }

    /**
     * append the log data to the log target
     *
     * @param   stubLogEntry     $logEntry
     * @return  stubLogAppender
     */
    public function append(stubLogEntry $logEntry)
    {
        $this->logEntries[] = $logEntry;
        return $this;
    }

    /**
     * finalize the log target
     * 
     * @throws  stubRuntimeException
     */
    public function finalize()
    {
        if (count($this->logEntries) === 0) {
            return;
        }
        
        $body = '';
        foreach ($this->logEntries as $logEntry) {
            $body .= $logEntry->getTarget() . ': ' . $logEntry->get() . "\n\n";
        }
        
        $body .= sprintf("\nURL that caused this:\nhttp://%s%s?%s\n", $_SERVER['HTTP_HOST'], $_SERVER['PHP_SELF'], $_SERVER['QUERY_STRING']);
        if (isset($_SERVER['HTTP_REFERER']) === true) {
            $body .= sprintf("\nReferer:\n%s\n", $_SERVER['HTTP_REFERER']);
        }
        
        $this->sendMail('Debug message from ' . $_SERVER['HTTP_HOST'], $body);
    }

    /**
     * sends the mail
     *
     * @param  string  $subject  subject of the mail to send
     * @param  string  $body     body of the mail to send
     */
    // @codeCoverageIgnoreStart
    protected function sendMail($subject, $body)
    {
        mail($this->mailAddress, $subject, $body, 'FROM: ' . $this->senderName . ' <' . $this->mailAddress. '>');
    }
    // @codeCoverageIgnoreEnd
}
?><?php
/**
 * A log appenders that stores log entries in memory.
 *
 * @package     stubbles
 * @subpackage  util_log_appender
 * @version     $Id: stubMemoryLogAppender.php 2432 2009-12-28 18:14:55Z mikey $
 */
stubClassLoader::load('net::stubbles::util::log::appender::stubLogAppender');
/**
 * A log appenders that stores log entries in memory.
 *
 * @package     stubbles
 * @subpackage  util_log_appender
 */
class stubMemoryLogAppender extends stubBaseObject implements stubLogAppender
{
    /**
     * stores the logged entries and represents the storing medium (memory)
     *
     * @var  array<string,array<stubLogEntry>>
     */
    protected $logEntries = array();

    /**
     * counts log entries for a certain target
     *
     * @param   string  $target
     * @return  int
     * @since   1.1.0
     */
    public function countLogEntries($target)
    {
        if (isset($this->logEntries[$target]) === false) {
            return 0;
        }

        return count($this->logEntries[$target]);
    }

    /**
     * returns data of a certain log entry
     *
     * @param   string         $target
     * @param   int            $position
     * @return  array<string>
     * @since   1.1.0
     */
    public function getLogEntryData($target, $position)
    {
        if (isset($this->logEntries[$target]) === false) {
            return array();
        }

        if (isset($this->logEntries[$target][$position]) === false) {
            return array();
        }

        return $this->logEntries[$target][$position]->getData();
    }

    /**
     * returns list of log entries
     *
     * If a target is given only log entries of this target will be returned.
     *
     * @param   string                                                 $target  optional
     * @return  array<string,array<stubLogEntry>>|array<stubLogEntry>
     */
    public function getLogEntries($target = null)
    {
        if (null == $target) {
            return $this->logEntries;
        }

        if (isset($this->logEntries[$target]) === false) {
            return array();
        }

        return $this->logEntries[$target];
    }

    /**
     * stores log entry in memory
     *
     * @param   stubLogEntry     $logEntry
     * @return  stubLogAppender
     */
    public function append(stubLogEntry $logEntry)
    {
        $this->logEntries[$logEntry->getTarget()][] = $logEntry;
        return $this;
    }

    /**
     * finalize the log target
     */
    public function finalize()
    {
        $this->logEntries = array();
    }
}
?><?php
/**
 * Abstract base implementation of a log entry factory.
 *
 * @package     stubbles
 * @subpackage  util_log_entryfactory
 * @version     $Id: stubAbstractLogEntryFactory.php 2442 2010-01-11 16:33:44Z mikey $
 */
stubClassLoader::load('net::stubbles::util::log::entryfactory::stubLogEntryFactory');
/**
 * Abstract base implementation of a log entry factory.
 *
 * @package     stubbles
 * @subpackage  util_log_entryfactory
 * @since       1.1.0
 */
abstract class stubAbstractLogEntryFactory extends stubBaseObject implements stubLogEntryFactory
{
    /**
     * recreates given log entry
     *
     * @param   stubLogEntry  $logEntry
     * @param   stubLogger    $logger
     * @return  stubLogEntry
     */
    public function recreate(stubLogEntry $logEntry, stubLogger $logger)
    {
        return $logEntry;
    }
}
?><?php
/**
 * Default factory which create log entry containers.
 *
 * @package     stubbles
 * @subpackage  util_log_entryfactory
 * @version     $Id: stubDefaultLogEntryFactory.php 2438 2010-01-07 16:28:49Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::session::stubSession',
                      'net::stubbles::util::log::entryfactory::stubAbstractLogEntryFactory'
);
/**
 * Default factory which create log entry containers.
 *
 * Log entry containers returned by this factory already have some prefilled log
 * data: the current timestamp in format Y-m-d H:i:s as first entry, and the
 * session id of the current user, if available.
 *
 * @package     stubbles
 * @subpackage  util_log_entryfactory
 */
class stubDefaultLogEntryFactory extends stubAbstractLogEntryFactory
{
    /**
     * session instance
     *
     * @var  stubSession
     */
    protected $session;

    /**
     * sets the session
     *
     * @param  stubSession  $session  the session of the current user
     * @Inject(optional=true)
     */
    public function setSession(stubSession $session)
    {
        $this->session = $session;
    }

    /**
     * creates a log entry container
     *
     * @param   string        $target  target where the log data should go to
     * @param   stubLogger    $logger  logger instance to create log entry container for
     * @return  stubLogEntry
     */
    public function create($target, stubLogger $logger)
    {
        $logEntry = new stubLogEntry($target, $logger);
        $logEntry->addData(date('Y-m-d H:i:s'));
        if (null !== $this->session) {
            $logEntry->addData($this->session->getId());
        }
        
        return $logEntry;
    }
}
?><?php
/**
 * Factory which creates empty log entry containers.
 *
 * @package     stubbles
 * @subpackage  util_log_entryfactory
 * @version     $Id: stubEmptyLogEntryFactory.php 2438 2010-01-07 16:28:49Z mikey $
 */
stubClassLoader::load('net::stubbles::util::log::entryfactory::stubAbstractLogEntryFactory');
/**
 * Factory which creates empty log entry containers.
 *
 * @package     stubbles
 * @subpackage  util_log_entryfactory
 */
class stubEmptyLogEntryFactory extends stubAbstractLogEntryFactory
{
    /**
     * creates a log entry container
     *
     * @param   string        $target  target where the log data should go to
     * @param   stubLogger    $logger  logger instance to create log entry container for
     * @return  stubLogEntry
     */
    public function create($target, stubLogger $logger)
    {
        return new stubLogEntry($target, $logger);
    }
}
?><?php
/**
 * Interface for factories which create log entry containers.
 *
 * @package     stubbles
 * @subpackage  util_log
 * @version     $Id: stubLogEntryFactory.php 2438 2010-01-07 16:28:49Z mikey $
 */
stubClassLoader::load('net::stubbles::util::log::stubLogEntry',
                      'net::stubbles::util::log::stubLogger'
);
/**
 * Interface for factories which create log entry containers.
 *
 * @package     stubbles
 * @subpackage  util_log
 */
interface stubLogEntryFactory extends stubObject
{
    /**
     * creates a log entry container
     *
     * @param   string        $target  target where the log data should go to
     * @param   stubLogger    $logger  logger instance to create log entry container for
     * @return  stubLogEntry
     */
    public function create($target, stubLogger $logger);

    /**
     * recreates given log entry
     *
     * @param   stubLogEntry  $logEntry
     * @param   stubLogger    $logger
     * @return  stubLogEntry
     * @since   1.1.0
     */
    public function recreate(stubLogEntry $logEntry, stubLogger $logger);
}
?><?php
/**
 * Injection provider for logger instances.
 *
 * @package     stubbles
 * @subpackage  util_log_ioc
 * @version     $Id: stubBaseLoggerProvider.php 2060 2009-01-26 12:57:25Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjectionProvider',
                      'net::stubbles::util::log::stubLogEntryFactory',
                      'net::stubbles::util::log::stubLogger'
);
/**
 * Injection provider for logger instances.
 *
 * Please note that this provider requires injections as well and thus should
 * only be added to the binding via the addProviderClass() method.
 *
 * Additionally note that this provider only creates logger instances without
 * any log appenders.
 *
 * @package     stubbles
 * @subpackage  util_log_ioc
 */
class stubBaseLoggerProvider extends stubBaseObject implements stubInjectionProvider
{
    /**
     * factory to be used to create log entry containers
     *
     * @var  stubLogEntryFactory
     */
    protected $logEntryFactory;

    /**
     * constructor
     *
     * @param  stubLogEntryFactory  $logEntryFactory  factory to be used to create log entry containers
     * @Inject
     */
    public function __construct(stubLogEntryFactory $logEntryFactory)
    {
        $this->logEntryFactory = $logEntryFactory;
    }

    /**
     * returns the value to provide
     *
     * @param   string  $name  optional
     * @return  mixed
     */
    public function get($name = null)
    {
        return new stubLogger($this->logEntryFactory);
    }
}
?><?php
/**
 * Injection provider for logger instances with a file appender.
 *
 * @package     stubbles
 * @subpackage  util_log_ioc
 * @version     $Id: stubDefaultLoggerProvider.php 2106 2009-02-16 23:33:38Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjectionProvider',
                      'net::stubbles::util::log::stubLogger',
                      'net::stubbles::util::log::appender::stubFileLogAppender'
);
/**
 * Injection provider for logger instances with a file appender.
 *
 * @package     stubbles
 * @subpackage  util_log_ioc
 */
class stubDefaultLoggerProvider extends stubBaseObject implements stubInjectionProvider
{
    /**
     * basic logger instance
     *
     * @var  stubLogger
     */
    protected $logger;
    /**
     * path where logfiles should be stored
     *
     * @var  string
     */
    protected $logPath;

    /**
     * constructor
     *
     * @param  stubLogger  $logger   basic logger instance
     * @param  string      $logPath  path where logfiles should be stored
     * @Inject
     * @Named{logger}('util.log.baseLogger')
     * @Named{logPath}('net.stubbles.log.path')
     */
    public function __construct(stubLogger $logger, $logPath)
    {
        $this->logger  = $logger;
        $this->logPath = $logPath;
    }

    /**
     * returns the value to provide
     *
     * @param   string  $name  optional
     * @return  mixed
     */
    public function get($name = null)
    {
        if ($this->logger->hasLogAppenders() === false) {
            $this->logger->addLogAppender(new stubFileLogAppender($this->logPath));
        }
        
        return $this->logger;
    }
}
?><?php
/**
 * Bindung module for a default log configuration.
 *
 * @package     stubbles
 * @subpackage  util_log_ioc
 * @version     $Id: stubLogBindingModule.php 2882 2011-01-11 20:54:26Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::module::stubBindingModule');
/**
 * Bindung module for a default log configuration.
 *
 * @package     stubbles
 * @subpackage  util_log_ioc
 */
class stubLogBindingModule extends stubBaseObject implements stubBindingModule
{
    /**
     * path where logfiles should be stored
     *
     * @var  string
     */
    protected $logPath;
    /**
     * class name of log entry factory class to be bound
     *
     * @var  string
     */
    protected $logEntryFactoryClassName = 'net::stubbles::util::log::entryfactory::stubDefaultLogEntryFactory';
    /**
     * name of class which provides the logger instance
     *
     * @var  string
     * @since  1.3.0
     */
    protected $loggerProviderClassName  = 'net::stubbles::util::log::ioc::stubDefaultLoggerProvider';

    /**
     * constructor
     *
     * Please note that the log path is only optional if it is bound by another
     * module.
     *
     * @param  string  $logPath  optional  path where logfiles should be stored
     */
    public function __construct($logPath = null)
    {
        $this->logPath = $logPath;
    }

    /**
     * static constructor
     *
     * Please note that the log path is only optional if it is bound by another
     * module.
     *
     * @param   string                $logPath  optional
     * @return  stubLogBindingModule
     */
    public static function create($logPath = null)
    {
        return new self($logPath);
    }

    /**
     * sets the class name of log entry factory class to be bound
     *
     * @param   string                $logEntryFactoryClassName
     * @return  stubLogBindingModule
     */
    public function setLogEntryFactoryClassName($logEntryFactoryClassName)
    {
        $this->logEntryFactoryClassName = $logEntryFactoryClassName;
        return $this;
    }

    /**
     * sets name of class which provides the logger instance
     *
     * @param   string                $loggerProviderClassName
     * @return  stubLogBindingModule
     * @since   1.3.0
     */
    public function setLoggerProviderClassName($loggerProviderClassName)
    {
        $this->loggerProviderClassName = $loggerProviderClassName;
        return $this;
    }

    /**
     * configure the binder
     *
     * @param  stubBinder  $binder
     */
    public function configure(stubBinder $binder)
    {
        if (null != $this->logPath) {
            $binder->bindConstant()
                   ->named('net.stubbles.log.path')
                   ->to($this->logPath);
        }
        
        $binder->bind('stubLogEntryFactory')
               ->to($this->getLogEntryFactoryClassName())
               ->asSingleton();
        $binder->bind('stubLogger')
               ->named('util.log.baseLogger')
               ->toProviderClass('net::stubbles::util::log::ioc::stubBaseLoggerProvider');
        $binder->bind('stubLogger')
               ->toProviderClass($this->getLoggerProviderClassName());
    }

    /**
     * returns the name of log entry factory class to be used
     *
     * @return  string
     */
    public function getLogEntryFactoryClassName()
    {
        return $this->logEntryFactoryClassName;
    }

    /**
     * returns name of class which provides the logger instance
     *
     * @return  string
     * @since   1.3.0
     */
    public function getLoggerProviderClassName()
    {
        return $this->loggerProviderClassName;
    }
}
?><?php
/**
 * Container class for log data.
 *
 * @package     stubbles
 * @subpackage  util_log
 * @version     $Id: stubLogEntry.php 2438 2010-01-07 16:28:49Z mikey $
 */
stubClassLoader::load('net::stubbles::util::log::stubLogger');
/**
 * Container class for log data.
 *
 * @package     stubbles
 * @subpackage  util_log
 */
class stubLogEntry extends stubBaseObject
{
    /**
     * default seperator between log data fields
     */
    const DEFAULT_SEPERATOR = '|';
    /**
     * seperator between log data fields
     *
     * @var  string
     */
    protected $seperator    = self::DEFAULT_SEPERATOR;
    /**
     * logger to which the log data should be send
     *
     * @var  stubLogger
     */
    protected $logger;
    /**
     * target where the log data should go to
     *
     * @var  string
     */
    protected $target;
    /**
     * data to log
     *
     * @var  array<string>
     */
    protected $logData      = array();

    /**
     * constructor
     * 
     * How the target is interpreted depends on the log appender which
     * takes the log data. A file log appender might use this as the basename
     * of a file, while a database log appender might use this as the name
     * of the table to write the log data into. Therefore it is advisable to
     * only use ascii characters, numbers and underscores to be sure that the
     * log appender will not mess up the log data.
     *
     * @param  string      $target   target where the log data should go to
     * @param  stubLogger  $logger   logger to which the log data should be send
     */
    public function __construct($target, stubLogger $logger)
    {
        $this->target = $target;
        $this->logger = $logger;
    }

    /**
     * sets the seperator to be used
     *
     * @param   string        $seperator
     * @return  stubLogEntry
     */
    public function setSeperator($seperator)
    {
        $this->seperator = $seperator;
        return $this;
    }

    /**
     * logs the data using the given logger
     */
    public function log()
    {
        $this->logger->log($this);
    }

    /**
     * logs the data delayed using the given logger
     *
     * @since  1.1.0
     */
    public function logDelayed()
    {
        $this->logger->logDelayed($this);
    }

    /**
     * adds data to the log object
     * 
     * Each call to this method will add a new field. If the data contains line
     * breaks they will be replaced by <nl>. If the data contains the value of
     * the seperator or windows line feeds they will be removed.
     *
     * If the data starts with a double quote but does not end with a double
     * quote a closing double quote will be appended.
     *
     * If the data consists only of a single double quote it will be removed and
     * the added data string will thus be empty.
     *
     * @param   string        $data
     * @return  stubLogEntry
     */
    public function addData($data)
    {
        $this->logData[] = $this->escapeData($data);
        return $this;
    }

    /**
     * helper method to escape given data
     *
     * @param   string  $data
     * @return  string
     */
    protected function escapeData($data)
    {
        settype($data, 'string');
        $data = str_replace(chr(13), '', str_replace("\n", '<nl>', $data));
        if (strlen($data) > 1 && '"' === $data{0} && '"' !== $data{(strlen($data) - 1)}) {
            $data .= '"';
        } elseif (strlen($data) == 1 && '"' === $data) {
            $data = '';
        }

        return $data;
    }

    /**
     * replaces data within the log entry
     *
     * If the position to replace does not exist the replacement data will be
     * thrown away. The replacement data will be escaped the same way as when
     * added via addData().
     *
     * @param   int           $position         position to replace
     * @param   string        $replacementData  the data to replace the old data
     * @return  stubLogEntry
     * @since   1.1.0
     */
    public function replaceData($position, $replacementData)
    {
        if (isset($this->logData[$position]) === false) {
            return $this;
        }

        $this->logData[$position] = $this->escapeData($replacementData);
        return $this;
    }

    /**
     * returns whole log data
     *
     * @return  array<string>
     * @since   1.1.0
     */
    public function getData()
    {
        return array_map(array($this, 'escapeSeperator'), $this->logData);
    }

    /**
     * returns the whole log data on one line with fields seperated by the seperator
     *
     * @return  string
     */
    public function get()
    {
        return join($this->seperator, array_map(array($this, 'escapeSeperator'), $this->logData));
    }

    /**
     * escape string against seperator, i.e. remove it from data
     *
     * @param   string  $data
     * @return  string
     */
    protected function escapeSeperator($data)
    {
        return str_replace($this->seperator, '', $data);
    }

    /**
     * returns the target where the log data should go to
     * 
     * @return  string
     */
    public function getTarget()
    {
        return $this->target;
    }
}
?><?php
/**
 * Class for logging.
 *
 * @package     stubbles
 * @subpackage  util_log
 * @version     $Id: stubLogger.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::util::log::stubLogEntry',
                      'net::stubbles::util::log::appender::stubLogAppender',
                      'net::stubbles::util::log::entryfactory::stubLogEntryFactory'
);
/**
 * Class for logging.
 * 
 * The logger is the interface to log data into differant targets. The logger
 * itself does not know where to write the log data - it just uses log appenders
 * which in turn do the real work. A logger is a collection of such appenders.
 *
 * @package     stubbles
 * @subpackage  util_log
 */
class stubLogger extends stubBaseObject
{
    /**
     * log level: no logging
     */
    const LEVEL_NONE             = 0;
    /**
     * log level: debug only
     */
    const LEVEL_DEBUG            = 1;
    /**
     * log level: info data only
     */
    const LEVEL_INFO             = 2;
    /**
     * log level: warnings only
     */
    const LEVEL_WARN             = 4;
    /**
     * log level: errors only
     */
    const LEVEL_ERROR            = 8;
    /**
     * log level: all
     */
    const LEVEL_ALL              = 15;
    /**
     * factory to be used to create log data containers
     *
     * @var  stubLogEntryFactory
     */
    protected $logEntryFactory;
    /**
     * list of log appenders to log data to
     *
     * @var  array<stubLogAppender>
     */
    protected $logAppender       = array();
    /**
     * list of delayed log entries
     *
     * @var  array<stubLogEntry>
     */
    protected $delayedLogEntries = array();

    /**
     * constructor
     *
     * @param  stubLogEntryFactory  $logEntryFactory  factory to be used to create log data containers
     */
    public function __construct(stubLogEntryFactory $logEntryFactory)
    {
        $this->logEntryFactory = $logEntryFactory;
    }

    /**
     * destructor
     * 
     * Calls all log appenders that they should finalize their work.
     */
    public final function __destruct()
    {
        $this->processDelayedLogEntries();
        foreach ($this->logAppender as $logAppender) {
            $logAppender->finalize();
        }
    }

    /**
     * adds a log appender to the logger
     * 
     * A log appender is responsible for writing the log data.
     *
     * @param   stubLogAppender  $logAppender
     * @return  stubLogAppender  the freshly added log appender instance
     */
    public function addLogAppender(stubLogAppender $logAppender)
    {
        $this->logAppender[] = $logAppender;
        return $logAppender;
    }

    /**
     * checks whether logger has any log appenders
     *
     * @return  bool
     */
    public function hasLogAppenders()
    {
        return (count($this->logAppender) > 0);
    }

    /**
     * returns a list of log appenders appended to the logger
     *
     * @return  array<stubLogAppender>
     */
    public function getLogAppenders()
    {
        return $this->logAppender;
    }

    /**
     * creates the log entry
     *
     * @param   string        $target
     * @return  stubLogEntry
     */
    public function createLogEntry($target)
    {
        return $this->logEntryFactory->create($target, $this);
    }

    /**
     * sends log data to all registered log appenders
     *
     * @param  stubLogEntry  $logEntry  contains data to log
     */
    public function log(stubLogEntry $logEntry)
    {
        foreach ($this->logAppender as $logAppender) {
            $logAppender->append($logEntry);
        }
    }

    /**
     * collects log entries but delays logging of them until destruction of the
     * logger or processDelayedLogEntries() gets called
     *
     * @param  stubLogEntry  $logEntry
     * @since  1.1.0
     */
    public function logDelayed(stubLogEntry $logEntry)
    {
        $this->delayedLogEntries[] = $logEntry;
    }

    /**
     * returns number of unprocessed delayed log entries
     *
     * @return  int
     * @since   1.1.0
     */
    public function hasUnprocessedDelayedLogEntries()
    {
        return (count($this->delayedLogEntries) > 0);
    }

    /**
     * processes all delayed log entries
     *
     * @return  int  amount of processed delayed entries
     * @since   1.1.0
     */
    public function processDelayedLogEntries()
    {
        if ($this->hasUnprocessedDelayedLogEntries() === false) {
            return 0;
        }

        foreach ($this->delayedLogEntries as $logEntry) {
            $this->log($this->logEntryFactory->recreate($logEntry, $this));
        }

        $amount = count($this->delayedLogEntries);
        $this->delayedLogEntries = array();
        return $amount;
    }
}
?><?php
/**
 * Log exceptions.
 *
 * @package     stubbles
 * @subpackage  util_log_types
 * @version     $Id: stubExceptionLog.php 2342 2009-10-06 13:02:37Z mikey $
 */
stubClassLoader::load('net::stubbles::util::log::stubLogger');
/**
 * Log exceptions.
 *
 * @package     stubbles
 * @subpackage  util_log_types
 */
class stubExceptionLog extends stubBaseObject
{
    /**
     * logger instance
     *
     * @var  stubLogger
     */
    protected $logger;
    /**
     * target of the log data
     *
     * @var  string
     */
    protected $logTarget = 'exceptions';

    /**
     * constructor
     *
     * @param  stubLogger  $logger
     */
    public function __construct(stubLogger $logger)
    {
        $this->logger = $logger;
    }

    /**
     * static constructor
     *
     * @param   stubLogger        $logger
     * @return  stubExceptionLog
     */
    public static function create(stubLogger $logger)
    {
        return new self($logger);
    }

    /**
     * sets the target of the log data
     *
     * @param   string            $logTarget
     * @return  stubExceptionLog
     */
    public function setLogTarget($logTarget)
    {
        $this->logTarget = $logTarget;
        return $this;
    }

    /**
     * logs an exception
     *
     * @param  Exception  $exception
     */
    public function log(Exception $exception)
    {
        $logEntry = $this->logger->createLogEntry($this->logTarget);
        $logEntry->addData(($exception instanceof stubThrowable) ? ($exception->getClassName()) : (get_class($exception)))
                 ->addData($exception->getMessage())
                 ->addData($exception->getFile())
                 ->addData($exception->getLine());
        if ($exception instanceof stubChainedException && null !== $exception->getCause()) {
            $cause = $exception->getCause();
            $logEntry->addData(($cause instanceof stubThrowable) ? ($cause->getClassName()) : (get_class($cause)))
                     ->addData($cause->getMessage())
                     ->addData($cause->getFile())
                     ->addData($cause->getLine());
        } else {
            $logEntry->addData('')
                     ->addData('')
                     ->addData('')
                     ->addData('');
        }
        
        $logEntry->log();
    }
}
?><?php
/**
 * Common interface for XJConf based initializers and factories that use the
 * net::stubbles::util::xjconf::stubXJConfProxy.
 * 
 * @package     stubbles
 * @subpackage  util_xjconf
 * @version     $Id: stubXJConfAbstractInitializer.php 2222 2009-06-09 21:55:06Z mikey $
 */
stubClassLoader::load('net::stubbles::util::xjconf::stubXJConfInitializer');
/**
 * Common interface for XJConf based initializers and factories that use the
 * net::stubbles::util::xjconf::stubXJConfProxy.
 *
 * @package     stubbles
 * @subpackage  util_xjconf
 */
abstract class stubXJConfAbstractInitializer extends stubBaseObject implements stubXJConfInitializer
{
    /**
     * initialize the interceptors
     *
     * @return  stubInitializer
     */
    public function init()
    {
        $xjconfProxy = new stubXJConfProxy($this);
        $xjconfProxy->process();
        return $this;
    }

    /**
     * returns definitions that are additionally required beyond the default definition
     *
     * @return  array<string>
     */
    public function getAdditionalDefinitions()
    {
        return array();
    }

    /**
     * returns a list of extensions for the parser
     *
     * @return  array<Extension>
     */
    public function getExtensions()
    {
        return array();
    }
}
?><?php
/**
 * Class loader that loads classes from XJConf.
 *
 * @package     stubbles
 * @subpackage  util_xjconf
 * @version     $Id: stubXJConfClassLoader.php 2360 2009-10-26 21:59:55Z mikey $
 */
/**
 * Class loader that loads classes from XJConf.
 *
 * @package     stubbles
 * @subpackage  util_xjconf
 * @uses        http://php.xjconf.net/
 */
class stubXJConfClassLoader extends stubBaseObject implements stubForeignClassLoader
{
    /**
     * namespace where this classloader is responsible for
     *
     * @var  string
     */
    protected $namespace = 'net::xjconf';

    /**
     * static initializer
     */
    // @codeCoverageIgnoreStart
    public static function __static()
    {
        stubClassLoader::registerForeignClassLoader(new self());
    }
    // @codeCoverageIgnoreEnd

    /**
     * sets the namespace where this classloader is responsible for
     *
     * @param  string $namespace
     */
    public function setNamespace($namespace)
    {
        $this->namespace = $namespace;
    }
    
    /**
     * returns the namespace where this classloader is responsible for
     *
     * @return  string
     */
    public function getNamespace()
    {
        return $this->namespace;
    }
    
    /**
     * loads the given class
     *
     * @param   string  $fqClassName  the full qualified class name of the class to load
     * @throws  stubClassNotFoundException
     */
    public function load($fqClassName)
    {
        $nqClassName = stubClassLoader::getNonQualifiedClassName($fqClassName);
        if (class_exists($nqClassName, false) === true || interface_exists($nqClassName, false) === true) {
            return;
        }
        
        if (class_exists('XJConfLoader', false) == false) {
            $this->init();
        }
        
        if (XJConfLoader::classFileExists($fqClassName) == false) {
            throw new stubClassNotFoundException($fqClassName, true);
        }
        
        XJConfLoader::load($fqClassName);
    }
    
    /**
     * initializes XJConf
     *
     * @throws  stubRuntimeException
     */
    protected function init()
    {
        $xjConfUri = StarClassRegistry::getUriForClass('net::xjconf::XJConfLoader');
        if (null === $xjConfUri) {
            // Try to include XJConf from PEAR installation
            if ((@include 'XJConf/XJConfLoader.php') == false) {
                throw new stubRuntimeException('XJConf could not be found in lib nor in include path.');
            }
        } else {
            // Include XJConf via Star
            require $xjConfUri;
        }
    }
}
?><?php
/**
 * Exception for wrapping xjconf exceptions.
 *
 * @package     stubbles
 * @subpackage  util_xjconf
 * @version     $Id: stubXJConfException.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubChainedException');
/**
 * Exception for wrapping xjconf exceptions.
 *
 * @package     stubbles
 * @subpackage  util_xjconf
 */
class stubXJConfException extends stubChainedException
{
    // intentionally empty
}
?><?php
/**
 * Decorator arround the facade for XJConf.
 *
 * @package     stubbles
 * @subpackage  util_xjconf
 * @version     $Id: stubXJConfFacade.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Decorator arround the facade for XJConf.
 *
 * @package     stubbles
 * @subpackage  util_xjconf
 */
class stubXJConfFacade extends stubBaseObject
{
    /**
     * the real facade
     *
     * @var  XJConfFacade
     */
    protected $realFacade;

    /**
     * construct the facade
     *
     * @param  XJConfFacade  $realFacade  the real facade
     */
    public function __construct($realFacade)
    {
        $this->realFacade = $realFacade;
    }

    /**
     * call interceptor
     *
     * @param   string  $method     name of the method to call
     * @param   array   $arguments  arguments to call
     * @return  mixed
     * @throws  stubXJConfException
     */
    public function __call($method, $arguments)
    {
        try {
            return call_user_func_array(array($this->realFacade, $method), $arguments);
        } catch (Exception $e) {
            throw new stubXJConfException($e->getMessage(), $e);
        }
    }
}
?><?php
/**
 * Common interface for XJConf based initializers and factories that use the
 * net::stubbles::util::xjconf::stubXJConfProxy.
 * 
 * @package     stubbles
 * @subpackage  util_xjconf
 * @version     $Id: stubXJConfInitializer.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::initializer::stubInitializer',
                      'net::stubbles::util::xjconf::stubXJConfFacade'
);
/**
 * Common interface for XJConf based initializers and factories that use the
 * net::stubbles::util::xjconf::stubXJConfProxy.
 *
 * @package     stubbles
 * @subpackage  util_xjconf
 */
interface stubXJConfInitializer extends stubObject, stubInitializer
{
    /**
     * descriptor type: config
     */
    const DESCRIPTOR_CONFIG     = 'config';
    /**
     * descriptor type: definition
     */
    const DESCRIPTOR_DEFINITION = 'definition';

    /**
     * returns the descriptor that identifies this initializer
     *
     * @param   string  $type  type of descriptor: config or definition
     * @return  string
     * @throws  stubIllegalArgumentException
     */
    public function getDescriptor($type);

    /**
     * returns the data to cache
     * 
     * The concrete implementation has to ensure that only serializable data
     * is returned within the array. If any specific classes should be
     * serialized the concrete implementation has to ensure that the class is
     * loaded.
     *
     * @return  array
     */
    public function getCacheData();

    /**
     * sets the data from the cache
     *
     * @param  array  $cacheData
     */
    public function setCacheData(array $cacheData);

    /**
     * returns definitions that are additionally required beyond the default definition
     *
     * @return  array<string>
     */
    public function getAdditionalDefinitions();

    /**
     * returns a list of extensions for the parser
     *
     * @return  array<Extension>
     */
    public function getExtensions();
    
    /**
     * will be called in case the stubXJConfProxy did not found the data in the
     * cache and the initializer has to load values from the facade
     *
     * @param  stubXJConfFacade  $xjconf
     */
    public function loadData(stubXJConfFacade $xjconf);
}
?><?php
/**
 * Class loader to use for XJConf.
 *
 * @package     stubbles
 * @subpackage  util_xjconf
 * @version     $Id: stubXJConfLoader.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::xjconf::XJConfClassLoader');
/**
 * Class loader to use for XJConf.
 *
 * Maps the stubClassLoader.
 *
 * @package     stubbles
 * @subpackage  util_xjconf
 * @uses        http://php.xjconf.net/
 */
class stubXJConfLoader extends stubBaseObject implements XJConfClassLoader
{
    /**
     * instance of the class loader
     *
     * @var  stubClassLoader
     */
    private static $instance;

    /**
     * forbidden constructor (singleton)
     */
    private final function __construct()
    {
        // nothing to do
    }

    /**
     * returns an instance of the class loader
     *
     * @return  stubClassLoader
     */
    public static function getInstance()
    {
        if (null == self::$instance) {
            self::$instance = new self();
        }

        return self::$instance;
    }

    /**
     * forbidden cloning (singleton)
     */
    private final function __clone()
    {
        // nothing to do
    }

    /**
     * load the file with the given class
     *
     * @param  string  $fqClassName  the full qualified class name
     */
    public function loadClass($fqClassName)
    {
        stubClassLoader::load($fqClassName);
    }

    /**
     * returns short class name
     *
     * @param   string  $fqClassName  the full qualified class name
     * @return  string
     */
    public function getType($fqClassName)
    {
        $className = explode('::', $fqClassName);
        return $className[count($className) - 1];
    }
}
?><?php
/**
 * Proxy for XJConf.
 * 
 * @package     stubbles
 * @subpackage  util_xjconf
 * @version     $Id: stubXJConfProxy.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::stubFactory',
                      'net::stubbles::lang::stubPathRegistry',
                      'net::stubbles::util::xjconf::stubXJConfInitializer'
);
/**
 * Proxy for XJConf.
 *
 * @package     stubbles
 * @subpackage  util_xjconf
 */
class stubXJConfProxy extends stubBaseObject
{
    /**
     * the initializer to use
     *
     * @var  stubXJConfInitializer
     */
    protected $initializer;
    /**
     * name of the config file to use for initializing
     *
     * @var  string
     */
    protected $configFile;
    /**
     * name of the cache file to use
     *
     * @var  string
     */
    protected $cacheFile;

    /**
     * constructor
     *
     * @param  stubXJConfInitializer  $initializer  the initializer to use
     * @param  string                 $configPath   optional  path to config files
     * @param  string                 $cachePath    optional  path to cache files
     */
    public function __construct(stubXJConfInitializer $initializer, $configPath = null, $cachePath = null)
    {
        $this->initializer = $initializer;
        if (null == $configPath) {
            $configPath = stubPathRegistry::getConfigPath() . '/xml';
        }
        
        if (null == $cachePath) {
            $cachePath = stubPathRegistry::getCachePath();
        }
        
        $this->configFile  = $configPath . '/' . $this->initializer->getDescriptor(stubXJConfInitializer::DESCRIPTOR_CONFIG) . '.xml';
        $this->cacheFile   = $cachePath . '/' . $this->initializer->getDescriptor(stubXJConfInitializer::DESCRIPTOR_CONFIG) . '.cache';
    }

    /**
     * initialize with configuration values from given configuration file
     *
     * @param   array<string>  $sources  optional  a list of sources to parse
     * @return  bool                     true if data was cached, else false
     * @throws  stubXJConfException
     */
    public function process(array $sources = array())
    {
        if (file_exists($this->cacheFile) == true) {
            $useCache = true;
            if (count($sources) == 0 && filemtime($this->cacheFile) < filemtime($this->configFile)) {
                $useCache = false;
            } elseif (count($sources) > 0) {
                foreach ($sources as $source) {
                    if (filemtime($this->cacheFile) < filemtime($source)) {
                        $useCache = false;
                    }
                }
            }
            
            if (true == $useCache) {
                $this->initializer->setCacheData(unserialize(file_get_contents($this->cacheFile)));
                return;
            }
        }
        
        stubClassLoader::load('net::stubbles::util::xjconf::xjconfReal');
        $xjconf = new stubXJConfFacade(new XJConfFacade(array('__default' => stubXJConfLoader::getInstance())));
        $xjconf->addDefinitions(stubFactory::getResourceURIs('xjconf/' . $this->initializer->getDescriptor(stubXJConfInitializer::DESCRIPTOR_DEFINITION) . '.xml'));
        foreach ($this->initializer->getAdditionalDefinitions() as $definition) {
            $xjconf->addDefinitions(stubFactory::getResourceURIs($definition));
        }
        
        $xjconf->enableXIncludes();
        foreach ($this->initializer->getExtensions() as $extension) {
            $xjconf->addExtension($extension);
        }
        
        if (count($sources) == 0) {
            $xjconf->parse($this->configFile);
            $this->initializer->loadData($xjconf);
        } else {
            foreach ($sources as $source) {
                $xjconf->parse($source);
                $this->initializer->loadData($xjconf);
                $xjconf->clearConfigValues();
            }
        }
        
        file_put_contents($this->cacheFile, serialize($this->initializer->getCacheData()));
    }
}
?><?php
/**
 * XJConf bootstrap file.
 *
 * @package     stubbles
 * @subpackage  util_xjconf
 * @version     $Id: xjconf.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::util::xjconf::stubXJConfException',
                      'net::stubbles::util::xjconf::stubXJConfFacade',
                      'net::stubbles::util::xjconf::stubXJConfInitializer',
                      'net::stubbles::util::xjconf::stubXJConfAbstractInitializer',
                      'net::stubbles::util::xjconf::stubXJConfProxy'
);
?><?php
/**
 * XJConf bootstrap file.
 *
 * @package     stubbles
 * @subpackage  util_xjconf
 * @version     $Id: xjconfReal.php 2063 2009-01-26 14:55:06Z mikey $
 */
stubClassLoader::load('net::stubbles::util::xjconf::stubXJConfClassLoader',
                      'net::stubbles::util::xjconf::stubXJConfLoader',
                      'net::xjconf::XJConfFacade'
);
?><?php
/**
 * Abstract base cache implementation for websites.
 *
 * @package     stubbles
 * @subpackage  websites_cache
 * @version     $Id: stubAbstractWebsiteCache.php 2222 2009-06-09 21:55:06Z mikey $
 */
stubClassLoader::load('net::stubbles::util::log::stubLogger',
                      'net::stubbles::websites::cache::stubWebsiteCache'
);
/**
 * Abstract base cache implementation for websites.
 *
 * @package     stubbles
 * @subpackage  websites_cache
 */
abstract class stubAbstractWebsiteCache extends stubBaseObject implements stubWebsiteCache
{
    /**
     * reason why cache is missing
     *
     * @var  string
     */
    protected $missReason = '';
    /**
     * the real cache
     *
     * @var  stubCacheContainer
     */
    protected $cache;
    /**
     * optional logger for logging cache hits/misses
     *
     * @var  stubLogger
     */
    protected $logger;

    /**
     * returns the cache container used by the implementation
     *
     * @return  stubCacheContainer
     */
    public function getCacheContainer()
    {
        return $this->cache;
    }

    /**
     * retrieves data from cache and puts it into response
     *
     * @param   stubRequest   $request
     * @param   stubResponse  $response
     * @param   string        $routeName  name of the route to be cached
     * @return  bool          true if data was retrieved from cache, else false
     */
    public function retrieve(stubRequest $request, stubResponse $response, $routeName)
    {
        $cacheKey = $this->generateCacheKey($routeName);
        if ($this->isCached($cacheKey) === false) {
            $this->log($routeName, $cacheKey, stubWebsiteCache::MISS);
            return false;
        }
        
        if ($this->doRetrieve($request, $response, $cacheKey) === true) {
            $response->addHeader('X-Cached', $this->getClassName());
            $this->log($routeName, $cacheKey, stubWebsiteCache::HIT);
            return true;
        }
        
        $this->log($routeName, $cacheKey, stubWebsiteCache::MISS);
        return false;
    }

    /**
     * does the real retrieve
     *
     * @param   stubRequest   $request
     * @param   stubResponse  $response
     * @param   string        $cacheKey
     * @return  bool          true if data was retrieved from cache, else false
     */
    protected abstract function doRetrieve(stubRequest $request, stubResponse $response, $cacheKey);

    /**
     * stores the data from the response in cche
     *
     * @param   stubRequest   $request
     * @param   stubResponse  $response
     * @param   string        $routeName  name of the route to be cached
     * @return  bool          true if successfully stored, else false
     */
    public function store(stubRequest $request, stubResponse $response, $routeName)
    {
        return $this->doStore($request, $response, $this->generateCacheKey($routeName));
    }

    /**
     * does the real storage
     *
     * @param   stubRequest   $request
     * @param   stubResponse  $response
     * @param   string        $cacheKey
     * @return  bool          true if successfully stored, else false
     */
    protected abstract function doStore(stubRequest $request, stubResponse $response, $cacheKey);

    /**
     * checks whether data is cached or not
     *
     * @param   string  $cacheKey
     * @return  bool
     */
    protected function isCached($cacheKey)
    {
        if ($this->cache->has($cacheKey) === false) {
            $this->missReason = 'no cache file';
            return false;
        }

        return true;
    }

    /**
     * sets logger instance to be used to log cache hits/misses
     *
     * @param   stubLogger                $logger
     * @return  stubAbstractWebsiteCache
     * @Inject(optional=true)
     * @Named(stubLogger::LEVEL_INFO)
     */
    public function setLogger(stubLogger $logger)
    {
        $this->logger = $logger;
        return $this;
    }

    /**
     * helper method to log cache acticity
     *
     * @param   string  $routeName  name of route
     * @param   string  $cacheKey   key for cache data
     * @param   string  $type       'hit' or 'miss'
     * @return  bool    true if data was logged, else false
     */
    protected function log($routeName, $cacheKey, $type)
    {
        if (null === $this->logger) {
            return false;
        }
        
        $this->logger->createLogEntry('cache')
                     ->addData($routeName)
                     ->addData($type)
                     ->addData($this->getClassName())
                     ->addData($this->missReason)
                     ->addData($cacheKey)
                     ->log();
        return true;
    }

    /**
     * generates the cache key from given list of cache variables
     *
     * @param   string  $routeName  name of the route to be cached
     * @return  string
     */
    protected function generateCacheKey($routeName)
    {
        $baseKey = $routeName . '?';
        foreach ($this->getCacheVars() as $name => $value) {
            $baseKey .= '&' . $name . '=' . $value;
        }
        
        return md5($baseKey);
    }

    /**
     * returns the list of cache variables
     *
     * @return  array<string,scalar>
     */
    protected abstract function getCacheVars();
}
?><?php
/**
 * Processor that can be applied onto any processor to cache its documents.
 *
 * @package     stubbles
 * @subpackage  websites_cache
 * @version     $Id: stubCachingProcessor.php 2222 2009-06-09 21:55:06Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::cache::stubWebsiteCache',
                      'net::stubbles::websites::processors::stubAbstractProcessorDecorator'
);
/**
 * Processor that can be applied onto any processor to cache its documents.
 *
 * @package     stubbles
 * @subpackage  websites_cache
 */
class stubCachingProcessor extends stubAbstractProcessorDecorator
{
    /**
     * the request
     *
     * @var  stubRequest
     */
    protected $request;
    /**
     * the created response
     *
     * @var  stubResponse
     */
    protected $response;
    /**
     * website cache to be used
     *
     * @var  stubWebsiteCache
     */
    protected $cache;

    /**
     * constructor
     *
     * @param  stubProcessor     $processor
     * @param  stubRequest       $request
     * @param  stubResponse      $response
     * @param  stubWebsiteCache  $websiteCache
     */
    public function __construct(stubProcessor $processor, stubRequest $request, stubResponse $response, stubWebsiteCache $websiteCache)
    {
        $this->processor = $processor;
        $this->request   = $request;
        $this->response  = $response;
        $this->cache     = $websiteCache;
    }

    /**
     * processes the request
     */
    public function process()
    {
        $isCachable = $this->processor->isCachable();
        if (true === $isCachable) {
            $this->cache->addCacheVars($this->processor->getCacheVars());
            $this->cache->addCacheVar('ssl', $this->processor->isSsl());
            if ($this->cache->retrieve($this->request, $this->response, $this->processor->getRouteName()) === true) {
                return;
            }
        }
        
        $this->processor->process();
        if (true === $isCachable) {
            $this->cache->store($this->request, $this->response, $this->processor->getRouteName());
        }
    }
}
?><?php
/**
 * Processor resolver to decorate another processor resolver and return a caching processor.
 * 
 * @package     stubbles
 * @subpackage  websites_processors
 * @version     $Id: stubCachingProcessorResolver.php 2222 2009-06-09 21:55:06Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::cache::stubCachingProcessor',
                      'net::stubbles::websites::cache::stubWebsiteCache',
                      'net::stubbles::websites::processors::stubProcessorResolver'
);
/**
 * Processor resolver to decorate another processor resolver and return a caching processor.
 * 
 * @package     stubbles
 * @subpackage  websites_processors
 */
class stubCachingProcessorResolver extends stubBaseObject implements stubProcessorResolver
{
    /**
     * decorated processor resolver
     *
     * @var  stubProcessorResolver
     */
    protected $processorResolver;
    /**
     * originally resolved processor
     *
     * @var  string
     */
    protected $originalProcessor;
    /**
     * website cache implementation to be used
     *
     * @var  stubWebsiteCache
     */
    protected $websiteCache;

    /**
     * constructor
     *
     * @param  stubProcessorResolver  $processorResolver
     * @param  stubWebsiteCache       $websiteCache
     * @Inject
     * @Named{processorResolver}('net.stubbles.websites.processor.defaultResolver')
     * @Named{websiteCache}('net.stubbles.websites.cache.default')
     */
    public function __construct(stubProcessorResolver $processorResolver, stubWebsiteCache $websiteCache)
    {
        $this->processorResolver = $processorResolver;
        $this->websiteCache      = $websiteCache;
    }

    /**
     * returns interceptor descriptor
     *
     * @param   stubRequest  $request
     * @return  string
     */
    public function getInterceptorDescriptor(stubRequest $request)
    {
        return $this->processorResolver->getInterceptorDescriptor($request);
    }

    /**
     * resolves the request and creates the appropriate processor
     *
     * @param   stubRequest    $request   the current request
     * @param   stubSession    $session   the current session
     * @param   stubResponse   $response  the current response
     * @return  stubProcessor
     */
    public function resolve(stubRequest $request, stubSession $session, stubResponse $response)
    {
        return new stubCachingProcessor($this->processorResolver->resolve($request, $session, $response),
                                        $request,
                                        $response,
                                        $this->websiteCache
               );
    }
}
?><?php
/**
 * Default cache implementation for websites.
 *
 * @package     stubbles
 * @subpackage  websites_cache
 * @version     $Id: stubDefaultWebsiteCache.php 2495 2010-01-27 18:29:11Z mikey $
 */
stubClassLoader::load('net::stubbles::util::cache::stubCacheContainer',
                      'net::stubbles::websites::cache::stubAbstractWebsiteCache');
/**
 * Default cache implementation for websites.
 * 
 * @package     stubbles
 * @subpackage  websites_cache
 */
class stubDefaultWebsiteCache extends stubAbstractWebsiteCache
{
    /**
     * list of variables for the cache
     *
     * @var  array<string,scalar>
     */
    protected $cacheVars  = array();

    /**
     * constructor
     *
     * @param  stubCacheContainer  $cache
     * @Inject
     * @Named('websites')
     */
    public function __construct(stubCacheContainer $cache)
    {
        $this->cache = $cache;
    }

    /**
     * adds a variable to the list of cache variables
     *
     * @param  string  $name
     * @param  scalar  $value
     */
    public function addCacheVar($name, $value)
    {
        $this->cacheVars[$name] = $value;
    }

    /**
     * adds a list of variables to the list of cache variables
     *
     * @param  array<string,scalar>  $cacheVars
     */
    public function addCacheVars(array $cacheVars)
    {
        foreach ($cacheVars as $name => $value) {
            $this->cacheVars[$name] = $value;
        }
    }

    /**
     * does the real retrieve
     *
     * @param   stubRequest   $request
     * @param   stubResponse  $response
     * @param   string        $cacheKey
     * @return  bool          true if successfully retrieved, else false
     */
    protected function doRetrieve(stubRequest $request, stubResponse $response, $cacheKey)
    {
        $response->write($this->cache->get($cacheKey));
        return true;
    }

    /**
     * does the real storage
     *
     * @param   stubRequest   $request
     * @param   stubResponse  $response
     * @param   string        $cacheKey
     * @return  bool          true if successfully stored, else false
     */
    protected function doStore(stubRequest $request, stubResponse $response, $cacheKey)
    {
        return (bool) $this->cache->put($cacheKey, $response->getData());
    }

    /**
     * returns the list of cache variables
     *
     * @return  array<string,scalar>
     */
    protected function getCacheVars()
    {
        return $this->cacheVars;
    }
}
?><?php
/**
 * Dummy implementation collecting cache variables only but not performing any real caching.
 *
 * @package     stubbles
 * @subpackage  websites_cache
 * @version     $Id: stubDummyWebsiteCache.php 2222 2009-06-09 21:55:06Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::cache::stubWebsiteCache');
/**
 * Dummy implementation collecting cache variables only but not performing any real caching.
 *
 * This dummy is useful in test cases where one wants to test if all cache
 * variables are collected, but no real caching should be performed.
 *
 * @package     stubbles
 * @subpackage  websites_cache
 */
class stubDummyWebsiteCache extends stubBaseObject implements stubWebsiteCache
{
    /**
     * list of variables for the cache
     *
     * @var  array<string,scalar>
     */
    protected $cacheVars  = array();

    /**
     * adds a variable to the list of cache variables
     *
     * @param  string  $name
     * @param  scalar  $value
     */
    public function addCacheVar($name, $value)
    {
        $this->cacheVars[$name] = $value;
    }

    /**
     * adds a list of variables to the list of cache variables
     *
     * @param  array<string,scalar>  $cacheVars
     */
    public function addCacheVars(array $cacheVars)
    {
        foreach ($cacheVars as $name => $value) {
            $this->cacheVars[$name] = $value;
        }
    }

    /**
     * returns collected cache variables
     *
     * @return  array<string,scalar>
     */
    public function getCacheVars()
    {
        return $this->cacheVars;
    }

    /**
     * returns the cache container used by the implementation
     *
     * @return  stubCacheContainer
     */
    public function getCacheContainer()
    {
        return null;
    }

    /**
     * retrieves data from cache and puts it into response
     *
     * @param   stubRequest   $request
     * @param   stubResponse  $response
     * @param   string        $routeName  name of the route to be cached
     * @return  bool          true if data was retrieved from cache, else false
     */
    public function retrieve(stubRequest $request, stubResponse $response, $routeName)
    {
        return false;
    }

    /**
     * stores the data from the response in cche
     *
     * @param   stubRequest   $request
     * @param   stubResponse  $response
     * @param   string        $routeName  name of the route to be cached
     * @return  bool          true if successfully stored, else false
     */
    public function store(stubRequest $request, stubResponse $response, $routeName)
    {
        return false;
    }
}
?><?php
/**
 * Gzip cache implementation for websites.
 * 
 * @package     stubbles
 * @subpackage  websites_cache
 * @version     $Id: stubGzipWebsiteCache.php 2624 2010-08-12 10:24:58Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::validator::stubContainsValidator',
                      'net::stubbles::websites::cache::stubAbstractWebsiteCache'
);
/**
 * Gzip cache implementation for websites.
 * 
 * @package     stubbles
 * @subpackage  websites_cache
 */
class stubGzipWebsiteCache extends stubAbstractWebsiteCache
{
    /**
     * content header for response
     */
    const HEADER = "\x1f\x8b\x08\x00\x00\x00\x00\x00";
    /**
     * mime type: x-gzip
     */
    const X_GZIP = 'x-gzip';
    /**
     * mime type: gzip
     */
    const GZIP   = 'gzip';
    /**
     * decorated cache instance
     *
     * @var  stubWebsiteCache
     */
    protected $websiteCache;

    /**
     * constructor
     *
     * @param  stubWebsiteCache  $websiteCache
     * @Inject
     * @Named('net.stubbles.websites.cache.simple')
     */
    public function __construct(stubWebsiteCache $websiteCache)
    {
        $this->websiteCache = $websiteCache;
        $this->cache        = $this->websiteCache->getCacheContainer();
    }

    /**
     * adds a variable to the list of cache variables
     *
     * @param  string  $name
     * @param  scalar  $value
     */
    public function addCacheVar($name, $value)
    {
        $this->websiteCache->addCacheVar($name, $value);
    }

    /**
     * adds a list of variables to the list of cache variables
     *
     * @param  array<string,scalar>  $cacheVars
     */
    public function addCacheVars(array $cacheVars)
    {
        $this->websiteCache->addCacheVars($cacheVars);
    }

    /**
     * returns the cache container used by the implementation
     *
     * @return  stubCacheContainer
     */
    public function getCacheContainer()
    {
        return $this->websiteCache->getCacheContainer();
    }

    /**
     * retrieves data from cache and puts it into response
     *
     * @param   stubRequest   $request
     * @param   stubResponse  $response
     * @param   string        $routeName  name of the route to be cached
     * @return  bool          true if data was retrieved from cache, else false
     */
    public function retrieve(stubRequest $request, stubResponse $response, $routeName)
    {
        if (parent::retrieve($request, $response, $routeName) === true) {
            return true;
        }
        
        return $this->websiteCache->retrieve($request, $response, $routeName);
    }

    /**
     * does the real retrieve
     *
     * @param   stubRequest   $request
     * @param   stubResponse  $response
     * @param   string        $cacheKey
     * @return  bool          true if data was retrieved from cache, else false
     */
    protected function doRetrieve(stubRequest $request, stubResponse $response, $cacheKey)
    {
        // we do not use gzipped content because we probably have to insert
        // the session id into the links of the document
        if ($request->acceptsCookies() === false) {
            $this->missReason = 'user agent does not accept cookies';
            return false;
        }
        
        $compression = $this->getCompression($request);
        if (null === $compression) {
            $this->missReason = 'user agent does not accept compressed content';
            return false;
        }
        
        $response->addHeader('Content-Encoding', $compression);
        $response->write(self::HEADER);
        $response->write($this->websiteCache->getCacheContainer()->get($cacheKey));
        return true;
    }

    /**
     * helper method to detect the supported compression
     *
     * If null is returned the user agent does not support compression.
     *
     * @param   stubRequest  $request
     * @return  string
     */
    protected function getCompression(stubRequest $request)
    {
        if ($request->validateHeader('HTTP_ACCEPT_ENCODING')->contains(self::X_GZIP) === true) {
            return self::X_GZIP;
        } elseif ($request->validateHeader('HTTP_ACCEPT_ENCODING')->contains(self::GZIP) === true) {
            return self::GZIP;
        }
        
        return null;
    }

    /**
     * stores the data from the response in cche
     *
     * @param   stubRequest   $request
     * @param   stubResponse  $response
     * @param   string        $routeName  name of the route to be cached
     * @return  bool          true if successfully stored, else false
     */
    public function store(stubRequest $request, stubResponse $response, $routeName)
    {
        parent::store($request, $response, $routeName);
        return $this->websiteCache->store($request, $response, $routeName);
    }

    /**
     * does the real storage
     *
     * @param   stubRequest   $request
     * @param   stubResponse  $response
     * @param   string        $cacheKey
     * @return  bool          true if successfully stored, else false
     */
    protected function doStore(stubRequest $request, stubResponse $response, $cacheKey)
    {
        $data  = $response->getData();
        $data  = str_replace('$SID', '', $data);
        $data  = str_replace('$SESSION_NAME', '', $data);
        $data  = str_replace('$SESSION_ID', '', $data);
        $size  = strlen($data);
        $crc32 = crc32($data);
        $data  = gzcompress($data, 9);
        $data  = substr($data, 0, strlen($data) - 4);
        $data .= $this->convert2Gzip($crc32) . $this->convert2Gzip($size);
        return (bool) $this->websiteCache->getCacheContainer()->put($cacheKey, $data);
    }

    /**
     * returns gzip-encoded value
     *
     * @param   int    $value
     * @return  string
     */
    protected function convert2Gzip($value)
    {
        $return = '';
        for ($i = 0; $i < 4; $i++) {
            $return .= chr($value % 256);
            $value   = floor($value / 256);
        }
        
        return $return;
    }

    /**
     * generates the cache key from given list of cache keys
     *
     * @param   string  $routeName  name of the route to be cached
     * @return  string
     */
    protected function generateCacheKey($routeName)
    {
        return parent::generateCacheKey($routeName) . '.gz';
    }

    /**
     * returns the list of cache variables
     *
     * @return  array<string,scalar>
     */
    protected function getCacheVars()
    {
        return $this->websiteCache->getCacheVars();
    }
}
?><?php
/**
 * Cache for websites.
 * 
 * @package     stubbles
 * @subpackage  websites_cache
 * @version     $Id: stubWebsiteCache.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::response::stubResponse'
);
/**
 * Cache for websites.
 * 
 * @package     stubbles
 * @subpackage  websites_cache
 */
interface stubWebsiteCache extends stubObject
{
    /**
     * cache hit
     */
    const HIT  = 'hit';
    /**
     * cache miss
     */
    const MISS = 'miss';

    /**
     * adds a variable to the list of cache variables
     *
     * @param  string  $name
     * @param  scalar  $value
     */
    public function addCacheVar($name, $value);

    /**
     * adds a list of variables to the list of cache variables
     *
     * @param  array<string,scalar>  $cacheVars
     */
    public function addCacheVars(array $cacheVars);

    /**
     * returns the cache container used by the implementation
     *
     * @return  stubCacheContainer
     */
    public function getCacheContainer();

    /**
     * retrieves data from cache and puts it into response
     *
     * @param   stubRequest   $request
     * @param   stubResponse  $response
     * @param   string        $routeName  name of the route to be cached
     * @return  bool          true if data was retrieved from cache, else false
     */
    public function retrieve(stubRequest $request, stubResponse $response, $routeName);

    /**
     * stores the data from the response in cche
     *
     * @param   stubRequest   $request
     * @param   stubResponse  $response
     * @param   string        $routeName  name of the route to be cached
     * @return  bool          true if successfully stored, else false
     */
    public function store(stubRequest $request, stubResponse $response, $routeName);
}
?><?php
/**
 * Provider for the processor resolver depending on runtime mode.
 *
 * @package     stubbles
 * @subpackage  websites_ioc
 * @version     $Id: stubProcessorResolverProvider.php 2111 2009-03-04 13:39:25Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjector',
                      'net::stubbles::lang::stubMode'
);
/**
 * Provider for the processor resolver depending on runtime mode.
 *
 * @package     stubbles
 * @subpackage  websites_ioc
 */
class stubProcessorResolverProvider extends stubBaseObject implements stubInjectionProvider
{
    /**
     * mode we are running in
     *
     * @var  stubMode
     */
    protected $mode;
    /**
     * injector instance
     *
     * @var  stubInjector
     */
    protected $injector;

    /**
     * constructor
     *
     * @param  stubInjector  $injector  injector instance to create processor resolver depending on mode
     * @Inject
     */
    public function __construct(stubInjector $injector)
    {
        $this->injector = $injector;
    }

    /**
     * sets the runtime mode we are running in
     *
     * @param  stubMode      $mode
     * @Inject(optional=true)
     */
    public function setMode(stubMode $mode)
    {
        $this->mode = $mode;
    }

    /**
     * returns the value to provide
     *
     * @param   string  $name  optional
     * @return  mixed
     */
    public function get($name = null)
    {
        if (null === $this->mode || $this->mode->isCacheEnabled() === true) {
            return $this->injector->getInstance('net::stubbles::websites::cache::stubCachingProcessorResolver');
        }
        
        return $this->injector->getInstance('stubProcessorResolver', 'net.stubbles.websites.processor.defaultResolver');
    }
}
?><?php
/**
 * Binding module for classes required by the front controller.
 *
 * @package     stubbles
 * @subpackage  websites_ioc
 * @version     $Id: stubWebsiteBindingModule.php 2812 2010-12-16 18:53:15Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::module::stubBindingModule');
/**
 * Binding module for classes required by the front controller.
 *
 * @package     stubbles
 * @subpackage  websites_ioc
 */
class stubWebsiteBindingModule extends stubBaseObject implements stubBindingModule
{
    /**
     * the default processor to use
     * 
     * @var  string
     */
    protected $defaultProcessorParamValue;
    /**
     * list of processors
     * 
     * @var  array<string,string>
     */
    protected $processors                 = array();
    /**
     * list of interceptor descriptors
     *
     * @var  array<string,string>
     */
    protected $interceptorDescriptors     = array();
    /**
     * class to be used as interceptor initializer
     *
     * @var  string
     */
    protected $interceptorInitializer     = 'net::stubbles::ipo::interceptors::stubPropertyBasedInterceptorInitializer';
    /**
     * list of router classes
     *
     * @var  array<string,string>
     */
    protected $routerClasses              = array();
    /**
     * list of default xml generators
     *
     * @var  array<string>
     */
    protected $xmlGenerators              = array('net::stubbles::websites::xml::generator::stubSessionXMLGenerator',
                                                  'net::stubbles::websites::xml::generator::stubRouteXMLGenerator',
                                                  'net::stubbles::websites::xml::generator::stubRequestXMLGenerator',
                                                  'net::stubbles::websites::xml::generator::stubModeXMLGenerator',
                                                  'net::stubbles::websites::xml::generator::stubVariantListGenerator'
                                            );
    /**
     * switch whether auth processor is enabled or not
     *
     * @var  bool
     */
    protected $authEnabled                = false;

    /**
     * constructor
     *
     * @param  string  $paramValue             value of the request parameter that identifies this processor
     * @param  string  $defaultProcessorClass  full qualified class name of the processor
     * @param  string  $interceptorDescriptor  optional  the interceptor descriptor
     * @param  string  $routerClass            optional  router class for the processor
     */
    public function __construct($paramValue, $defaultProcessorClass, $interceptorDescriptor = null, $routerClass = null)
    {
        $this->defaultProcessorParamValue = $paramValue;
        $this->addProcessor($paramValue, $defaultProcessorClass, $interceptorDescriptor, $routerClass);
    }

    /**
     * static constructor to allow method chaining
     *
     * @param   string                    $paramValue             value of the request parameter that identifies this processor
     * @param   string                    $defaultProcessorClass  full qualified class name of the processor
     * @param   string                    $interceptorDescriptor  optional  the interceptor descriptor
     * @param   string                    $routerClass            optional  router class for the processor
     * @return  stubWebsiteBindingModule
     */
    public static function create($paramValue, $defaultProcessorClass, $interceptorDescriptor = null, $routerClass = null)
    {
        return new self($paramValue, $defaultProcessorClass, $interceptorDescriptor, $routerClass);
    }

    /**
     * static constructor which adds the xml processor as default processor
     *
     * @param   string                    $interceptorDescriptor  optional  the interceptor descriptor
     * @param   string                    $routerClass            optional  router class for the processor
     * @return  stubWebsiteBindingModule
     */
    public static function createWithXmlProcessorAsDefault($interceptorDescriptor = null, $routerClass = 'net::stubbles::websites::processors::routing::stubPropertyBasedRouter')
    {
        return new self('xml', 'net::stubbles::websites::xml::stubXMLProcessor', $interceptorDescriptor, $routerClass);
    }

    /**
     * static constructor which adds the rest processor as default processor
     *
     * @param   string                    $interceptorDescriptor  optional  the interceptor descriptor
     * @return  stubWebsiteBindingModule
     */
    public static function createWithRestProcessorAsDefault($interceptorDescriptor = null)
    {
        return new self('rest', 'net::stubbles::service::rest::stubRestProcessor', $interceptorDescriptor);
    }

    /**
     * adds a processor to the list of available processors
     * 
     * @param   string                    $paramValue             value of the request parameter that identifies this processor
     * @param   string                    $fqClassName            full qualified class name of the processor
     * @param   string                    $interceptorDescriptor  optional  the interceptor descriptor
     * @param   string                    $routerClass            optional  router class for the processor
     * @return  stubWebsiteBindingModule
     */
    public function addProcessor($paramValue, $fqClassName, $interceptorDescriptor = null, $routerClass = null)
    {
        $this->processors[$paramValue]             = $fqClassName;
        $this->interceptorDescriptors[$paramValue] = $interceptorDescriptor;
        $this->routerClasses[$paramValue]          = $routerClass;
        return $this;
    }

    /**
     * enables the json-rpc processor
     *
     * @param   string                    $interceptorDescriptor  optional  the interceptor descriptor
     * @return  stubWebsiteBindingModule
     */
    public function enableJsonRpc($interceptorDescriptor = 'interceptors-jsonrpc')
    {
        $this->addProcessor('jsonrpc', 'net::stubbles::service::jsonrpc::stubJsonRpcProcessor', $interceptorDescriptor);
        return $this;
    }

    /**
     * enables the rss processor
     *
     * @param   string                    $interceptorDescriptor  optional  the interceptor descriptor
     * @return  stubWebsiteBindingModule
     */
    public function enableRss($interceptorDescriptor = 'interceptors-rss')
    {
        $this->addProcessor('rss', 'net::stubbles::xml::rss::stubRSSProcessor', $interceptorDescriptor);
        return $this;
    }

    /**
     * enables the rest processor
     *
     * @param   string                    $interceptorDescriptor  optional  the interceptor descriptor
     * @return  stubWebsiteBindingModule
     * @since   1.1.0
     */
    public function enableRest($interceptorDescriptor = 'interceptors-rest')
    {
        $this->addProcessor('rest', 'net::stubbles::service::rest::stubRestProcessor', $interceptorDescriptor);
        return $this;
    }

    /**
     * enable auth processor
     *
     * @return  stubWebsiteBindingModule
     */
    public function enableAuth()
    {
        $this->authEnabled = true;
        return $this;
    }

    /**
     * sets list of xml generators for xml processor
     *
     * @param   array<string>             $xmlGenerators
     * @return  stubWebsiteBindingModule
     */
    public function setXmlGenerators(array $xmlGenerators)
    {
        $this->xmlGenerators = $xmlGenerators;
        return $this;
    }

    /**
     * add a xml generator for xml processor
     *
     * @param   string                    $xmlGenerator
     * @return  stubWebsiteBindingModule
     */
    public function addXmlGenerator($xmlGenerator)
    {
        $this->xmlGenerators[] = $xmlGenerator;
        return $this;
    }

    /**
     * full qualified class name of interceptor initializer class to be used
     *
     * @param   string                    $interceptorInitializerClassName
     * @return  stubWebsiteBindingModule
     */
    public function usingInterceptorInitializer($interceptorInitializerClassName)
    {
        $this->interceptorInitializer = $interceptorInitializerClassName;
        return $this;
    }

    /**
     * configure the binder
     *
     * @param  stubBinder  $binder
     */
    public function configure(stubBinder $binder)
    {
        $binder->bind('stubInterceptorInitializer')
               ->to($this->interceptorInitializer);
        $binder->bind('stubWebsiteCache')
               ->named('net.stubbles.websites.cache.simple')
               ->to('net::stubbles::websites::cache::stubDefaultWebsiteCache');
        $binder->bind('stubWebsiteCache')
               ->named('net.stubbles.websites.cache.default')
               ->to('net::stubbles::websites::cache::stubGzipWebsiteCache');
        $binder->bind('stubProcessorResolver')
               ->named('net.stubbles.websites.processor.defaultResolver')
               ->toInstance($this->createProcessorResolver($binder->getInjector()));
        if (false === $this->authEnabled) {
            $binder->bind('stubProcessorResolver')
                   ->toProviderClass('net::stubbles::websites::ioc::stubProcessorResolverProvider');
        } else {
            $binder->bind('stubProcessorResolver')
                   ->named('net.stubbles.websites.processor.finalResolver')
                   ->toProviderClass('net::stubbles::websites::ioc::stubProcessorResolverProvider');
            $binder->bind('stubProcessorResolver')
                   ->to('net::stubbles::websites::processors::auth::stubAuthProcessorResolver');
        }
        
        foreach ($this->routerClasses as $paramValue => $routerClass) {
            if (null != $routerClass) {
                $binder->bind('stubRouter')
                       ->named($paramValue)
                       ->to($routerClass);
            }
        }
        
        if (isset($this->processors['xml']) === true) {
            $binder->bind('stubSkinGenerator')
                   ->named('websites.xml.skin.default')
                   ->to('net::stubbles::websites::xml::skin::stubDefaultSkinGenerator');
            $binder->bind('stubSkinGenerator')
                   ->named('websites.xml.skin.cached')
                   ->to('net::stubbles::websites::xml::skin::stubCachingSkinGenerator');
            $binder->bind('stubSkinGenerator')
                   ->toProviderClass('net::stubbles::websites::xml::skin::stubSkinGeneratorProvider');
            $binder->bindConstant()
                   ->named('net.stubbles.websites.xml.generators')
                   ->to($this->xmlGenerators);
        }
    }

    /**
     * returns the processor resolver according to configured processors
     *
     * @param   stubInjector           $injector
     * @return  stubProcessorResolver
     */
    protected function createProcessorResolver(stubInjector $injector)
    {
        if (count($this->processors) > 1) {
            stubClassLoader::load('net::stubbles::websites::processors::stubDefaultProcessorResolver');
            $processorResolver = new stubDefaultProcessorResolver($injector,
                                                                  $this->defaultProcessorParamValue,
                                                                  $this->processors[$this->defaultProcessorParamValue],
                                                                  $this->interceptorDescriptors[$this->defaultProcessorParamValue]
                                 );
            foreach ($this->processors as $paramValue => $processor) {
                if ($paramValue != $this->defaultProcessorParamValue) {
                    $processorResolver->addProcessor($paramValue,
                                                     $processor,
                                                     $this->interceptorDescriptors[$paramValue]
                    );
                }
            }
        } else {
            stubClassLoader::load('net::stubbles::websites::processors::stubSimpleProcessorResolver');
            $processorResolver = new stubSimpleProcessorResolver($injector,
                                                                 $this->processors[$this->defaultProcessorParamValue],
                                                                 $this->interceptorDescriptors[$this->defaultProcessorParamValue]
                                 );
        }
        
        return $processorResolver;
    }
}
?><?php
/**
 * Interface for authentication handlers.
 * 
 * @package     stubbles
 * @subpackage  websites_processors_auth
 * @version     $Id: stubAuthHandler.php 2157 2009-04-06 22:42:40Z mikey $
 */
/**
 * Interface for authentication handlers.
 * 
 * @package     stubbles
 * @subpackage  websites_processors_auth
 */
interface stubAuthHandler extends stubObject
{
    /**
     * checks if given role required login
     *
     * @param   string  $role
     * @return  bool
     */
    public function requiresLogin($role);

    /**
     * returns login url
     *
     * @return  string
     */
    public function getLoginUrl();

    /**
     * checks whether the auth handler has a user
     *
     * @return  bool
     */
    public function hasUser();

    /**
     * returns a default role
     *
     * @return  string
     */
    public function getDefaultRole();

    /**
     * checks if user has a specific role
     *
     * @param   string  $role
     * @return  bool
     */
    public function userHasRole($role);
}
?><?php
/**
 * Processor to handle authentication and authorization on websites.
 *
 * @package     stubbles
 * @subpackage  websites_processors_auth
 * @version     $Id: stubAuthProcessor.php 2851 2011-01-05 13:18:02Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::processors::stubAbstractProcessorDecorator',
                      'net::stubbles::websites::processors::stubProcessorException',
                      'net::stubbles::websites::processors::auth::stubAuthHandler'
);
/**
 * Processor to handle authentication and authorization on websites.
 * 
 * @package     stubbles
 * @subpackage  websites_processors_auth
 */
class stubAuthProcessor extends stubAbstractProcessorDecorator
{
    /**
     * the request
     *
     * @var  stubRequest
     */
    protected $request;
    /**
     * the created response
     *
     * @var  stubResponse
     */
    protected $response;
    /**
     * authentication handler
     *
     * @var  stubAuthHandler
     */
    protected $authHandler;
    /**
     * switch whether the processor's process() method can be called
     *
     * @var  bool
     */
    protected $callProcess = false;

    /**
     * constructor
     *
     * @param  stubProcessor    $processor
     * @param  stubRequest      $request
     * @param  stubResponse     $response
     * @param  stubAuthHandler  $authHandler
     * @Inject
     */
    public function __construct(stubProcessor $processor, stubRequest $request, stubResponse $response, stubAuthHandler $authHandler)
    {
        $this->processor   = $processor;
        $this->request     = $request;
        $this->response    = $response;
        $this->authHandler = $authHandler;
    }

    /**
     * operations to be done before the request is processed
     *
     * @return  stubProcessor
     * @throws  stubProcessorException
     * @throws  stubRuntimeException
     */
    public function startup()
    {
        $requiredRole = $this->processor->getRequiredRole($this->authHandler->getDefaultRole());
        if (null !== $requiredRole && $this->authHandler->userHasRole($requiredRole) === false) {
            if ($this->authHandler->hasUser() === false && $this->authHandler->requiresLogin($requiredRole) === true) {
                $this->response->addHeader('Location', $this->authHandler->getLoginUrl());
            } elseif ($this->authHandler->hasUser() === true) {
                throw new stubProcessorException(403, 'Forbidden');
            } else {
                throw new stubRuntimeException('Role is required but there is no user and the role requires no login - most likely the auth handler is errounous.');
            }
            
            $this->request->cancel();
        } else {
            $this->processor->startup();
            $this->callProcess = true;
        }

        return $this;
    }

    /**
     * processes the request
     *
     * @return  stubProcessor
     */
    public function process()
    {
        if (true === $this->callProcess) {
            $this->processor->process();
        }

        return $this;
    }
}
?><?php
/**
 * Processor resolver to decorate another processor resolver and return an authentication based processor.
 * 
 * @package     stubbles
 * @subpackage  websites_processors_auth
 * @version     $Id: stubAuthProcessorResolver.php 2556 2010-04-09 14:41:07Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::processors::stubProcessorResolver',
                      'net::stubbles::websites::processors::auth::stubAuthHandler',
                      'net::stubbles::websites::processors::auth::stubAuthProcessor'
);
/**
 * Processor resolver to decorate another processor resolver and return an authentication based processor.
 * 
 * @package     stubbles
 * @subpackage  websites_processors_auth
 */
class stubAuthProcessorResolver extends stubBaseObject implements stubProcessorResolver
{
    /**
     * decorated processor resolver
     *
     * @var  stubProcessorResolver
     */
    protected $processorResolver;
    /**
     * injector to create authentication handler
     *
     * @var  stubInjector
     */
    protected $injector;

    /**
     * constructor
     *
     * @param  stubProcessorResolver  $processorResolver
     * @param  stubInjector           $injector
     * @Inject
     * @Named{processorResolver}('net.stubbles.websites.processor.finalResolver')
     */
    public function __construct(stubProcessorResolver $processorResolver, stubInjector $injector)
    {
        $this->processorResolver = $processorResolver;
        $this->injector          = $injector;
    }

    /**
     * returns interceptor descriptor
     *
     * @param   stubRequest  $request
     * @return  string
     */
    public function getInterceptorDescriptor(stubRequest $request)
    {
        return $this->processorResolver->getInterceptorDescriptor($request);
    }

    /**
     * resolves the request and creates the appropriate processor
     *
     * @param   stubRequest    $request   the current request
     * @param   stubSession    $session   the current session
     * @param   stubResponse   $response  the current response
     * @return  stubProcessor
     */
    public function resolve(stubRequest $request, stubSession $session, stubResponse $response)
    {
        return new stubAuthProcessor($this->processorResolver->resolve($request, $session, $response),
                                     $request,
                                     $response,
                                     $this->injector->getInstance('stubAuthHandler')
               );
    }
}
?><?php
/**
 * Abstract base implementation of a processable.
 *
 * @package     stubbles
 * @subpackage  websites_processors_routing
 * @version     $Id: stubAbstractProcessable.php 2903 2011-01-12 11:47:34Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequestPrefixDecorator',
                      'net::stubbles::websites::processors::routing::stubProcessable'
);
/**
 * Abstract base implementation of a processable.
 *
 * @package     stubbles
 * @subpackage  websites_processors_routing
 */
abstract class stubAbstractProcessable extends stubBaseObject implements stubProcessable
{
    /**
     * request instance
     *
     * @var  stubRequest
     */
    protected $request;
    /**
     * context with additional information
     *
     * @var  array<string,mixed>
     */
    protected $context = array();

    /**
     * sets the context
     *
     * @param   array<string,mixed>  $context
     * @return  stubProcessable
     */
    public function setContext(array $context)
    {
        $this->context = $context;
        if ($this->request instanceof stubRequest && isset($context['prefix']) === true) {
            $this->request = new stubRequestPrefixDecorator($this->request, $context['prefix']);
        }
        
        return $this;
    }

    /**
     * operations to be done before processing is done
     */
    public function startup()
    {
        // nothing to do
    }

    /**
     * checks whether the processable is available or not
     *
     * @return  bool
     */
    public function isAvailable()
    {
        return true;
    }

    /**
     * operations to be done after processing is done
     */
    public function cleanup()
    {
        // nothing to do
    }
}
?><?php
/**
 * Interface for a processable.
 *
 * @package     stubbles
 * @subpackage  websites_processors_routing
 * @version     $Id: stubProcessable.php 2324 2009-09-16 11:50:14Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::session::stubSession',
                      'net::stubbles::ipo::response::stubResponse'
);
/**
 * Interface for a processable.
 *
 * @package     stubbles
 * @subpackage  websites_processors_routing
 */
interface stubProcessable extends stubObject
{
    /**
     * sets the context
     *
     * @param   array<string,mixed>  $context
     * @return  stubProcessable
     */
    public function setContext(array $context);

    /**
     * operations to be done before processing is done
     *
     * The startup() method is called after construction, any setter with
     * an @Inject annotation and setContext(), but before any other method and
     * can be used to set up the internal state of the processable properly.
     */
    public function startup();

    /**
     * checks whether the processable is available or not
     *
     * @return  bool
     */
    public function isAvailable();

    /**
     * checks whether processable is cachable or not
     *
     * @return  bool
     */
    public function isCachable();

    /**
     * returns a list of variables that have an influence on caching
     *
     * @return  array<string,scalar>
     */
    public function getCacheVars();

    /**
     * processes the processable
     *
     * @return  mixed
     */
    public function process();

    /**
     * operations to be done after processing is done
     *
     * The cleanup() method is called in every case, even if the process()
     * method was not called because the route result was retrieved from cache or
     * if the process() method throwed a stubProcessorException.
     */
    public function cleanup();
}
?><?php
/**
 * Router implementation to read route information from property files.
 *
 * @package     stubbles
 * @subpackage  websites_processors_routing
 * @version     $Id: stubPropertyBasedRouter.php 2688 2010-08-24 22:48:36Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::stubProperties',
                      'net::stubbles::websites::processors::routing::stubRouter'
);
/**
 * Router implementation to read route information from property files.
 *
 * @package     stubbles
 * @subpackage  websites_processors_routing
 * @since       1.3.0
 */
class stubPropertyBasedRouter extends stubBaseObject implements stubRouter
{
    /**
     * path to cache files
     *
     * @var  string
     */
    protected $cachePath;
    /**
     * path to config files
     *
     * @var  string
     */
    protected $routeConfigPath;
    /**
     * file mode for cache directory
     *
     * @var  int
     */
    protected $fileMode        = 0700;

    /**
     * constructor
     *
     * @param  string  $cachePath        path to cache files
     * @param  string  $routeConfigPath  path to route config files
     * @Inject
     * @Named{cachePath}('net.stubbles.cache.path')
     * @Named{routeConfigPath}('net.stubbles.page.path')
     */
    public function __construct($cachePath, $routeConfigPath)
    {
        $this->cachePath       = $cachePath . DIRECTORY_SEPARATOR . 'pages' . DIRECTORY_SEPARATOR;
        $this->routeConfigPath = $routeConfigPath . DIRECTORY_SEPARATOR . 'conf' . DIRECTORY_SEPARATOR;
    }

    /**
     * sets the file mode
     *
     * @param   int                      $fileMode
     * @return  stubPropertyBasedRouter
     * @Inject(optional=true)
     * @Named('net.stubbles.filemode')
     */
    public function setFileMode($fileMode)
    {
        $this->fileMode = $fileMode;
        return $this;
    }

    /**
     * routes the current request and returns a route info object
     *
     * The method is allowed to fall back to the index route if the request
     * does not specify any route.
     *
     * @param   stubRequest  $request
     * @return  stubRoute
     */
    public function route(stubRequest $request)
    {
        return $this->reroute($request->readParam('route')
                                      ->ifSatisfiesRegex(stubRouter::ROUTENAME_REGEX, 'index')
               );
    }

    /**
     * reroutes the current request to the route determined by $routeName
     *
     * The return value should be null if no route with given name exists.
     *
     * @param   string     $routeName
     * @return  stubRoute
     */
    public function reroute($routeName)
    {
        $routeSource = $this->routeConfigPath . $routeName . '.ini';
        if (file_exists($routeSource) === false) {
            return null;
        }

        $cacheSource = $this->cachePath . $routeName . '.cache';
        if (file_exists($cacheSource) === true && filemtime($cacheSource) >= filemtime($routeSource)) {
            return unserialize(file_get_contents($cacheSource));
        }

        $props = stubProperties::fromFile($routeSource);
        $route = new stubRoute();
        $route->setProperties($props->getSection('properties', array()))
              ->setProperty('name', $routeName)
              ->setProcessables($props->getSection('processables', array()));
        if (file_exists(dirname($cacheSource)) === false) {
            mkdir(dirname($cacheSource), $this->fileMode, true);
        }

        file_put_contents($cacheSource, serialize($route));
        return $route;
    }

    /**
     * redirects the current request to a new request
     *
     * @param  stubRequest   $request
     * @param  stubResponse  $response
     * @param  string        $routeName
     */
    public function redirect(stubRequest $request, stubResponse $response, $routeName)
    {
        $host = $request->readHeader('HTTP_HOST')->unsecure();
        $response->addHeader('Location', '//' . $host . '/xml/' . $routeName);
    }
}
?><?php
/**
 * Container for route resources.
 *
 * @package     stubbles
 * @subpackage  websites_processors_routing
 * @version     $Id: stubRoute.php 2903 2011-01-12 11:47:34Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::processors::routing::stubProcessable');
/**
 * Container for route resources.
 *
 * A route can have two elements:
 * - Properties are the simplest ones, this are scalar values which may be used
 *   for some configuration options.
 * - Processables are a list of implementations of net::stubbles::websites::processors::Processable
 *   and should be processed by the processor.
 *
 * @package     stubbles
 * @subpackage  websites_processors_routing
 */
class stubRoute extends stubBaseObject
{
    /**
     * list of key => value properties
     *
     * @var  array<string,scalar>
     */
    protected $properties   = array();
    /**
     * list of processable classes
     *
     * @var  array<string,string>
     */
    protected $processables = array();

    /**
     * sets a property
     *
     * @param   string     $name   name of the property
     * @param   scalar     $value  value of the property
     * @return  stubRoute
     */
    public function setProperty($name, $value)
    {
        $this->properties[$name] = $value;
        return $this;
    }

    /**
     * sets a list of properties
     *
     * @param   array      $properties  list of properties to set
     * @return  stubRoute
     */
    public function setProperties(array $properties)
    {
        $this->properties = array_merge($this->properties, $properties);
        return $this;
    }

    /**
     * checks whether a property for the route exists
     *
     * @param   string  $name  name of the property
     * @return  bool
     */
    public function hasProperty($name)
    {
        return isset($this->properties[$name]);
    }

    /**
     * returns the property or null if it does not exist
     *
     * @param   string  $name     name of the property
     * @param   scalar  $default  optional  default value to return if property not set
     * @return  scalar
     */
    public function getProperty($name, $default = null)
    {
        if (isset($this->properties[$name]) === true) {
            return $this->properties[$name];
        }

        return $default;
    }

    /**
     * adds a processable to the route
     *
     * @param   string     $name                  prefix name of processable
     * @param   string     $processableClassName  full qualified class name of processable
     * @return  stubRoute
     */
    public function addProcessable($name, $processableClassName)
    {
        $this->processables[$name] = $processableClassName;
        return $this;
    }

    /**
     * sets list of processables
     *
     * @param   array<string,string>  $processables
     * @return  stubRoute
     */
    public function setProcessables(array $processables)
    {
        $this->processables = $processables;
        return $this;
    }

    /**
     * returns the list of processables
     *
     * @return  array<string,stubProcessable>
     */
    public function getProcessables()
    {
        return $this->processables;
    }
}
?><?php
/**
 * Interface for routers.
 *
 * @package     stubbles
 * @subpackage  websites_processors_routing
 * @version     $Id: stubRouter.php 2549 2010-03-18 22:11:34Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::response::stubResponse',
                      'net::stubbles::websites::processors::routing::stubRoute'
);
/**
 * Interface for routers.
 *
 * A router is responsible for parsing the request and return a route with
 * informations about what should be processed.
 *
 * @package     stubbles
 * @subpackage  websites_processors_routing
 */
interface stubRouter extends stubObject
{
    /**
     * regular expression for checking route names
     */
    const ROUTENAME_REGEX = '/^([a-zA-Z0-9_])+$/';

    /**
     * routes the current request and returns a route info object
     *
     * The method is allowed to fall back to the index route if the request
     * does not specify any route.
     *
     * @param   stubRequest  $request
     * @return  stubRoute
     */
    public function route(stubRequest $request);

    /**
     * reroutes the current request to the route determined by $routeName
     *
     * The return value should be null if no route with given name exists.
     *
     * @param   string     $routeName
     * @return  stubRoute
     */
    public function reroute($routeName);

    /**
     * redirects the current request to a new request
     *
     * @param  stubRequest   $request
     * @param  stubResponse  $response
     * @param  string        $routeName
     */
    public function redirect(stubRequest $request, stubResponse $response, $routeName);
}
?><?php
/**
 * Base processor implementation.
 *
 * @package     stubbles
 * @subpackage  websites_processors
 * @version     $Id: stubAbstractProcessor.php 2851 2011-01-05 13:18:02Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::processors::stubProcessor');
/**
 * Base processor implementation.
 *
 * @package     stubbles
 * @subpackage  websites_processors
 */
abstract class stubAbstractProcessor extends stubBaseObject implements stubProcessor
{
    /**
     * the request
     *
     * @var  stubRequest
     */
    protected $request;
    /**
     * current session
     *
     * @var  stubSession
     */
    protected $session;
    /**
     * the created response
     *
     * @var  stubResponse
     */
    protected $response;
    /**
     * switch whether we are running in ssl mode or not
     *
     * @var  bool
     */
    private $ssl        = null;

    /**
     * constructor
     *
     * @param  stubRequest   $request   current request
     * @param  stubSession   $session   current session
     * @param  stubResponse  $response  current response
     * @Inject
     */
    public function __construct(stubRequest $request, stubSession $session, stubResponse $response)
    {
        $this->request  = $request;
        $this->session  = $session;
        $this->response = $response;
    }

    /**
     * returns the required role of the user to be able to process the request
     *
     * @param   string  $defaultRole  a default role to return if no special role is required
     * @return  string
     */
    public function getRequiredRole($defaultRole)
    {
        return $defaultRole;
    }

    /**
     * checks whether the current request forces ssl or not
     *
     * @return  bool
     */
    public function forceSsl()
    {
        return false;
    }

    /**
     * checks whether the request is ssl or not
     *
     * @return  bool
     */
    public function isSsl()
    {
        if (null === $this->ssl) {
            $this->ssl = false;
            if ($this->request->validateHeader('SERVER_PORT')->isOneOf(array(443, '443')) === true) {
                $this->ssl = true;
            }
        }
        
        return $this->ssl;
    }

    /**
     * operations to be done before the request is processed
     *
     * @return  stubProcessor
     */
    public function startup()
    {
        return $this;
    }

    /**
     * checks whether document part is cachable or not
     *
     * @return  bool
     */
    public function isCachable()
    {
        return false;
    }

    /**
     * returns a list of variables that have an influence on caching
     *
     * @return  array<string,scalar>
     */
    public function getCacheVars()
    {
        return array();
    }

    /**
     * operations to be done after the request was processed
     *
     * @return  stubProcessor
     */
    public function cleanup()
    {
        return $this;
    }
}
?><?php
/**
 * Abstract decorator implementation for processors.
 *
 * @package     stubbles
 * @subpackage  websites_processors
 * @version     $Id: stubAbstractProcessorDecorator.php 2851 2011-01-05 13:18:02Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::processors::stubProcessor');
/**
 * Abstract decorator implementation for processors.
 *
 * @package     stubbles
 * @subpackage  websites_processors
 */
abstract class stubAbstractProcessorDecorator extends stubBaseObject implements stubProcessor
{
    /**
     * decorated processor instance
     *
     * @var  stubProcessor
     */
    protected $processor;

    /**
     * returns the required role of the user to be able to process the request
     *
     * @param   string  $defaultRole
     * @return  string
     */
    public function getRequiredRole($defaultRole)
    {
        return $this->processor->getRequiredRole($defaultRole);
    }


    /**
     * returns the name of the current route
     *
     * @return  string
     */
    public function getRouteName()
    {
        return $this->processor->getRouteName();
    }

    /**
     * checks whether the current request forces ssl or not
     *
     * @return  bool
     */
    public function forceSsl()
    {
        return $this->processor->forceSsl();
    }

    /**
     * checks whether the request is ssl or not
     *
     * @return  bool
     */
    public function isSsl()
    {
        return $this->processor->isSsl();
    }

    /**
     * operations to be done before the request is processed
     *
     * @return  stubProcessor
     */
    public function startup()
    {
        $this->processor->startup();
        return $this;
    }

    /**
     * checks whether document to generate is cachable or not
     *
     * @return  bool
     */
    public function isCachable()
    {
        return $this->processor->isCachable();
    }

    /**
     * returns a list of variables that have an influence on caching
     *
     * @return  array<string,scalar>
     */
    public function getCacheVars()
    {
        return $this->processor->getCacheVars();
    }

    /**
     * processes the request
     *
     * @return  stubProcessor
     */
    public function process()
    {
        $this->processor->process();
        return $this;
    }

    /**
     * operations to be done after the request was processed
     *
     * @return  stubProcessor
     */
    public function cleanup()
    {
        $this->processor->cleanup();
        return $this;
    }
}
?><?php
/**
 * Basic abstract implementation of a processor resolver.
 * 
 * @package     stubbles
 * @subpackage  websites_processors
 * @version     $Id: stubAbstractProcessorResolver.php 2222 2009-06-09 21:55:06Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjector',
                      'net::stubbles::lang::exceptions::stubConfigurationException',
                      'net::stubbles::websites::processors::stubProcessorResolver'
);
/**
 * Basic abstract implementation of a processor resolver.
 * 
 * @package     stubbles
 * @subpackage  websites_processors
 */
abstract class stubAbstractProcessorResolver extends stubBaseObject implements stubProcessorResolver
{
    /**
     * injector
     *
     * @var  stubInjector
     */
    protected $injector;

    /**
     * resolves the request and creates the appropriate processor
     *
     * @param   stubRequest    $request   the current request
     * @param   stubSession    $session   the current session
     * @param   stubResponse   $response  the current response
     * @return  stubProcessor
     * @throws  stubConfigurationException
     */
    public function resolve(stubRequest $request, stubSession $session, stubResponse $response)
    {
        $processorClassName = $this->doResolve($request, $session, $response);
        if (null == $processorClassName) {
            throw new stubConfigurationException('Configuration error: no processor specified.');
        }
        
        return $this->injector->getInstance($processorClassName);
    }

    /**
     * does the real resolving work
     *
     * @param   stubRequest   $request   the current request
     * @param   stubSession   $session   the current session
     * @param   stubResponse  $response  the current response
     * @return  string        full qualified classname of the processor to create
     */
    protected abstract function doResolve(stubRequest $request, stubSession $session, stubResponse $response);
}
?><?php
/**
 * Default implementation for the processor resolver.
 *
 * @package     stubbles
 * @subpackage  websites_processors
 * @version     $Id: stubDefaultProcessorResolver.php 2688 2010-08-24 22:48:36Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::processors::stubAbstractProcessorResolver');
/**
 * Default implementation for the processor resolver.
 *
 * The default processor resolver is able to select the processor to be used
 * for the current request depending on the request parameter <em>processor</em>.
 * For instance, if you add two processors with
 * <code>
 *   $defaultProcessor->addProcessor('foo', 'org::stubbles::test::FooProcessor');
 *   $defaultProcessor->addProcessor('bar', 'org::stubbles::test::BarProcessor');
 * </code>
 * then the first processor class will be selected if the value of the request
 * param is <em>foo</em>.
 *
 * If the parameter is not set or invalid it will fallback to the default
 * processor set with the constructor.
 *
 * @package     stubbles
 * @subpackage  websites_processors
 */
class stubDefaultProcessorResolver extends stubAbstractProcessorResolver
{
    /**
     * the default processor to use
     * 
     * @var  string
     */
    protected $defaultProcessorParamValue;
    /**
     * list of processors
     * 
     * @var  array<string,string>
     */
    protected $processors             = array();
    /**
     * list of interceptor descriptors
     *
     * @var  array<string,string>
     */
    protected $interceptorDescriptors = array();

    /**
     * constructor
     *
     * The processor given here will become the default processor to be used
     * if no processor or an invalid one is choosen.
     *
     * @param  stubInjector  $injector                   injector
     * @param  string        $paramValue                 value of the request parameter that identifies this processor
     * @param  string        $defaultProcessorClassName  full qualified class name of the processor
     * @param  string        $interceptorDescriptor      optional  the interceptor descriptor
     */
    public function __construct(stubInjector $injector, $paramValue, $defaultProcessorClassName, $interceptorDescriptor = null)
    {
        $this->injector                   = $injector;
        $this->defaultProcessorParamValue = $paramValue;
        $this->addProcessor($paramValue, $defaultProcessorClassName, $interceptorDescriptor);
    }

    /**
     * adds a processor to the list of available processors
     * 
     * @param  string  $paramValue             value of the request parameter that identifies this processor
     * @param  string  $fqClassName            full qualified class name of the processor
     * @param  string  $interceptorDescriptor  optional  the interceptor descriptor
     */
    public function addProcessor($paramValue, $fqClassName, $interceptorDescriptor = null)
    {
        $this->processors[$paramValue]             = $fqClassName;
        $this->interceptorDescriptors[$paramValue] = ((null == $interceptorDescriptor) ? ('interceptors') : ($interceptorDescriptor));
    }

    /**
     * returns interceptor descriptor
     *
     * @param   stubRequest  $request  the current request
     * @return  string
     */
    public function getInterceptorDescriptor(stubRequest $request)
    {
        $paramValue = $request->readParam('processor')->ifIsOneOf(array_keys($this->processors), $this->defaultProcessorParamValue);
        return $this->interceptorDescriptors[$paramValue];
    }

    /**
     * does the real resolving work
     *
     * @param   stubRequest   $request   the current request
     * @param   stubSession   $session   the current session
     * @param   stubResponse  $response  the current response
     * @return  string        full qualified classname of the processor to create
     */
    protected function doResolve(stubRequest $request, stubSession $session, stubResponse $response)
    {
        $paramValue = $request->readParam('processor')->ifIsOneOf(array_keys($this->processors), $this->defaultProcessorParamValue);
        $session->putValue('net.stubbles.websites.lastProcessor', $paramValue);
        return $this->processors[$paramValue];
    }
}
?><?php
/**
 * Interface for processors.
 *
 * @package     stubbles
 * @subpackage  websites_processors
 * @version     $Id: stubProcessor.php 2851 2011-01-05 13:18:02Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::response::stubResponse',
                      'net::stubbles::ipo::session::stubSession'
);
/**
 * Interface for processors.
 *
 * @package     stubbles
 * @subpackage  websites_processors
 */
interface stubProcessor extends stubObject
{
    /**
     * returns the required role of the user to be able to process the request
     *
     * The method should return <null> if no role is required at all. It should
     * return the value of $defaultRole if a role is required, but no special
     * role for the current request (i.e. processing the request requires a login,
     * but not any role). In any other case it should return the required role.
     *
     * @param   string  $defaultRole
     * @return  string
     */
    public function getRequiredRole($defaultRole);

    /**
     * returns the name of the current route
     *
     * @return  string
     */
    public function getRouteName();

    /**
     * checks whether the current request requires ssl or not
     *
     * @return  bool
     */
    public function forceSsl();

    /**
     * checks whether the request is ssl or not
     *
     * @return  bool
     */
    public function isSsl();

    /**
     * operations to be done before the request is processed
     *
     * @return  stubProcessor
     */
    public function startup();

    /**
     * checks whether document to generate is cachable or not
     *
     * @return  bool
     */
    public function isCachable();

    /**
     * returns a list of variables that have an influence on caching
     *
     * @return  array<string,scalar>
     */
    public function getCacheVars();

    /**
     * processes the request
     *
     * @return  stubProcessor
     */
    public function process();

    /**
     * operations to be done after the request was processed
     *
     * @return  stubProcessor
     */
    public function cleanup();
}
?><?php
/**
 * Exception to be thrown if an error occurs while processor handling.
 *
 * @package     stubbles
 * @subpackage  websites_processors
 * @version     $Id: stubProcessorException.php 2277 2009-07-28 19:51:30Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubChainedException');
/**
 * Exception to be thrown if an error occurs while processor handling.
 *
 * @package     stubbles
 * @subpackage  websites_processors
 */
class stubProcessorException extends stubChainedException
{
    /**
     * status code of processing failure
     *
     * @var  int
     */
    protected $statusCode;

    /**
     * constructor
     *
     * @param  int        $statusCode
     * @param  string     $message
     * @param  Exception  $cause
     */
    public function __construct($statusCode, $message, Exception $cause = null)
    {
        parent::__construct($message, $cause);
        $this->statusCode = $statusCode;
    }

    /**
     * returns status code
     *
     * @return  int
     */
    public function getStatusCode()
    {
        return $this->statusCode;
    }
}
?><?php
/**
 * Interface for processor resolvers.
 * 
 * @package     stubbles
 * @subpackage  websites_processors
 * @version     $Id: stubProcessorResolver.php 2222 2009-06-09 21:55:06Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::response::stubResponse',
                      'net::stubbles::ipo::session::stubSession',
                      'net::stubbles::websites::processors::stubProcessor'
);
/**
 * Interface for processor resolvers.
 * 
 * @package     stubbles
 * @subpackage  websites_processors
 */
interface stubProcessorResolver extends stubObject
{
    /**
     * returns interceptor descriptor for given processor
     *
     * @param   stubRequest  $request  the current request
     * @return  string
     */
    public function getInterceptorDescriptor(stubRequest $request);

    /**
     * resolves the request and creates the appropriate processor
     *
     * @param   stubRequest    $request   the current request
     * @param   stubSession    $session   the current session
     * @param   stubResponse   $response  the current response
     * @return  stubProcessor
     */
    public function resolve(stubRequest $request, stubSession $session, stubResponse $response);
}
?><?php
/**
 * A very simple implementation for the processor resolver which returns always
 * the same processor.
 *
 * @package     stubbles
 * @subpackage  websites_processors
 * @version     $Id: stubSimpleProcessorResolver.php 2222 2009-06-09 21:55:06Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::processors::stubAbstractProcessorResolver');
/**
 * A very simple implementation for the processor resolver which returns always
 * the same processor.
 *
 * @package     stubbles
 * @subpackage  websites_processors
 */
class stubSimpleProcessorResolver extends stubAbstractProcessorResolver
{
    /**
     * full qualified classname of the processor to use
     * 
     * @var  string
     */
    protected $processorClassName   = null;
    /**
     * descriptor for interceptor config
     *
     * @var  string
     */
    protected $interceptorDescriptor = null;

    /**
     * constructor
     *
     * @param  stubInjector  $injector               injector
     * @param  string        $processorClassName     full qualified class name of the processor
     * @param  string        $interceptorDescriptor  optional  the interceptor descriptor
     */
    public function __construct(stubInjector $injector, $processorClassName, $interceptorDescriptor = null)
    {
        $this->injector              = $injector;
        $this->processorClassName    = $processorClassName;
        $this->interceptorDescriptor = ((null == $interceptorDescriptor) ? ('interceptors') : ($interceptorDescriptor));
    }

    /**
     * returns interceptor descriptor for given processor
     *
     * @param   stubRequest  $request  the current request
     * @return  string
     */
    public function getInterceptorDescriptor(stubRequest $request)
    {
        return $this->interceptorDescriptor;
    }

    /**
     * does the real resolving work
     *
     * @param   stubRequest   $request   the current request
     * @param   stubSession   $session   the current session
     * @param   stubResponse  $response  the current response
     * @return  string        full qualified classname of the processor to create
     */
    protected function doResolve(stubRequest $request, stubSession $session, stubResponse $response)
    {
        return $this->processorClassName;
    }
}
?><?php
/**
 * The front controller for websites.
 *
 * @package     stubbles
 * @subpackage  websites
 * @version     $Id: stubFrontController.php 2899 2011-01-12 02:06:32Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::interceptors::stubInterceptorInitializer',
                      'net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::response::stubResponse',
                      'net::stubbles::ipo::session::stubSession',
                      'net::stubbles::websites::processors::stubProcessorException',
                      'net::stubbles::websites::processors::stubProcessorResolver'
);
/**
 * The front controller for websites.
 *
 * @package     stubbles
 * @subpackage  websites
 */
class stubFrontController extends stubBaseObject
{
    /**
     * contains request data
     *
     * @var  stubRequest
     */
    protected $request;
    /**
     * session container
     *
     * @var  stubSession
     */
    protected $session;
    /**
     * response container
     *
     * @var  stubResponse
     */
    protected $response;
    /**
     * resolver to create the correct processor
     *
     * @var  stubProcessorResolver
     */
    protected $processorResolver;
    /**
     * resolver to create the correct processor
     *
     * @var  stubInterceptorInitializer
     */
    protected $interceptorInitializer;

    /**
     * constructor
     * 
     * @param  stubRequest                 $request                 request data container
     * @param  stubSession                 $session                 session container
     * @param  stubResponse                $response                response container
     * @param  stubProcessorResolver       $processorResolver       resolver to create the correct processor
     * @param  stubInterceptorInitializer  $interceptorInitializer  initializer to create pre- and post interceptors
     * @Inject
     */
    public function __construct(stubRequest $request, stubSession $session, stubResponse $response, stubProcessorResolver $processorResolver, stubInterceptorInitializer $interceptorInitializer)
    {
        $this->request                = $request;
        $this->session                = $session;
        $this->response               = $response;
        $this->processorResolver      = $processorResolver;
        $this->interceptorInitializer = $interceptorInitializer;
    }

    /**
     * does the whole processing
     */
    public function process()
    {
        if ($this->request->isCancelled() === true) {
            $this->setSessionData();
            $this->response->send();
            return;
        }
        
        $this->interceptorInitializer->setDescriptor($this->processorResolver->getInterceptorDescriptor($this->request))
                                     ->init();
        foreach ($this->interceptorInitializer->getPreInterceptors() as $preInterceptor) {
            $preInterceptor->preProcess($this->request, $this->session, $this->response);
            if ($this->request->isCancelled() === true) {
                $this->setSessionData();
                $this->response->send();
                return;
            }
        }
        
        $processor = null;
        try {
            $processor = $this->processorResolver->resolve($this->request, $this->session, $this->response);
            if ($processor->forceSsl() === true && $processor->isSsl() === false) {
                $this->response->addHeader('Location', 'https://' . $this->request->getURI());
                $this->request->cancel();
                $this->response->send();
                return;
            }
            
            $processor->startup();
            $processor->process();
        } catch (stubProcessorException $pe) {
            $this->response->setStatusCode($pe->getStatusCode());
        }
        
        if (null !== $processor) {
            $processor->cleanup();
        }
        
        if ($this->request->isCancelled() === false) {
            foreach ($this->interceptorInitializer->getPostInterceptors() as $postInterceptor) {
                $postInterceptor->postProcess($this->request, $this->session, $this->response);
                if ($this->request->isCancelled() === true) {
                    break;
                }
            }
        }
        
        $this->setSessionData();
        $this->response->send();
    }

    /**
     * helper method to replace session place holders with correct session data
     */
    protected function setSessionData()
    {
        $responseData = $this->response->getData();
        if (strlen($responseData) > 0) {
            $contents = str_replace('$SID', $this->session->getName() . '=' . $this->session->getId(), $responseData);
            $contents = str_replace('$SESSION_NAME', $this->session->getName(), $contents);
            $this->response->replaceData(str_replace('$SESSION_ID', $this->session->getId(), $contents));
        }
    }
}
?><?php
/**
 * Abstract base implementation for a variant factory.
 * 
 * @package     stubbles
 * @subpackage  websites_variantmanager
 * @version     $Id: stubAbstractVariantFactory.php 2867 2011-01-10 17:02:33Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::variantmanager::stubVariantFactory',
                      'net::stubbles::websites::variantmanager::stubVariantsMap'
);
/**
 * Abstract base implementation for a variant factory.
 * 
 * @package     stubbles
 * @subpackage  websites_variantmanager
 */
abstract class stubAbstractVariantFactory extends stubBaseObject implements stubVariantFactory
{
    /**
     * map of available variants
     *
     * @var  stubVariantsMap
     */
    protected $variantsMap;

    /**
     * Get all defined variants in this configuration
     * 
     * @return  array<string>
     */
    public function getVariantNames()
    {
        return $this->variantsMap->getVariantNames();
    }

    /**
     * get a variant by its name
     *
     * @param   string       $variantName
     * @return  stubVariant
     */
    public function getVariantByName($variantName)
    {
        return $this->variantsMap->getVariantByName($variantName);
    }

    /**
     * Checks, whether a variant is valid for the current request and the
     * session of the user.
     *
     * This method also checks, whether all parent variants of the
     * variant are valid, as the conditions should be inherited from
     * the parents.
     *
     * @param   string       $variantName
     * @param   stubSession  $session
     * @param   stubRequest  $request
     * @return  boolean
     * @since   1.5.0
     */
    public function isVariantValid($variantName, stubSession $session, stubRequest $request)
    {
        return $this->variantsMap->isVariantValid($variantName, $session, $request);
    }

    /**
     * checks whether we should use persistence or not
     *
     * @return  boolean
     * @since   1.1.0
     */
    public function shouldUsePersistence()
    {
        return $this->variantsMap->shouldUsePersistence();
    }

    /**
     * returns the matching variant based on the current request and the session
     * of the user
     *
     * @param   stubSession  $session
     * @param   stubRequest  $request
     * @return  stubVariant
     * @since   1.1.0
     */
    public function getVariant(stubSession $session, stubRequest $request)
    {
        return $this->variantsMap->getVariant($session, $request);
    }

    /**
     * returns a variant that enforces to be used based on the session of the user
     * and the current request
     *
     * @param   stubSession  $session
     * @param   stubRequest  $request
     * @return  stubVariant
     * @since   1.1.0
     */
    public function getEnforcingVariant(stubSession $session, stubRequest $request)
    {
        return $this->variantsMap->getEnforcingVariant($session, $request);
    }

    /**
     * return the variant map
     *
     * @return  stubVariantsMap
     */
    public function getVariantsMap()
    {
        return $this->variantsMap;
    }

    /**
     * returns the name of the variant map
     *
     * @return  string
     * @since   1.5.0
     */
    public function getVariantsMapName()
    {
        return $this->variantsMap->getName();
    }
}
?><?php
/**
 * Exception to be thrown in case the variant configuration contains an error.
 * 
 * @package     stubbles
 * @subpackage  websites_variantmanager
 * @version     $Id: stubVariantConfigurationException.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubChainedException');
/**
 * Exception to be thrown in case the variant configuration contains an error.
 * 
 * @package     stubbles
 * @subpackage  websites_variantmanager
 */
class stubVariantConfigurationException extends stubChainedException
{
    // intentionally empty
}
?><?php
/**
 * Interface for variant factories that create a variant map.
 * 
 * @package     stubbles
 * @subpackage  websites_variantmanager
 * @version     $Id: stubVariantFactory.php 2867 2011-01-10 17:02:33Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::session::stubSession',
                      'net::stubbles::lang::initializer::stubInitializer',
                      'net::stubbles::websites::variantmanager::stubVariantConfigurationException',
                      'net::stubbles::websites::variantmanager::stubVariantsMap'
);
/**
 * Interface for variant factories that create a variant map.
 * 
 * @package     stubbles
 * @subpackage  websites_variantmanager
 * @ImplementedBy(net::stubbles::websites::variantmanager::stubVariantXJConfFactory.class)
 */
interface stubVariantFactory extends stubInitializer
{
    /**
     * Get all defined variants in this configuration
     * 
     * @return  array<string>
     */
    public function getVariantNames();

    /**
     * get a variant by its name
     *
     * @param   string       $variantName
     * @return  stubVariant
     */
    public function getVariantByName($variantName);

    /**
     * Checks, whether a variant is valid for the current request and the
     * session of the user.
     *
     * This method also checks, whether all parent variants of the
     * variant are valid, as the conditions should be inherited from
     * the parents.
     *
     * @param   string       $variantName
     * @param   stubSession  $session
     * @param   stubRequest  $request
     * @return  boolean
     * @since   1.5.0
     */
    public function isVariantValid($variantName, stubSession $session, stubRequest $request);

    /**
     * checks whether we should use persistence or not
     *
     * @return  boolean
     */
    public function shouldUsePersistence();

    /**
     * returns the matching variant based on the current request and the session
     * of the user
     *
     * @param   stubSession  $session
     * @param   stubRequest  $request
     * @return  stubVariant
     * @throws  stubVariantConfigurationException
     */
    public function getVariant(stubSession $session, stubRequest $request);

    /**
     * returns a variant that enforces to be used based on the session of the user
     * and the current request
     *
     * @param   stubSession  $session
     * @param   stubRequest  $request
     * @return  stubVariant
     */
    public function getEnforcingVariant(stubSession $session, stubRequest $request);

    /**
     * return the variant map
     *
     * @return  stubVariantsMap
     */
    public function getVariantsMap();

    /**
     * returns the name of the variant map
     *
     * @return  string
     * @since   1.5.0
     */
    public function getVariantsMapName();
}
?><?php
/**
 * Factory to create variant related cookies.
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager
 * @version     $Id: stubVariantsCookieCreator.php 2866 2011-01-10 16:56:34Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::response::stubCookie');
/**
 * Factory to create variant related cookies.
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager
 * @Singleton
 */
class stubVariantsCookieCreator extends stubBaseObject
{
    /**
     * name of cookie where current map name is stored
     *
     * @var  string
     */
    protected $cookieMapName   = 'variant_configname';
    /**
     * name of cookie to be used to store the variant
     *
     * @var  string
     */
    protected $cookieName      = 'variant';
    /**
     * lifetime for the variant cookie, defaults to 90 days
     *
     * @var  int
     */
    protected $cookieLifetime  = 7776000; // 90 days
    /**
     * url of the variant cookie
     *
     * @var  string
     */
    protected $cookieDomain    = null;
    /**
     * path of the variant cookie
     *
     * @var  string
     */
    protected $cookiePath      = '/';

    /**
     * sets the name of cookie where current map name is stored
     *
     * @param   string                     $cookieMapName
     * @return  stubVariantsCookieCreator
     * @Inject(optional=true)
     * @Named('net.stubbles.variantmanager.cookie.mapname')
     */
    public function setCookieMapName($cookieMapName)
    {
        $this->cookieMapName = $cookieMapName;
        return $this;
    }

    /**
     * returns the name of cookie where current map name is stored
     *
     * @return  string
     */
    public function getCookieMapName()
    {
        return $this->cookieMapName;
    }

    /**
     * sets the name of cookie to be used to store the variant
     *
     * @param   string                     $cookieName
     * @return  stubVariantsCookieCreator
     * @Inject(optional=true)
     * @Named('net.stubbles.variantmanager.cookie.name')
     */
    public function setCookieName($cookieName)
    {
        $this->cookieName = $cookieName;
        return $this;
    }

    /**
     * returns the name of cookie to be used to store the variant
     *
     * @return  string
     */
    public function getCookieName()
    {
        return $this->cookieName;
    }

    /**
     * sets the lifetime for the variant cookie
     *
     * @param   int                        $cookieLifetime
     * @return  stubVariantsCookieCreator
     * @Inject(optional=true)
     * @Named('net.stubbles.variantmanager.cookie.lifetime')
     */
    public function setCookieLifetime($cookieLifetime)
    {
        $this->cookieLifetime = $cookieLifetime;
        return $this;
    }

    /**
     * sets the domain of the variant cookie
     *
     * @param   string                     $cookieDomain
     * @return  stubVariantsCookieCreator
     * @Inject(optional=true)
     * @Named('net.stubbles.variantmanager.cookie.url')
     */
    public function setCookieDomain($cookieDomain)
    {
        $this->cookieDomain = $cookieDomain;
        return $this;
    }

    /**
     * sets the path of the variant cookie
     *
     * @param   string                     $cookiePath
     * @return  stubVariantsCookieCreator
     * @Inject(optional=true)
     * @Named('net.stubbles.variantmanager.cookie.path')
     */
    public function setCookiePath($cookiePath)
    {
        $this->cookiePath = $cookiePath;
        return $this;
    }

    /**
     * creates the cookie which stores the variant
     *
     * @param   string      $variantName
     * @return  stubCookie
     */
    public function createVariantCookie($variantName)
    {
        return stubCookie::create($this->cookieName, $variantName)
                         ->expiringAt(time() + $this->cookieLifetime)
                         ->forPath($this->cookiePath)
                         ->forDomain($this->cookieDomain);
    }

    /**
     * creates the cookie which stores the name of the map
     *
     * @param   string      $variantMapName
     * @return  stubCookie
     */
    public function createMapCookie($variantMapName)
    {
        return stubCookie::create($this->cookieMapName, $variantMapName)
                         ->expiringAt(time() + $this->cookieLifetime)
                         ->forPath($this->cookiePath)
                         ->forDomain($this->cookieDomain);
    }
}
?><?php
/**
 * Base class for pre interceptors which set the variant.
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager
 * @version     $Id: stubVariantSettingPreInterceptor.php 2897 2011-01-12 01:05:55Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::interceptors::stubPreInterceptor',
                      'net::stubbles::websites::variantmanager::stubVariantsCookieCreator',
                      'net::stubbles::websites::variantmanager::stubVariantFactory'
);
/**
 * Base class for pre interceptors which set the variant.
 *
 * The choosen variant can be accessed within the session by the key
 * net.stubbles.websites.variantmanager.variant.
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager
 */
abstract class stubVariantSettingPreInterceptor extends stubBaseObject implements stubPreInterceptor
{
    /**
     * variant factory to be used for creating the variant
     *
     * @var  stubVariantFactory
     */
    protected $variantFactory;
    /**
     * class to use for creating variant cookies
     *
     * @var  stubVariantsCookieCreator
     */
    protected $variantCookieCreator;

    /**
     * constructor
     *
     * @param  stubVariantFactory         $variantFactory
     * @param  stubVariantsCookieCreator  $variantCookieCreator
     * @Inject
     */
    public function __construct(stubVariantFactory $variantFactory, stubVariantsCookieCreator $variantCookieCreator)
    {
        $this->variantFactory       = $variantFactory;
        $this->variantCookieCreator = $variantCookieCreator;
    }

    /**
     * does the preprocessing stuff
     *
     * @param  stubRequest   $request   access to request data
     * @param  stubSession   $session   access to session data
     * @param  stubResponse  $response  access to response data
     */
    public function preProcess(stubRequest $request, stubSession $session, stubResponse $response)
    {
        if ($this->canSelectVariant($request, $session, $response) === false) {
            return;
        }

        $this->variantFactory->init();
        $variant = $this->selectVariant($request, $session, $response);
        if (null === $variant) {
            return;
        }

        $session->putValue('net.stubbles.websites.variantmanager.variant.name', $variant->getFullQualifiedName());
        $session->putValue('net.stubbles.websites.variantmanager.variant.alias', $variant->getAlias());
        $response->addCookie($this->variantCookieCreator->createVariantCookie($variant->getFullQualifiedName()));
        $response->addCookie($this->variantCookieCreator->createMapCookie($this->variantFactory->getVariantsMapName()));
    }

    /**
     * checks if there is enough data to select a variant
     *
     * @param   stubRequest   $request   access to request data
     * @param   stubSession   $session   access to session data
     * @param   stubResponse  $response  access to response data
     * @return  bool
     */
    protected abstract function canSelectVariant(stubRequest $request, stubSession $session, stubResponse $response);

    /**
     * selects variant based on request and session data
     *
     * If no variant can be selected it is allowed to return null.
     *
     * @param   stubRequest   $request   access to request data
     * @param   stubSession   $session   access to session data
     * @param   stubResponse  $response  access to response data
     * @return  stubVariant
     */
    protected abstract function selectVariant(stubRequest $request, stubSession $session, stubResponse $response);
}
?><?php
/**
 * The variants map knows all configured variants and to check validity of a
 * variant and if a variant is enforcing.
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager
 * @version     $Id: stubVariantsMap.php 2321 2009-09-15 15:29:23Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::variantmanager::types::stubVariant',
                      'net::stubbles::websites::variantmanager::types::stubRootVariant',
                      'net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::session::stubSession'
);
/**
 * The variants map knows all configured variants and to check validity of a
 * variant and if a variant is enforcing.
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager
 */
class stubVariantsMap extends stubBaseObject
{
    /**
     * name of the current variant configuration
     * 
     * @var  string
     */
    private $name;
    /**
     * switch whether persistence should be used or not
     * 
     * @var  boolean
     */
    private $usePersistence = true;
    /**
     * Flat version of all variants
     * 
     * @var  array<string,stubVariant>
     */
    private $variants       = array();
    /**
     * tree structure of the variants
     * 
     * @var  stubRootVariant
     */
    protected $root;

    /**
     * constructor
     * 
     * @param  stubRootVariant  $rootVariant  optional
     */
    public function __construct(stubRootVariant $rootVariant = null)
    {
        if (null == $rootVariant) {
            $this->root = new stubRootVariant();
        } else {
            $this->root = $rootVariant;
            $children   = $rootVariant->getChildren();
            foreach ($children as $child) {
                $this->flattenVariantTree($child);
            }
        }
    }

    /**
     * returns a flat list of all variants
     * 
     * @return  array<String,stubVariant>
     */
    public function getVariants()
    {
        return $this->variants;
    }

    /**
     * returns a variant by supplying its name
     * 
     * @param   string           $variantName
     * @return  stubVariant
     */
    public function getVariantByName($variantName)
    {
        if (isset($this->variants[$variantName]) == true) {
            return $this->variants[$variantName];
        }
        
        return null;
    }

    /**
     * returns a list of all variants
     * 
     * @return  array<String>
     */
    public function getVariantNames()
    {
        return array_keys($this->variants);
    }

    /**
     * adds a new variant
     * 
     * @param  stubVariant  $child
     */
    public function addChild(stubVariant $child)
    {
        $this->root->addChild($child);
        $this->flattenVariantTree($child);
    }

    /**
     * store a variant and all of its children in the flat variant list
     * 
     * @param  stubVariant  $variant
     */
    private function flattenVariantTree(stubVariant $variant)
    {
        $this->variants[$variant->getName()]              = $variant;
        $this->variants[$variant->getFullQualifiedName()] = $variant;
        $children = $variant->getChildren();
        foreach ($children as $child) {
            $this->flattenVariantTree($child);
        }
    }

    /**
     * returns the name of the current variant configuration
     * 
     * @return  string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * sets the name of the variant configuration
     * 
     * @param  string  $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }

    /**
     * checks whether we should use persistence or not
     * 
     * @return  boolean
     */
    public function shouldUsePersistence()
    {
        return $this->usePersistence;
    }

    /**
     * sets whether persistence should be used or not
     * 
     * @param  boolean  $usePersistence  the usePersistence to set
     */
    public function setUsePersistence($usePersistence)
    {
        $this->usePersistence = $usePersistence;
    }

    /**
     * Checks, whether a variant is valid for the current request and the
     * session of the user.
     * 
     * This method also checks, whether all parent variants of the
     * variant are valid, as the conditions should be inherited from
     * the parents.
     * 
     * @param   string       $variantName
     * @param   stubSession  $session
     * @param   stubRequest  $request
     * @return  boolean
     */
    public function isVariantValid($variantName, stubSession $session, stubRequest $request)
    {
        if (isset($this->variants[$variantName]) == false) {
            return false;
        }
        
        $variant = $this->variants[$variantName];
        if ($variant->conditionsMet($session, $request)) {
            while ($variant->hasParent()) {
                $variant = $variant->getParent();
                if ($variant->conditionsMet($session, $request) == false) {
                    return false;
                }
            }
            
            return true;
        }
        
        return false;
    }

    /**
     * returns a variant that enforces to be used based on the session of the user
     * and the current request
     * 
     * @param   stubSession  $session
     * @param   stubRequest  $request
     * @return  stubVariant
     */
    public function getEnforcingVariant(stubSession $session, stubRequest $request)
    {
        $enforcing = $this->root->getEnforcingVariant($session, $request);
        if (null === $enforcing || $enforcing instanceof stubRootVariant) {
            return null;
        }
        
        return $enforcing;
    }

    /**
     * returns the matching variant based on the current request and the session
     * of the user
     * 
     * @param   stubSession  $session
     * @param   stubRequest  $request
     * @return  stubVariant
     * @throws  stubVariantConfigurationException
     */
    public function getVariant(stubSession $session, stubRequest $request)
    {
        $variant = $this->root->getVariant($session, $request);
        if ($variant instanceof stubRootVariant) {
            throw new stubVariantConfigurationException("No valid variant for current session and request found.");
        }
        
        return $variant;
    }

    /**
     * checks, whether a specified variant exists
     * 
     * @param   string   $variantName
     * @return  boolean
     */
    public function variantExists($variantName)
    {
        return isset($this->variants[$variantName]);
    }

    /**
     * returns the root variant
     * 
     * @return  stubRootVariant
     */
    public function getRootVariant()
    {
        return $this->root;
    }
}
?><?php
/**
 * Pre interceptor for selecting the variant based on request data.
 * 
 * @package     stubbles
 * @subpackage  websites_variantmanager
 * @version     $Id: stubVariantsPreInterceptor.php 2866 2011-01-10 16:56:34Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::variantmanager::stubVariantSettingPreInterceptor');
/**
 * Pre interceptor for selecting the variant based on request data.
 *
 * If there is already a selected variant within the session no further
 * selection will take place.
 * 
 * @package     stubbles
 * @subpackage  websites_variantmanager
 */
class stubVariantsPreInterceptor extends stubVariantSettingPreInterceptor
{
    /**
     * checks if there is enough data to select a variant
     *
     * @param   stubRequest   $request   access to request data
     * @param   stubSession   $session   access to session data
     * @param   stubResponse  $response  access to response data
     * @return  bool
     */
    protected function canSelectVariant(stubRequest $request, stubSession $session, stubResponse $response)
    {
        return (false === $session->hasValue('net.stubbles.websites.variantmanager.variant.name'));
    }

    /**
     * selects variant based on request and session data
     *
     * @param   stubRequest   $request   access to request data
     * @param   stubSession   $session   access to session data
     * @param   stubResponse  $response  access to response data
     * @return  stubVariant
     */
    protected function selectVariant(stubRequest $request, stubSession $session, stubResponse $response)
    {
        $variant = null;
        if ($this->variantFactory->shouldUsePersistence() === true) {
            $variant = $this->getVariantFromCookie($request, $session);
        }
        
        if (null === $variant) {
            $variant = $this->variantFactory->getVariant($session, $request);
        }
        
        return $variant;
    }

    /**
     * tries to get the variant from the cookie
     *
     * @param   stubRequest  $request  access to request data
     * @param   stubSession  $session  access to session data
     * @return  stubVariant
     */
    protected function getVariantFromCookie(stubRequest $request, stubSession $session)
    {
        if ($request->hasCookie($this->variantCookieCreator->getCookieName()) === false) {
            return null;
        }

        if ($request->validateCookie($this->variantCookieCreator->getCookieMapName())
                    ->isEqualTo($this->variantFactory->getVariantsMapName()) === false) {
            return null;
        }

        $variantName = $request->readCookie($this->variantCookieCreator->getCookieName())
                               ->ifIsOneOf($this->variantFactory->getVariantNames());
        if (null == $variantName) {
            return null;
        }
        
        if ($this->variantFactory->isVariantValid($variantName, $session, $request) === false) {
            return null;
        }

        $cookieVariant    = $this->variantFactory->getVariantByName($variantName);
        $enforcingVariant = $this->variantFactory->getEnforcingVariant($session, $request);
        if (null === $enforcingVariant) {
            return $cookieVariant;
        }
        
        if (substr($cookieVariant->getFullQualifiedName(), 0, strlen($enforcingVariant->getFullQualifiedName())) === $enforcingVariant->getFullQualifiedName()) {
            return $cookieVariant;
        }
        
        return $enforcingVariant;
    }
}
?><?php
/**
 * Interceptor which allows switching of variants.
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager
 * @version     $Id: stubVariantSwitchPreInterceptor.php 2807 2010-12-13 15:43:33Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::stubMode',
                      'net::stubbles::websites::variantmanager::stubVariantSettingPreInterceptor'
);
/**
 * Interceptor which allows switching of variants.
 *
 * A variant can be switched in STAGE or DEV mode only. The variant to switch to
 * has to be given with the __variant parameter and must be the fully qualified
 * variant name.
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager
 */
class stubVariantSwitchPreInterceptor extends stubVariantSettingPreInterceptor
{
    /**
     * runtime mode
     *
     * @var  stubMode
     */
    protected $mode;

    /**
     * sets current runtime mode
     *
     * @param  stubMode  $mode
     * @Inject(optional=true)
     */
    public function setMode(stubMode $mode)
    {
        $this->mode = $mode;
    }

    /**
     * checks if there is enough data to select a variant
     *
     * @param   stubRequest   $request   access to request data
     * @param   stubSession   $session   access to session data
     * @param   stubResponse  $response  access to response data
     * @return  bool
     */
    protected function canSelectVariant(stubRequest $request, stubSession $session, stubResponse $response)
    {
        if ($this->isAllowed() === false || $request->hasParam('__variant') === false) {
            return false;
        }

        return true;
    }

    /**
     * checks whether switching the variant is allowed within current context
     *
     * Switching the variant is possible if the application is running in STAGE
     * or DEV mode. If no mode is available it is assumed the application runs
     * in PROD mode.
     *
     * @return  bool
     */
    protected function isAllowed()
    {
        if (null === $this->mode) {
            return false;
        }

        if ($this->mode->name() !== 'STAGE' && $this->mode->name() !== 'DEV') {
            return false;
        }

        return true;
    }

    /**
     * selects variant based on request and session data
     *
     * @param   stubRequest   $request   access to request data
     * @param   stubSession   $session   access to session data
     * @param   stubResponse  $response  access to response data
     * @return  stubVariant
     */
    protected function selectVariant(stubRequest $request, stubSession $session, stubResponse $response)
    {
        $variantName = $request->readParam('__variant')->ifIsOneOf($this->variantFactory->getVariantNames());
        if (null == $variantName) {
            return null;
        }

        return $this->variantFactory->getVariantByName($variantName);
    }
}
?><?php
/**
 * Variant factory that reads variant configurations from xml files with XJConf.
 * 
 * @package     stubbles
 * @subpackage  websites_variantmanager
 * @version     $Id: stubVariantXJConfFactory.php 2420 2009-12-10 16:16:33Z mikey $
 */
stubClassLoader::load('net::stubbles::util::xjconf::xjconf',
                      'net::stubbles::websites::variantmanager::stubAbstractVariantFactory'
);
/**
 * Variant factory that reads variant configurations from xml files with XJConf.
 * 
 * @package     stubbles
 * @subpackage  websites_variantmanager
 */
class stubVariantXJConfFactory extends stubAbstractVariantFactory implements stubXJConfInitializer
{
    /**
     * initialize the interceptors
     *
     * @return  stubInitializer
     * @throws  stubVariantConfigurationException
     */
    public function init()
    {
        try {
            $xjconfProxy = new stubXJConfProxy($this);
            $xjconfProxy->process();
            return $this;
        } catch (stubXJConfException $xjce) {
            throw new stubVariantConfigurationException('Can not read variant configuration: ' . $xjce->getMessage(), $xjce);
        }
    }

    /**
     * returns the descriptor that identifies the initializer
     *
     * @param   string  $type  type of descriptor: config or definition
     * @return  string
     */
    public function getDescriptor($type)
    {
        return 'variantmanager';
    }

    /**
     * returns the data to cache
     *
     * @return  array
     */
    public function getCacheData()
    {
        $cacheData = array('name'           => $this->variantsMap->getName(),
                           'usePersistence' => $this->variantsMap->shouldUsePersistence(),
                           'rootVariant'    => $this->variantsMap->getRootVariant()->getSerialized()
                     );
        return $cacheData;
    }

    /**
     * sets the data from the cache
     *
     * @param  array  $cacheData
     */
    public function setCacheData(array $cacheData)
    {
        $this->variantsMap = new stubVariantsMap($cacheData['rootVariant']->getUnserialized());
        $this->variantsMap->setName($cacheData['name']);
        $this->variantsMap->setUsePersistence($cacheData['usePersistence']);
        
    }

    /**
     * returns definitions that are additionally required beyond the default definition
     *
     * @return  array<string>
     */
    public function getAdditionalDefinitions()
    {
        return array();
    }

    /**
     * returns a list of extensions for the parser
     *
     * @return  array<Extension>
     */
    public function getExtensions()
    {
        return array();
    }

    /**
     * will be called in case the stubXJConfProxy did not found the data in the
     * cache and the initializer has to load values from the facade
     *
     * @param  stubXJConfFacade  $xjconf
     */
    public function loadData(stubXJConfFacade $xjconf)
    {
        $this->variantsMap = $xjconf->getConfigValue('variants');
    }
}
?><?php
/**
 * Base class for the different variant types.
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager_types
 * @version     $Id: stubAbstractVariant.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::variantmanager::types::stubVariant',
                      'net::stubbles::websites::variantmanager::stubVariantConfigurationException'
);
/**
 * Base class for the different variant types.
 * 
 * Implements functionality that is shared and does not influence variant
 * selection algorithms.
 * 
 * @package     stubbles
 * @subpackage  websites_variantmanager_types
 */
abstract class stubAbstractVariant extends stubSerializableObject implements stubVariant
{
    /**
     * List of all children of the variant
     * 
     * @var  array<stubVariant>
     */
    protected $children = array();
    /**
     * Reference to the parent variant.
     * 
     * @var  stubVariant
     */
    protected $parent;
    /**
     * Name of the variant
     * 
     * @var  string
     */
    protected $name     = '';
    /**
     * Title of the variant, only used when exporting the variant configuration
     * 
     * @var  string
     */
    protected $title    = '';
    /**
     * alias of the variant, only used when exporting the variant configuration
     * 
     * @var  string
     */
    protected $alias    = '';

    /**
     * returns the name of the variant
     * 
     * @return  string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * returns the full qualified name of the variant
     *
     * @return  string
     */
    public function getFullQualifiedName()
    {
        if ($this->hasParent() === true && ($this->parent instanceof stubRootVariant) === false) {
            return $this->parent->getFullQualifiedName() . ':' . $this->name;
        }
        
        return $this->name;
    }

    /**
     * sets the name of the variant
     *
     * @param   string  $name
     * @throws  stubVariantConfigurationException
     */
    public function setName($name)
    {
        if (strlen($name) > 12) {
            throw new stubVariantConfigurationException("The variant name '" . $name . "' is too long. Variant names must not be longer than 12 characters.");
        }
        
        $this->name = $name;
    }

    /**
     * returns title of the variant
     * 
     * @return  string
     */
    public function getTitle()
    {
        return $this->title;
    }

    /**
     * sets the title of the variant
     *
     * @param  string  $title
     */
    public function setTitle($title)
    {
        $this->title = $title;
    }

    /**
     * returns alias name of the variant
     * 
     * @return  string
     */
    public function getAlias()
    {
        return $this->alias;
    }

    /**
     * set alias name of the variant
     * 
     * @param  string  $alias  the alias to set
     */
    public function setAlias($alias)
    {
        $this->alias = $alias;
    }

    /**
     * return the forced variant
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  stubVariant
     */
    public function getEnforcingVariant(stubSession $session, stubRequest $request)
    {
        if ($this->isEnforcing($session, $request) === true) {
            if (count($this->children) > 0) {
                foreach ($this->children as $child) {
                    $validChild = $child->getEnforcingVariant($session, $request);
                    if (null !== $validChild) {
                        return $validChild;
                    }
                }
            }
            
            return $this;
        }
        
        return null;
    }

    /**
     * return the variant
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  stubVariant
     */
    public final function getVariant(stubSession $session, stubRequest $request)
    {
        if ($this->isValid($session, $request) === true) {
            if (count($this->children) > 0) {
                foreach ($this->children as $child) {
                    $validChild = $child->getVariant($session, $request);
                    if (null !== $validChild) {
                        return $validChild;
                    }
                }
            }
            
            $this->assign($session, $request);
            return $this;
        }
        
        return null;
    }

    /**
     * check whether the conditions for this variant are met
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  bool
     */
    public function conditionsMet(stubSession $session, stubRequest $request)
    {
        return $this->isValid($session, $request);
    }

    /**
     * assign that this variant has been choosen
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  bool         true if was assigned, else false
     */
    public function assign(stubSession $session, stubRequest $request)
    {
        if ($this->hasParent() === true) {
            $this->getParent()->assign($session, $request);
            return true;
        }
        
        return false;
    }

    /**
     * returns parent variant
     * 
     * @return  stubVariant
     */
    public function getParent()
    {
        return $this->parent;
    }

    /**
     * set parent variant
     * 
     * @param  stubVariant  $parent
     */
    public function setParent(stubVariant $parent = null)
    {
        $this->parent = $parent;
    }

    /**
     * check whether the variant has a parent variant
     * 
     * @return  bool
     */
    public function hasParent()
    {
        return (null !== $this->parent);
    }

    /**
     * return child variants of this variant
     * 
     * @return  array<stubVariant>
     */
    public function getChildren()
    {
        return $this->children;
    }

    /**
     * add a child variant
     * 
     * @param   stubVariant  $child
     * @throws  stubVariantConfigurationException
     */
    public function addChild(stubVariant $child)
    {
        if ($child->hashCode() === $this->hashCode()) {
            throw new stubVariantConfigurationException('A variant can not add itself as child.');
        }
        
        $this->children[$child->getName()] = $child;
        $child->setParent($this);
    }

    /**
     * remove a child variant
     * 
     * @param  stubVariant  $child
     */
    public function removeChild(stubVariant $child)
    {
        if (isset($this->children[$child->getName()]) === true) {
            unset($this->children[$child->getName()]);
            $child->setParent(null);
        }
    }

    /**
     * template method to hook into __sleep()
     *
     * @return  array<string>  list of property names that should not be serialized
     */
    protected function __doSleep()
    {
        foreach ($this->children as $name => $child) {
            $this->_serializedProperties[$name] = $child->getSerialized();
        }
        
        return array('children', 'parent');
    }

    /**
     * template method to hook into __wakeup()
     */
    protected function __doWakeUp()
    {
        foreach ($this->_serializedProperties as $serializedChild) {
            $this->addChild($serializedChild->getUnserialized());
        }
        
        $this->_serializedProperties = array();
    }
}
?><?php
/**
 * This variant type is only used to include variants in the
 * configuration, that can only be set from php code.
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager_types
 * @version     $Id: stubDummyVariant.php 2695 2010-09-03 19:37:29Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::variantmanager::types::stubAbstractVariant');
/**
 * This variant type is only used to include variants in the
 * configuration, that can only be set from php code.
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager_types
 */
class stubDummyVariant extends stubAbstractVariant
{
    /**
     * check whether the variant is an enforcing variant
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  bool
     */
    public function isEnforcing(stubSession $session, stubRequest $request)
    {
        return false;
    }

    /**
     * check whether the variant is valid
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  bool
     */
    public function isValid(stubSession $session, stubRequest $request)
    {
        return false;
    }
}
?><?php
/**
 * Variant that is always valid but never enforcing.
 * 
 * @package     stubbles
 * @subpackage  websites_variantmanager_types
 * @version     $Id: stubLeadVariant.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::variantmanager::types::stubAbstractVariant');
/**
 * Variant that is always valid but never enforcing.
 * 
 * @package     stubbles
 * @subpackage  websites_variantmanager_types
 */
class stubLeadVariant extends stubAbstractVariant
{
    /**
     * check whether the variant is an enforcing variant
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  bool
     */
    public function isEnforcing(stubSession $session, stubRequest $request)
    {
        return false;
    }
    
    /**
     * check whether the variant is valid
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  bool
     */
    public function isValid(stubSession $session, stubRequest $request)
    {
        return true;
    }
}
?><?php
/**
 * A variant chosen randomly based on the weight defined in the configuration.
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager_types
 * @version     $Id: stubRandomVariant.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::variantmanager::types::stubAbstractVariant');
/**
 * A variant chosen randomly based on the weight defined in the configuration.
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager_types
 */
class stubRandomVariant extends stubAbstractVariant
{
    /**
     * weight of the variant
     * 
     * @var  int
     */
    private $weight       = 0;
    /**
     * the choosen sibling
     *
     * @var  array<string,int>
     */
    public static $random = array();

    /**
     * Get the weight of the variant
     * 
     * @return  int
     */
    public function getWeight()
    {
        return $this->weight;
    }

    /**
     * Set the weight of the variant
     * 
     * @param  int  $weight
     */
    public function setWeight($weight)
    {
        $this->weight = $weight;
    }
    
    /**
     * check whether the variant is an enforcing variant
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  bool
     */
    public function isEnforcing(stubSession $session, stubRequest $request)
    {
        return false;
    }
    
    /**
     * check whether the conditions for this variant are met
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  bool
     */
    public function conditionsMet(stubSession $session, stubRequest $request)
    {
        return true;
    }
    
    /**
     * check whether the variant is valid
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  bool
     */
    public function isValid(stubSession $session, stubRequest $request)
    {
        return $this->equals(self::getRandom($this));
    }
    
    /**
     * finds a random variant
     *
     * @param   stubRandomVariant  $actual
     * @return  stubRandomVariant
     */
    protected static function getRandom(self $actual)
    {
        if ($actual->hasParent() == false) {
            return $actual;
        }
        
        $parentHash = $actual->getParent()->hashCode();
        if (isset(self::$random[$parentHash]) == true) {
            return self::$random[$parentHash];
        }
        
        $siblings = $actual->findSiblings();
        if (count($siblings) == 1) {
            self::$random[$parentHash] = $actual;
            return self::$random[$parentHash];
        }
        
        $choice = array();
        foreach ($siblings as $sibling) {
            for ($i = $sibling->weight; $i > 0; $i--) {
                $choice[] = $sibling;
            }
        }
        
        self::$random[$parentHash] = $choice[rand(0, count($choice) - 1)];
        return self::$random[$parentHash];
    }
    
    /**
     * Find the siblings of this variant
     * 
     * @return  array<stubRandomVariant>
     */
    private function findSiblings()
    {
        $siblings = array();
        $parent   = $this->getParent();
        if (null != $parent) {
            $children = $parent->getChildren();
            foreach ($children as $child) {
                if ($child instanceof self) {
                    $siblings[] = $child;
                }
            }
        }
        
        return $siblings;
    }
}
?><?php
/**
 * RequestParamVariant
 * 
 * Will be triggered, if the request contains a specified parameter
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager_types
 * @version     $Id: stubRequestParamVariant.php 2632 2010-08-13 18:31:42Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::variantmanager::types::stubAbstractVariant');
/**
 * RequestParamVariant
 * 
 * Will be triggered, if the request contains a specified parameter
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager_types
 */
class stubRequestParamVariant extends stubAbstractVariant
{
    /**
     * the name of the request parameter
     * 
     * @var  string
     */
    private $paramName  = null;
    /**
     * the value of the request parameter
     * 
     * @var  string
     */
    private $paramValue = null;
    
    /**
     * check whether the variant is an enforcing variant
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  bool
     * @throws  stubVariantConfigurationException
     */
    public function isEnforcing(stubSession $session, stubRequest $request)
    {
        return $this->isValid($session, $request);
    }
    
    /**
     * check whether the variant is valid
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  bool
     * @throws  stubVariantConfigurationException
     */
    public function isValid(stubSession $session, stubRequest $request)
    {
        if (null == $this->paramName) {
            throw new stubVariantConfigurationException('RequestParamVariant requires the param name to be set.');
        }
        
        if ($request->hasParam($this->paramName) == false) {
            return false;
        }
        
        if (null == $this->paramValue) {
            return true;
        }
        
        return $request->validateParam($this->paramName)->isEqualTo($this->paramValue);
    }
    
    /**
     * Set the name of the request parameter
     * 
     * @param  string  $paramName  the paramName to set
     */
    public function setParamName($paramName)
    {
        $this->paramName = $paramName;
    }

    /**
     * Set the desired value of the request parameter
     * 
     * @param  string  $paramValue  the paramValue to set
     */
    public function setParamValue($paramValue)
    {
        $this->paramValue = $paramValue;
    }
}
?><?php
/**
 * Root variant that contains all other variants.
 * 
 * @package     stubbles
 * @subpackage  websites_variantmanager_types
 * @version     $Id: stubRootVariant.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::variantmanager::types::stubAbstractVariant');
/**
 * Root variant that contains all other variants.
 * 
 * @package     stubbles
 * @subpackage  websites_variantmanager_types
 */
class stubRootVariant extends stubAbstractVariant
{
    /**
     * constructor
     */
    public function __construct()
    {
        $this->name = 'root';
    }
    
    /**
     * sets the name of the variant
     *
     * @param  string  $name
     */
    public function setName($name)
    {
        // can not reset name of RootVariant
    }
    
    /**
     * check whether the variant is an enforcing variant
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  bool
     */
    public function isEnforcing(stubSession $session, stubRequest $request)
    {
        return true;
    }
    
    /**
     * check whether the variant is valid
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  bool
     */
    public function isValid(stubSession $session, stubRequest $request)
    {
        return true;
    }
}
?><?php
/**
 * Interface for all variants.
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager_types
 * @version     $Id: stubVariant.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::session::stubSession'
);
/**
 * Interface for all variants.
 *
 * @package     stubbles
 * @subpackage  websites_variantmanager_types
 */
interface stubVariant extends stubSerializable
{
    /**
     * returns the name of the variant
     * 
     * @return  string
     */
    public function getName();

    /**
     * returns the full qualified name of the variant
     *
     * @return  string
     */
    public function getFullQualifiedName();

    /**
     * sets the name of the variant
     *
     * @param  string  $name
     */
    public function setName($name);

    /**
     * returns title of the variant
     * 
     * @return  string
     */
    public function getTitle();

    /**
     * sets the title of the variant
     *
     * @param  string  $title
     */
    public function setTitle($title);

    /**
     * returns alias name of the variant
     * 
     * @return  string
     */
    public function getAlias();

    /**
     * check whether the variant is an enforcing variant
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  boolean
     */
    public function isEnforcing(stubSession $session, stubRequest $request);

    /**
     * return the forced variant
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  stubVariant
     */
    public function getEnforcingVariant(stubSession $session, stubRequest $request);

    /**
     * return the variant
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request
     * @return  stubVariant
     */
    public function getVariant(stubSession $session, stubRequest $request);

    /**
     * check whether the conditions for this variant are met
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  boolean
     */
    public function conditionsMet(stubSession $session, stubRequest $request);

    /**
     * check whether the variant is valid
     * 
     * @param   stubSession  $session  access to session
     * @param   stubRequest  $request  access to request parameters
     * @return  boolean
     */
    public function isValid(stubSession $session, stubRequest $request);

    /**
     * assign that this variant has been choosen
     * 
     * @param  stubSession  $session  access to session
     * @param  stubRequest  $request  access to request parameters
     */
    public function assign(stubSession $session, stubRequest $request);

    /**
     * returns parent variant
     * 
     * @return  stubVariant
     */
    public function getParent();

    /**
     * set parent variant
     * 
     * @param  stubVariant  $parent
     */
    public function setParent(stubVariant $parent = null);

    /**
     * check whether the variant has a parent variant
     * 
     * @return  boolean
     */
    public function hasParent();

    /**
     * return child variants of this variant
     * 
     * @return  array<stubVariant>
     */
    public function getChildren();

    /**
     * add a child variant
     * 
     * @param  stubVariant  $child
     */
    public function addChild(stubVariant $child);

    /**
     * remove a child variant
     * 
     * @param  stubblesVariant  $child
     */
    public function removeChild(stubVariant $child);
}
?><?php
/**
 * Serializes current mode into xml result document.
 *
 * @package     stubbles
 * @subpackage  websites_xml_generator
 * @version     $Id: stubModeXMLGenerator.php 2903 2011-01-12 11:47:34Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::stubMode',
                      'net::stubbles::websites::xml::generator::stubXMLGenerator'
);
/**
 * Serializes current mode into xml result document.
 *
 * Default values are whether the session is new or not, the current and
 * the next token of the request:
 * <code>
 * <document>
 *   [...]
 *   <mode>
 *     <name>DEV</name>
 *     <isCacheEnabled>true</isCacheEnabled>
 *   </mode>
 *   [...]
 * </document>
 * </code>
 *
 * @package     stubbles
 * @subpackage  websites_xml_generator
 */
class stubModeXMLGenerator extends stubBaseObject implements stubXMLGenerator
{
    /**
     * name of mode we are running in
     *
     * @var  string
     */
    protected $modeName     = 'PROD';
    /**
     * whether caching is enabled or not
     *
     * @var  bool
     */
    protected $cacheEnabled = true;

    /**
     * sets the mode we are running in
     *
     * @param  stubMode  $mode
     * @Inject(optional=true)
     */
    public function setMode(stubMode $mode)
    {
        $this->modeName     = $mode->name();
        $this->cacheEnabled = $mode->isCacheEnabled();
    }

    /**
     * operations to be done before serialization is done
     */
    public function startup()
    {
        // nothing to do
    }

    /**
     * checks whether document part is cachable or not
     *
     * @return  bool
     */
    public function isCachable()
    {
        return $this->cacheEnabled;
    }

    /**
     * returns a list of variables that have an influence on caching
     *
     * @return  array<string,scalar>
     */
    public function getCacheVars()
    {
        return array();
    }

    /**
     * serializes session data into result document
     *
     * @param  stubXMLStreamWriter  $xmlStreamWriter  writer to be used
     * @param  stubXMLSerializer    $xmlSerializer    serializer to be used
     */
    public function generate(stubXMLStreamWriter $xmlStreamWriter, stubXMLSerializer $xmlSerializer)
    {
        $xmlStreamWriter->writeStartElement('mode');
        $xmlStreamWriter->writeElement('name', array(), $this->modeName);
        $xmlStreamWriter->writeElement('isCacheEnabled', array(), ((true === $this->cacheEnabled) ? ('true') : ('false')));
        $xmlStreamWriter->writeEndElement();  // end mode
    }

    /**
     * operations to be done after serialization is done
     */
    public function cleanup()
    {
        // nothing to do
    }
}
?><?php
/**
 * Serializes request data into xml result document.
 *
 * @package     stubbles
 * @subpackage  websites_xml_generator
 * @version     $Id: stubRequestXMLGenerator.php 2903 2011-01-12 11:47:34Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::request::useragent::stubUserAgent',
                      'net::stubbles::websites::xml::generator::stubXMLGenerator'
);
/**
 * Serializes request data into xml result document.
 *
 * Currently this is the user agent and the request errors created during
 * processing of the processabled:
 * <code>
 * <document>
 *   [...]
 *   <request>
 *     <userAgent name="Mozilla ..." isBot="false"/>
 *     <errors>
 *       <error id="foo">
 *         <messages>
 *           <de_DE>Dies ist eine deutsche Fehlermeldung.</de_DE>
 *           <en_EN>This is an english error message.</en_EN>
 *         </messages>
 *       </error>
 *       [...]
 *     </errors>
 *   </request>
 *   [...]
 * </document>
 * </code>
 * Concrete request values will not be written into the result document.
 *
 * The serializing of the request should take place after processables were
 * processed - only these generate the request value errors stored in the
 * request. Additionally those processables should take care of whether a route
 * is cachable or not and the required cache variables.
 *
 * @package     stubbles
 * @subpackage  websites_xml_generator
 */
class stubRequestXMLGenerator extends stubBaseObject implements stubXMLGenerator
{
    /**
     * request instance to be used
     *
     * @var  stubRequest
     */
    protected $request;
    /**
     * user agent detected from request
     *
     * @var    stubUserAgent
     * @since  1.2.0
     */
    protected $userAgent;

    /**
     * constructor
     *
     * @param  stubRequest    $request
     * @param  stubUserAgent  $userAgent
     * @Inject
     */
    public function __construct(stubRequest $request, stubUserAgent $userAgent)
    {
        $this->request   = $request;
        $this->userAgent = $userAgent;
    }

    /**
     * operations to be done before serialization is done
     */
    public function startup()
    {
        // nothing to do
    }

    /**
     * checks whether document part is cachable or not
     *
     * @return  bool
     */
    public function isCachable()
    {
        return true;
    }

    /**
     * returns a list of variables that have an influence on caching
     *
     * @return  array<string,scalar>
     */
    public function getCacheVars()
    {
        return array('isBot' => $this->userAgent->isBot());
    }

    /**
     * serializes request data into result document
     *
     * @param  stubXMLStreamWriter  $xmlStreamWriter  writer to be used
     * @param  stubXMLSerializer    $xmlSerializer    serializer to be used
     */
    public function generate(stubXMLStreamWriter $xmlStreamWriter, stubXMLSerializer $xmlSerializer)
    {
        $xmlStreamWriter->writeStartElement('request');
        $xmlSerializer->serialize($this->userAgent, $xmlStreamWriter);
        foreach ($this->request->paramErrors()->get() as $requestValueName => $requestErrorValues) {
            $xmlStreamWriter->writeStartElement('value');
            $xmlStreamWriter->writeAttribute('name', $requestValueName);
            $xmlSerializer->serialize(array_values($requestErrorValues), $xmlStreamWriter, array(stubXMLSerializer::OPT_ROOT_TAG => 'errors'));
            $xmlStreamWriter->writeEndElement();
        }

        $xmlStreamWriter->writeEndElement();  // end request
    }

    /**
     * operations to be done after serialization is done
     */
    public function cleanup()
    {
        // nothing to do
    }
}
?><?php
/**
 * Serializes route data into xml result document.
 *
 * @package     stubbles
 * @subpackage  websites_xml_generator
 * @version     $Id: stubRouteXMLGenerator.php 2903 2011-01-12 11:47:34Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjector',
                      'net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::request::stubRequestPrefixDecorator',
                      'net::stubbles::websites::processors::routing::stubRoute',
                      'net::stubbles::websites::xml::generator::stubXMLGenerator',
                      'net::stubbles::websites::xml::routing::stubXmlFormProcessable'
);
/**
 * Serializes route data into xml result document.
 *
 * @package     stubbles
 * @subpackage  websites_xml_generator
 */
class stubRouteXMLGenerator extends stubBaseObject implements stubXMLGenerator
{
    /**
     * request instance to be used
     *
     * @var  stubRequest
     */
    protected $request;
    /**
     * injector instance to be used
     *
     * @var  stubInjector
     */
    protected $injector;
    /**
     * route to be serialized
     *
     * @var  stubRoute
     */
    protected $route;
    /**
     * list of available processables
     *
     * @var  array<string,stubProcessable>
     */
    protected $processables = array();
    /**
     * switch whether document part is cachable or not
     *
     * @var  bool
     */
    protected $isCachable   = true;
    /**
     * list of cache variables for this route
     *
     * @var  array<string,scalar>
     */
    protected $cacheVars    = array();

    /**
     * constructor
     *
     * @param  stubRequest   $request
     * @param  stubInjector  $injector
     * @param  stubRoute     $route
     * @Inject
     */
    public function __construct(stubRequest $request, stubInjector $injector, stubRoute $route)
    {
        $this->request  = $request;
        $this->injector = $injector;
        $this->route    = $route;
    }

    /**
     * operations to be done before serialization is done
     */
    public function startup()
    {
        foreach ($this->route->getProcessables() as $name => $processable) {
            $processable = $this->injector->getInstance($processable)
                                          ->setContext(array('prefix' => $name));
            $processable->startup();
            if ($processable->isAvailable() === true) {
                $this->processables[$name] = $processable;
                // we can spare this if the route is not cachable
                if (true === $this->isCachable) {
                    if ($processable->isCachable() === false) {
                        $this->isCachable = false;
                    } else {
                        $this->cacheVars = array_merge($this->cacheVars, $processable->getCacheVars());
                    }
                }
            }
        }
    }

    /**
     * checks whether document part is cachable or not
     *
     * Document part is cachable if all processables are cachable.
     *
     * @return  bool
     */
    public function isCachable()
    {
        return $this->isCachable;
    }

    /**
     * returns a list of variables that have an influence on caching
     *
     * @return  array<string,scalar>
     */
    public function getCacheVars()
    {
        return $this->cacheVars;
    }

    /**
     * serializes session data into result document
     *
     * @param  stubXMLStreamWriter  $xmlStreamWriter  writer to be used
     * @param  stubXMLSerializer    $xmlSerializer    serializer to be used
     */
    public function generate(stubXMLStreamWriter $xmlStreamWriter, stubXMLSerializer $xmlSerializer)
    {
        $formValues = array();
        foreach ($this->processables as $name => $processable) {
            $data = $processable->process();
            if ($this->request->isCancelled() === true) {
                return;
            }
            
            $xmlSerializer->serialize($data, $xmlStreamWriter, array(stubXMLSerializer::OPT_ROOT_TAG => $name));
            if ($processable instanceof stubXmlFormProcessable) {
                $formValues[$name] = $processable->getFormValues();
            }
        }

        $xmlSerializer->serialize($formValues, $xmlStreamWriter, array(stubXMLSerializer::OPT_ROOT_TAG => 'forms'));
    }

    /**
     * operations to be done after serialization is done
     */
    public function cleanup()
    {
        foreach ($this->processables as $name => $processable) {
            $processable->cleanup();
        }
    }
}
?><?php
/**
 * Serializes session data into xml result document.
 *
 * @package     stubbles
 * @subpackage  websites_xml_generator
 * @version     $Id: stubSessionXMLGenerator.php 2903 2011-01-12 11:47:34Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::ipo::session::stubSession',
                      'net::stubbles::websites::xml::generator::stubXMLGenerator'
);
/**
 * Serializes session data into xml result document.
 *
 * Default values are whether the session is new or not, the current and
 * the next token of the request:
 * <code>
 * <document>
 *   [...]
 *   <session>
 *     <acceptsCookies>true</acceptsCookies>
 *     <id>abc123</id>
 *     <name>PHPSESSID</name>
 *     <isNew>true</isNew>
 *     <variant>
 *       <name>foo</name>
 *       <alias>bar</alias>
 *     </variant>
 *   </session>
 *   [...]
 * </document>
 * </code>
 * Concrete session data will not be written into the result document.
 *
 * @package     stubbles
 * @subpackage  websites_xml_generator
 */
class stubSessionXMLGenerator extends stubBaseObject implements stubXMLGenerator
{
    /**
     * request instance to be used
     *
     * @var  stubRequest
     */
    protected $request;
    /**
     * session instance to be used
     *
     * @var  stubSession
     */
    protected $session;

    /**
     * constructor
     *
     * @param  stubRequest  $request
     * @param  stubSession  $session
     * @Inject
     */
    public function __construct(stubRequest $request, stubSession $session)
    {
        $this->request = $request;
        $this->session = $session;
    }

    /**
     * operations to be done before serialization is done
     */
    public function startup()
    {
        // nothing to do
    }

    /**
     * checks whether document part is cachable or not
     *
     * @return  bool
     */
    public function isCachable()
    {
        return true;
    }

    /**
     * returns a list of variables that have an influence on caching
     *
     * @return  array<string,scalar>
     */
    public function getCacheVars()
    {
        return array('isNew'          => $this->session->isNew(),
                     'variant'        => (string) $this->session->getValue('net.stubbles.websites.variantmanager.variant.name'),
                     'acceptsCookies' => $this->request->acceptsCookies()
               );
    }

    /**
     * serializes session data into result document
     *
     * @param  stubXMLStreamWriter  $xmlStreamWriter  writer to be used
     * @param  stubXMLSerializer    $xmlSerializer    serializer to be used
     */
    public function generate(stubXMLStreamWriter $xmlStreamWriter, stubXMLSerializer $xmlSerializer)
    {
        $xmlStreamWriter->writeStartElement('session');
        if ($this->request->acceptsCookies() === true) {
            $xmlStreamWriter->writeElement('acceptsCookies', array(), 'true');
        } else {
            $xmlStreamWriter->writeElement('acceptsCookies', array(), 'false');
        }
        
        $xmlStreamWriter->writeElement('id', array(), '$SESSION_ID');
        $xmlStreamWriter->writeElement('name', array(), '$SESSION_NAME');
        $xmlStreamWriter->writeElement('isNew', array(), (($this->session->isNew() === true) ? ('true') : ('false')));
        $xmlStreamWriter->writeStartElement('variant');
        $xmlStreamWriter->writeElement('name', array(), (string) $this->session->getValue('net.stubbles.websites.variantmanager.variant.name'));
        $xmlStreamWriter->writeElement('alias', array(), (string) $this->session->getValue('net.stubbles.websites.variantmanager.variant.alias'));
        $xmlStreamWriter->writeEndElement();  // end variant
        $xmlStreamWriter->writeEndElement();  // end session
    }

    /**
     * operations to be done after serialization is done
     */
    public function cleanup()
    {
        // nothing to do
    }
}
?><?php
/**
 * Generator for serializing current variant configuration to XML.
 *
 * @package     stubbles
 * @subpackage  websites_xml_generator
 * @version     $Id: stubVariantListGenerator.php 2903 2011-01-12 11:47:34Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjector',
                      'net::stubbles::ipo::session::stubSession',
                      'net::stubbles::websites::variantmanager::types::stubVariant',
                      'net::stubbles::websites::xml::generator::stubXMLGenerator'
);
/**
 * Generator for serializing current variant configuration to XML.
 *
 * @package     stubbles
 * @subpackage  websites_xml_generator
 */
class stubVariantListGenerator extends stubBaseObject implements stubXMLGenerator
{
    /**
     * session instance to be used
     *
     * @var  stubSession
     */
    protected $session;
    /**
     * injector instance for creating the variant factory if necessary
     *
     * @var  stubInjector
     */
    protected $injector;

    /**
     * constructor
     *
     * @param  stubRequest  $request
     * @param  stubSession  $session
     * @Inject
     */
    public function __construct(stubSession $session, stubInjector $injector)
    {
        $this->session  = $session;
        $this->injector = $injector;
    }

    /**
     * operations to be done before serialization is done
     */
    public function startup()
    {
        // nothing to do
    }

    /**
     * checks whether document part is cachable or not
     *
     * @return  bool
     */
    public function isCachable()
    {
        return true;
    }

    /**
     * returns a list of variables that have an influence on caching
     *
     * @return  array<string,scalar>
     */
    public function getCacheVars()
    {
        return array();
    }

    /**
     * serializes session data into result document
     *
     * @param  stubXMLStreamWriter  $xmlStreamWriter  writer to be used
     * @param  stubXMLSerializer    $xmlSerializer    serializer to be used
     */
    public function generate(stubXMLStreamWriter $xmlStreamWriter, stubXMLSerializer $xmlSerializer)
    {
        $xmlStreamWriter->writeStartElement('variants');
        $xmlStreamWriter->writeStartElement('variantList');
        if ($this->session->hasValue('net.stubbles.websites.variantmanager.variant.name') === true) {
            $this->serializeChildVariants($this->injector->getInstance('net::stubbles::websites::variantmanager::stubVariantFactory')
                                                         ->init()
                                                         ->getVariantsMap()
                                                         ->getRootVariant(),
                                          $xmlStreamWriter
            );
        }

        $xmlStreamWriter->writeEndElement();  // end variantList
        $xmlStreamWriter->writeEndElement();  // end variants
    }

    /**
     * serializes children of given variant
     *
     * @param  stubVariant          $variant
     * @param  stubXMLStreamWriter  $xmlStreamWriter
     */
    protected function serializeChildVariants(stubVariant $variant, stubXMLStreamWriter $xmlStreamWriter)
    {
         foreach ($variant->getChildren() as $childVariant) {
            /* @var $childVariant stubVariant */
            $xmlStreamWriter->writeStartElement('variant');
            $xmlStreamWriter->writeAttribute('name', $childVariant->getFullQualifiedName());
            $xmlStreamWriter->writeAttribute('title', $childVariant->getTitle());
            $xmlStreamWriter->writeAttribute('type', $childVariant->getClassName());
            $this->serializeChildVariants($childVariant, $xmlStreamWriter);
            $xmlStreamWriter->writeEndElement();
        }
    }

    /**
     * operations to be done after serialization is done
     */
    public function cleanup()
    {
        // nothing to do
    }
}
?><?php
/**
 * Interface for generators of the xml result document.
 *
 * @package     stubbles
 * @subpackage  websites_xml_generator
 * @version     $Id: stubXMLGenerator.php 2903 2011-01-12 11:47:34Z mikey $
 */
stubClassLoader::load('net::stubbles::xml::stubXMLStreamWriter',
                      'net::stubbles::xml::serializer::stubXMLSerializer'
);
/**
 * Interface for generators of the xml result document.
 *
 * @package     stubbles
 * @subpackage  websites_xml_generator
 */
interface stubXMLGenerator extends stubObject
{
    /**
     * operations to be done before serialization is done
     */
    public function startup();

    /**
     * checks whether document part is cachable or not
     *
     * @return  bool
     */
    public function isCachable();

    /**
     * returns a list of variables that have an influence on caching
     *
     * @return  array<string,scalar>
     */
    public function getCacheVars();

    /**
     * serializes something
     *
     * @param  stubXMLStreamWriter  $xmlStreamWriter  writer to be used
     * @param  stubXMLSerializer    $xmlSerializer    serializer to be used
     */
    public function generate(stubXMLStreamWriter $xmlStreamWriter, stubXMLSerializer $xmlSerializer);

    /**
     * operations to be done after serialization is done
     */
    public function cleanup();
}
?><?php
/**
 * Facade to hide complexity of connecting single generator instances.
 *
 * @package     stubbles
 * @subpackage  websites_xml_generator
 * @version     $Id: stubXmlGeneratorFacade.php 2903 2011-01-12 11:47:34Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjector',
                      'net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::websites::xml::generator::stubXMLGenerator'
);
/**
 * Facade to hide complexity of connecting single generator instances.
 *
 * @package     stubbles
 * @subpackage  websites_xml_generator
 * @since       1.5.0
 */
class stubXmlGeneratorFacade extends stubBaseObject implements stubXMLGenerator
{
    /**
     * request instance
     *
     * @var  stubRequest
     */
    protected $request;
    /**
     * injector instance
     *
     * @var  stubInjector
     */
    protected $injector;
    /**
     * list of xml generators to be used
     *
     * @var  array<stubXMLGenerator>
     */
    protected $xmlGenerators  = array();

    /**
     * constructor
     *
     * @param  stubRequest   $request
     * @param  stubInjector  $injector
     * @Inject
     */
    public function  __construct(stubRequest $request, stubInjector $injector)
    {
        $this->request  = $request;
        $this->injector = $injector;
    }

    /**
     * operations to be done before serialization is done
     */
    public function startup()
    {
        foreach ($this->injector->getConstant('net.stubbles.websites.xml.generators') as $xmlGeneratorClassName) {
            $xmlGenerator = $this->injector->getInstance($xmlGeneratorClassName);
            $xmlGenerator->startup();
            $this->xmlGenerators[] = $xmlGenerator;
        }
    }

    /**
     * checks whether document part is cachable or not
     *
     * @return  bool
     */
    public function isCachable()
    {
        foreach ($this->xmlGenerators as $xmlGenerator) {
            if ($xmlGenerator->isCachable() === false) {
                return false;
            }
        }

        return true;
    }

    /**
     * returns a list of variables that have an influence on caching
     *
     * @return  array<string,scalar>
     */
    public function getCacheVars()
    {
        $cacheVars = array();
        foreach ($this->xmlGenerators as $xmlGenerator) {
            $cacheVars = array_merge($cacheVars, $xmlGenerator->getCacheVars());
        }

        return $cacheVars;
    }

    /**
     * serializes something
     *
     * @param  stubXMLStreamWriter  $xmlStreamWriter  writer to be used
     * @param  stubXMLSerializer    $xmlSerializer    serializer to be used
     */
    public function generate(stubXMLStreamWriter $xmlStreamWriter, stubXMLSerializer $xmlSerializer)
    {
        foreach ($this->xmlGenerators as $xmlGenerator) {
            $xmlGenerator->generate($xmlStreamWriter, $xmlSerializer);
            if ($this->request->isCancelled() === true) {
                return;
            }
        }
    }

    /**
     * operations to be done after serialization is done
     */
    public function cleanup()
    {
        foreach ($this->xmlGenerators as $xmlGenerator) {
            $xmlGenerator->cleanup();
        }
    }
}
?><?php
/**
 * Base implementation for a xml form processable.
 *
 * @package     stubbles
 * @subpackage  websites_xml_routing
 * @version     $Id: stubAbstractXmlFormProcessable.php 2633 2010-08-13 18:34:54Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::processors::routing::stubAbstractProcessable',
                      'net::stubbles::websites::xml::routing::stubXmlFormProcessable'
);
/**
 * Base implementation for a xml form processable.
 *
 * @package     stubbles
 * @subpackage  websites_xml_routing
 */
abstract class stubAbstractXmlFormProcessable extends stubAbstractProcessable implements stubXmlFormProcessable
{
    /**
     * switch whether form value serialization to DOM should be disabled
     *
     * @var    bool
     * @since  1.2.0
     */
    private $_serializeFormValue = true;

    /**
     * disables serialization of form values into DOM
     *
     * This can be helpful in case you want to redisplay the form after
     * processing it successfully but not prefilled with values from the request
     * before.
     *
     * @since  1.2.0
     */
    protected function disableFormValueSerialization()
    {
        $this->_serializeFormValue = false;
    }

    /**
     * enables serialization of form values into DOM
     *
     * Redo disabling. There is no need to specifically enable the serialization,
     * it's enabled by default. This method is only in case you need to revert
     * the disabling from before.
     *
     * @since  1.2.0
     */
    protected function enableFormValueSerialization()
    {
        $this->_serializeFormValue = true;
    }

    /**
     * returns a list of form values
     *
     * @return  array<string,string>
     */
    public function getFormValues()
    {
        if (false === $this->_serializeFormValue) {
            return array();
        }
        
        $data      = array();
        foreach ($this->request->getParamNames() as $key) {
            $data[$key] = $this->request->readParam($key)->unsecure();
        }
        
        return $data;
    }
}
?><?php
/**
 * Interface for a xml form processable.
 *
 * @package     stubbles
 * @subpackage  websites_xml_routing
 * @version     $Id: stubXmlFormProcessable.php 2222 2009-06-09 21:55:06Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::processors::routing::stubProcessable');
/**
 * Interface for a xml form processable.
 *
 * @package     stubbles
 * @subpackage  websites_xml_routing
 */
interface stubXmlFormProcessable extends stubProcessable
{
    /**
     * returns a list of form values
     *
     * @return  array<string,string>
     */
    public function getFormValues();
}
?><?php
/**
 * Skin generator that uses another skin generator and caches its results.
 *
 * @package     stubbles
 * @subpackage  websites_xml_skin
 * @version     $Id: stubCachingSkinGenerator.php 2222 2009-06-09 21:55:06Z mikey $
 */
stubClassLoader::load('net::stubbles::util::cache::stubCacheContainer',
                      'net::stubbles::websites::xml::skin::stubSkinGenerator'
);
/**
 * Skin generator that uses another skin generator and caches its results.
 *
 * @package     stubbles
 * @subpackage  websites_xml_skin
 */
class stubCachingSkinGenerator extends stubBaseObject implements stubSkinGenerator
{
    /**
     * real skin generator to be used
     *
     * @var  stubSkinGenerator
     */
    protected $skinGenerator;
    /**
     * cache to be used
     *
     * @var  stubCacheContainer
     */
    protected $cache;

    /**
     * constructor
     *
     * @param  stubSkinGenerator   $skinGenerator  real skin generator to be used
     * @param  stubCacheContainer  $cache          cache to be used
     * @Inject
     * @Named{skinGenerator}('websites.xml.skin.default')
     * @Named{cache}('skin')
     */
    public function __construct(stubSkinGenerator $skinGenerator, stubCacheContainer $cache)
    {
        $this->skinGenerator = $skinGenerator;
        $this->cache         = $cache;
    }

    /**
     * checks whether a given skin exists
     *
     * @param   string  $skinName
     * @return  bool
     */
    public function hasSkin($skinName)
    {
        return $this->skinGenerator->hasSkin($skinName);
    }

    /**
     * generates the skin document
     *
     * @param   string       $routeName
     * @param   string       $skinName
     * @param   string       $locale
     * @return  DOMDocument
     */
    public function generate($routeName, $skinName, $locale)
    {
        $key = md5($routeName . $skinName . $locale);
        if ($this->cache->has($key) === true) {
            $resultXSL = new DOMDocument();
            $resultXSL->loadXML($this->cache->get($key));
            return $resultXSL;
        }
        
        $resultXSL = $this->skinGenerator->generate($routeName, $skinName, $locale);
        $this->cache->put($key, $resultXSL->saveXML());
        return $resultXSL;
    }
}
?><?php
/**
 * Default implementation to generate the skin to be applied onto the XML result document.
 *
 * @package     stubbles
 * @subpackage  websites_xml_skin
 * @version     $Id: stubDefaultSkinGenerator.php 2863 2011-01-10 16:35:36Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::stubFactory',
                      'net::stubbles::lang::stubMode',
                      'net::stubbles::websites::xml::skin::stubSkinGenerator',
                      'net::stubbles::xml::stubXMLException',
                      'net::stubbles::xml::xsl::stubXSLProcessor',
                      'net::stubbles::xml::xsl::util::stubXslImportStreamWrapper',
                      'net::stubbles::xml::xsl::util::stubXslXIncludeStreamWrapper'
);
/**
 * Default implementation to generate the skin to be applied onto the XML result document.
 *
 * @package     stubbles
 * @subpackage  websites_xml_skin
 */
class stubDefaultSkinGenerator extends stubBaseObject implements stubSkinGenerator
{
    /**
     * xsl processor to be used for generating the skin
     *
     * @var  stubXSLProcessor
     */
    protected $xslProcessor;
    /**
     * cache path for generated skins
     *
     * @var  string
     */
    protected $cachePath;
    /**
     * config path
     *
     * @var  string
     */
    protected $configPath;
    /**
     * path to page files
     *
     * @var  string
     */
    protected $pagePath;
    /**
     * file mode for cache pathes to create
     *
     * @var  int
     */
    protected $fileMode          = 0700;
    /**
     * switch whether cache is enabled or not
     *
     * @var  bool
     */
    protected $cacheEnabled      = true;

    /**
     * constructor
     *
     * @param  stubXSLProcessor  $xslProcessor
     * @param  string            $cachePath
     * @param  string            $configPath
     * @param  string            $pagePath
     * @Inject
     * @Named{cachePath}('net.stubbles.cache.path')
     * @Named{configPath}('net.stubbles.config.path')
     * @Named{pagePath}('net.stubbles.page.path')
     */
    public function __construct(stubXSLProcessor $xslProcessor, $cachePath, $configPath, $pagePath)
    {
        $this->xslProcessor = $xslProcessor;
        $this->cachePath    = $cachePath;
        $this->configPath   = $configPath;
        $this->pagePath     = $pagePath;
    }

    /**
     * sets file mode for cache pathes to create
     *
     * @param   int                       $fileMode
     * @return  stubDefaultSkinGenerator
     * @Inject(optional=true)
     * @Named('net.stubbles.filemode')
     */
    public function setFileMode($fileMode)
    {
        $this->fileMode = $fileMode;
        return $this;
    }

    /**
     * enable/disable caching via mode
     *
     * @param  stubMode  $mode
     * @Inject(optional=true)
     */
    public function enableCache(stubMode $mode)
    {
        $this->cacheEnabled = $mode->isCacheEnabled();
    }

    /**
     * enable common path
     *
     * @param   bool                      $enableCommonPath
     * @param   string                    $commonPagePath
     * @return  stubDefaultSkinGenerator
     * @Inject(optional=true)
     * @Named{enableCommonPath}('net.stubbles.websites.xml.skin.common.enable')
     * @Named{commonPagePath}('net.stubbles.pages.path.common')
     */
    public function enableCommonPath($enableCommonPath, $commonPagePath)
    {
        if (true === (bool) $enableCommonPath) {
            stubXslXIncludeStreamWrapper::addIncludePath('common', $commonPagePath);
        }

        return $this;
    }

    /**
     * checks whether a given skin exists
     *
     * @param   string  $skinName
     * @return  bool
     */
    public function hasSkin($skinName)
    {
        return file_exists($this->pagePath . '/skin/' . $skinName . '.xml');
    }

    /**
     * generates the skin document
     *
     * @param   string       $routeName
     * @param   string       $skinName
     * @param   string       $locale
     * @return  DOMDocument
     */
    public function generate($routeName, $skinName, $locale)
    {
        stubXslImportStreamWrapper::init($this->configPath, $this->cachePath, $this->cacheEnabled);
        stubXslXIncludeStreamWrapper::register($this->xslProcessor,
                                               $this->pagePath . '/txt',
                                               $this->cachePath . '/xinc',
                                               $this->fileMode,
                                               $this->cacheEnabled,
                                               $routeName
        );
        $resultXSL = $this->xslProcessor->applyStylesheet($this->createXslStylesheet())
                                        ->withParameter('', 'page', $routeName)
                                        ->withParameter('', 'lang', $locale)
                                        ->withParameter('', 'lang_base', substr($locale, 0, strpos($locale, '_')) . '_*')
                                        ->onDocument($this->createXmlSkinDocument($skinName))
                                        ->toDoc();
        @$resultXSL->xinclude();
        return $resultXSL;
    }

    /**
     * creates the xsl stylesheet
     *
     * @return  DOMDocument
     * @todo    fix selection of uri
     */
    protected function createXslStylesheet()
    {
        $uris        = stubFactory::getResourceURIs('xsl/master.xsl');
        $domDocument = new DOMDocument();
        $domDocument->load($uris[0]);
        return $domDocument;
    }

    /**
     * creates the skin document
     *
     * @param   string       $skinName
     * @return  DOMDocument
     * @throws  stubXMLException
     */
    protected function createXmlSkinDocument($skinName)
    {
        $domDocument = new DOMDocument();
        if (false === $domDocument->load($this->pagePath . '/skin/' . $skinName . '.xml')) {
            throw new stubXMLException('Invalid xml file ' . $this->pagePath . '/skin/' . $skinName . '.xml');
        }
        
        return $domDocument;
    }
}
?><?php
/**
 * Interface to generate the skin to be applied onto the XML result document.
 *
 * @package     stubbles
 * @subpackage  websites_xml_skin
 * @version     $Id: stubSkinGenerator.php 2222 2009-06-09 21:55:06Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::session::stubSession');
/**
 * Interface to generate the skin to be applied onto the XML result document.
 *
 * @package     stubbles
 * @subpackage  websites_xml_skin
 */
interface stubSkinGenerator extends stubObject
{
    /**
     * checks whether a given skin exists
     *
     * @param   string  $skinName
     * @return  bool
     */
    public function hasSkin($skinName);

    /**
     * generates the skin document
     *
     * @param   string       $routeName
     * @param   string       $skinName
     * @param   string       $locale
     * @return  DOMDocument
     */
    public function generate($routeName, $skinName, $locale);
}
?><?php
/**
 * Provides skin generator instances depending on the current runtime mode.
 *
 * @package     stubbles
 * @subpackage  websites_xml_skin
 * @version     $Id: stubSkinGeneratorProvider.php 2111 2009-03-04 13:39:25Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjectionProvider',
                      'net::stubbles::lang::stubMode'
);
/**
 * Provides skin generator instances depending on the current runtime mode.
 *
 * @package     stubbles
 * @subpackage  websites_xml_skin
 */
class stubSkinGeneratorProvider extends stubBaseObject implements stubInjectionProvider
{
    /**
     * current mode we are running in
     *
     * @var  stubMode
     */
    protected $mode;
    /**
     * injector instance
     *
     * @var  stubInjector
     */
    protected $injector;

    /**
     * constructor
     *
     * @param  stubInjector  $injector
     * @Inject
     */
    public function __construct(stubInjector $injector)
    {
        $this->injector = $injector;
    }

    /**
     * sets the runtime mode we are running in
     *
     * @param  stubMode      $mode
     * @Inject(optional=true)
     */
    public function setMode(stubMode $mode)
    {
        $this->mode = $mode;
    }

    /**
     * returns the value to provide
     *
     * @param   string  $name  optional
     * @return  mixed
     */
    public function get($name = null)
    {
        if (null === $this->mode || $this->mode->isCacheEnabled() === true) {
            return $this->injector->getInstance('stubSkinGenerator', 'websites.xml.skin.cached');
        }
        
        return $this->injector->getInstance('stubSkinGenerator', 'websites.xml.skin.default');
    }
}
?><?php
/**
 * Preinterceptor that is able to display the last created XML result document.
 *
 * @package     stubbles
 * @subpackage  websites_xml
 * @version     $Id: stubShowLastXMLInterceptor.php 2632 2010-08-13 18:31:42Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::interceptors::stubPreInterceptor');
/**
 * Preinterceptor that is able to display the last created XML result document.
 *
 * This interceptor cancels the request in case the request param
 * showLastRequestXML is set and the session is not new.
 *
 * @package     stubbles
 * @subpackage  websites_xml
 */
class stubShowLastXMLInterceptor extends stubBaseObject implements stubPreInterceptor
{
    /**
     * does the preprocessing stuff
     *
     * @param  stubRequest   $request   access to request data
     * @param  stubSession   $session   access to session data
     * @param  stubResponse  $response  access to response data
     */
    public function preProcess(stubRequest $request, stubSession $session, stubResponse $response)
    {
        if ($request->hasParam('showLastRequestXML') === true && $session->isNew() === false) {
            $response->addHeader('Content-type', 'text/xml');
            $response->write($session->getValue('net.stubbles.websites.lastRequestResponseData'));
            $request->cancel();
        }
    }
}
?><?php
/**
 * Default processor delivered by stubbles.
 *
 * @package     stubbles
 * @subpackage  websites_xml
 * @version     $Id: stubXMLProcessor.php 2903 2011-01-12 11:47:34Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::processors::stubAbstractProcessor',
                      'net::stubbles::websites::processors::stubProcessorException',
                      'net::stubbles::websites::processors::routing::stubRouter',
                      'net::stubbles::websites::xml::stubXmlProcessorTransformer',
                      'net::stubbles::websites::xml::generator::stubXmlGeneratorFacade',
                      'net::stubbles::xml::stubXMLStreamWriter',
                      'net::stubbles::xml::serializer::stubXMLSerializer'
);
/**
 * Default processor delivered by stubbles.
 *
 * @package     stubbles
 * @subpackage  websites_xml
 */
class stubXMLProcessor extends stubAbstractProcessor
{
    /**
     * route to display
     *
     * @var  stubRoute
     */
    protected $route;
    /**
     * generator facade to hide complexity of managing each single generator instance
     *
     * @var  stubXmlGeneratorFacade
     */
    protected $xmlGeneratorFacade;
    /**
     * transforms generated xml data to target format using xsl
     *
     * @var  stubXmlProcessorTransformer
     */
    protected $xmlTransformer;
    /**
     * injector instance
     *
     * @var  stubInjector
     */
    protected $injector;

    /**
     * constructor
     *
     * @param   stubRequest                  $request             current request
     * @param   stubSession                  $session             current session
     * @param   stubResponse                 $response            current response
     * @param   stubRouter                   $router              router to select the route to display
     * @param   stubXmlGeneratorFacade       $xmlGeneratorFacade  generator facade to hide single generator instances
     * @param   stubXmlProcessorTransformer  $xmlTransformer      transforms generated xml data to target format using xsl
     * @param   stubInjector                 $injector
     * @throws  stubProcessorException
     * @Inject
     * @Named{router}('xml')
     */
    public function __construct(stubRequest $request,
                                stubSession $session,
                                stubResponse $response,
                                stubRouter $router,
                                stubXmlGeneratorFacade $xmlGeneratorFacade,
                                stubXmlProcessorTransformer $xmlTransformer,
                                stubInjector $injector)
    {
        parent::__construct($request, $session, $response);
        $this->xmlGeneratorFacade = $xmlGeneratorFacade;
        $this->xmlTransformer     = $xmlTransformer;
        $this->injector           = $injector;
        $this->route = $router->route($this->request);
        if (null === $this->route) {
            $this->route = $router->reroute('error404');
            if (null === $this->route) {
                $this->request->cancel();
                throw new stubProcessorException(404, 'Not Found');
            }
            
            $this->response->setStatusCode(404);
        }

        $this->session->putValue('net.stubbles.websites.lastPage',
                                 $this->route->getProperty('name')
        );
    }

    /**
     * returns the required role of the user to be able to process the request
     *
     * @param   string  $defaultRole  a default role to return if no special role is required
     * @return  string
     */
    public function getRequiredRole($defaultRole)
    {
        return $this->route->getProperty('role', $defaultRole);
    }

    /**
     * checks whether the current request forces ssl or not
     *
     * @return  bool
     */
    public function forceSsl()
    {
        $forceSsl = $this->route->getProperty('forceSsl', false);
        if (true === $forceSsl || 'true' === $forceSsl) {
            return true;
        }
        
        return false;
    }

    /**
     * operations to be done before the request is processed
     *
     * @return  stubProcessor
     */
    public function startup()
    {
        $this->injector->bind('stubRoute')->toInstance($this->route);
        $this->xmlTransformer->selectSkin($this->request->readParam('frame')->unsecure(),
                                          $this->route->getProperty('skin')
                               )
                             ->selectLocale($this->session->getValue('net.stubbles.locale'),
                                            $this->route->getProperty('locale')
                               );
        $this->xmlGeneratorFacade->startup();
        return $this;
    }

    /**
     * checks whether document part is cachable or not
     *
     * @return  bool
     */
    public function isCachable()
    {
        return $this->xmlGeneratorFacade->isCachable();
    }

    /**
     * returns a list of variables that have an influence on caching
     *
     * @return  array<string,scalar>
     */
    public function getCacheVars()
    {
        return array_merge(array('route'  => $this->route->getProperty('name'),
                                 'skin'   => $this->xmlTransformer->getSelectedSkinName(),
                                 'locale' => $this->xmlTransformer->getSelectedLocale()
                           ),
                           $this->xmlGeneratorFacade->getCacheVars()
               );
    }

    /**
     * returns the name of the current route
     *
     * @return  string
     */
    public function getRouteName()
    {
        return $this->route->getProperty('name');
    }

    /**
     * processes the request
     *
     * @return  stubProcessor
     */
    public function process()
    {
        $xmlStreamWriter = $this->injector->getInstance('stubXMLStreamWriter');
        $xmlStreamWriter->writeStartElement('document');
        $xmlStreamWriter->writeAttribute('page', $this->route->getProperty('name'));
        $xmlSerializer = $this->injector->getInstance('stubXMLSerializer');
        $this->xmlGeneratorFacade->generate($xmlStreamWriter, $xmlSerializer);
        if ($this->request->isCancelled() === true) {
            return;
        }

        $xmlStreamWriter->writeEndElement(); // end document
        $this->session->putValue('net.stubbles.websites.lastRequestResponseData',
                                 $xmlStreamWriter->asXML()
        );

        $this->response->replaceData($this->xmlTransformer->transform($xmlStreamWriter,
                                                                      $this->route->getProperty('name')
                                                            )
        );
        return $this;
    }

    /**
     * operations to be done after the request was processed
     *
     * @return  stubProcessor
     */
    public function cleanup()
    {
        $this->xmlGeneratorFacade->cleanup();
        return $this;
    }
}
?><?php
/**
 * Transforms the xml stream from the xml processor into desired output format.
 *
 * @package     stubbles
 * @subpackage  websites_xml
 * @version     $Id: stubXmlProcessorTransformer.php 2867 2011-01-10 17:02:33Z mikey $
 */
stubClassLoader::load('net::stubbles::websites::xml::skin::stubSkinGenerator',
                      'net::stubbles::xml::stubXMLStreamWriter',
                      'net::stubbles::xml::xsl::stubXSLProcessor'
);
/**
 * Transforms the xml stream from the xml processor into desired output format.
 *
 * @package     stubbles
 * @subpackage  websites_xml
 * @since       1.5.0
 */
class stubXmlProcessorTransformer extends stubBaseObject
{
    /**
     * skin generator to be used
     *
     * @var  stubSkinGenerator
     */
    protected $skinGenerator;
    /**
     * name of skin to be used
     *
     * @var  stubSkinGenerator
     */
    protected $skinName       = 'default';
    /**
     * xsl processor to transform xml to html
     *
     * @var  stubXSLProcessor
     */
    protected $xslProcessor;
    /**
     * locale for output
     *
     * @var  string
     */
    protected $locale;

    /**
     * constructor
     *
     * @param  stubXSLProcessor   $xslProcessor
     * @param  stubSkinGenerator  $skinGenerator
     * @param  string             $locale
     * @Inject
     * @Named{locale}('net.stubbles.locale')
     */
    public function __construct(stubXSLProcessor $xslProcessor, stubSkinGenerator $skinGenerator, $locale)
    {
        $this->xslProcessor  = $xslProcessor;
        $this->skinGenerator = $skinGenerator;
        $this->locale        = $locale;
    }

    /**
     * select skin based on request and route
     *
     * Skin is selected based on the following rules:
     * 1. If $requestSkinName is not empty and skin with this name exists use this.
     * 2. If $routeSkinName is not empty and skin with this name exists use this.
     * 3. Use 'default' as skin.
     *
     * @param  stubRequest                  $requestSkinName
     * @param  string                       $routeSkinName
     * @return stubXmlProcessorTransformer
     */
    public function selectSkin($requestSkinName, $routeSkinName)
    {
        if (null != $requestSkinName && $this->skinGenerator->hasSkin($requestSkinName) === true) {
            $this->skinName = $requestSkinName;
            return $this;
        }

        if (null != $routeSkinName && $this->skinGenerator->hasSkin($routeSkinName) === true) {
            $this->skinName = $routeSkinName;
        }

        return $this;
    }

    /**
     * returns name of selected skin
     *
     * @return  string
     */
    public function getSelectedSkinName()
    {
        return $this->skinName;
    }

    /**
     * selects locale
     *
     * Locale is selected based on the following rules:
     * 1. If $sessionLocale is not empty use this.
     * 2. If $routeLocale is not empty use this.
     * 3. Use locale configured in config.ini
     *
     * @param   string                       $sessionLocale
     * @param   string                       $routeLocale
     * @return  stubXmlProcessorTransformer
     */
    public function selectLocale($sessionLocale, $routeLocale)
    {
        if (null != $sessionLocale) {
            $this->locale = $sessionLocale;
            return $this;
        }

        if (null != $routeLocale) {
            $this->locale = $routeLocale;
        }

        return $this;
    }

    /**
     * returns selected locale
     *
     * @return  string
     */
    public function getSelectedLocale()
    {
        return $this->locale;
    }

    /**
     * transforms given xml stream to target format
     *
     * @param   stubXMLStreamWriter  $xmlStreamWriter
     * @param   string               $routeName
     * @return  string
     */
    public function transform(stubXMLStreamWriter $xmlStreamWriter, $routeName)
    {
        return str_replace(' xmlns=""',
                           '',
                           preg_replace('/ xml:base="(.*)"/U',
                                        '',
                                        $this->xslProcessor->applyStylesheet($this->skinGenerator->generate($routeName,
                                                                                                            $this->skinName,
                                                                                                            $this->locale
                                                                                                   )
                                                             )
                                                           ->onDocument($xmlStreamWriter->asDOM())
                                                           ->toXml()
                           )
               );
    }
}
?><?php
/**
 * Abstract base implementation for rss feeds.
 *
 * @package     stubbles
 * @subpackage  xml_rss
 * @version     $Id: stubAbstractRSSFeed.php 2720 2010-09-30 14:32:45Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::xml::rss::stubRSSFeed'
);
/**
 * Abstract base implementation for rss feeds.
 *
 * @package     stubbles
 * @subpackage  xml_rss
 */
abstract class stubAbstractRSSFeed extends stubBaseObject implements stubRSSFeed
{
    /**
     * request instance
     *
     * @var  stubRequest
     */
    protected $request;
    /**
     * current locale
     *
     * @var  string
     */
    protected $locale      = 'en_EN';
    /**
     * rss feed caption
     *
     * @var  string
     */
    protected $title;
    /**
     * rss feed description
     *
     * @var  string
     */
    protected $description;
    /**
     * rss feed http base link
     *
     * @var  string
     */
    protected $link        = null;
    /**
     * rss feed copyright clause
     *
     * @var  string
     */
    protected $copyright;

    /**
     * sets the request instance
     *
     * @param   stubRequest          $request
     * @return  stubAbstractRSSFeed
     * @Inject
     */
    public function setRequest(stubRequest $request)
    {
        $this->request = $request;
        return $this;
    }

    /**
     * sets the locale
     *
     * @param   string               $locale
     * @return  stubAbstractRSSFeed
     * @Inject(optional=true)
     * @Named('net.stubbles.locale')
     */
    public function setLocale($locale)
    {
        $this->locale = $locale;
        return $this;
    }

    /**
     * creates the rss feed
     *
     * This method creates a new RSS feed generator or pass-through the
     * optional given instance to fill and manipulate feed contents. The
     * create lifecycle is seperated in three internal build steps:
     *
     * - before (before feed contents exists)
     * - create (fill feed contents)
     * - after  (after feed contents filled)
     *
     * @param   stubRSSFeedGenerator  $rssFeedGenerator  optional
     * @return  stubRSSFeedGenerator  pass-through after filled with content
     * @see     doBefore()
     * @see     doCreate()
     * @see     doAfter()
     */
    public function create(stubRSSFeedGenerator $rssFeedGenerator = null)
    {
        if ($rssFeedGenerator === null) {
            $rssFeedGenerator = new stubRSSFeedGenerator($this->getTitle(), $this->getLink(), $this->getDescription());
            $rssFeedGenerator->setCopyright($this->getCopyright())
                             ->setLocale($this->getLocale());
        }

        return $this->doAfter($this->doCreate($this->doBefore($rssFeedGenerator)));
    }

    /**
     * returns the title of the feed
     *
     * @return  string
     */
    public function getTitle()
    {
        return $this->title;
    }

    /**
     * returns the link for the feed
     *
     * @return  string
     */
    public function getLink()
    {
        if (null === $this->link && null !== $this->request) {
            $this->link = sprintf('http://%s/', $this->request->readHeader('SERVER_NAME')->unsecure());
        }
        
        return $this->link;
    }

    /**
     * returns the description for the feed
     *
     * @return  string
     */
    public function getDescription()
    {
        return $this->description;
    }

    /**
     * returns the detected locale from config as current feed locale
     *
     * @return  string
     */
    public function getLocale()
    {
        return $this->locale;
    }

    /**
     * returns the copyright for the feed
     *
     * @return  string
     */
    public function getCopyright()
    {
        return $this->copyright;
    }

    /**
     * creation pre-interceptor
     *
     * Overwrite this method to hook into the process before the feed contents create.
     *
     * @param   stubRSSFeedGenerator  $rssFeedGenerator
     * @return  stubRSSFeedGenerator  pass-through given feed generator
     */
    protected function doBefore(stubRSSFeedGenerator $rssFeedGenerator)
    {
        return $rssFeedGenerator;
    }

    /**
     * creation post-interceptor
     *
     * @param   stubRSSFeedGenerator  $rssFeedGenerator
     * @return  stubRSSFeedGenerator  pass-through given feed generator
     */
    protected function doAfter(stubRSSFeedGenerator $rssFeedGenerator)
    {
        return $rssFeedGenerator;
    }

    /**
     * does the real creation of the feed's contents
     *
     * @param   stubRSSFeedGenerator  $rssFeedGenerator
     * @return  stubRSSFeedGenerator  pass-through given feed generator
     */
    protected abstract function doCreate(stubRSSFeedGenerator $rssFeedGenerator);
}
?><?php
/**
 * Interface for rss feeds to be accessed via the rss processor.
 *
 * @package     stubbles
 * @subpackage  xml_rss
 */
stubClassLoader::load('net::stubbles::xml::rss::stubRSSFeedGenerator');
/**
 * Interface for rss feeds to be accessed via the rss processor.
 *
 * @package     stubbles
 * @subpackage  xml_rss
 */
interface stubRSSFeed extends stubObject
{
    /**
     * checks whether document part is cachable or not
     *
     * @return  bool
     */
    public function isCachable();

    /**
     * returns a list of variables that have an influence on caching
     *
     * @return  array<string,scalar>
     */
    public function getCacheVars();

    /**
     * creates the rss feed
     *
     * @return  stubRSSFeedGenerator
     */
    public function create();
}
?><?php
/**
 * Class for generating a rss 2.0 feed.
 *
 * @package     stubbles
 * @subpackage  xml_rss
 * @version     $Id: stubRSSFeedGenerator.php 2089 2009-02-10 14:39:23Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::xml::rss::stubRSSFeedItem',
                      'net::stubbles::xml::stubXMLStreamWriter'
);
/**
 * Class for generating a rss 2.0 feed.
 *
 * The implementation follows the rss specification available at
 * http://rssboard.org/rss-specification. However some of the elements are
 * not implemented:
 * pubDate
 * category   Why categorize a whole feed when the items can be categorized?
 * cloud      This implies security and spamming dangers.
 * rating
 * textInput  Most aggregators ignore it.
 * skipHours  Usage relies on behaviour of aggregators.
 * skipDays   Usage relies on behaviour of aggregators.
 *
 * @package     stubbles
 * @subpackage  xml_rss
 * @see         http://rssboard.org/rss-specification
 */
class stubRSSFeedGenerator extends stubBaseObject
{
    /**
     * name of the channel
     *
     * @var  string
     */
    protected $title          = '';
    /**
     * URL to the HTML website corresponding to the channel
     *
     * @var  string
     */
    protected $link           = '';
    /**
     * phrase or sentence describing the channel
     *
     * @var  string
     */
    protected $description    = '';
    /**
     * list of items in feed
     *
     * @var  array<stubRssFeedItem>
     */
    protected $items          = array();
    /**
     * the generator of this rss feed
     *
     * @var  string
     */
    protected $generator      = 'Stubbles RSSFeedGenerator';
    /**
     * list of stylesheets to append as processing instructions
     *
     * @var  array<string>
     */
    protected $stylesheets    = array();
    /**
     * the locale the channel is written in
     *
     * @var  string
     * @see  http://rssboard.org/rss-language-codes
     */
    protected $locale         = null;
    /**
     * copyright notice for content in the channel
     *
     * @var  string
     */
    protected $copyright      = null;
    /**
     * email address for person responsible for editorial content
     *
     * @var  string
     */
    protected $managingEditor = null;
    /**
     * email address for person responsible for technical issues relating to channel
     *
     * @var  string
     */
    protected $webMaster      = null;
    /**
     * last time the content of the channel changed
     *
     * @var  string
     */
    protected $lastBuildDate  = null;
    /**
     * URL points to RSS file format documentation
     *
     * A URL that points to the documentation for the format used in the RSS
     * file. It's probably a pointer to this page. It's for people who might
     * stumble across an RSS file on a Web server 25 years from now and wonder
     * what it is.
     *
     * @var  string
     */
    protected $docs           = 'http://rssboard.org/rss-specification';
    /**
     * number of minutes that indicates how long a channel can be cached before refreshing from the source
     *
     * @var  int
     */
    protected $ttl            = null;
    /**
     * specifies a GIF, JPEG or PNG image that can be displayed with the channel
     *
     * @var  array
     */
    protected $image          = array('url'         => '',
                                      'description' => '',
                                      'width'       => 88,
                                      'height'      => 31
                                );

    /**
     * constructor
     *
     * @param  string  $title        title of rss feed
     * @param  string  $link         optional  source of rss feed
     * @param  string  $description  optional  source description
     */
    public function __construct($title, $link, $description)
    {
        $this->setTitle($title);
        $this->setLink($link);
        $this->setDescription($description);
    }

    /**
     * sets the rss feed caption
     *
     * @param   string  $title        title of rss feed
     * @return  stubRSSFeedGenerator  provides a fluent interface
     */
    public function setTitle($title)
    {
        $this->title = $title;
        return $this;
    }

    /**
     * returns the title of rss feed
     *
     * @return  string
     */
    public function getTitle()
    {
        return $this->title;
    }

    /**
     * sets the source of rss feed
     *
     * @param   string  $link         http hyperlink
     * @return  stubRSSFeedGenerator  provides a fluent interface
     */
    public function setLink($link)
    {
        $this->link = $link;
        return $this;
    }

    /**
     * returns the source of rss feed
     *
     * @return  string
     */
    public function getLink()
    {
        return $this->link;
    }

    /**
     * sets the source description
     *
     * @param   string  $description  http hyperlink
     * @return  stubRSSFeedGenerator  provides a fluent interface
     */
    public function setDescription($description)
    {
        $this->description = $description;
        return $this;
    }

    /**
     * returns the source description
     *
     * @return  string
     */
    public function getDescription()
    {
        return $this->description;
    }

    /**
     * set the locale the channel is written in
     *
     * @param   string                $locale
     * @return  stubRSSFeedGenerator  provides a fluent interface
     */
    public function setLocale($locale)
    {
        $this->locale = $locale;
        return $this;
    }

    /**
     * returns the locale
     *
     * @return  string
     */
    public function getLocale()
    {
        return $this->locale;
    }

    /**
     * set copyright notice for content in the channel
     *
     * @param   string  $copyright
     * @return  stubRSSFeedGenerator  provides a fluent interface
     */
    public function setCopyright($copyright)
    {
        $this->copyright = $copyright;
        return $this;
    }

    /**
     * returns the copyright notice
     *
     * @return  string
     */
    public function getCopyright()
    {
        return $this->copyright;
    }

    /**
     * add an item to the feed
     *
     * @param   string           $title        title of the item
     * @param   string           $link         URL of the item
     * @param   string           $description  item synopsis
     * @return  stubRssFeedItem  the added item
     */
    public function addItem($title, $link, $description)
    {
        return ($this->items[] = stubRssFeedItem::create($title, $link, $description));
    }

    /**
     * adds an entity as item to the rss feed
     *
     * @param   object               $entity
     * @param   array<string,mixed>  $overrides  optional
     * @return  stubRssFeedItem      the item created from $entity
     */
    public function addEntity($entity, array $overrides = array())
    {
        $rssFeedItem = stubRssFeedItem::fromEntity($entity, $overrides);
        array_push($this->items, $rssFeedItem);
        return $rssFeedItem;
    }

    /**
     * checks whether an item is present at given position
     *
     * @param   int   $pos
     * @return  bool
     */
    public function hasItem($pos)
    {
        return isset($this->items[$pos]);
    }

    /**
     * returns item at given position
     *
     * @param   int              $pos
     * @return  stubRssFeedItem
     */
    public function getItem($pos)
    {
        if ($this->hasItem($pos) === true) {
            return $this->items[$pos];
        }

        return null;
    }

    /**
     * returns a list of all items
     *
     * @return  stubRssFeedItem
     */
    public function getItems()
    {
        return $this->items;
    }

    /**
     * returns the number of items added for this feed
     *
     * @return  int
     */
    public function countItems()
    {
        return count($this->items);
    }

    /**
     * set the generator of the feed
     *
     * @param  string  $generator  name of the generator to use
     */
    public function setGenerator($generator)
    {
        $this->generator = $generator;
    }

    /**
     * returns the generator of the feed
     *
     * @return  string
     */
    public function getGenerator()
    {
        return $this->generator;
    }

    /**
     * append a stylesheet to the document
     *
     * @param  string  $stylesheet  the stylesheet to append
     */
    public function appendStylesheet($stylesheet)
    {
        $this->stylesheets[] = $stylesheet;
    }

    /**
     * set email address for person responsible for editorial content
     *
     * @param  string  $managingEditor
     */
    public function setManagingEditor($managingEditor)
    {
        if (strstr($managingEditor, '@') === false) {
            $this->managingEditor = 'nospam@example.com (' . $managingEditor . ')';
        } else {
            $this->managingEditor = $managingEditor;
        }
    }

    /**
     * returns the email address for person responsible for editorial content
     *
     * @return  string
     */
    public function getManagingEditor()
    {
        return $this->managingEditor;
    }

    /**
     * set email address for person responsible for technical issues relating to channel
     *
     * @param  string  $webMaster
     */
    public function setWebMaster($webMaster)
    {
        if (strstr($webMaster, '@') === false) {
            $this->webMaster = 'nospam@example.com (' . $webMaster . ')';
        } else {
            $this->webMaster = $webMaster;
        }
    }

    /**
     * returns the email address for person responsible for technical issues relating to channel
     *
     * @return  string
     */
    public function getWebMaster()
    {
        return $this->webMaster;
    }

    /**
     * set the last time when the content of the channel changed
     *
     * @param   string|int   $lastBuildDate  last time the content of the channel changed
     * @throws  stubIllegalArgumentException
     */
    public function setLastBuildDate($lastBuildDate)
    {
        if (is_int($lastBuildDate) === false) {
            $lastBuildDate = strtotime($lastBuildDate);
            if (false === $lastBuildDate) {
                throw new stubIllegalArgumentException('Argument must be a unix timestamp or a valid string representation of a time.');
            }
        }

        $this->lastBuildDate = date('D d M Y H:i:s O', $lastBuildDate);
    }

    /**
     * returns the last build date
     *
     * @return  string
     */
    public function getLastBuildDate()
    {
        return $this->lastBuildDate;
    }

    /**
     * set number of minutes that indicates how long a channel can be cached
     * before refreshing from the source
     *
     * @param  int  $ttl
     */
    public function setTimeToLive($ttl)
    {
        $this->ttl = $ttl;
    }

    /**
     * specify a GIF, JPEG or PNG image to be displayed with the channel
     *
     * @param   string  $url          URL of a GIF, JPEG or PNG image that represents the channel
     * @param   string  $description  contains text that is included in the TITLE attribute of the link formed around the image in the HTML rendering
     * @param   int     $width        indicating the width of the image in pixels, must be 0 < $width <= 144, default 88
     * @param   int     $height       indicating the height of the image in pixels, must be 0 < $height <= 400, default 31
     * @throws  stubIllegalArgumentException  in case $width or $height have invalid values
     */
    public function setImage($url, $description, $width = 88, $height = 31)
    {
        if (144 < $width || 0 > $width) {
            throw new stubIllegalArgumentException('Width must be a value between 0 and 144.');
        }

        if (400 < $height || 0 > $height) {
            throw new stubIllegalArgumentException('Height must be a value between 0 and 400.');
        }

        $this->image = array('url'         => $url,
                             'description' => $description,
                             'width'       => $width,
                             'height'      => $height
                       );
    }

    /**
     * serialize the feed to xml and return the given stream writer instance
     *
     * @param   stubXMLStreamWriter  $xmlStreamWriter
     * @return  stubXMLStreamWriter
     */
    public function serialize(stubXMLStreamWriter $xmlStreamWriter)
    {
        foreach ($this->stylesheets as $stylesheet) {
            $xmlStreamWriter->writeProcessingInstruction('xml-stylesheet', 'href="' . $stylesheet . '" type="text/xsl"');
        }

        $xmlStreamWriter->writeStartElement('rss');
        $xmlStreamWriter->writeAttribute('version', '2.0');
        $xmlStreamWriter->writeAttribute('xmlns:rdf', 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');
        $xmlStreamWriter->writeAttribute('xmlns:content', 'http://purl.org/rss/1.0/modules/content/');

        $xmlStreamWriter->writeStartElement('channel');
        $xmlStreamWriter->writeElement('title', array(), $this->title);
        $xmlStreamWriter->writeElement('link', array(), $this->link);
        $xmlStreamWriter->writeElement('description', array(), $this->description);
        $xmlStreamWriter->writeElement('generator', array(), $this->generator);

        if (null !== $this->locale) {
            $xmlStreamWriter->writeElement('language', array(), $this->locale);
        }

        if (null !== $this->copyright) {
            $xmlStreamWriter->writeElement('copyright', array(), $this->copyright);
        }

        if (null !== $this->managingEditor) {
            $xmlStreamWriter->writeElement('managingEditor', array(), $this->managingEditor);
        }

        if (null !== $this->webMaster) {
            $xmlStreamWriter->writeElement('webMaster', array(), $this->webMaster);
        }

        if (null !== $this->lastBuildDate) {
            $xmlStreamWriter->writeElement('lastBuildDate', array(), $this->lastBuildDate);
        }

        if (null !== $this->ttl) {
            $xmlStreamWriter->writeElement('ttl', array(), $this->ttl);
        }

        if (strlen($this->image['url']) > 0) {
            $xmlStreamWriter->writeStartElement('image');
            $xmlStreamWriter->writeElement('url', array(), $this->image['url']);
            $xmlStreamWriter->writeElement('title', array(), $this->title);
            $xmlStreamWriter->writeElement('link', array(), $this->link);
            $xmlStreamWriter->writeElement('width', array(), $this->image['width']);
            $xmlStreamWriter->writeElement('height', array(), $this->image['height']);
            $xmlStreamWriter->writeElement('description', array(), $this->image['description']);
            $xmlStreamWriter->writeEndElement();
        }

        foreach ($this->items as $item) {
            $item->serialize($xmlStreamWriter);
        }

        $xmlStreamWriter->writeEndElement(); // end channel element
        $xmlStreamWriter->writeEndElement(); // end rss
        return $xmlStreamWriter;
    }
}
?><?php
/**
 * Class for a rss 2.0 feed item.
 * 
 * @package     stubbles
 * @subpackage  xml_rss
 * @version     $Id: stubRSSFeedItem.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::lang::types::stubDate',
                      'net::stubbles::xml::stubXMLStreamWriter',
                      'net::stubbles::xml::rss::stubRSSFeedItemAnnotation'
);
/**
 * Class for a rss 2.0 feed item.
 *
 * @package     stubbles
 * @subpackage  xml_rss
 * @see         http://rssboard.org/rss-specification
 */
class stubRSSFeedItem extends stubBaseObject
{
    /**
     * title of the item
     *
     * @var  string
     */
    protected $title       = '';
    /**
     * URL of the item
     *
     * @var  string
     */
    protected $link        = '';
    /**
     * item synopsis
     *
     * @var  string
     */
    protected $description = '';
    /**
     * email address of the author of the item
     *
     * @var  string
     */
    protected $author      = null;
    /**
     * categories where the item is included
     *
     * @var  array
     */
    protected $categories  = array();
    /**
     * URL of a page for comments relating to the item
     *
     * @var  string
     */
    protected $comments    = null;
    /**
     * describes a media object that is attached to the item
     *
     * @var  array
     */
    protected $enclosures  = array();
    /**
     * unique identifier for the item
     *
     * @var  string
     */
    protected $guid        = null;
    /**
     * whether the id may be interpreted as a permanent link or not
     *
     * @var  bool
     */
    protected $isPermaLink = true;
    /**
     * indicates when the item was published
     *
     * @var  string
     */
    protected $pubDate     = null;
    /**
     * where that the item came from
     *
     * @var  array
     */
    protected $sources     = array();
    /**
     * content of rss feed item
     *
     * @var  string
     */
    protected $content     = null;

    /**
     * constructor
     *
     * @param  string  $title        title of the item
     * @param  string  $link         URL of the item
     * @param  string  $description  item synopsis
     */
    private function __construct($title, $link, $description)
    {
        $this->title       = $title;
        $this->link        = $link;
        $this->description = $description;
    }

    /**
     * create a new stubRssFeedItem
     *
     * @param   string           $title        title of the item
     * @param   string           $link         URL of the item
     * @param   string           $description  item synopsis
     * @return  stubRSSFeedItem
     */
    public static function create($title, $link, $description)
    {
        $self = new self($title, $link, $description);
        return $self;
    }

    /**
     * creates a new stubRssFeedItem from given entity
     *
     * @param   object               $entity
     * @param   array<string,mixed>  $overrides  optional
     * @return  stubRSSFeedItem
     * @throws  stubIllegalArgumentException
     * @throws  stubXMLException
     */
    public static function fromEntity($entity, array $overrides = array())
    {
        if (is_object($entity) === false) {
            throw new stubIllegalArgumentException('Given entity must be an object.');
        }
        
        $entityClass = (($entity instanceof stubObject) ? ($entity->getClass()) : (new stubReflectionObject($entity)));
        if ($entityClass->hasAnnotation('RSSFeedItem') === false) {
            throw new stubXMLException('Class ' . $entityClass->getFullQualifiedClassName() . ' is not annotated with @RSSFeedItem.');
        }
        
        $methods = $entityClass->getAnnotation('RSSFeedItem')->getMethods();
        $self    = new self(self::getRequiredAttribute($entity, $entityClass, 'title', $methods, $overrides),
                            self::getRequiredAttribute($entity, $entityClass, 'link', $methods, $overrides),
                            self::getRequiredAttribute($entity, $entityClass, 'description', $methods, $overrides)
                   );
        unset($methods['title']);
        unset($methods['link']);
        unset($methods['description']);
        foreach ($methods as $itemMethod => $entityMethod) {
            if (isset($overrides[$itemMethod]) === true) {
                $self->$itemMethod($overrides[$itemMethod]);
            } elseif ($entityClass->hasMethod($entityMethod) === true) {
                $self->$itemMethod($entityClass->getMethod($entityMethod)->invoke($entity));
            }
        }
        
        return $self;
    }

    /**
     * helper method to retrieve a required attribute
     *
     * @param   object                $entity
     * @param   stubReflectionObject  $entityClass
     * @param   string                $name
     * @param   array<string,string>  $methods
     * @param   array<string,mixed>   $overrides
     * @return  string
     * @throws  stubXMLException
     */
    protected static function getRequiredAttribute($entity, $entityClass, $name, array $methods, array $overrides)
    {
        if (isset($overrides[$name]) === true) {
            return $overrides[$name];
        } elseif ($entityClass->hasMethod($methods[$name]) === false) {
            throw new stubXMLException('RSSFeedItem ' . $entityClass->getFullQualifiedClassName() . ' does not offer a method to return the ' . $name . ', but ' . $name . ' is required.');
        }
        
        return $entityClass->getMethod($methods[$name])->invoke($entity);
    }

    /**
     * set the email address of the author of the item who created the item
     *
     * @param   string           $author  author of rss feed item
     * @return  stubRSSFeedItem
     */
    public function byAuthor($author)
    {
        if (strstr($author, '@') === false) {
            $this->author = 'nospam@example.com (' . $author . ')';
        } else {
            $this->author = $author;
        }
        
        return $this;
    }

    /**
     * set one or more categories where the item is included into
     *
     * @param   string  $category  category where the item is included
     * @param   string  $domain    optional  categorization taxonomy
     * @return  stubRSSFeedItem
     */
    public function inCategory($category, $domain = '')
    {
        $this->categories[] = array('category' => $category,
                                    'domain'   => $domain
                              );
        return $this;
    }

    /**
     * sets categories where the item is included into
     *
     * @param   array<string,string>  $categories
     * @return  stubRSSFeedItem
     */
    public function inCategories(array $categories)
    {
        $this->categories = $categories;
        return $this;
    }

    /**
     * set the URL of a page for comments relating to the item
     *
     * @param   string  $comments
     * @return  stubRSSFeedItem
     */
    public function addCommentsAt($comments)
    {
        $this->comments = $comments;
        return $this;
    }

    /**
     * add an enclosure to the item
     *
     * @param   string           $url     location of enclosure
     * @param   int              $length  length of enclosure in bytes
     * @param   string           $type    MIME type of enclosure
     * @return  stubRSSFeedItem
     */
    public function deliveringEnclosure($url, $length, $type)
    {
        $this->enclosures[] = array('url'    => $url,
                                    'length' => $length,
                                    'type'   => $type
                              );
        return $this;
    }

    /**
     * sets enclosures for the item
     *
     * @param   array<array<string,string>>  $enclosures
     * @return  stubRSSFeedItem
     */
    public function deliveringEnclosures(array $enclosures)
    {
        $this->enclosures = $enclosures;
        return $this;
    }

    /**
     * set id of rss feed item
     *
     * @param   string           $guid         the id of the item
     * @param   bool             $isPermaLink  optional
     * @return  stubRSSFeedItem
     */
    public function withGuid($guid, $isPermaLink = true)
    {
        $this->guid        = $guid;
        $this->isPermaLink = $isPermaLink;
        return $this;
    }

    /**
     * sets whether guid is perma link or not
     *
     * @param   bool             $isPermaLink
     * @return  stubRSSFeedItem
     */
    public function andGuidIsPermaLink($isPermaLink)
    {
        $this->isPermaLink = $isPermaLink;
        return $this;
    }

    /**
     * set the date when the item was published
     *
     * @param   string|int|stubDate  $pubDate  publishing date of rss feed item
     * @return  stubRSSFeedItem
     * @throws  stubIllegalArgumentException
     */
    public function publishedOn($pubDate)
    {
        if ($pubDate instanceof stubDate) {
            $pubDate = $pubDate->getTimestamp();
        } elseif (is_int($pubDate) === false) {
            $pubDate = strtotime($pubDate);
            if (false === $pubDate) {
                throw new stubIllegalArgumentException('Argument must be a unix timestamp, a valid string representation of a time or an instance of net::stubbles::lang::types::stubDate.');
            }
        }
        
        $this->pubDate = date('D d M Y H:i:s O', $pubDate);
        return $this;
    }

    /**
     * set the source where that the item came from
     *
     * @param   string           $name  name of the source
     * @param   string           $url   url of the source
     * @return  stubRSSFeedItem
     */
    public function inspiredBySource($name, $url)
    {
        $this->sources[] = array('name' => $name, 'url' => $url);
        return $this;
    }

    /**
     * sets the sources where that the item came from
     *
     * @param   array<array<string,string>>  $sources
     * @return  stubRSSFeedItem
     */
    public function inspiredBySources(array $sources)
    {
        $this->sources = $sources;
        return $this;
    }

    /**
     * set the content of the item
     *
     * @param   string           $content  content of rss feed item
     * @return  stubRSSFeedItem
     */
    public function withContent($content)
    {
        $this->content = $content;
        return $this;
    }

    /**
     * returns the title of the item
     *
     * @return  string
     */
    public function getTitle()
    {
        return $this->title;
    }

    /**
     * returns the URL of the item
     *
     * @return  string
     */
    public function getLink()
    {
        return $this->link;
    }

    /**
     * returns the item synopsis
     *
     * @return  string
     */
    public function getDescription()
    {
        return $this->description;
    }

    /**
     * returns the email address of the author of the item
     *
     * @return  string
     */
    public function getAuthor()
    {
        return $this->author;
    }

    /**
     * returns one or more categories where the item is included into
     *
     * @return  array
     */
    public function getCategories()
    {
        return $this->categories;
    }

    /**
     * returns the URL of a page for comments relating to the item
     *
     * @return  string
     */
    public function getComments()
    {
        return $this->comments;
    }

    /**
     * returns the description of a media object that is attached to the item
     *
     * @return  array
     */
    public function getEnclosures()
    {
        return $this->enclosures;
    }

    /**
     * returns the unique identifier for the item
     *
     * @return  string
     */
    public function getGuid()
    {
        return $this->guid;
    }

    /**
     * checks whether the guid represents a perma link or not
     *
     * @return  bool
     */
    public function isGuidPermaLink()
    {
        return $this->isPermaLink;
    }

    /**
     * return the publishing date of the item
     *
     * @return  string
     */
    public function getPubDate()
    {
        return $this->pubDate;
    }

    /**
     * returns where that the item came from
     *
     * @return  array
     */
    public function getSources()
    {
        return $this->sources;
    }

    /**
     * return the content of the item
     *
     * @return  string
     */
    public function getContent()
    {
        return $this->content;
    }

    /**
     * serialize the item to xml
     *
     * @param  stubXMLStreamWriter  $xmlStreamWriter
     */
    public function serialize(stubXMLStreamWriter $xmlStreamWriter)
    {
        $xmlStreamWriter->writeStartElement('item');
        $xmlStreamWriter->writeElement('title', array(), $this->title);
        $xmlStreamWriter->writeElement('link', array(), $this->link);
        $xmlStreamWriter->writeElement('description', array(), $this->description);
        if (null !== $this->author) {
            $xmlStreamWriter->writeElement('author', array(), $this->author);
        }
        
        foreach ($this->categories as $category) {
            $attributes = array();
            if (strlen($category['domain']) > 0) {
                $attributes['domain'] = $category['domain'];
            }
            $xmlStreamWriter->writeElement('category', $attributes, $category['category']);
        }
        
        if (null !== $this->comments) {
            $xmlStreamWriter->writeElement('comments', array(), $this->comments);
        }
        
        foreach ($this->enclosures as $enclosure) {
            $xmlStreamWriter->writeElement('enclosure', array('url'    => $enclosure['url'],
                                                              'length' => $enclosure['length'],
                                                              'type'   => $enclosure['type']
                                                        )
            );
        }
        
        if (null !== $this->guid) {
            $xmlStreamWriter->writeElement('guid', array('isPermaLink' => ((true == $this->isPermaLink) ? ('true') : ('false'))), $this->guid);
        }
        
        if (null !== $this->pubDate) {
            $xmlStreamWriter->writeElement('pubDate', array(), $this->pubDate);
        }
        
        foreach ($this->sources as $source) {
            $xmlStreamWriter->writeElement('source', array('url' => $source['url']), $source['name']);
        }

        if (empty($this->content) === false) {
            $xmlStreamWriter->writeElement('content:encoded', array(), $this->content);
        }
        
        $xmlStreamWriter->writeEndElement(); // end item
    }
}
?><?php
/**
 * Annotation to mark an entity as an item of an RSS feed.
 *
 * @package     stubbles
 * @subpackage  xml_rss
 * @version     $Id: stubRSSFeedItemAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAbstractAnnotation');
/**
 * Annotation to mark an entity as an item of an RSS feed.
 *
 * @package     stubbles
 * @subpackage  xml_rss
 */
class stubRSSFeedItemAnnotation extends stubAbstractAnnotation
{
    /**
     * list of methods to retrieve rss feed item data from
     *
     * The key is the method of the stubRSSFeedItem class that needs to be called
     * to set the respective property. This does not apply to title, link and
     * description as these are set on construction via the constructor.
     *
     * The value is the name of the method of the entity marked with this
     * annotation. The method names here are the default ones, all of them may
     * be overwritten by the annotation on the entity class.
     *
     * @var  array<string,string>
     */
    protected $methods = array('title'                => 'getTitle',
                               'link'                 => 'getLink',
                               'description'          => 'getDescription',
                               'byAuthor'             => 'getAuthor',
                               'inCategories'         => 'getCategories',
                               'addCommentsAt'        => 'getCommentsURL',
                               'deliveringEnclosures' => 'getEnclosures',
                               'withGuid'             => 'getGuid',
                               'andGuidIsPermaLink'   => 'isPermaLink',
                               'publishedOn'          => 'getPubDate',
                               'inspiredBySources'    => 'getSources',
                               'withContent'          => 'getContent'
                         );

    /**
     * returns the target of the annotation as bitmap
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_CLASS;
    }

    /**
     * returns list of methods to retrieve rss feed item data from
     *
     * @return  array<string,string>
     */
    public function getMethods()
    {
        return $this->methods;
    }

    /**
     * sets the name of method to return the title of the item
     *
     * @param  string  $titleMethod
     */
    public function setTitleMethod($titleMethod)
    {
        $this->methods['title'] = $titleMethod;
    }

    /**
     * sets the name of method to return the URL of the item
     *
     * @param  string  $linkMethod
     */
    public function setLinkMethod($linkMethod)
    {
        $this->methods['link'] = $linkMethod;
    }

    /**
     * sets the name of method to return the item synopsis
     *
     * @param  string  $descriptionMethod
     */
    public function setDescriptionMethod($descriptionMethod)
    {
        $this->methods['description'] = $descriptionMethod;
    }

    /**
     * sets the name of method to return the email address of the author of the item
     *
     * @param  string  $authorMethod
     */
    public function setAuthorMethod($authorMethod)
    {
        $this->methods['byAuthor'] = $authorMethod;
    }

    /**
     * sets the name of method to return the categories where the item is included
     *
     * @param  string  $categoriesMethod
     */
    public function setCategoriesMethod($categoriesMethod)
    {
        $this->methods['inCategories'] = $categoriesMethod;
    }

    /**
     * sets the name of method to return the URL of a page for comments relating to the item
     *
     * @param  string  $commentsMethod
     */
    public function setCommentsMethod($commentsMethod)
    {
        $this->methods['addCommentsAt'] = $commentsMethod;
    }

    /**
     * sets the name of method to return the media object descriptions attached to the item
     *
     * @param  string  $enclosuresMethod
     */
    public function setEnclosuresMethod($enclosuresMethod)
    {
        $this->methods['deliveringEnclosures'] = $enclosuresMethod;
    }

    /**
     * sets the name of method to return the unique identifier for the item
     *
     * @param  string  $guidMethod
     */
    public function setGuidMethod($guidMethod)
    {
        $this->methods['withGuid'] = $guidMethod;
    }

    /**
     * sets the name of method to return whether the id may be interpreted as a permanent link or not
     *
     * @param  string  $isPermaLinkMethod
     */
    public function setIsPermaLinkMethod($isPermaLinkMethod)
    {
        $this->methods['andGuidIsPermaLink'] = $isPermaLinkMethod;
    }

    /**
     * sets the name of method to return the date when the item was published
     *
     * @param  string  $pubDateMethod
     */
    public function setPubDateMethod($pubDateMethod)
    {
        $this->methods['publishedOn'] = $pubDateMethod;
    }

    /**
     * sets the name of method to return where that the item came from
     *
     * @param  string  $sourcesMethod
     */
    public function setSourcesMethod($sourcesMethod)
    {
        $this->methods['inspiredBySources'] = $sourcesMethod;
    }

    /**
     * sets the name of method to return the content of rss feed item
     *
     * @param  string  $contentMethod
     */
    public function setContentMethod($contentMethod)
    {
        $this->methods['withContent'] = $contentMethod;
    }
}
?><?php
/**
 * Processor for rss feeds.
 *
 * @package     stubbles
 * @subpackage  xml_rss
 * @version     $Id: stubRSSProcessor.php 2851 2011-01-05 13:18:02Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjector',
                      'net::stubbles::lang::stubProperties',
                      'net::stubbles::lang::exceptions::stubConfigurationException',
                      'net::stubbles::websites::processors::stubAbstractProcessor',
                      'net::stubbles::xml::stubXMLStreamWriter',
                      'net::stubbles::xml::rss::stubRSSFeed'
);
/**
 * Processor for rss feeds.
 *
 * @package     stubbles
 * @subpackage  xml_rss
 */
class stubRSSProcessor extends stubAbstractProcessor
{
    /**
     * injector instance
     *
     * @var  stubInjector
     */
    protected $injector;
    /**
     * name of the route
     *
     * @var  string
     */
    protected $routeName;
    /**
     * rss feed to create
     *
     * @var  stubRSSFeed
     */
    protected $rssFeed;

    /**
     * constructor
     *
     * @param   stubRequest   $request     current request
     * @param   stubSession   $session     current session
     * @param   stubResponse  $response    current response
     * @param   stubInjector  $injector    injector to create feed instances with
     * @param   string        $configPath  path to config file
     * @throws  stubConfigurationException
     * @Inject
     * @Named{configPath}('net.stubbles.config.path')
     */
    public function __construct(stubRequest $request, stubSession $session, stubResponse $response, stubInjector $injector, $configPath)
    {
        $feeds = stubProperties::fromFile($configPath . DIRECTORY_SEPARATOR . 'rss-feeds.ini')
                               ->getSection('feeds', array());
        if (count($feeds) === 0) {
            throw new stubConfigurationException('No rss feeds configured in ' . $configPath . DIRECTORY_SEPARATOR . 'rss-feeds.ini in section [feeds]');
        }
        
        parent::__construct($request, $session, $response);
        $this->injector  = $injector;
        reset($feeds);
        $defaultRouteName = key($feeds);
        $this->routeName  = $this->request->readParam('feed')->ifIsOneOf(array_keys($feeds), $defaultRouteName);
        $this->rssFeed    = $this->injector->getInstance($feeds[$this->routeName]);
    }

    /**
     * checks whether document part is cachable or not
     *
     * @return  bool
     */
    public function isCachable()
    {
        return $this->rssFeed->isCachable();
    }

    /**
     * returns a list of variables that have an influence on caching
     *
     * @return  array<string,scalar>
     */
    public function getCacheVars()
    {
        return $this->rssFeed->getCacheVars();
    }

    /**
     * returns the name of the current route
     *
     * @return  string
     */
    public function getRouteName()
    {
        return $this->routeName;
    }

    /**
     * processes the request
     *
     * @return  stubProcessor
     */
    public function process()
    {
        $this->response->addHeader('Content-Type', 'text/xml; charset=utf-8');
        $this->response->write($this->rssFeed->create()
                                             ->serialize($this->injector->getInstance('stubXMLStreamWriter'))
                                             ->asXML()
        );
        return $this;
    }
}
?><?php
/**
 * Annotation for XMLSerializer
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 * @version     $Id: stubXMLAttributeAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation'
);
/**
 * Annotation for XMLSerializer
 *
 * Use this annotation to serialize a value as an XML attribute.
 *
 * Properties of the annotation are:
 * - attributeName
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 */
class stubXMLAttributeAnnotation extends stubAbstractAnnotation implements stubAnnotation
{
    /**
     * Name of the XML attribute
     *
     * @var  string
     */
    protected $attributeName;
    /**
     * Whether an empty value should be skipped
     *
     * @var  boolean
     */
    protected $skipEmpty = true;
    /**
     * Set the attribute name
     *
     * @param  string  $attributeName
     */
    public function setAttributeName($attributeName)
    {
        $this->attributeName = $attributeName;
    }

    /**
     * Set the skipEmpty behaviour
     *
     * @param  boolean  $skipEmpty
     */
    public function setSkipEmpty($skipEmpty)
    {
        $this->skipEmpty = $skipEmpty;
    }

    /**
     * Get the name for the attribute
     *
     * @return  string
     */
    public function getAttributeName()
    {
        return $this->attributeName;
    }

    /**
     * Check, whether empty values should be skipped
     *
     * @return  boolean
     */
    public function shouldSkipEmpty()
    {
        return $this->skipEmpty;
    }

    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_FUNCTION + stubAnnotation::TARGET_METHOD + stubAnnotation::TARGET_PROPERTY;
    }
}
?><?php
/**
 * Annotation for XMLSerializer
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 * @version     $Id: stubXMLFragmentAnnotation.php 2206 2009-05-05 19:37:59Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation'
);
/**
 * Annotation for XMLSerializer
 *
 * Use this annotation to serialize a value as an XML fragment.
 *
 * Properties of the annotation are:
 * - tagName
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 */
class stubXMLFragmentAnnotation extends stubAbstractAnnotation implements stubAnnotation
{
    /**
     * name of the XML tag
     *
     * @var  string
     */
    protected $tagName;
    /**
     * whether to transform new lines in value to <br/>
     *
     * @var  bool
     */
    protected $transformNewLineToBr = false;

    /**
     * Set the tag name
     *
     * @param  string  $tagName
     */
    public function setTagName($tagName)
    {
        $this->tagName = $tagName;
    }

    /**
     * Get the tag name for the tag
     *
     * @return  string
     */
    public function getTagName()
    {
        return $this->tagName;
    }

    /**
     * sets whether new lines should be transformed into <br/>
     *
     * @param  bool  $transformNewLineToBr
     */
    public function setTransformNewLineToBr($transformNewLineToBr)
    {
        $this->transformNewLineToBr = $transformNewLineToBr;
    }

    /**
     * checks whether new lines should be transformed into <br/>
     *
     * @return  bool
     */
    public function transformNewLineToBr()
    {
        return $this->transformNewLineToBr;
    }

    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_PROPERTY + stubAnnotation::TARGET_METHOD;
    }
}
?><?php
/**
 * Annotation for XMLSerializer
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 * @version     $Id: stubXMLIgnoreAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation'
);
/**
 * Annotation for XMLSerializer
 *
 * Use this annotation, if you do not want a property to be serialized.
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 */
class stubXMLIgnoreAnnotation extends stubAbstractAnnotation implements stubAnnotation
{

    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_ALL;
    }
}
?><?php
/**
 * Annotation for XMLSerializer
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 * @version     $Id: stubXMLMatcherAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation',
                      'net::stubbles::xml::stubXMLException',
                      'net::stubbles::xml::serializer::annotations::stubXMLMethodsAnnotation',
                      'net::stubbles::xml::serializer::annotations::stubXMLPropertiesAnnotation'
);

/**
 * Annotation for XMLSerializer
 *
 * Use this annotation to define, which properties/methods of a class should be serialized
 *
 * Properties of the annotation are:
 * - pattern
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 */
class stubXMLMatcherAnnotation extends stubAbstractAnnotation implements stubAnnotation, stubXMLPropertiesAnnotation, stubXMLMethodsAnnotation
{
    /**
     * Pattern of the properties, that should be serialized
     *
     * @var  string
     */
    protected $pattern;

    /**
     * Set the pattern
     *
     * @param  string  $pattern
     */
    public function setPattern($pattern)
    {
        $this->pattern = $pattern;
    }

    /**
     * Get the name of the tag to use for a property
     *
     * @param   stubReflectionProperty  $property
     * @return  string|false
     * @throws  stubXMLException
     */
    public function getTagnameForProperty(stubReflectionProperty $property)
    {
        $matches = array();
        $success = @preg_match($this->pattern, $property->getName(), $matches);
        if (false === $success) {
            throw new stubXMLException("Syntax error in regular expression '{$this->pattern}': {$php_errormsg}");
        }
        
        if (empty($matches) === true) {
            return false;
        }
        
        if (isset($matches[1]) === true) {
            return $matches[1];
        }
        
        return $matches[0];
    }

    /**
     * Get the name of the tag to use for a method
     *
     * @param   stubReflectionMethod  $method
     * @return  string|bool
     * @throws  stubXMLException
     */
    public function getTagnameForMethod(stubReflectionMethod $method)
    {
        $matches = array();
        $success = preg_match($this->pattern, $method->getName(), $matches);
        if (false === $success) {
            throw new stubXMLException("Syntax error in regular expression '{$this->pattern}': {$php_errormsg}");
        }
        
        if (empty($matches) === true) {
            return false;
        }
        
        if (isset($matches[1]) === true) {
            $name = $matches[1];
        } else {
            $name = $matches[0];
        }
        
        return strtolower($name{0}) . substr($name, 1);
    }

    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_CLASS;
    }
}
?><?php
/**
 * Annotation for XMLSerializer
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 * @version     $Id: stubXMLMethodsAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation'
);
/**
 * Annotation for XMLSerializer
 *
 * Use this annotation to define, which methods of a class should be serialized
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 */
interface stubXMLMethodsAnnotation
{
    /**
     * Get the name of the tag to use for a method
     *
     * @param   stubReflectionMethod  $method
     * @return  string|false
     */
    public function getTagnameForMethod(stubReflectionMethod $method);
}
?><?php
/**
 * Annotation for XMLSerializer
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 * @version     $Id: stubXMLPropertiesAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation'
);
/**
 * Annotation for XMLSerializer
 *
 * Use this annotation to define, which properties of a class should be serialized
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 */
interface stubXMLPropertiesAnnotation
{
    /**
     * Get the name of the tag to use for a property
     *
     * @param   stubReflectionProperty  $property
     * @return  string|false
     */
    public function getTagnameForProperty(stubReflectionProperty $property);
}
?><?php
/**
 * Annotation for XMLSerializer
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 * @version     $Id: stubXMLStrategyAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation'
);
/**
 * Annotation for XMLSerializer
 *
 * Use this annotation, if you do not want a property to be serialized.
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 */
class stubXMLStrategyAnnotation extends stubAbstractAnnotation implements stubAnnotation
{
    /**
     * The strategy to use for this class
     *
     * @var  int
     */
    protected $value;

    /**
     * Set the value of the annotation
     *
     * @param  int  $value
     */
    public function setValue($value)
    {
        $this->value = $value;
    }

    /**
     * Get the value of the annotation
     *
     * @return  int
     */
    public function getValue()
    {
        return $this->value;
    }

    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_CLASS;
    }
}
?><?php
/**
 * Annotation for XMLSerializer
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 * @version     $Id: stubXMLTagAnnotation.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation'
);
/**
 * Annotation for XMLSerializer
 *
 * Use this annotation to serialize a value as an XML tag.
 *
 * Properties of the annotation are:
 * - tagName
 * - elementTagName
 *
 * @package     stubbles
 * @subpackage  xml_serializer_annotations
 */
class stubXMLTagAnnotation extends stubAbstractAnnotation implements stubAnnotation
{
    /**
     * Name of the XML tag
     *
     * @var  string
     */
    protected $tagName;
    /**
     * Name of the XML tag for elements if this element is indexed
     *
     * @var  string
     */
    protected $elementTagName = null;

    /**
     * Set the tag name
     *
     * @param  string  $tagName
     */
    public function setTagName($tagName)
    {
        $this->tagName = $tagName;
    }

    /**
     * Get the tag name for the tag
     *
     * @return  string
     */
    public function getTagName()
    {
        return $this->tagName;
    }

    /**
     * Set the element tag name
     *
     * @param  string  $elementTagName
     */
    public function setElementTagName($elementTagName)
    {
        $this->elementTagName = $elementTagName;
    }

    /**
     * Get the name for the element tag
     *
     * @return  string
     */
    public function getElementTagName()
    {
        return $this->elementTagName;
    }

    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_ALL;
    }
}
?><?php
/**
 * Matcher for methods and properties.
 * 
 * @package     stubbles
 * @subpackage  xml_serializer_matcher
 * @version     $Id: stubXMLSerializerMethodPropertyMatcher.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::matcher::stubMethodMatcher',
                      'net::stubbles::reflection::matcher::stubPropertyMatcher'
);
/**
 * Matcher for methods and properties.
 * 
 * @package     stubbles
 * @subpackage  xml_serializer_matcher
 */
class stubXMLSerializerMethodPropertyMatcher extends stubBaseObject implements stubMethodMatcher, stubPropertyMatcher
{
    /**
     * checks whether the matcher is satisfied with the given method
     *
     * @param   ReflectionMethod  $method
     * @return  bool
     */
    public function matchesMethod(ReflectionMethod $method)
    {
        if ($method->isPublic() === false || $method->isStatic() === true) {
            return false;
        }
        
        if ($method->isConstructor() === true || $method->isDestructor() === true) {
            return false;
        }
        
        if (0 == strncmp($method->getName(), '__', 2)) {
            return false;
        }
        
        if (0 != $method->getNumberOfParameters()) {
            return false;
        }
        
        return true;
    }

    /**
     * checks whether the matcher is satisfied with the given method
     *
     * @param   stubReflectionMethod  $method
     * @return  bool
     */
    public function matchesAnnotatableMethod(stubReflectionMethod $method)
    {
        return ($method->hasAnnotation('XMLIgnore') !== true);
    }

    /**
     * checks whether the matcher is satisfied with the given property
     *
     * @param   ReflectionProperty  $property
     * @return  bool
     */
    public function matchesProperty(ReflectionProperty $property)
    {
        if ($property->isPublic() === false || $property->isStatic() === true) {
            return false;
        }
        
        return true;
    }

    /**
     * checks whether the matcher is satisfied with the given property
     *
     * @param   stubReflectionProperty  $property
     * @return  bool
     */
    public function matchesAnnotatableProperty(stubReflectionProperty $property)
    {
        return ($property->hasAnnotation('XMLIgnore') !== true);
    }
}
?><?php
/**
 * XMLSerializer main class
 *
 * @package     stubbles
 * @subpackage  xml_serializer
 * @version     $Id: stubXMLSerializer.php 2589 2010-07-20 15:43:12Z mikey $
 */
stubClassLoader::load('net::stubbles::xml::stubXMLStreamWriter',
                      'net::stubbles::xml::serializer::stubXMLSerializerObjectData'
);
/**
 * XMLSerializer main class
 *
 * @package     stubbles
 * @subpackage  xml_serializer
 */
class stubXMLSerializer extends stubBaseObject
{
    /**
     * Option to define the root tag of the serialized document
     */
    const OPT_ROOT_TAG     = 'root-tag';
    /**
     * Option to define the strategy
     */
    const OPT_STRATEGY     = 'strategy';
    /**
     * Do not export any properties or methods
     */
    const STRATEGY_NONE    = 0;
    /**
     * export only public properties
     */
    const STRATEGY_PROPS   = 1;
    /**
     * export only public methods
     */
    const STRATEGY_METHODS = 2;
    /**
     * export public properties and methods
     */
    const STRATEGY_ALL     = 3;
    /**
     * Default options
     *
     * @var  array
     */
    private $defaultOpts = array(self::OPT_ROOT_TAG => null,
                                 self::OPT_STRATEGY => self::STRATEGY_ALL
                           );
    /**
     * Currently used options
     *
     * @var  array
     */
    private $opts;

    /**
     * serialize any data structure to XML
     *
     * @param   mixed                $data       data to serialize
     * @param   stubXMLStreamWriter  $xmlWriter  XML Writer to use
     * @param   array<string,int>    $opts       optional  options to influence the serializing
     * @return  stubXMLStreamWriter  the given xml stream writer for fluent use
     */
    public function serialize($data, stubXMLStreamWriter $xmlWriter, array $opts = array())
    {
        // set the currently used options
        $this->opts = array_merge($this->defaultOpts, $opts);
        $this->serializeDispatcher($data, $xmlWriter, ((isset($this->opts[self::OPT_ROOT_TAG]) == true) ? ($this->opts[self::OPT_ROOT_TAG]) : (null)));
        return $xmlWriter;
    }

    /**
     * serialize any data structure to XML
     *
     * @param  mixed                $data       data to serialize
     * @param  stubXMLStreamWriter  $xmlWriter  XML Writer to use
     * @param  string               $tagName    name of the XML tag
     */
    protected function serializeDispatcher($data, stubXMLStreamWriter $xmlWriter, $tagName = null)
    {
        switch (gettype($data)) {
            case 'NULL':
                if (null === $tagName) {
                    $tagName = 'null';
                }
                
                $xmlWriter->writeStartElement($tagName);
                $xmlWriter->writeStartElement('null');
                $xmlWriter->writeEndElement();
                $xmlWriter->writeEndElement();
                break;
            
            case 'boolean':
                if (null === $tagName) {
                    $tagName = 'boolean';
                }
                
                $xmlWriter->writeStartElement($tagName);
                $xmlWriter->writeText($data === true ? 'true' : 'false');
                $xmlWriter->writeEndElement();
                break;
            
            case 'string':
            case 'integer':
            case 'double':
                if (null === $tagName) {
                    $tagName = gettype($data);
                }
                
                $xmlWriter->writeStartElement($tagName);
                $xmlWriter->writeText(strval($data));
                $xmlWriter->writeEndElement();
                break;
            
            case 'array':
                $this->serializeArray($data, $xmlWriter, $tagName);
                break;
            
            case 'object':
                if ($data instanceof Iterator) {
                    $this->serializeArray($data, $xmlWriter, $tagName);
                } else {
                    $this->serializeObject($data, $xmlWriter, $tagName);
                }
                break;
            
            default:
                // nothing to do
        }
    }

    /**
     * serialize an object
     *
     * @param  object               $object     object to serialize
     * @param  stubXMLStreamWriter  $xmlWriter  XML Writer to use
     * @param  string               $tagName    name of the XML tag
     */
    protected function serializeObject($object, stubXMLStreamWriter $xmlWriter, $tagName)
    {
        $serializerData = stubXMLSerializerObjectData::fromObject($object);
        $xmlWriter->writeStartElement($serializerData->getTagName($tagName));
        $strategy = $serializerData->getStrategy($this->opts[self::OPT_STRATEGY]);
        foreach ($serializerData->getProperties() as $propertyName => $propertyData) {
            $this->handle($object->$propertyName, $xmlWriter, $propertyData, ($strategy & self::STRATEGY_PROPS));
        }
        
        foreach ($serializerData->getMethods() as $methodName => $methodData) {
            $this->handle($object->$methodName(), $xmlWriter, $methodData, ($strategy & self::STRATEGY_METHODS));
        }
        
        $xmlWriter->writeEndElement();
    }

    /**
     * serializes given value with instructions from $data
     *
     * @param  mixed                               $value          the value to serialize
     * @param  stubXMLStreamWriter                 $xmlWriter      XML Writer to use
     * @param  array<string,array<string,scalar>>  $data           instructions on how to serialize
     * @param  int                                 $mustSerialize  whether the element must be serialized or not
     */
    protected function handle($value, stubXMLStreamWriter $xmlWriter, array $data, $mustSerialize)
    {
        switch ($data['type']) {
            case 'attribute':
                if (gettype($value) === 'boolean') {
                    $xmlWriter->writeAttribute($data['attributeName'], ((true === $value) ? ('true') : ('false')));
                } else {
                    if ('' === (string) $value && true === $data['shouldSkipEmpty']) {
                        return;
                    }

                    $xmlWriter->writeAttribute($data['attributeName'], (string) $value);
                }

                break;
            
            case 'fragment':
                if (null != $data['tagName']) {
                    $xmlWriter->writeStartElement($data['tagName']);
                    if (empty($value) === false) {
                        if (true === $data['nl2br']) {
                            $value = str_replace('&', '&amp;', nl2br($value));
                        }
                        
                        $xmlWriter->writeXmlFragment($value);
                    }
                    
                    $xmlWriter->writeEndElement();
                } elseif (empty($value) === false) {
                    $xmlWriter->writeXmlFragment($value);
                }
                break;
            
            default:
                if (false === $data['mustSerialize'] && 0 === $mustSerialize) {
                    return;
                }
                
                if (is_array($value) === true || $value instanceof Iterator) {
                    $this->serializeArray($value, $xmlWriter, $data['tagName'], $data['elementName']);
                } else {
                    $this->serializeDispatcher($value, $xmlWriter, $data['tagName']);
                }
        }
    }

    /**
     * serialize an array
     *
     * @param  array                $array       array to serialize
     * @param  stubXMLStreamWriter  $xmlWriter   XML Writer to use
     * @param  string               $tagName     'root' name for the array
     * @param  string               $defaultTag  The default tag for indexed arrays
     */
    protected function serializeArray($array, stubXMLStreamWriter $xmlWriter, $tagName, $defaultTag = null)
    {
        if (null === $tagName) {
            $tagName = 'array';
        }
        
        if (false !== $tagName) {
            $xmlWriter->writeStartElement($tagName);
        }
        
        foreach ($array as $key => $value) {
            if (is_int($key) === true) {
                if (null === $defaultTag) {
                    $this->serializeDispatcher($value, $xmlWriter);
                } else {
                    $this->serializeDispatcher($value, $xmlWriter, $defaultTag);
                }
            } else {
                $this->serializeDispatcher($value, $xmlWriter, $key);
            }
        }
        
        if (false !== $tagName) {
            $xmlWriter->writeEndElement();
        }
    }
}
?><?php
/**
 * Facade to simplify xml serializing.
 *
 * @package     stubbles
 * @subpackage  xml_serializer
 * @version     $Id: stubXmlSerializerFacade.php 2359 2009-10-26 10:10:12Z mikey $
 */
stubClassLoader::load('net::stubbles::xml::stubXMLStreamWriter',
                      'net::stubbles::xml::serializer::stubXMLSerializer'
);
/**
 * Facade to simplify xml serializing.
 *
 * @package     stubbles
 * @subpackage  xml_serializer
 * @since       1.1.0
 */
class stubXmlSerializerFacade extends stubBaseObject
{
    /**
     * xml serializer to hide
     *
     * @var  stubXMLSerializer
     */
    protected $xmlSerializer;
    /**
     * xml stream writer to write serialization to
     *
     * @var  stubXMLStreamWriter
     */
    protected $xmlStreamWriter;

    /**
     * constructor
     *
     * @param  stubXMLSerializer    $xmlSerializer
     * @param  stubXMLStreamWriter  $xmlStreamWriter
     * @Inject
     */
    public function __construct(stubXMLSerializer $xmlSerializer, stubXMLStreamWriter $xmlStreamWriter)
    {
        $this->xmlSerializer   = $xmlSerializer;
        $this->xmlStreamWriter = $xmlStreamWriter;
    }
    
    /**
     * serialize any data structure to XML
     *
     * @param   mixed  $data  data to serialize
     * @param   array  $opts  optional  options to influence the serializing
     * @return  string
     */
    public function serializeToXml($data, array $opts = array())
    {
        return $this->xmlSerializer->serialize($data, $this->xmlStreamWriter, $opts)
                                   ->asXml();
    }

    /**
     * serialize any data structure to XML
     *
     * @param   mixed        $data  data to serialize
     * @param   array        $opts  optional  options to influence the serializing
     * @return  DOMDocument
     */
    public function serializeToDom($data, array $opts = array())
    {
        return $this->xmlSerializer->serialize($data, $this->xmlStreamWriter, $opts)
                                   ->asDOM();
    }
}
?><?php
/**
 * Container for extracting informations on how to serialize a class.
 *
 * @package     stubbles
 * @subpackage  xml_serializer
 * @version     $Id: stubXMLSerializerObjectData.php 2206 2009-05-05 19:37:59Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubIllegalArgumentException',
                      'net::stubbles::xml::serializer::annotations::stubXMLTagAnnotation',
                      'net::stubbles::xml::serializer::annotations::stubXMLFragmentAnnotation',
                      'net::stubbles::xml::serializer::annotations::stubXMLAttributeAnnotation',
                      'net::stubbles::xml::serializer::annotations::stubXMLIgnoreAnnotation',
                      'net::stubbles::xml::serializer::annotations::stubXMLPropertiesAnnotation',
                      'net::stubbles::xml::serializer::annotations::stubXMLMethodsAnnotation',
                      'net::stubbles::xml::serializer::annotations::stubXMLMatcherAnnotation',
                      'net::stubbles::xml::serializer::annotations::stubXMLStrategyAnnotation',
                      'net::stubbles::xml::serializer::matcher::stubXMLSerializerMethodPropertyMatcher',
                      'net::stubbles::reflection::stubReflectionObject'
);
/**
 * Container for extracting informations on how to serialize a class.
 *
 * @package     stubbles
 * @subpackage  xml_serializer
 */
class stubXMLSerializerObjectData extends stubBaseObject
{
    /**
     * list of key-values pairs containing informations about the class to serialize
     *
     * @var  array<string,mixed>
     */
    protected $classData  = array();
    /**
     * list of properties to serialize
     *
     * @var  array<string,array<string,scalar>>
     */
    protected $properties  = array();
    /**
     * list of methods to serialize
     *
     * @var  array<string,array<string,scalar>>
     */
    protected $methods     = array();
    /**
     * reflection instance of class to serialize
     *
     * @var  stubBaseReflectionClass
     */
    protected $refClass;
    /**
     * the matcher to be used for methods and properties
     *
     * @var  stubXMLSerializerMethodPropertyMatcher
     */
    protected static $methodAndPropertyMatcher;
    /**
     * simple cache
     *
     * @var  array
     */
    protected static $cache = array();

    /**
     * static initializer
     */
    // @codeCoverageIgnoreStart
    public static function __static()
    {
        self::$methodAndPropertyMatcher = new stubXMLSerializerMethodPropertyMatcher();
    }
    // @codeCoverageIgnoreEnd

    /**
     * constructor
     *
     * It is recommended to not use the constructor but the static fromObject()
     * method. The constructor should be used if one is sure that there is only
     * one instance of a class to serialize.
     *
     * @param   object  $object
     * @throws  stubIllegalArgumentException
     */
    public function __construct($object)
    {
        if (is_object($object) === false) {
            throw new stubIllegalArgumentException('Can only handle objects.');
        }
        
        $this->refClass              = new stubReflectionObject($object);
        $this->classData['tagName']  = (($this->refClass->hasAnnotation('XMLTag') === true) ? ($this->refClass->getAnnotation('XMLTag')->getTagName()) : ($this->refClass->getName()));
        $this->classData['strategy'] = (($this->refClass->hasAnnotation('XMLStrategy') === false) ? (null) : ($this->refClass->getAnnotation('XMLStrategy')->getValue()));
        $this->extractProperties();
        $this->extractMethods();
    }

    /**
     * creates the structure from given object
     *
     * This method will cache the result - on the next request with the same
     * class it will return the same result, even if the given object is a
     * different instance.
     *
     * @param   object                       $object
     * @return  stubXMLSerializerObjectData
     * @throws  stubIllegalArgumentException
     */
    public static function fromObject($object)
    {
        if (is_object($object) === false) {
            throw new stubIllegalArgumentException('Can only handle objects.');
        }
        
        $class = get_class($object);
        if (isset(self::$cache[$class]) === true) {
            return self::$cache[$class];
        }
        
        self::$cache[$class] = new self($object);
        return self::$cache[$class];
    }

    /**
     * extract informations about properties
     */
    protected function extractProperties()
    {
        $properties = $this->refClass->getPropertiesByMatcher(self::$methodAndPropertyMatcher);
        $matcher    = null;
        if ($this->refClass->hasAnnotation('XMLProperties')) {
            $matcher = $this->refClass->getAnnotation('XMLProperties');
        }

        foreach ($properties as $property) {
            $data = $this->extractFromAnnotatableElement($property);
            if (null !== $data) {
                $this->properties[$property->getName()] = $data;
            } else {
                if (null !== $matcher) {
                    $tagName = $matcher->getTagnameForProperty($property);
                    if (false === $tagName) {
                        continue;
                    }
                    
                    $mustSerialize = true;
                } else {
                    $mustSerialize = false;
                    $tagName       = $property->getName();
                }
                
                $this->properties[$property->getName()] = array('type'          => 'tag',
                                                                'tagName'       => $tagName,
                                                                'elementName'   => null,
                                                                'mustSerialize' => $mustSerialize
                                                          );
            }
        }
    }

    /**
     * extract informations about methods
     */
    protected function extractMethods()
    {
        $methods = $this->refClass->getMethodsByMatcher(self::$methodAndPropertyMatcher);
        $matcher = null;
        if ($this->refClass->hasAnnotation('XMLMethods')) {
            $matcher = $this->refClass->getAnnotation('XMLMethods');
        }

        foreach ($methods as $method) {
            $data = $this->extractFromAnnotatableElement($method);
            if (null !== $data) {
                $this->methods[$method->getName()] = $data;
            } else {
                if (null !== $matcher) {
                    $tagName = $matcher->getTagnameForMethod($method);
                    if (false === $tagName) {
                        continue;
                    }
                    
                    $mustSerialize = true;
                } else {
                    $mustSerialize = false;
                    $tagName = $method->getName();
                }
                
                $this->methods[$method->getName()] = array('type'          => 'tag',
                                                           'tagName'       => $tagName,
                                                           'elementName'   => null,
                                                           'mustSerialize' => $mustSerialize
                                                     );
            }
        }
    }

    /**
     * extracts informations about annotated element
     *
     * @param   stubAnnotatable  $annotatable  the annotatable element to serialize
     * @return  array
     */
    protected function extractFromAnnotatableElement(stubAnnotatable $annotatable)
    {
        if ($annotatable->hasAnnotation('XMLAttribute') === true) {
            $xmlAttribute = $annotatable->getAnnotation('XMLAttribute');
            return array('type'            => 'attribute',
                         'attributeName'   => $xmlAttribute->getAttributeName(),
                         'shouldSkipEmpty' => $xmlAttribute->shouldSkipEmpty()
                   );
        } elseif ($annotatable->hasAnnotation('XMLFragment') === true) {
            $xmlFragment = $annotatable->getAnnotation('XMLFragment');
            return array('type'    => 'fragment',
                         'tagName' => $xmlFragment->getTagName(),
                         'nl2br'   => $xmlFragment->transformNewLineToBr()
                   );
        } elseif ($annotatable->hasAnnotation('XMLTag') === true) {
            $xmlTag = $annotatable->getAnnotation('XMLTag');
            return array('type'          => 'tag',
                         'tagName'       => $xmlTag->getTagName(),
                         'elementName'   => $xmlTag->getElementTagName(),
                         'mustSerialize' => true
                   );
        }
        
        return null;
    }

    /**
     * returns the tagname to be used for the object
     *
     * The given argument resambles the tagname requested by the serializer.
     * Only if this is NULL the extracted tagname will be returned.
     *
     * @param   string  $tagName
     * @return  string
     */
    public function getTagName($tagName)
    {
        if (null !== $tagName) {
            return $tagName;
        }
        
        return $this->classData['tagName'];
    }

    /**
     * returns the strategy for serialization
     *
     * If no strategy is annotated to the class the default value will be returned.
     *
     * @param   int  $default
     * @return  int
     */
    public function getStrategy($default)
    {
        if (null !== $this->classData['strategy']) {
            return $this->classData['strategy'];
        }
        
        return $default;
    }

    /**
     * returns informations about properties to serialize
     *
     * @return  array<string,array<string,scalar>>
     */
    public function getProperties()
    {
        return $this->properties;
    }

    /**
     * returns informations about methods to serialize
     *
     * @return  array<string,array<string,scalar>>
     */
    public function getMethods()
    {
        return $this->methods;
    }
}
?><?php
/**
 * Abstract base class for XML stream writers.
 *
 * @package     stubbles
 * @subpackage  xml
 * @version     $Id: stubAbstractXMLStreamWriter.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Abstract base class for XML stream writers.
 *
 * @package     stubbles
 * @subpackage  xml
 */
abstract class stubAbstractXMLStreamWriter extends stubBaseObject
{
    /**
     * XML version
     *
     * @var  string
     */
    protected $xmlVersion;
    /**
     * encoding used by the writer
     *
     * @var  string
     */
    protected $encoding;
    /**
     * List of supported features
     *
     * @var  array
     */
    protected $features = array();
    /**
     * depth, i.e. amount of opened tags
     *
     * @var  int
     */
    protected $depth   = 0;

    /**
     * returns the xml version used by the writer
     *
     * @return  string
     */
    public function getVersion()
    {
        return $this->xmlVersion;
    }

    /**
     * returns the encoding used by the writer
     *
     * @return  string
     */
    public function getEncoding()
    {
        return $this->encoding;
    }

    /**
     * Checks, whether the implementation has a desired feature
     *
     * @param   int   $feature
     * @return  bool
     */
    public function hasFeature($feature)
    {
        return in_array($feature, $this->features);
    }

    /**
     * Write an opening tag
     *
     * @param  string  $elementName
     */
    public function writeStartElement($elementName)
    {
        $this->doWriteStartElement($elementName);
        $this->depth++;
    }

    /**
     * really writes an opening tag
     *
     * @param  string  $elementName
     */
    protected abstract function doWriteStartElement($elementName);

    /**
     * Write an end element
     */
    public function writeEndElement()
    {
        $this->doWriteEndElement();
        $this->depth--;
    }

    /**
     *  really writes an end element
     */
    protected abstract function doWriteEndElement();

    /**
     * checks whether the document is finished meaning no open tags are left
     *
     * @return  bool
     */
    public function isFinished()
    {
        return 0 === $this->depth;
    }
}
?><?php
/**
 * XML STream Writer based on DOM
 *
 * @package     stubbles
 * @subpackage  xml
 * @version     $Id: stubDomXMLStreamWriter.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::xml::stubXMLStreamWriter',
                      'net::stubbles::xml::stubAbstractXMLStreamWriter'
);
/**
 * XML STream Writer based on DOM
 *
 * @package     stubbles
 * @subpackage  xml
 */
class stubDomXMLStreamWriter extends stubAbstractXMLStreamWriter implements stubXMLStreamWriter
{
    /**
     * List of supported features
     *
     * @var  array
     */
    protected $features = array(stubXMLStreamWriter::FEATURE_AS_DOM,
                                stubXMLStreamWriter::FEATURE_IMPORT_WRITER
                          );
    /**
     * DOM Document
     *
     * @var  DOMDocument
     */
    protected $doc;
    /**
     * Stores al opened elements
     *
     * @var  array
     */
    protected $elementStack = array();

    /**
     * Create a new writer
     *
     * @param  string  $xmlVersion
     * @param  string  $encoding
     */
    public function __construct($xmlVersion = '1.0', $encoding = 'UTF-8')
    {
        $this->xmlVersion = $xmlVersion;
        $this->encoding   = $encoding;
        $this->doc        = new DOMDocument($xmlVersion, $encoding);
    }

    /**
     * Clear all data, that has been written
     */
    public function clear()
    {
        $this->doc = new DOMDocument($this->xmlVersion, $this->encoding);
        $this->elementStack = array();
    }

    /**
     * really writes an opening tag
     *
     * @param   string            $elementName
     * @throws  stubXMLException
     */
    protected function doWriteStartElement($elementName)
    {
        try {
            libxml_use_internal_errors(true);
            $element = $this->doc->createElement($elementName);
            if (count($this->elementStack) == 0) {
                $this->doc->appendChild($element);
            } else {
                $parent = end($this->elementStack);
                $parent->appendChild($element);
            }
            array_push($this->elementStack, $element);
            $errors = libxml_get_errors();
            if (!empty($errors)) {
                libxml_clear_errors();
                throw new stubXMLException('Error writing start element: "' . $elementName . '": ' . $this->convertLibXmlErrorsToString($errors));
            }
        } catch (DOMException $e) {
            throw new stubXMLException('Error writing start element "' . $elementName . '".', $e);
        }
    }

    /**
     * Write a text node
     *
     * @param   string            $data
     * @throws  stubXMLException
     */
    public function writeText($data)
    {
        try {
            libxml_use_internal_errors(true);
            $textNode = $this->doc->createTextNode($this->encode($data));
            $this->addToDom($textNode);
            $errors = libxml_get_errors();
            if (!empty($errors)) {
                libxml_clear_errors();
                throw new stubXMLException('Error writing text: ' . $this->convertLibXmlErrorsToString($errors));
            }
        } catch (DOMException $e) {
            throw new stubXMLException('Error writing text.', $e);
        }
    }

    /**
     * Write a cdata section
     *
     * @param   string            $cdata
     * @throws  stubXMLException
     */
    public function writeCData($cdata)
    {
        try {
            libxml_use_internal_errors(true);
            $cdataNode = $this->doc->createCDATASection($this->encode($cdata));
            $this->addToDom($cdataNode);
            $errors = libxml_get_errors();
            if (!empty($errors)) {
                libxml_clear_errors();
                throw new stubXMLException('Error writing cdata section: ' . $this->convertLibXmlErrorsToString($errors));
            }
        } catch (DOMException $e) {
            throw new stubXMLException('Error writing cdata section.', $e);
        }
    }

    /**
     * Write a comment
     *
     * @param   string            $comment
     * @throws  stubXMLException
     */
    public function writeComment($comment)
    {
        try {
            libxml_use_internal_errors(true);
            $commentNode = $this->doc->createComment($this->encode($comment));
            $this->addToDom($commentNode);
            $errors = libxml_get_errors();
            if (!empty($errors)) {
                libxml_clear_errors();
                throw new stubXMLException('Error writing comment: ' . $this->convertLibXmlErrorsToString($errors));
            }
        } catch (DOMException $e) {
            throw new stubXMLException('Error writing comment.', $e);
        }
    }

    /**
     * Write a processing instruction
     *
     * @param   string            $target
     * @param   string            $data
     * @throws  stubXMLException
     */
    public function writeProcessingInstruction($target, $data = '')
    {
        try {
            libxml_use_internal_errors(true);
            $piNode = $this->doc->createProcessingInstruction($target, $data);
            $this->addToDom($piNode);
            $errors = libxml_get_errors();
            if (!empty($errors)) {
                libxml_clear_errors();
                throw new stubXMLException('Error writing processing instruction: ' . $this->convertLibXmlErrorsToString($errors));
            }
        } catch (DOMException $e) {
            throw new stubXMLException('Error writing processing instruction.', $e);
        }
    }

    /**
     * Write an xml fragment
     *
     * @param   string            $fragment
     * @throws  stubXMLException
     */
    public function writeXmlFragment($fragment)
    {
        try {
            libxml_use_internal_errors(true);
            $fragmentNode = $this->doc->createDocumentFragment();
            $fragmentNode->appendXML($fragment);
            $this->addToDom($fragmentNode);
            $errors = libxml_get_errors();
            if (!empty($errors)) {
                libxml_clear_errors();
                throw new stubXMLException('Error writing document fragment: ' . $this->convertLibXmlErrorsToString($errors));
            }
        } catch (DOMException $e) {
            throw new stubXMLException('Error writing document fragment.', $e);
        }
    }

    /**
     * Write an attribute
     *
     * @param   string            $attributeName
     * @param   string            $attributeValue
     * @throws  stubXMLException
     */
    public function writeAttribute($attributeName, $attributeValue)
    {
        try {
            libxml_use_internal_errors(true);
            $currentElement = end($this->elementStack);
            $currentElement->setAttribute($attributeName, $this->encode($attributeValue));
            $errors = libxml_get_errors();
            if (!empty($errors)) {
                libxml_clear_errors();
                throw new stubXMLException('Error writing attribute:  "' . $attributeName . ':' . $attributeValue . '":' . $this->convertLibXmlErrorsToString($errors));
            }
        } catch (DOMException $e) {
            throw new stubXMLException('Error writing attribute "' . $attributeName . ':' . $attributeValue . '".', $e);
        }
    }

    /**
     * really writes an end element
     *
     * @throws  stubXMLException
     */
    protected function doWriteEndElement()
    {
        if (count($this->elementStack) === 0) {
            throw new stubXMLException('No open element available.');
        }
        
        array_pop($this->elementStack);
    }

    /**
     * Write a full element
     *
     * @param   string            $elementName
     * @param   array             $attributes  optional
     * @param   string            $cdata       optional
     * @throws  stubXMLException
     */
    public function writeElement($elementName, array $attributes = array(), $cdata = null)
    {
        try {
            libxml_use_internal_errors(true);
            $element = $this->doc->createElement($elementName);
            foreach ($attributes as $attName => $attValue) {
                $element->setAttribute($attName, $this->encode($attValue));
            }
            
            if (null !== $cdata) {
                $element->appendChild($this->doc->createTextNode($cdata));
            }
            
            if (count($this->elementStack) == 0) {
                $this->doc->appendChild($element);
            } else {
                $parent = end($this->elementStack);
                $parent->appendChild($element);
            }
            
            $errors = libxml_get_errors();
            if (!empty($errors)) {
                libxml_clear_errors();
                throw new stubXMLException('Error writing element: "' . $elementName . '":' . $this->convertLibXmlErrorsToString($errors));
            }
        } catch (DOMException $e) {
            throw new stubXMLException('Error writing element"' . $elementName . '".', $e);
        }
    }

    /**
     * Import another stream
     *
     * @param   stubXMLStreamWriter  $writer
     * @throws  stubXMLException
     */
    public function importStreamWriter(stubXMLStreamWriter $writer)
    {
        try {
            libxml_use_internal_errors(true);
            $newNode = $writer->asDOM()->documentElement;
            $newNodeImported = $this->doc->importNode($newNode, true);
            $this->addToDom($newNodeImported);
            $errors = libxml_get_errors();
            if (!empty($errors)) {
                libxml_clear_errors();
                throw new stubXMLException('Error during import: ' . $this->convertLibXmlErrorsToString($errors));
            }
        } catch (DOMException $e) {
            throw new stubXMLException('Error during import.', $e);
        }
    }

    /**
     * Add a node to the internal DOM tree
     *
     * @param   DOMNode           $node
     * @throws  stubXMLException
     */
    protected function addToDom(DOMNode $node)
    {
        if (count($this->elementStack) < 1) {
            throw new stubXMLException('No tag is currently open, you need to call writeStartElement() first.');
        }
        $current = end($this->elementStack);
        $current->appendChild($node);
    }

    /**
     * Return the XML as a DOM
     *
     * @return  DOMDocument
     */
    public function asDom()
    {
        return $this->doc;
    }

    /**
     * Return the XML as a string
     *
     * @return  string
     */
    public function asXML()
    {
        return rtrim($this->doc->saveXML());
    }

    /**
     * Converts all errors to a string
     *
     * @param   array   $errors
     * @return  string
     */
    protected function convertLibXmlErrorsToString($errors)
    {
        $messages = array();
        foreach ($errors as $error) {
            $messages[] = trim($error->message);
        }
        return implode(', ', $messages);
    }

    /**
     * helper method to transform data into correct encoding
     * 
     * Data has to be encoded even if document encoding is not UTF-8.
     *
     * @param   string  $data
     * @return  string
     * @see     http://php.net/manual/en/function.dom-domdocument-save.php#67952
     */
    protected function encode($data)
    {
        if (mb_detect_encoding($data, 'UTF-8, ISO-8859-1') === 'UTF-8') {
            return $data;
        }
        
        return utf8_encode($data);
    }
}
?><?php
/**
 * XML Stream Writer based on libxml
 *
 * @package     stubbles
 * @subpackage  xml
 * @version     $Id: stubLibXmlXMLStreamWriter.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubMethodNotSupportedException',
                      'net::stubbles::xml::stubXMLStreamWriter',
                      'net::stubbles::xml::stubAbstractXMLStreamWriter'
);
/**
 * XML Stream Writer based on libxml
 *
 * @package     stubbles
 * @subpackage  xml
 */
class stubLibXmlXMLStreamWriter extends stubAbstractXMLStreamWriter implements stubXMLStreamWriter
{
    /**
     * List of supported features
     *
     * @var  array
     */
    protected $features = array(stubXMLStreamWriter::FEATURE_AS_DOM);
    /**
     * Writer
     *
     * @var  XMLWriter
     */
    protected $writer;

    /**
     * Create a new writer
     *
     * @param  string  $xmlVersion
     * @param  string  $encoding
     */
    public function __construct($xmlVersion = '1.0', $encoding = 'UTF-8')
    {
        $this->xmlVersion = $xmlVersion;
        $this->encoding   = $encoding;
        $this->writer     = new XMLWriter();
        $this->writer->openMemory();
        $this->writer->startDocument($xmlVersion, $encoding);
        $this->writer->setIndent(false);
    }

    /**
     * Clear all data, that has been written
     */
    public function clear()
    {
        unset($this->writer);

        $this->writer = new XMLWriter();
        $this->writer->openMemory();
        $this->writer->startDocument($this->xmlVersion, $this->encoding);
        $this->writer->setIndent(false);
    }

    /**
     * really writes an opening tag
     *
     * @param  string  $elementName
     */
    protected function doWriteStartElement($elementName)
    {
        $this->writer->startElement($elementName);
    }

    /**
     * Write a text node
     *
     * @param  string  $data
     */
    public function writeText($data)
    {
        $this->writer->text($data);
    }

    /**
     * Write a cdata section
     *
     * @param  string  $cdata
     */
    public function writeCData($cdata)
    {
        $this->writer->writeCdata($cdata);
    }

    /**
     * Write a comment
     *
     * @param  string  $comment
     */
    public function writeComment($comment)
    {
        $this->writer->writeComment($comment);
    }

    /**
     * Write a processing instruction
     *
     * @param  string  $target
     * @param  string  $data
     */
    public function writeProcessingInstruction($target, $data = '')
    {
        $this->writer->writePi($target, $data);
    }

    /**
     * Write an xml fragment
     *
     * @param  string  $fragment
     */
    public function writeXmlFragment($fragment)
    {
        $this->writer->writeRaw($fragment);
    }

    /**
     * Write an attribute
     *
     * @param  string  $attributeName
     * @param  string  $attributeValue
     */
    public function writeAttribute($attributeName, $attributeValue)
    {
        $this->writer->writeAttribute($attributeName, $attributeValue);
    }

    /**
     * really writes an end element
     */
    protected function doWriteEndElement()
    {
        $this->writer->endElement();
    }

    /**
     * Write a full element
     *
     * @param  string  $elementName
     * @param  array   $attributes
     * @param  string  $cdata
     */
    public function writeElement($elementName, array $attributes = array(), $cdata = null)
    {
        $this->writeStartElement($elementName);
        foreach ($attributes as $attName => $attValue) {
            $this->writeAttribute($attName, $attValue);
        }
        if (null !== $cdata) {
            $this->writeText($cdata);
        }
        $this->writeEndElement();
    }

    /**
     * Import another stream
     *
     * @param   stubXMLStreamWriter              $writer
     * @throws  stubMethodNotSupportedException
     */
    public function importStreamWriter(stubXMLStreamWriter $writer)
    {
        throw new stubMethodNotSupportedException('Can not import another stream writer.');
    }

    /**
     * Return the XML as a DOM
     *
     * @return  DOMDocument
     */
    public function asDom()
    {
        $doc = new DOMDocument();
        $doc->loadXML($this->writer->outputMemory());
        return $doc;
    }

    /**
     * Return the XML as a string
     *
     * @return  string
     */
    public function asXML()
    {
        return rtrim($this->writer->outputMemory());
    }
}
?><?php
/**
 * XML Exception
 *
 * @package     stubbles
 * @subpackage  xml
 * @version     $Id: stubXMLException.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubChainedException');
/**
 * XML Exception
 *
 * @package     stubbles
 * @subpackage  xml
 */
class stubXMLException extends stubChainedException
{
    // intentionally empty
}
?><?php
/**
 * Interface to create XML documents
 *
 * @package     stubbles
 * @subpackage  xml
 * @version     $Id: stubXMLStreamWriter.php 2369 2009-10-30 14:54:40Z mikey $
 */
stubClassLoader::load('net::stubbles::xml::stubXMLException');
/**
 * Interface to create XML documents
 *
 * @package     stubbles
 * @subpackage  xml
 * @ProvidedBy(net::stubbles::xml::stubXmlStreamWriterProvider.class)
 */
interface stubXMLStreamWriter extends stubObject
{
    /**
     * Is able to import an stubXMLStreamWriter
     *
     * @var int
     */
    const FEATURE_IMPORT_WRITER = 1;
    /**
     * Is able to export as DOM
     *
     * @var int
     */
    const FEATURE_AS_DOM = 2;

    /**
     * Create a new writer
     *
     * @param  string  $xmlVersion
     * @param  string  $encoding
     */
    #public function __construct($xmlVersion = '1.0', $encoding = 'UTF-8');

    /**
     * returns the xml version used by the writer
     *
     * @return  string
     */
    public function getVersion();

    /**
     * returns the encoding used by the writer
     *
     * @return  string
     */
    public function getEncoding();

    /**
     * Checks, whether the implementation has a desired feature
     *
     * @param   int  $feature
     * @return  bool
     */
    public function hasFeature($feature);

    /**
     * Clear all data, that has been written
     */
    public function clear();

    /**
     * Write an opening tag
     *
     * @param  string  $elementName
     */
    public function writeStartElement($elementName);

    /**
     * Write a text node
     *
     * @param  string  $data
     */
    public function writeText($data);

    /**
     * Write a cdata section
     *
     * @param  string  $cdata
     */
    public function writeCData($cdata);

    /**
     * Write a comment
     *
     * @param  string  $comment
     */
    public function writeComment($comment);

    /**
     * Write a processing instruction
     *
     * @param  string  $target
     * @param  string  $data
     */
    public function writeProcessingInstruction($target, $data = '');

    /**
     * Write an xml fragment
     *
     * @param  string  $fragment
     */
    public function writeXmlFragment($fragment);

    /**
     * Write an attribute
     *
     * @param  string  $attributeName
     * @param  string  $attributeValue
     */
    public function writeAttribute($attributeName, $attributeValue);

    /**
     * Write an end element
     */
    public function writeEndElement();

    /**
     * Write a full element
     *
     * @param  string  $elementName
     * @param  array   $attributes
     * @param  string  $cdata
     */
    public function writeElement($elementName, array $attributes = array(), $cdata = null);

    /**
     * Import another stream
     *
     * @param  stubXMLStreamWriter  $writer
     */
    public function importStreamWriter(stubXMLStreamWriter $writer);

    /**
     * checks whether the document is finished meaning no open tags are left
     *
     * @return  bool
     */
    public function isFinished();

    /**
     * Return the XML as a string
     *
     * @return  string
     */
    public function asXML();

    /**
     * Return the XML as a DOM
     *
     * @return  DOMDocument
     */
    public function asDOM();
}
?><?php
/**
 * Provider to create a xml stream writer instances.
 *
 * @package     stubbles
 * @subpackage  xml
 * @version     $Id: stubXmlStreamWriterProvider.php 2364 2009-10-29 17:35:20Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjectionProvider',
                      'net::stubbles::xml::stubXMLException'
);
/**
 * Provider to create a xml stream writer instances.
 *
 * @package     stubbles
 * @subpackage  xml
 * @since       1.1.0
 */
class stubXmlStreamWriterProvider extends stubBaseObject implements stubInjectionProvider
{
    /**
     * list of available streamwriter types
     *
     * @var  array
     */
    protected $types = array('dom'       => 'Dom',
                             'xmlwriter' => 'LibXml'
                       );
    /**
     * default version of xml stream writers to create
     *
     * @var  string
     */
    protected $version  = '1.0';
    /**
     * default encoding of xml stream writers to create
     *
     * @var  string
     */
    protected $encoding = 'UTF-8';

    /**
     * set available xml stream writer types
     *
     * @param  array<string,string>  $types
     * @Inject(optional=true)
     * @Named('net.stubbles.xml.types')
     */
    public function setTypes(array $types)
    {
        $this->types = $types;
    }

    /**
     * sets the default version of xml stream writers to create
     *
     * @param  string  $version
     * @Inject(optional=true)
     * @Named('net.stubbles.xml.version')
     */
    public function setVersion($version)
    {
        $this->version = $version;
    }

    /**
     * sets the default encoding of xml stream writers to create
     *
     * @param  string  $encoding
     * @Inject(optional=true)
     * @Named('net.stubbles.xml.encoding')
     */
    public function setEncoding($encoding)
    {
        $this->encoding = $encoding;
    }

    /**
     * returns the value to provide
     *
     * @param   string  $name  optional
     * @return  mixed
     */
    public function get($name = null)
    {
        if (null != $name) {
            return $this->createStreamWriter($name);
        }
        
        return $this->createAsAvailable();
    }

    /**
     * creates a xml stream writer of the given type
     *
     * @param   string               $xmlExtension  concrete type to create
     * @return  stubXMLStreamWriter
     */
    protected function createStreamWriter($xmlExtension)
    {
        $fqClassName = 'net::stubbles::xml::stub' . $this->types[$xmlExtension] . 'XMLStreamWriter';
        $nqClassName = stubClassLoader::getNonQualifiedClassName($fqClassName);
        if (class_exists($nqClassName, false) === false) {
            stubClassLoader::load($fqClassName);
        }

        return new $nqClassName($this->version, $this->encoding);
    }

    /**
     * creates a xml stream writer depending on available xml extensions
     *
     * @return  stubXMLStreamWriter
     * @throws  stubXMLException
     */
    protected function createAsAvailable()
    {
        foreach (array_keys($this->types) as $xmlExtension) {
            if (extension_loaded($xmlExtension) === true) {
                return $this->createStreamWriter($xmlExtension);
            }
        }

        throw new stubXMLException('No supported xml extension available, can not create a xml stream writer!');
    }
}
?><?php
/**
 * Class to read XML files and turn them into simple PHP types.
 *
 * @package     stubbles
 * @subpackage  xml_unserializer
 * @version     $Id: stubXMLUnserializer.php 2857 2011-01-10 13:43:39Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubFileNotFoundException',
                      'net::stubbles::xml::stubXMLException',
                      'net::stubbles::xml::unserializer::stubXMLUnserializerOption'
);
/**
 * Class to read XML files and turn them into simple PHP types.
 *
 * @package     stubbles
 * @subpackage  xml_unserializer
 */
class stubXMLUnserializer extends stubBaseObject
{
    /**
     * current options for the serialization
     *
     * @var  array<string,mixed>
     */
    protected $options   = array();
    /**
     * current depth within the parsed document
     *
     * @var  int
     */
    protected $depth      = 0;
    /**
     * stack of opened elements while parsing
     *
     * @var  array
     */
    protected $dataStack  = array();
    /**
     * value stack
     *
     * @var  array
     */
    protected $valueStack = array();

    /**
     * constructor
     *
     * @param  array<string,mixed>  $options
     */
    public function __construct(array $options = null)
    {
        if (null === $options) {
            $this->options = stubXMLUnserializerOption::getDefault();
        } else {
            $this->options = array_merge(stubXMLUnserializerOption::getDefault(), $options);
        }
    }

    /**
     * unserializes data from given file
     *
     * @param   string  $fileName
     * @return  mixed
     * @throws  stubFileNotFoundException
     * @throws  stubXMLException
     */
    public function unserializeFile($fileName)
    {
        if (file_exists($fileName) === false) {
            throw new stubFileNotFoundException($fileName);
        }
        
        $reader = $this->initParser();
        if ($reader->open($fileName, $this->options[stubXMLUnserializerOption::ENCODING_SOURCE]) === false) {
            throw new stubXMLException('Failed to unserialize contents of ' . $fileName . ', can not create XML reader for given file.');
        }
        
        $result = $this->parse($reader);
        $reader->close($fileName);
        return $result;
    }

    /**
     * unserialize data
     *
     * @param   string  $data  data to unserialize
     * @return  mixed
     * @throws  stubXMLException
     */
    public function unserialize($data)
    {
        $reader = $this->initParser();
        if ($reader->xml($data, $this->options[stubXMLUnserializerOption::ENCODING_SOURCE]) === false) {
            throw new stubXMLException('Failed to unserialize data, can not create XML reader for given data.');
        }
        
        return $this->parse($reader);
    }

    /**
     * parses the xml document and creates the data structure from it
     *
     * @param   XMLReader $reader
     * @return  mixed
     */
    protected function parse($reader)
    {
        $data = null;
        while ($reader->read()) {
            switch ($reader->nodeType) {
                case XMLReader::ELEMENT:
                    $empty        = $reader->isEmptyElement;
                    $nameSpaceURI = $reader->namespaceURI;
                    $elementName  = $reader->localName;
                    $attributes   = array();
                    if (true == $reader->hasAttributes) {
                        // go to first attribute
                        $attribute = $reader->moveToFirstAttribute();
                        // save data of all attributes
                        while (true == $attribute) {
                            $attributes[$reader->localName] = $reader->value;
                            $attribute = $reader->moveToNextAttribute();
                        }
                    }

                    $this->startElement($nameSpaceURI, $elementName, $attributes);
                    if (true === $empty) {
                        $data = $this->endElement($nameSpaceURI, $elementName);
                    }
                    break;

                case XMLReader::TEXT:
                case XMLReader::CDATA:
                    $this->characters($reader->value);
                    break;

                case XMLReader::END_ELEMENT:
                    $data = $this->endElement($reader->namespaceURI, $reader->localName);
                    break;
                
                default:
                    // intentionally empty
            }
        }
        
        return $data;
    }

    /**
     * initializes the parser
     * 
     * @return  XMLReader $reader
     */
    protected function initParser()
    {
        $reader = new XMLReader();
        return $reader;
    }

    /**
     * handles the start element
     *
     * Creates a new Tag object and pushes it
     * onto the stack.
     *
     * @param  string  $namespaceURI  namespace of start tag
     * @param  string  $sName         name of start tag
     * @param  array   $atts          attributes of tag
     */
    protected function startElement($namespaceURI, $sName, $atts)
    {
        $this->depth++;
        $this->dataStack[$this->depth] = null;
        if (isset($atts[$this->options[stubXMLUnserializerOption::ATTRIBUTE_TYPE]])) {
            $type      = $atts[$this->options[stubXMLUnserializerOption::ATTRIBUTE_TYPE]];
            $guessType = false;
        } else {
            $type     = 'string';
            $guessType = $this->options[stubXMLUnserializerOption::GUESS_TYPES];
        }
        
        if (is_array($this->options[stubXMLUnserializerOption::TAG_MAP]) && isset($this->options[stubXMLUnserializerOption::TAG_MAP][$sName])) {
            $sName = $this->options[stubXMLUnserializerOption::TAG_MAP][$sName];
        }

        $val = array('name'         => $sName,
                     'value'        => null,
                     'type'         => $type,
                     'guessType'    => $guessType,
                     'childrenKeys' => array(),
                     'aggregKeys'   => array()
               );
        if (true === $this->options[stubXMLUnserializerOption::ATTRIBUTES_PARSE] && (count($atts) > 0)) {
            $val['children'] = array();
            $val['type']     = 'array';
            $val['class']    = $sName;

            if ($this->options[stubXMLUnserializerOption::GUESS_TYPES] === true) {
                $atts = $this->guessAndSetType($atts);
            }
            
            if ($this->options[stubXMLUnserializerOption::ATTRIBUTES_ARRAYKEY] != false) {
                $val['children'][$this->options[stubXMLUnserializerOption::ATTRIBUTES_ARRAYKEY]] = $atts;
            } else {
                foreach ($atts as $attrib => $value) {
                    $val['children'][$this->options[stubXMLUnserializerOption::ATTRIBUTES_PREPEND] . $attrib] = $value;
                }
            }
        }

        $keyAttr = $this->getKeyAttribute($sName);
        if (null !== $keyAttr && isset($atts[$keyAttr]) === true) {
            $val['name'] = $atts[$keyAttr];
        }

        array_push($this->valueStack, $val);
    }

    /**
     * helper method to detect the key attribute
     *
     * @param   string  $sName  name of element to retrieve key attribute for
     * @return  string
     */
    protected function getKeyAttribute($sName)
    {
        if (is_string($this->options[stubXMLUnserializerOption::ATTRIBUTE_KEY]) === true) {
            return $this->options[stubXMLUnserializerOption::ATTRIBUTE_KEY];
        }
        
        if (is_array($this->options[stubXMLUnserializerOption::ATTRIBUTE_KEY]) === false) {
            return null;
        }
        
        
        if (isset($this->options[stubXMLUnserializerOption::ATTRIBUTE_KEY][$sName]) === true) {
            return $this->options[stubXMLUnserializerOption::ATTRIBUTE_KEY][$sName];
        }
        
        if (isset($this->options[stubXMLUnserializerOption::ATTRIBUTE_KEY]['#default']) === true) {
            return $this->options[stubXMLUnserializerOption::ATTRIBUTE_KEY]['#default'];
        }
        
        if (isset($this->options[stubXMLUnserializerOption::ATTRIBUTE_KEY]['__default']) === true) {
            return $this->options[stubXMLUnserializerOption::ATTRIBUTE_KEY]['__default'];
        }
        
        return null;
    }

    /**
     * handles the end element
     *
     * Fetches the current element from the stack and
     * converts it to the correct type.
     *
     * @param   string  $namespaceURI  namespace of end tag
     * @param   string  $sName         name of end tag
     * @return  mixed
     */
    protected function endElement($namespaceURI, $sName)
    {
        $value = array_pop($this->valueStack);
        switch ($this->options[stubXMLUnserializerOption::WHITESPACE]) {
            case stubXMLUnserializerOption::WHITESPACE_KEEP:
                $data = $this->dataStack[$this->depth];
                break;
            
            case stubXMLUnserializerOption::WHITESPACE_NORMALIZE:
                $data = trim(preg_replace('/\s\s+/m', ' ', $this->dataStack[$this->depth]));
                break;
            
            case stubXMLUnserializerOption::WHITESPACE_TRIM:
            default:
                $data = trim($this->dataStack[$this->depth]);
                break;
        }

        // adjust type of the value
        switch (strtolower($value['type'])) {
            // unserialize an object
            case 'object':
                $value['value'] = new stdClass();
                if (trim($data) !== '') {
                    if (true === $value['guessType']) {
                        $data = $this->guessAndSetType($data);
                    }
                    
                    $value['children'][$this->options[stubXMLUnserializerOption::CONTENT_KEY]] = $data;
                }

                // set properties
                foreach ($value['children'] as $prop => $propVal) {
                    $value['value']->$prop = $propVal;
                }
                break;

            // unserialize an array
            case 'array':
                if (trim($data) !== '') {
                    if (true === $value['guessType']) {
                        $data = $this->guessAndSetType($data);
                    }
                    
                    $value['children'][$this->options[stubXMLUnserializerOption::CONTENT_KEY]] = $data;
                }
                
                if (isset($value['children']) === true) {
                    $value['value'] = $value['children'];
                } else {
                    $value['value'] = array();
                }
                break;

            // unserialize a null value
            case 'null':
                $data = null;
                break;

            // unserialize a resource => this is not possible :-(
            case 'resource':
                $value['value'] = $data;
                break;

            // unserialize any scalar value
            default:
                if (true === $value['guessType']) {
                    $data = $this->guessAndSetType($data);
                } else {
                    settype($data, $value['type']);
                }
            
                $value['value'] = $data;
                break;
        }
        
        $parent = array_pop($this->valueStack);
        if (null === $parent) {
            return $value['value'];
        } else {
            // parent has to be an array
            if (isset($parent['children']) === false || is_array($parent['children']) === false) {
                $parent['children'] = array();
                if ('array' !== $parent['type']) {
                    $parent['type'] = 'array';
                }
            }

            $ignoreKey = in_array($sName, $this->options[stubXMLUnserializerOption::IGNORE_KEYS]);
            if (empty($value['name']) === false && false === $ignoreKey) {
                // there already has been a tag with this name
                if (in_array($value['name'], $parent['childrenKeys']) === true || in_array($value['name'], $this->options[stubXMLUnserializerOption::FORCE_LIST]) === true) {
                    // no aggregate has been created for this tag
                    if (in_array($value['name'], $parent['aggregKeys']) === false) {
                        if (isset($parent['children'][$value['name']]) === true) {
                            $parent['children'][$value['name']] = array($parent['children'][$value['name']]);
                        } else {
                            $parent['children'][$value['name']] = array();
                        }
                        
                        array_push($parent['aggregKeys'], $value['name']);
                    }
                    array_push($parent['children'][$value['name']], $value['value']);
                } else {
                    $parent['children'][$value['name']] = &$value['value'];
                    array_push($parent['childrenKeys'], $value['name']);
                }
            } else {
                array_push($parent['children'], $value['value']);
            }
            
            array_push($this->valueStack, $parent);
        }
        
        $this->depth--;
    }

    /**
     * character data handler
     *
     * Fetches the current tag from the stack and
     * appends the data.
     *
     * @param  string  $buf
     */
    protected function characters($buf)
    {
        $this->dataStack[$this->depth] .= $buf;
    }

    /**
     * try to guess the type of a value and set it accordingly
     *
     * @param   string  $value  character data
     * @return  mixed           value with the best matching type
     */
    protected function guessAndSetType($value)
    {
        if (is_array($value) === true) {
            return array_map(array($this, 'guessAndSetType'), $value);
        }
        
        if ('true' === $value) {
            return true;
        }
        
        if ('false' === $value) {
            return false;
        }
        
        if ('NULL' === $value) {
            return null;
        }
        
        if (preg_match('/^[-+]?[0-9]{1,}$/', $value) != false) {
            return intval($value);
        }
        
        if (preg_match('/^[-+]?[0-9]{1,}\.[0-9]{1,}$/', $value) != false) {
            return doubleval($value);
        }
        
        return (string) $value;
    }
}
?><?php
/**
 * Class to read XML files and turn them into simple PHP types.
 *
 * @package     stubbles
 * @subpackage  xml_unserializer
 * @version     $Id: stubXMLUnserializerOption.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Class to read XML files and turn them into simple PHP types.
 *
 * @package     stubbles
 * @subpackage  xml_unserializer
 */
class stubXMLUnserializerOption extends stubBaseObject
{
    /**
     * option: name of the attribute that stores the type
     *
     * Possible values:
     * - any string
     */
    const ATTRIBUTE_KEY       = 'keyAttribute';
    /**
     * option: name of the attribute that stores the type
     *
     * Possible values:
     * - any string
     */
    const ATTRIBUTE_TYPE      = 'typeAttribute';
    /**
     * option: whether to parse attributes
     *
     * Possible values:
     * - true or false
     */
    const ATTRIBUTES_PARSE    = 'parseAttributes';
    /**
     * option: key of the array to store attributes (if any)
     *
     * Possible values:
     * - any string
     * - false (disabled)
     */
    const ATTRIBUTES_ARRAYKEY = 'attributesArray';
    /**
     * option: string to prepend attribute name (if any)
     *
     * Possible values:
     * - any string
     * - false (disabled)
     */
    const ATTRIBUTES_PREPEND  = 'prependAttributes';
    /**
     * option: key to store the content, if XML_UNSERIALIZER_ATTRIBUTES_PARSE is used
     *
     * Possible values:
     * - any string
     */
    const CONTENT_KEY         = 'contentName';
    /**
     * option: map tag names
     *
     * Possible values:
     * - associative array
     */
    const TAG_MAP             = 'tagMap';
    /**
     * option: list of tags that will always be enumerated
     *
     * Possible values:
     * - indexed array
     */
    const FORCE_LIST          = 'forceList';
    /**
     * option: encoding of the XML document
     *
     * Possible values:
     * - UTF-8
     * - ISO-8859-1
     */
    const ENCODING_SOURCE     = 'encoding';
    /**
     * option: list of tags, that will not be used as keys
     *
     * Possible values:
     * - true or false
     */
    const IGNORE_KEYS         = 'ignoreKeys';
    /**
     * option: whether to use type guessing for scalar values
     *
     * Possible values:
     * - true or false
     */
    const GUESS_TYPES         = 'guessTypes';
    /**
     * option: set the whitespace behaviour
     *
     * Possible values:
     * - WHITESPACE_KEEP
     * - WHITESPACE_TRIM
     * - WHITESPACE_NORMALIZE
     */
    const WHITESPACE          = 'whitespace';
    /**
     * Keep all whitespace
     */
    const WHITESPACE_KEEP     = 'keep';
    /**
     * remove whitespace from start and end of the data
     */
    const WHITESPACE_TRIM     = 'trim';
    /**
     * normalize whitespace
     */
    const WHITESPACE_NORMALIZE = 'normalize';
    /**
     * default options for the serialization
     *
     * @var  array<string,mixed>
     */
    protected static $defaultOptions = array(self::ATTRIBUTE_KEY       => '_originalKey',         // get array key/property name from this attribute
                                             self::ATTRIBUTE_TYPE      => '_type',                // get type from this attribute
                                             self::ATTRIBUTES_PARSE    => false,                  // parse the attributes of the tag into an array
                                             self::ATTRIBUTES_ARRAYKEY => false,                  // parse them into sperate array (specify name of array here)
                                             self::ATTRIBUTES_PREPEND  => '',                     // prepend attribute names with this string
                                             self::CONTENT_KEY         => '_content',             // put cdata found in a tag that has been converted to a complex type in this key
                                             self::TAG_MAP             => array(),                // use this to map tagnames
                                             self::FORCE_LIST          => array(),                // these tags will always be an indexed array
                                             self::ENCODING_SOURCE     => null,                   // specify the encoding character of the document to parse
                                             self::WHITESPACE          => self::WHITESPACE_TRIM,  // remove whitespace around data
                                             self::IGNORE_KEYS         => array(),                // list of tags that will automatically be added to the parent, instead of adding a new key
                                             self::GUESS_TYPES         => false                   // Whether to use type guessing
                                       );

    /**
     * returns list of default options
     *
     * @return  array<string,mixed>
     */
    public static function getDefault()
    {
        return self::$defaultOptions;
    }
}
?><?php
/**
 * Class with helper methods for callbacks.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 * @version     $Id: stubXslAbstractCallback.php 2280 2009-07-28 20:28:58Z mikey $
 */
stubClassLoader::load('net::stubbles::xml::stubXMLStreamWriter');
/**
 * Class with helper methods for callbacks.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 */
abstract class stubXslAbstractCallback extends stubBaseObject
{
    /**
     * the stream writer to use
     *
     * @var  stubXMLStreamWriter
     */
    protected $xmlStreamWriter;

    /**
     * constructor
     *
     * @param  stubXMLStreamWriter  $xmlStreamWriter  xml stream writer to create the document with
     * @Inject
     */
    public function __construct(stubXMLStreamWriter $xmlStreamWriter)
    {
        $this->xmlStreamWriter = $xmlStreamWriter;
    }

    /**
     * parses a value and returns the real value
     *
     * When called from within an xsl stylesheet the given param is often an
     * array with one DOMAttr instance in it. This helper method will return the
     * real value.
     *
     * @param   array<DOMAttr>|string  $value
     * @return  string
     */
    protected function parseValue($value)
    {
        if (is_array($value) === true) {
            if (isset($value[0]) === true && $value[0] instanceof DOMAttr) {
                return $value[0]->value;
            }
            
            return '';
        }

        return $value;
    }

    /**
     * creates DOMDocument and dumps stream writer data from memory
     *
     * @return  DOMDocument
     */
    protected function createDomDocument()
    {
        $doc = $this->xmlStreamWriter->asDom();
        $this->xmlStreamWriter->clear();
        return $doc;
    }
}
?><?php
/**
 * Class to register classes and make their methods available as callback in xsl.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 * @version     $Id: stubXslCallback.php 2867 2011-01-10 17:02:33Z mikey $
 */
stubClassLoader::load('net::stubbles::xml::xsl::callback::stubXslCallbackException',
                      'net::stubbles::xml::xsl::callback::stubXslMethodAnnotation'
);
/**
 * Class to register classes and make their methods available as callback in xsl.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 */
class stubXslCallback extends stubBaseObject
{
    /**
     * list of callback instances
     *
     * @var  array<string,stubObject>
     */
    protected $callbacks = array();

    /**
     * returns an instance of this class
     *
     * @return  stubXslCallback
     * @deprecated  is not a singleton any more, will be removed with 1.6.0 or 2.0.0
     */
    public static function getInstance()
    {
        return new self();
    }

    /**
     * register a new instance as callback
     *
     * @param  string      $name      name to register the callback under
     * @param  stubObject  $callback
     */
    public function setCallback($name, stubObject $callback)
    {
        $this->callbacks[$name] = $callback;
    }

    /**
     * removes callback with given name
     *
     * @param  string  $name  name the callback is registered under
     * @deprecated  not required any more, will be removed with 1.6.0 or 2.0.0
     */
    public function removeCallback($name)
    {
        if (isset($this->callbacks[$name]) == true) {
            $this->callbacks[$name] = null;
        }
    }

    /**
     * clears all callbacks
     *
     * @deprecated  not required any more, will be removed with 1.6.0 or 2.0.0
     */
    public function clearCallbacks()
    {
        $this->callbacks = array();
    }

    /**
     * check if a callback exists for the given name
     *
     * @param   string  $name  name the callback is registered under
     * @return  bool
     */
    public function hasCallback($name)
    {
        return isset($this->callbacks[$name]);
    }

    /**
     * returns the callback with the given name
     *
     * @param   string      $name  name the callback is registered under
     * @return  stubObject
     */
    public function getCallback($name)
    {
        if (isset($this->callbacks[$name]) == true) {
            return $this->callbacks[$name];
        }
        
        return null;
    }

    /**
     * returns list of callbacks
     *
     * @return  array<string,stubObject>
     * @since   1.5.0
     */
    public function getCallbacks()
    {
        return $this->callbacks;
    }

    /**
     * invoke a method on a callback class
     *
     * @param   string  $name        name of callback instance to call method on
     * @param   string  $methodName  name of method to call
     * @param   array   $arguments   list of arguments for method to call
     * @return  mixed
     * @throws  stubXslCallbackException
     */
    public function invoke($name, $methodName, array $arguments = array())
    {
        if ($this->hasCallback($name) == false) {
            throw new stubXslCallbackException('A callback with the name ' . $name . ' does not exist.');
        }

        $callback   = $this->getCallback($name);
        $class      = $callback->getClass();
        if ($class->hasMethod($methodName) === false) {
            throw new stubXslCallbackException('Callback with name ' . $name . ' does not have a method named ' . $methodName);
        }
        
        $method = $class->getMethod($methodName);
        if ($method->hasAnnotation('XslMethod') === false) {
            throw new stubXslCallbackException('The callback\'s ' . $name . ' ' . $callback->getClassName() . '::' . $methodName . '() is not annotated as XslMethod.');
        }
        
        if ($method->isPublic() === false) {
            throw new stubXslCallbackException('The callback\'s ' . $name . ' ' . $callback->getClassName() . '::' . $methodName . '() is not a public method.');
        }
        
        if ($method->isStatic() === true) {
            return $method->invokeArgs(null, $arguments);
        }
        
        return $method->invokeArgs($callback, $arguments);
    }
}
?><?php
/**
 * Exception to be thrown when a xsl callback can not be called.
 * 
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 * @version     $Id: stubXslCallbackException.php 2098 2009-02-12 22:17:12Z mikey $
 */
/**
 * Exception to be thrown when a xsl callback can not be called.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 */
class stubXslCallbackException extends stubException
{

}
?><?php
/**
 * Class to transfer the query string into an xml document.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 * @version     $Id: stubXslDateFormatterCallback.php 2098 2009-02-12 22:17:12Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::types::stubDate',
                      'net::stubbles::xml::stubXMLStreamWriter',
                      'net::stubbles::xml::xsl::callback::stubXslAbstractCallback'
);
/**
 * Class to transfer the query string into an xml document.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 */
class stubXslDateFormatterCallback extends stubXslAbstractCallback
{
    /**
     * returns a formatted date
     *
     * If no timestamp is given the current time will be used.
     * 
     * @param   array<DOMAttr>|string  $format     format for the date string to be returned
     * @param   array<DOMAttr>|string  $timestamp  optional  timestamp to format
     * @return  DOMDocument
     * @XslMethod
     */
    public function formatDate($format, $timestamp = null)
    {
        $format    = $this->parseValue($format);
        $timestamp = $this->parseValue($timestamp);
        if (null == $timestamp) {
            $timestamp = time();
        }
        
        $date = new stubDate($timestamp);
        $this->xmlStreamWriter->writeElement('date',
                                             array('timestamp' => $timestamp),
                                             $date->format($format)
        );
        return $this->createDomDocument();
    }

    /**
     * returns a formatted date
     *
     * If no timestamp is given the current time will be used.
     * 
     * @param   array<DOMAttr>|string  $format     format for the date string to be returned
     * @param   array<DOMAttr>|string  $timestamp  optional  timestamp to format
     * @return  DOMDocument
     * @XslMethod
     */
    public function formatLocaleDate($format, $timestamp = null)
    {
        $format    = $this->parseValue($format);
        $timestamp = $this->parseValue($timestamp);
        if (null == $timestamp) {
            $timestamp = time();
        }
        
        $this->xmlStreamWriter->writeElement('date',
                                             array('timestamp' => $timestamp),
                                             strftime($format, $timestamp)
        );
        return $this->createDomDocument();
    }
}
?><?php
/**
 * Class to transfer image data into an xml document.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 * @version     $Id: stubXslImageDimensionsCallback.php 2867 2011-01-10 17:02:33Z mikey $
 */
stubClassLoader::load('net::stubbles::xml::xsl::callback::stubXslCallbackException',
                      'net::stubbles::xml::xsl::callback::stubXslAbstractCallback'
);
/**
 * Class to transfer image data into an xml document.
 *
 * Lookup for image is done with the following steps:
 * 1. Find image in document root of current project. If not exists, try next.
 * 2. Find image in document root of common project. If not exists throw exception.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 */
class stubXslImageDimensionsCallback extends stubXslAbstractCallback
{
    /**
     * a list of file types where the key corresponds to the IMAGETYPE constants of PHP
     *
     * @var  array<int,string>
     */
    protected $types              = array('unknown', 'GIF', 'JPG', 'PNG', 'SWF', 'PSD', 'BMP',
                                          'TIFF(intel byte order)', 'TIFF(motorola byte order)',
                                          'JPC', 'JP2', 'JPX', 'JB2', 'SWC', 'IFF', 'WBMP', 'XBM'
                                    );
    /**
     * path to images in project docroot
     *
     * @var  string
     */
    protected $projectDocrootPath = null;
    /**
     * path to images in common docroot
     *
     * @var  string
     */
    protected $commonDocrootPath  = null;

    /**
     * constructor
     *
     * @param  stubXMLStreamWriter  $xmlStreamWriter     xml stream writer to create the document with
     * @param  string               $projectDocrootPath  path to docroot of current project
     * @param  string               $commonDocrootPath   path to docroot of common project
     * @since  1.5.0
     * @Inject
     * @Named{projectDocrootPath}('net.stubbles.docroot.path')
     * @Named{commonDocrootPath}('net.stubbles.docroot.path.common')
     */
    public function __construct(stubXMLStreamWriter $xmlStreamWriter, $projectDocrootPath, $commonDocrootPath)
    {
        parent::__construct($xmlStreamWriter);
        $this->projectDocrootPath = $projectDocrootPath;
        $this->commonDocrootPath  = $commonDocrootPath;
    }

    /**
     * takes a dom attribute and return the image informations for the first one
     *
     * @param   array<DOMAttr>|string  $imageFile
     * @return  DOMDocument
     * @throws  stubXslCallbackException
     * @XslMethod
     */
    public function getImageDimensions($imageSrc)
    {
        $imageFileName = $this->findImage($this->parseValue($imageSrc));
        $image         = @getimagesize($imageFileName);
        if (false === $image) {
            throw new stubXslCallbackException('Image ' . $imageFileName . ' seems not to be an image, can not retrieve dimension data.');
        }

        $this->xmlStreamWriter->writeStartElement('image');
        $this->xmlStreamWriter->writeElement('width', array(), $image[0]);
        $this->xmlStreamWriter->writeElement('height', array(), $image[1]);
        $this->xmlStreamWriter->writeElement('type', array(), $this->getType($image[2]));
        $this->xmlStreamWriter->writeElement('mime', array(), $image['mime']);
        $this->xmlStreamWriter->writeEndElement();
        $doc = $this->xmlStreamWriter->asDom();
        $this->xmlStreamWriter->clear();
        return $doc;
    }

    /**
     * finds image and returns complete path to image
     *
     * @param   string  $imageTag
     * @return  string
     * @throws  stubXslCallbackException
     */
    protected function findImage($imageSrc)
    {
        if (file_exists($this->projectDocrootPath . '/' . $imageSrc) === false) {
            if (file_exists($this->commonDocrootPath . '/' . $imageSrc) === false) {
                throw new stubXslCallbackException('Image ' . $imageSrc . ' does not exist.');
            }

            return $this->commonDocrootPath . '/' . $imageSrc;
        }

        return $this->projectDocrootPath . '/' . $imageSrc;
    }

    /**
     * returns the image type as string
     *
     * @param   int     $type
     * @return  string
     */
    protected function getType($type)
    {
        if (isset($this->types[$type]) == true) {
            return $this->types[$type];
        }

        return $this->types[0];
    }
}
?><?php
/**
 * Annotation to mark class methods accessable as xsl callback.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 * @version     $Id: stubXslMethodAnnotation.php 2098 2009-02-12 22:17:12Z mikey $
 */
stubClassLoader::load('net::stubbles::reflection::annotations::stubAnnotation',
                      'net::stubbles::reflection::annotations::stubAbstractAnnotation'
);
/**
 * Annotation to mark class methods accessable as xsl callback.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 */
class stubXslMethodAnnotation extends stubAbstractAnnotation implements stubAnnotation
{
    /**
     * Returns the target of the annotation as bitmap.
     *
     * @return  int
     */
    public function getAnnotationTarget()
    {
        return stubAnnotation::TARGET_METHOD;
    }
}
?><?php
/**
 * XSL callback to handle missing include parts.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 * @version     $Id: stubXslMissingIncludeCallback.php 2279 2009-07-28 20:28:10Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::stubMode',
                      'net::stubbles::util::log::stubLogger',
                      'net::stubbles::xml::xsl::stubXSLProcessorException',
                      'net::stubbles::xml::xsl::callback::stubXslAbstractCallback'
);
/**
 * XSL callback to handle missing include parts.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 */
class stubXslMissingIncludeCallback extends stubXslAbstractCallback
{
    /**
     * runtime mode
     *
     * @var  stubMode
     */
    protected $mode;
    /**
     * logger instance
     *
     * @var  stubLogger
     */
    protected $logger;

    /**
     * sets runtime mode
     *
     * @param  stubMode  $mode
     * @Inject(optional=true)
     */
    public function setMode(stubMode $mode)
    {
        $this->mode = $mode;
    }

    /**
     * sets runtime mode
     *
     * @param  stubLogger  $logger
     * @Inject(optional=true)
     * @Named(stubLogger::LEVEL_ERROR)
     */
    public function setLogger(stubLogger $logger)
    {
        $this->logger = $logger;
    }

    /**
     * records missing include part or throws an exception
     *
     * @param   array<DOMAttr>|string  $includingFile  file in which the include happens
     * @param   array<DOMAttr>|string  $includingPart  part which tried the include
     * @param   array<DOMAttr>|string  $includedPart   missing include part
     * @param   array<DOMAttr>|string  $includedFile   file in which the include part should be found
     * @param   array<DOMAttr>|string  $project        project in which file with missing include part should be found
     * @return  DOMDocument
     * @throws  stubXSLProcessorException
     * @XslMethod
     */
    public function recordMissingInclude($includingFile, $includingPart, $includedPart, $includedFile, $project)
    {
        $includingFile = $this->parseValue($includingFile);
        $includingPart = $this->parseValue($includingPart);
        $includedPart  = $this->parseValue($includedPart);
        $includedFile  = $this->parseValue($includedFile);
        $project       = $this->parseValue($project);
        if (null !== $this->mode && $this->mode->name() !== 'PROD') {
            $msg = 'The part "' . $includingPart . '" in file "' . $includingFile . '" can not find the include "' . $includedPart . '"';
            if (empty($includedFile) === false) {
                $msg .= ' in file "' . $includedFile . '"';
                if (empty($project) === false) {
                    $msg .= ' from project "' . $project . '"';
                }
            }
            
            throw new stubXSLProcessorException($msg);
        }
        
        $this->xmlStreamWriter->writeElement('missing-include');
        if (null !== $this->logger) {
            $this->logger->createLogEntry('missing-includes')
                         ->addData($includingFile)
                         ->addData($includingPart)
                         ->addData($includedPart)
                         ->addData($includedFile)
                         ->addData($project)
                         ->log();
        }
        
        return $this->createDomDocument();
    }
}
?><?php
/**
 * Class to transfer the query string into an xml document.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 * @version     $Id: stubXslRequestParamsCallback.php 2626 2010-08-12 17:05:15Z mikey $
 */
stubClassLoader::load('net::stubbles::ipo::request::stubRequest',
                      'net::stubbles::xml::xsl::callback::stubXslAbstractCallback'
);
/**
 * Class to transfer the query string into an xml document.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_callback
 */
class stubXslRequestParamsCallback extends stubXslAbstractCallback
{
    /**
     * request instance
     *
     * @var  stubRequest
     */
    protected $request;

    /**
     * sets the request instance to be used
     *
     * @param  stubRequest  $request  request instance
     * @Inject
     */
    public function setRequest(stubRequest $request)
    {
        $this->request = $request;
    }

    /**
     * returns the query string within a dom document
     * 
     * @return  DOMDocument
     * @XslMethod
     */
    public function getQueryString()
    {
        $queryString = $this->request->readHeader('QUERY_STRING')->unsecure();
        $this->xmlStreamWriter->writeElement('requestParams',
                                             array(),
                                             $this->filterQueryString($queryString)
        );
        
        return $this->createDomDocument();
    }

    /**
     * filters processor and page out of query string
     *
     * @param   string  $queryString
     * @return  string
     */
    protected function filterQueryString($queryString)
    {
        $return = $queryString;
        $data   = array();
        parse_str($queryString, $data);
        foreach ($data as $key => $value) {
            if ('processor' === $key || 'page' === $key) {
                $return = str_replace($key . '=' . $value, '', $return);
            }
        }
        
        return str_replace('&=', '', str_replace('&&', '&', $return));
    }
}
?><?php
/**
 * Class to transform xml via xsl.
 *
 * @package     stubbles
 * @subpackage  xml_xsl
 * @version     $Id: stubXSLProcessor.php 2867 2011-01-10 17:02:33Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::stubClonable',
                      'net::stubbles::lang::exceptions::stubIOException',
                      'net::stubbles::xml::xsl::stubXSLProcessorException',
                      'net::stubbles::xml::xsl::callback::stubXslCallback',
                      'net::stubbles::xml::xsl::callback::stubXslCallbackException'
);
/**
 * Class to transform xml via xsl.
 *
 * @package     stubbles
 * @subpackage  xml_xsl
 * @ProvidedBy(net::stubbles::xml::xsl::stubXslProcessorProvider.class)
 */
class stubXSLProcessor extends stubBaseObject implements stubClonable
{
    /**
     * the document to transform
     *
     * @var  DOMDocument
     */
    protected $document;
    /**
     * the real processor used for the transformation
     *
     * @var  XSLTProcessor
     */
    protected $xsltProcessor;
    /**
     * list of parameters that were set
     *
     * @var  array<string,array<string,string>>
     */
    protected $parameters    = array();
    /**
     * list of callbacks which should be available while processing the stylesheet
     *
     * @var  stubXslCallback
     */
    protected $xslCallback;
    /**
     * workaround for limitation of XSLTProcessor::registerPHPFunctions()
     *
     * @var  stubXslCallback
     */
    private static $_callback;
    /**
     * list of used stylesheets
     *
     * @var  array<DOMDocument>
     */
    protected $stylesheets   = array();

    /**
     * constructor
     *
     * @throws  stubRuntimeException
     */
    public function __construct()
    {
        if (extension_loaded('xsl') === false) {
            throw new stubRuntimeException('Can not create ' . __CLASS__ . ', requires PHP-extension "xsl".');
        }

        $this->xslCallback = new stubXslCallback();
        $this->createXsltProcessor();
    }

    /**
     * creates the XSLTProcessor instance
     */
    protected function createXsltProcessor()
    {
        $this->xsltProcessor = new XSLTProcessor();
    }

    /**
     * sets the document to transform
     *
     * @param   DOMDocument       $doc
     * @return  stubXSLProcessor
     */
    public function onDocument(DOMDocument $doc)
    {
        $this->document = $doc;
        return $this;
    }

    /**
     * sets the document to transform
     *
     * @param   string            $xmlFile   name of the xml file containing the document to transform
     * @param   bool              $xinclude  optional  whether to resolve xincludes or not, defaults to true
     * @return  stubXSLProcessor
     * @throws  stubIOException
     */
    public function onXmlFile($xmlFile, $xinclude = true)
    {
        $doc = new DOMDocument();
        if (false === $doc->load($xmlFile)) {
            throw new stubIOException('Can not read xml document file ' . $xmlFile);
        }
        
        if (true === $xinclude) {
            $doc->xinclude();
        }
        
        return $this->onDocument($doc);
    }

    /**
     * add a stylesheet to use
     *
     * @param   DOMDocument       $stylesheet
     * @return  stubXSLProcessor
     */
    public function applyStylesheet(DOMDocument $stylesheet)
    {
        $this->stylesheets[] = $stylesheet;
        $this->xsltProcessor->importStylesheet($stylesheet);
        return $this;
    }

    /**
     * add a stylesheet to use from a file
     *
     * @param   string            $stylesheetFile
     * @return  stubXSLProcessor
     * @throws  stubIOException
     */
    public function applyStylesheetFromFile($stylesheetFile)
    {
        $stylesheet = new DOMDocument();
        if (false === $stylesheet->load($stylesheetFile)) {
            throw new stubIOException('Can not read stylesheet file ' . $stylesheetFile);
        }
        
        return $this->applyStylesheet($stylesheet);
    }

    /**
     * returns the list of used stylesheets
     *
     * @return  array<DOMDocument>
     */
    public function getStylesheets()
    {
        return $this->stylesheets;
    }

    /**
     * register an instance as callback
     *
     * @param   string            $name      name to register the callback under
     * @param   stubObject        $instance  the instance to register as callback
     * @return  stubXSLProcessor
     */
    public function usingCallback($name, stubObject $instance)
    {
        $this->xslCallback->setCallback($name, $instance);
        return $this;
    }

    /**
     * returns list of callbacks
     *
     * @return  array<string,stubObject>
     */
    public function getCallbacks()
    {
        return $this->xslCallback->getCallbacks();
    }

    /**
     * register all callback instances
     */
    protected function registerCallbacks()
    {
        // workaround for limitation of XSLTProcessor::registerPHPFunctions()
        // callback instance in static variable to have data available
        // when php:function callback calls the static method as
        // XSLTProcessor::registerPHPFunctions() does not support non-static
        // methods nor anonymous functions directly
        self::$_callback = $this->xslCallback;
        $this->xsltProcessor->registerPHPFunctions(get_class($this) . '::invokeCallback');
    }

    /**
     * invoke a method on a callback class
     *
     * @return  mixed
     * @throws  stubXslCallbackException
     * @since   1.5.0
     */
    public static function invokeCallback()
    {
        $arguments = func_get_args();
        if (count($arguments) < 2) {
            throw new stubXslCallbackException('To less arguments: need at last two arguments to use callbacks.');
        }

        $name       = array_shift($arguments);
        $methodName = array_shift($arguments);
        return self::$_callback->invoke($name, $methodName, $arguments);
    }

    /**
     * sets a parameter for a namespace
     *
     * @param   string            $nameSpace   the namespace where the parameter is in
     * @param   string            $paramName   the name of the parameter to set
     * @param   string            $paramValue  the value to set the parameter to
     * @return  stubXSLProcessor
     * @throws  stubXSLProcessorException
     */
    public function withParameter($nameSpace, $paramName, $paramValue)
    {
        if (false === $this->xsltProcessor->setParameter($nameSpace, $paramName, $paramValue)) {
            throw new stubXSLProcessorException('Could not set parameter ' . $nameSpace . ':' . $paramName . ' with value ' . $paramValue);
        }
        
        if (isset($this->parameters[$nameSpace]) === false) {
            $this->parameters[$nameSpace] = array();
        }
        
        $this->parameters[$nameSpace][$paramName] = $paramValue;
        return $this;
    }

    /**
     * checks if a parameter for a namespace exists
     *
     * @param   string  $nameSpace   the namespace where the parameter is in
     * @param   string  $paramName   the name of the parameter to check
     * @return  bool
     */
    public function hasParameter($nameSpace, $paramName)
    {
        return isset($this->parameters[$nameSpace][$paramName]);
    }

    /**
     * returns a parameter of the given namespace
     *
     * @param   string  $nameSpace   the namespace where the parameter is in
     * @param   string  $paramName   the name of the parameter to check
     * @return  string
     */
    public function getParameter($nameSpace, $paramName)
    {
        if (isset($this->parameters[$nameSpace][$paramName]) === true) {
            return $this->parameters[$nameSpace][$paramName];
        }
        
        return null;
    }

    /**
     * removes a parameter
     *
     * @param   string  $nameSpace  the namespace where the parameter is in
     * @param   string  $paramName  the name of the parameter to remove
     * @return  bool    true if successful, else false
     */
    public function removeParameter($nameSpace, $paramName)
    {
        if ($this->hasParameter($nameSpace, $paramName) === false) {
            return true;
        }
        
        $result = $this->xsltProcessor->removeParameter($nameSpace, $paramName);
        if (false === $result) {
            return false;
        }
        
        unset($this->parameters[$nameSpace][$paramName]);
        if (count($this->parameters[$nameSpace]) === 0) {
            unset($this->parameters[$nameSpace]);
        }
        
        return true;
    }

    /**
     * set a list of parameters for the given namespace
     *
     * @param   string            $nameSpace  the namespace where the parameters are in
     * @param   array             $params     the list of parameters to set: name => value
     * @return  stubXSLProcessor
     * @throws  stubXSLProcessorException
     */
    public function withParameters($nameSpace, array $params)
    {
        if (false === $this->xsltProcessor->setParameter($nameSpace, $params)) {
            throw new stubXSLProcessorException('Could not set parameters in ' . $nameSpace);
        }
        
        if (isset($this->parameters[$nameSpace]) === false) {
            $this->parameters[$nameSpace] = array();
        }
        
        $this->parameters[$nameSpace] = array_merge($this->parameters[$nameSpace], $params);
        return $this;
    }

    /**
     * returns all parameters for the given namespace3
     *
     * @param   string  $nameSpace
     * @return  array
     */
    public function getParameters($nameSpace)
    {
        if (isset($this->parameters[$nameSpace]) === true) {
            return $this->parameters[$nameSpace];
        }
        
        return array();
    }

    /**
     * returns a list of all used namespaces
     *
     * @return  array
     */
    public function getParameterNamespaces()
    {
        return array_keys($this->parameters);
    }

    /**
     * removes a list of parameters for the given namespace
     *
     * @param   string              $nameSpace  the namespace where the parameters are in
     * @param   array               $params     the list of parameters to remove
     * @return  array<string,bool>  return values of removing the parameters
     */
    public function removeParameters($nameSpace, array $params)
    {
        $result = array();
        foreach ($params as $paramName) {
            $result[$paramName] = $this->removeParameter($nameSpace, $paramName);
        }
        
        return $result;
    }

    /**
     * does some corrections after cloning
     */
    public function __clone()
    {
        $this->createXsltProcessor();
        foreach ($this->parameters as $nameSpace => $params) {
            $this->xsltProcessor->setParameter($nameSpace, $params);
        }
        
        foreach ($this->stylesheets as $stylesheet) {
            $this->xsltProcessor->importStylesheet($stylesheet);
        }
        
        $this->document = null;
    }

    /**
     * transoforms the document into another DOMDocument
     * 
     * @return  DOMDocument
     * @throws  stubXSLProcessorException
     */
    public function toDoc()
    {
        $this->registerCallbacks();
        $result = $this->xsltProcessor->transformToDoc($this->document);
        if (false === $result) {
            throw new stubXSLProcessorException($this->createMessage());
        }
        
        return $result;
    }

    /**
     * transforms the document and saves it to the given uri, returns the
     * amount of bytes written
     *
     * @param   string  $uri
     * @return  int
     * @throws  stubXSLProcessorException
     */
    public function toUri($uri)
    {
        $this->registerCallbacks();
        $bytes = $this->xsltProcessor->transformToURI($this->document, $uri);
        if (false === $bytes) {
            throw new stubXSLProcessorException($this->createMessage());
        }
        
        return $bytes;
    }

    /**
     * transforms the document and returns the result as string
     *
     * @return  string
     * @throws  stubXSLProcessorException
     */
    public function toXml()
    {
        $this->registerCallbacks();
        $result = $this->xsltProcessor->transformToXML($this->document);
        if (false === $result) {
            throw new stubXSLProcessorException($this->createMessage());
        }
        
        return $result;
    }

    /**
     * creates a message frim the last libxml error
     *
     * @return  string
     */
    protected function createMessage()
    {
        $message = '';
        foreach (libxml_get_errors() as $error) {
            $message .= trim($error->message) . (($error->file) ? (' in file ' . $error->file) : ('')) . ' on line ' . $error->line . ' in column ' . $error->column . "\n";
        }

        libxml_clear_errors();
        if (strlen($message) === 0) {
            return 'Transformation failed: unknown error.';
        }

        return $message;
    }
}
?><?php
/**
 * Exception to be thrown when a xsl processor failed.
 * 
 * @package     stubbles
 * @subpackage  xml_xsl
 * @version     $Id: stubXSLProcessorException.php 2857 2011-01-10 13:43:39Z mikey $
 */
/**
 * Exception to be thrown when a xsl processor failed.
 *
 * @package     stubbles
 * @subpackage  xml_xsl
 */
class stubXSLProcessorException extends stubException
{

}
?><?php
/**
 * Class to create instances of the XSL processor.
 *
 * @package     stubbles
 * @subpackage  xml_xsl
 * @version     $Id: stubXSLProcessorFactory.php 2867 2011-01-10 17:02:33Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubBinderRegistry',
                      'net::stubbles::lang::stubPathRegistry',
                      'net::stubbles::lang::exceptions::stubRuntimeException',
                      'net::stubbles::xml::xsl::stubXSLProcessor'
);
/**
 * Class to create instances of the XSL processor.
 *
 * @package     stubbles
 * @subpackage  xml_xsl
 * @deprecated  use net::stubbles::xml::xsl::stubXslProcessorProvider instead, will be removed with 1.6.0 or 2.0.0
 */
class stubXSLProcessorFactory extends stubBaseObject
{
    /**
     * creates an XSL processor
     *
     * @return  stubXSLProcessor
     */
    public static function create()
    {
        return new stubXSLProcessor();
    }

    /**
     * creates an XSL processor configured with callbacks
     *
     * If no config file is given the file $PROJECT/config/xsl-callbacks.ini
     * will be used.
     *
     * @param   string            $callbackConfigFile  optional  file with configured callbacks
     * @return  stubXSLProcessor
     * @throws  stubRuntimeException
     */
    public static function createWithCallbacks($callbackConfigFile = null)
    {
        if (null === $callbackConfigFile) {
            $callbackConfigFile = stubPathRegistry::getConfigPath() . '/xsl-callbacks.ini';
        }
        
        if (file_exists($callbackConfigFile) === false) {
            throw new stubRuntimeException('Configuration file ' . $callbackConfigFile . ' for XSL callback configuration is missing.');
        }
        
        $binder = stubBinderRegistry::get();
        $binder->bindConstant()->named('imagePath')->to(getcwd());
        $injector     = $binder->getInjector();
        $xslProcessor = new stubXSLProcessor();
        foreach (parse_ini_file($callbackConfigFile) as $callbackName => $callbackClass) {
            $xslProcessor->usingCallback($callbackName, $injector->getInstance($callbackClass));
        }
        
        return $xslProcessor;
    }
}
?><?php
/* 
 * Injection provider for XSL processor instances.
 *
 * @package     stubbles
 * @subpackage  xml_xsl
 * @version     $Id: stubXslProcessorProvider.php 2867 2011-01-10 17:02:33Z mikey $
 */
stubClassLoader::load('net::stubbles::ioc::stubInjectionProvider',
                      'net::stubbles::ioc::stubInjector',
                      'net::stubbles::xml::xsl::stubXSLProcessor'
);
/**
 * Injection provider for XSL processor instances.
 *
 * @package     stubbles
 * @subpackage  xml_xsl
 * @since       1.5.0
 */
class stubXslProcessorProvider extends stubBaseObject implements stubInjectionProvider
{
    /**
     * injector instance to create instances of other classes
     *
     * @var  stubInjector
     */
    protected $injector;
    /**
     * path to config files
     *
     * @var  string
     */
    protected $configPath;

    /**
     * constructor
     *
     * @param  stubInjector  $injector
     * @param  string        $configPath
     * @Inject
     * @Named{configPath}('net.stubbles.config.path')
     */
    public function  __construct(stubInjector $injector, $configPath)
    {
        $this->injector   = $injector;
        $this->configPath = $configPath;
    }

    /**
     * returns the value to provide
     *
     * @param   string  $name  optional
     * @return  mixed
     */
    public function get($name = null)
    {
        $xslProcessor = new stubXSLProcessor();
        if ($this->shouldHaveCallbacks($name) === true && $this->callbackConfigurationExists() === true) {
            $callbackList = @parse_ini_file($this->configPath . '/xsl-callbacks.ini');
            if (false === $callbackList) {
                throw new stubConfigurationException('XSL callback in ' . $this->configPath . '/xsl-callbacks.ini contains errors and can not be parsed.');
            }

            foreach ($callbackList as $callbackName => $callbackClass) {
                $xslProcessor->usingCallback($callbackName, $this->injector->getInstance($callbackClass));
            }
        }

        return $xslProcessor;
    }

    /**
     * checks whether the xsl processor instance to create should have callbacks
     *
     * @param   string  $name
     * @return  bool
     */
    protected function shouldHaveCallbacks($name)
    {
        return ('net.stubbles.xml.xsl.callbacks.disabled' !== $name);
    }

    /**
     * checks whether callback configuration file exists
     *
     * @return  bool
     */
    protected function callbackConfigurationExists()
    {
        return file_exists($this->configPath . '/xsl-callbacks.ini');
    }
}
?><?php
/**
 * Stream wrapper to enable inclusion of external xsl stylesheets into Stubbles' master.xsl.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_util
 * @version     $Id: stubXslImportStreamWrapper.php 2817 2010-12-16 19:37:14Z mikey $
 */
/**
 * Stream wrapper to enable inclusion of external xsl stylesheets into Stubbles' master.xsl.
 *
 * @package     stubbles
 * @subpackage  xml_xsl_util
 */
class stubXslImportStreamWrapper extends stubBaseObject
{
    /**
     * base xsl to return
     *
     * @var  string
     */
    protected static $xsl;
    /**
     * list of default imports
     *
     * @var  array<string>
     */
    protected static $defaultImports = array('stubbles.php?xsl/copy.xsl',
                                             'stubbles.php?xsl/stub.xsl',
                                             'stubbles.php?xsl/ingrid.xsl',
                                             'stubbles.php?xsl/variant.xsl'
                                       );
    /**
     * current reading offset
     *
     * @var  int
     */
    protected $offset     = 0;

    /**
     * initializes the stream wrapper
     *
     * @param  string  $configPath   path to xsl-imports.ini file
     * @param  string  $cachePath    path to store cached xsl
     * @param  bool    $enableCache  whether to cache or not
     * @param  string  $configFile   optional  config file to be used
     * @todo   think about using stubProperties instead of doing raw ini file work
     */
    public static function init($configPath, $cachePath, $enableCache, $configFile = 'xsl-imports.ini')
    {
        static $registered;
        if (true !== $registered) {
            stream_wrapper_register('xslimport', __CLASS__);
            $registered = true;
        }
        
        if (true === $enableCache && file_exists($cachePath . DIRECTORY_SEPARATOR . 'xsl-imports.cache') === true) {
            self::$xsl = file_get_contents($cachePath . '/xsl-imports.cache');
            return;
        }
        
        self::$xsl = '<xsl:stylesheet version="1.1" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">' . "\n";
        $source = 'star://' . urlencode(stubBootstrap::getRootPath() . DIRECTORY_SEPARATOR . 'lib' . DIRECTORY_SEPARATOR);
        foreach (self::$defaultImports as $import) {
            self::$xsl .= '  <xsl:import href="' . $source . $import . "\"/>\n";
        }
        
        if (file_exists($configPath . DIRECTORY_SEPARATOR . $configFile) === true) {
            $imports = @parse_ini_file($configPath . DIRECTORY_SEPARATOR . $configFile, true);
            if (false !== $imports) {
                foreach ($imports as $source => $sourceImports) {
                    if ('lib' === $source) {
                        $source = 'star://' . urlencode(stubBootstrap::getRootPath() . DIRECTORY_SEPARATOR . 'lib' . DIRECTORY_SEPARATOR);
                    } elseif ('resources' === $source) {
                        $source = 'file://' . urlencode(stubBootstrap::getSourcePath() . DIRECTORY_SEPARATOR . 'resources' . DIRECTORY_SEPARATOR);
                    }
        
                    foreach ($sourceImports as $import) {
                        if (in_array($import, self::$defaultImports) === false) {
                            self::$xsl .= '  <xsl:import href="' . $source . $import . "\"/>\n";
                        }
                    }
                }
            }
        }
        
        self::$xsl .= '</xsl:stylesheet>';
        if (true === $enableCache) {
            file_put_contents($cachePath . DIRECTORY_SEPARATOR . 'xsl-imports.cache', self::$xsl);
        }
    }

    /**
     * open the stream
     *
     * @param   string  $path         the path to open
     * @param   string  $mode         mode for opening
     * @param   string  $options      options for opening
     * @param   string  $opened_path  full path that was actually opened
     * @return  bool
     */
    public function stream_open($path, $mode, $options, $opened_path)
    {
        return (null !== self::$xsl);
    }

    /**
     * closes the stream
     */
    public function stream_close()
    {
        // nothing to do here
    }

    /**
     * read the stream up to $count bytes
     *
     * @param   int     $count  amount of bytes to read
     * @return  string
     */
    public function stream_read($count)
    {
        $substring     = substr(self::$xsl, $this->offset, $count);
        $this->offset += $count;
        return $substring;
    }

    /**
     * checks whether stream is at end of file
     *
     * @return  bool
     */
    public function stream_eof()
    {
        return ($this->offset >= strlen(self::$xsl));
    }

    /**
     * returns status of stream
     *
     * @return  array
     */
    public function stream_stat()
    {
        return array('size' => strlen(self::$xsl));
    }

    /**
     * returns status of url
     *
     * @param   string  $path  path of url to return status for
     * @return  array
     */
    public function url_stat($path)
    {
        return array('size' => strlen(self::$xsl));
    }
}
?><?php
/**
 * Class to wrap xincludes transparently as stream wrapper.
 *
 * @package     stubbles
 * @subpackage  xml_xsl
 * @version     $Id: stubXslXIncludeStreamWrapper.php 2863 2011-01-10 16:35:36Z mikey $
 */
stubClassLoader::load('net::stubbles::lang::exceptions::stubFileNotFoundException',
                      'net::stubbles::lang::exceptions::stubIOException',
                      'net::stubbles::xml::stubXMLException',
                      'net::stubbles::xml::xsl::stubXSLProcessor'
);
/**
 * Class to wrap xincludes transparently as stream wrapper.
 *
 * @package     stubbles
 * @subpackage  xml_xsl
 */
class stubXslXIncludeStreamWrapper extends stubBaseObject
{
    /**
     * the xsl processor to use for the transformation
     *
     * @var  stubXSLProcessor
     */
    protected static $xslProcessor;
    /**
     * path to cache
     *
     * @var  string
     */
    protected static $cachePath;
    /**
     * mode for cache path if it needs to be created
     *
     * @var  int
     */
    protected static $fileMode;
    /**
     * switch whether caching is enabled or not
     *
     * @var  bool
     */
    protected static $enableCaching    = true;
    /**
     * list of include pathes where files may reside
     *
     * @var  array<string>
     */
    protected static $includePathes    = array();
    /**
     * list of already transformed files
     *
     * @var  array<string>
     */
    protected static $transformedFiles = array();
    /**
     * name of current route
     *
     * @var  string
     */
    protected static $routeName;
    /**
     * current xml file
     *
     * @var  string
     */
    protected $fileName;
    /**
     * file name of the cached file
     *
     * @var  string
     */
    protected $cachedFileName;
    /**
     * project from which the file will be taked
     *
     * @var  string
     */
    protected $project;
    /**
     * the part that will be included
     *
     * @var  string
     */
    protected $part;
    /**
     * current file pointer
     *
     * @var  resource
     */
    protected $fp;

    /**
     * registers the class as stream wrapper for the sml protocol
     *
     * Please note that a cache path is required independent of whether caching
     * is enabled or not. This is due to the fact that the transformed file
     * needs to be saved to disc before its xincludes are resolved because
     * the xincluded files may refer back to the current file with other
     * xincludes.
     *
     * @param   stubXSLProcessor  $xslProcessor
     * @param   string            $defaultIncludePath  default path where to find files to xinclude
     * @param   string            $cachePath           where to cache included files
     * @param   int               $fileMode            mode for cache path if it needs to be created
     * @param   bool              $enableCaching       whether caching is enabled or not
     * @param   string            $routeName           name of route to resolve xincludes for
     * @throws  stubIOException
     */
    public static function register(stubXSLProcessor $xslProcessor, $defaultIncludePath, $cachePath, $fileMode, $enableCaching, $routeName)
    {
        static $registered;
        self::$xslProcessor             = $xslProcessor;
        self::$includePathes['default'] = $defaultIncludePath;
        self::$cachePath                = $cachePath;
        self::$fileMode                 = $fileMode;
        self::$enableCaching            = $enableCaching;
        self::$routeName                = $routeName;
        if (file_exists($cachePath) === false) {
            if (@mkdir($cachePath, self::$fileMode, true) === false) {
                throw new stubIOException('Can not create cache directory ' . $cachePath);
            }
        }
        
        if (true === $registered) {
            return;
        }

        if (stream_wrapper_register('xinc', __CLASS__) === false) {
            throw new stubIOException('A handler has already been registered for the xinc protocol.');
        }

        $registered = true;
    }

    /**
     * checks whether cache is enabled or not
     *
     * @return  bool
     */
    public static function isCacheEnabled()
    {
        return self::$enableCaching;
    }

    /**
     * adds an include path
     *
     * @param  string  $key
     * @param  string  $includePath
     */
    public static function addIncludePath($key, $includePath)
    {
        self::$includePathes[$key] = $includePath;
    }

    /**
     * returns a list of include pathes
     *
     * @return  array<string,string>
     */
    public static function getIncludePathes()
    {
        return self::$includePathes;
    }

    /**
     * open the stream
     *
     * @param   string  $path         the path to open
     * @param   string  $mode         mode for opening
     * @param   string  $options      options for opening
     * @param   string  $opened_path  full path that was actually opened
     * @return  bool
     */
    public function stream_open($path, $mode, $options, $opened_path)
    {
        $this->parsePath($path);
        if (file_exists($this->cachedFileName) === false || $this->needsRefresh() === true) {
            $this->processFile();
        }

        $fp = fopen($this->cachedFileName, 'rb');
        if (false === $fp) {
            return false;
        }

        $this->fp = $fp;
        return true;
    }

    /**
     * check whether the cached file needs to be refreshed
     *
     * @return  bool
     */
    protected function needsRefresh()
    {
        if (in_array($this->cachedFileName, self::$transformedFiles) === true) {
            return false;
        }
        
        if (false === self::$enableCaching) {
            return true;
        }
        
        if (filemtime($this->cachedFileName) > filemtime($this->fileName))  {
            return false;
        }

        return true;
    }

    /**
     * processes the file and creates a cached version of it
     *
     * @throws  stubIOException
     */
    protected function processFile()
    {
        $previousErrorHandling = libxml_use_internal_errors(true);
        $xslProcessor          = clone self::$xslProcessor;
        $xslProcessor->withParameter('', '__file', $this->fileName)
                     ->withParameter('', '__part', $this->part);
        $domDocument           = new DOMDocument();
        if (false === $domDocument->load($this->fileName)) {
            $errors = libxml_get_errors();
            libxml_clear_errors();
            $this->handleErrors($errors, $previousErrorHandling);
        }

        $resultDoc = $xslProcessor->onDocument($domDocument)
                                  ->toDoc();
        // we save first to prevent a infinite loop in case of recursions
        $resultDoc->save($this->cachedFileName);
        $resultDoc->xinclude();
        $errors = libxml_get_errors();
        if (count($errors) > 0) {
            unlink($this->cachedFileName);
            libxml_clear_errors();
            $this->handleErrors($errors, $previousErrorHandling, $domDocument);
        }

        libxml_use_internal_errors($previousErrorHandling);
        $resultDoc->save($this->cachedFileName);
        self::$transformedFiles[] = $this->cachedFileName;
    }

    /**
     * handles libxml errors
     *
     * @param   array             $errors
     * @param   boolean           $previousErrorHandling
     * @param   DOMDocument       $resultDoc
     * @throws  stubXMLException
     */
    protected function handleErrors(array $errors, $previousErrorHandling, DOMDocument $resultDoc = null)
    {
        foreach ($errors as $error) {
            $message = trim($error->message) . (($error->file) ? (' in file ' . $error->file) : ('')) . ' on line ' . $error->line . ' in column ' . $error->column;
            switch ($error->level) {
                case LIBXML_ERR_WARNING:
                    if (null !== $resultDoc) {
                        $this->appendError($resultDoc, 'warning', $message);
                        break;
                    }
                    
                    // break omitted if no result doc given
                
                case LIBXML_ERR_ERROR:
                    if (null !== $resultDoc) {
                        $this->appendError($resultDoc, 'error', $message);
                        break;
                    }
                    
                    // break omitted if no result doc given
                
                case LIBXML_ERR_FATAL:
                    libxml_use_internal_errors($previousErrorHandling);
                    throw new stubXMLException('Fatal error: ' . $message);
                
                default:
                    if (null !== $resultDoc) {
                        $this->appendError($resultDoc, 'warning', $message);
                    }
            }
        }
    }

    /**
     * appends the error message into the result document
     *
     * If a part for the inclusion is known it tries to append the error
     * message into this part, if no part is known the error message is
     * appended directly before the end tag of the root element.
     *
     * @param  DOMDocument  $resultDoc  the document to append the error message into
     * @param  string       $level      level of the error
     * @param  string       $message    the error message
     */
    protected function appendError(DOMDocument $resultDoc, $level, $message)
    {
        $element = $resultDoc->createElement('error', ucfirst($level) . ': ' . $message);
        $element->setAttribute('errorType', $level);
        if (null != $this->part && strlen($this->part) > 0) {
            $xpath = new DOMXPath($resultDoc);
            $entry = $xpath->query("/parts/part[@name='" . $this->part ."']")->item(0);
            if (null !== $entry) {
                $entry->appendChild($element);
            } else {
                $resultDoc->documentElement->appendChild($element);
            }
        } else {
            $resultDoc->documentElement->appendChild($element);
        }
    }

    /**
     * closes the stream
     */
    public function stream_close()
    {
        fclose($this->fp);
    }

    /**
     * read the stream up to $count bytes
     *
     * @param   int     $count  amount of bytes to read
     * @return  string
     */
    public function stream_read($count)
    {
        return fread($this->fp, $count);
    }

    /**
     * checks whether stream is at end of file
     *
     * @return  bool
     */
    public function stream_eof()
    {
        return feof($this->fp);
    }

    /**
     * returns status of stream
     *
     * @return  array
     */
    public function stream_stat()
    {
        return array('size' => filesize($this->cachedFileName));
    }

    /**
     * returns status of url
     *
     * @param   string      $path  path of url to return status for
     * @return  array|bool  false if $path does not exist, else
     */
    public function url_stat($path)
    {
        return array('size' => filesize($this->cachedFileName));
    }

    /**
     * parses the path into class members
     *
     * @param   string  $path
     * @throws  stubFileNotFoundException
     */
    protected function parsePath($path)
    {
        list($project, $fileName, $part) = sscanf($path, 'xinc://%[^/?#]/%[^?]?part=%[^$]');
        if (null !== $fileName) {
            if (isset(self::$includePathes[$project]) === false || file_exists(self::$includePathes[$project] . DIRECTORY_SEPARATOR . $fileName) === false) {
                throw new stubFileNotFoundException(self::$includePathes[$project] . DIRECTORY_SEPARATOR . $fileName);
            }
            
            $this->fileName = self::$includePathes[$project] . DIRECTORY_SEPARATOR . $fileName;
            $cacheKey       = $project . DIRECTORY_SEPARATOR;
        } elseif (file_exists($project) === true) {
            $this->fileName = $project;
            $cacheKey       = '';
        } else {
            throw new stubFileNotFoundException($fileName);
        }

        $this->project = $project;
        $this->part    = $part;
        $locale        = '';
        if (self::$xslProcessor->hasParameter('', 'lang') === true) {
            $locale = self::$xslProcessor->getParameter('', 'lang');
        }
        
        $this->cachedFileName = self::$cachePath . DIRECTORY_SEPARATOR . $cacheKey . $locale  . DIRECTORY_SEPARATOR . self::$routeName  . DIRECTORY_SEPARATOR . $fileName;
        if (file_exists(dirname($this->cachedFileName)) === false) {
            mkdir(dirname($this->cachedFileName), self::$fileMode, true);
        }
    }
}
?>[FIELD_EMPTY]
default="Please enter a value."
en_*="Please enter a value."
de_*="Bitte geben Sie einen Wert an."
fr_*="Veuillez remplir le champ."
es_*="Este campo es obligatorio."
ro_*="Vă rugăm să completaţi acest câmp."
pl_*="Proszę uzupełnić pole"
valueKeys=""

[FIELD_NO_SELECT]
default="Please choose a value."
en_*="Please choose a value."
de_*="Bitte wählen Sie einen Wert aus."
fr_*="Veuillez choisir un élément parmi la liste."
es_*="Por favor, seleccione una opción de la lista."
ro_*="Alegeţi o valoare din lista alăturată."
pl_*="Proszę wybrać opcję z listy"
valueKeys=""

[FIELD_WRONG_VALUE]
default="Please enter a correct value."
en_*="Please enter a correct value."
de_*="Bitte geben Sie einen korrekten Wert an."
fr_*="Votre choix n’est pas valide. Veuillez modifier votre choix."
es_*="Selección no válida. Vuelva a realizar la selección."
ro_*="Valoarea introdusă nu este validă. Completaţi câmpul cu o valoare corectă."
pl_*="Proszę uzupełnić to pole poprawnie"
valueKeys=""

[VALUE_TOO_SMALL]
default="Please enter a value greater or equal to {minNumber}."
en_*="Please enter a value greater or equal to {minNumber}."
de_*="Bitte geben Sie einen Wert größer oder gleich {minNumber} an."
ro_*="Introduceţi o valoare mai mare sau egală cu {minNumber}."
pl_*="Proszę wprowadzić wartość wyższą lub równą {minNumber}."
valueKeys="minNumber"

[VALUE_TOO_GREAT]
default="Please enter a value smaller or equal to {maxNumber}."
en_*="Please enter a value smaller or equal to {maxNumber}."
de_*="Bitte geben Sie einen Wert kleiner oder gleich {maxNumber} an."
ro_*="Introduceţi o valoare mai mică sau egală cu {maxNumber}."
pl_*="Proszę wprowadzić wartość niższą lub równą {maxNumber}."
valueKeys="maxNumber"

[PASSWORDS_NOT_EQUAL]
default="Your passwords are not equal. Please enter the same password in both fields."
en_*="Your passwords are not equal. Please enter the same password in both fields."
de_*="Die eingegebenen Passwörter stimmen nicht überein. Bitte geben Sie in beiden Feldern das gleiche Passwort an."
ro_*="Parolele introduse nu sunt identice. Introduceţi aceeaşi parolă în ambele câmpuri."
pl_*="Niezgodność haseł. Proszę wpisać takie same hasła w obydwu polach."
valueKeys=""

[PASSWORD_INVALID]
default="You choose an invalid password. Please choose another password."
en_*="You choose an invalid password. Please choose another password."
de_*="Sie haben ein ungültiges Passwort angegeben. Bitte wählen Sie ein anderes Passwort."
ro_*="Parola introdusă este incorectă. Introduceţi o altă parolă."
pl_*="Wybrane hasło jest nieważne. Proszę wybrać inne."
valueKeys=""

[PASSWORD_TOO_LESS_DIFF_CHARS]
default="Your password has to less different characters. Please choose another password."
en_*="Your password has to less different characters. Please choose another password."
de_*="Ihr Passwort hat zu wenig unterschiedliche Zeichen. Bitte wählen Sie ein anderes Passwort."
ro_*="Parola introdusă are prea puţine caractere diferite. Alegeţi o altă parolă."
pl_*="Podane hasło ma za mało znaków. Proszę wybrać inne."
valueKeys=""

[STRING_TOO_SHORT]
default="Please enter at least {minLength} characters."
en_*="Please enter at least {minLength} characters."
de_*="Bitte geben Sie mindestens {minLength} Zeichen an."
fr_*="Veuillez saisir au minimum {minLength} caractères."
es_*="Debe incluir un mínimo de {minLength} caracteres."
ro_*="Vă rugăm să introduceţi cel puţin {minLength} caractere."
pl_*="Proszę wpisać co najmniej {minLength} znaków."
valueKeys="minLength"

[STRING_TOO_LONG]
default="Please use not more than {maxLength} characters."
en_*="Please use not more than {maxLength} characters."
de_*="Bitte geben Sie nicht mehr als {maxLength} Zeichen an."
fr_*="Veuillez saisir au maximum {maxLength} caractères."
es_*="Debe incluir un máximo de {maxLength} caracteres."
ro_*="Vă rugăm să introduceţi cel mult {maxLength} caractere."
pl_*="Proszę wpisać nie więcej niż {maxLength} znaków."
valueKeys="maxLength"

[DATE_INVALID]
default="Please enter a correct date."
en_*="Please enter a correct date."
de_*="Bitte wählen Sie ein korrektes Datum."
ro_*="Introduceţi o dată corectă."
pl_*="Proszę podać poprawną datę."
valueKeys=""

[DATE_TOO_EARLY]
default="The choosen date is too early. The earliest possible date is {earliestDate}."
en_*="The choosen date is too early. The earliest possible date is {earliestDate}."
de_*="Das gewählte Datum ist zu früh. Das frühestmögliche Datum ist {earliestDate}."
ro_*="Data aleasă este prea devreme. Cea mai apropiată dată posibilă este {earliestDate}."
pl_*="Nie odnaleziono artykułu. Najwcześniejszy dostępny artykuł pochodzi z dnia {earliestDate}."
valueKeys="earliestDate"

[DATE_TOO_LATE]
default="The choosen date is too late. The latest possible date is {latestDate}."
en_*="The choosen date is too late. The latest possible date is {latestDate}."
de_*="Das gewählte Datum ist zu spät. Das spätestmögliche Datum ist {latestDate}."
ro_*="Data aleasă este prea îndepărtată. Cea mai îndepărtată dată posibilă este {latestDate}."
pl_*="Nie odnaleziono artykułu. Ostatni opublikowano {latestDate}."
valueKeys="latestDate"

[MAILADDRESS_CANNOT_CONTAIN_SPACES]
default="The mail address can not contain spaces."
en_*="The mail address can not contain spaces."
de_*="Die E-Mail Adresse darf keine Leerzeichen enthalten."
fr_*="L’adresse email ne doit pas comporter d’espace."
es_*="La dirección de e-mail no deberá contener espacios en blanco."
ro_*="Adresa de e-mail nu poate conţine spaţii."
pl_*="Adres email nie może zawierać spacji."
valueKeys=""

[MAILADDRESS_CANNOT_CONTAIN_UMLAUTS]
default="The mail address can not contain german umlauts nor the character 'ß'."
en_*="The mail address can not contain german umlauts nor the character 'ß'."
de_*="Die E-Mail Adresse darf keine Umlaute oder 'ß' enthalten."
fr_*="L’adresse email ne doit pas comporter d’accent."
es_*="La dirección de e-mail no deberá contener caracteres con tilde o diéresis."
ro_*="Adresa de e-mail nu poate conţine litere cu diacritice."
pl_*="Adres email nie może zawierać umlautów w języku niemieckim ani znaku 'Ã'."
valueKeys=""

[MAILADDRESS_CONTAINS_ILLEGAL_CHARS]
default="The mail address contains illegal characters."
en_*="The mail address contains illegal characters."
de_*="Die E-Mail Adresse enthält ungültige Zeichen."
fr_*="L’adresse email comporte des caractères invalides."
es_*="La dirección de e-mail contiene caracteres no válidos."
ro_*="Adresa de e-mail conţine caractere invalide."
pl_*="Adres email zawiera niepoprawne znaki."
valueKeys=""

[MAILADDRESS_MUST_CONTAIN_ONE_AT]
default="The mail address must contain exactly one '@' sign."
en_*="The mail address must contain exactly one '@' sign."
de_*="Eine E-Mail-Adresse muss genau ein '@' enthalten."
fr_*="Une adresse email doit comporter exactement un '@'."
es_*="La dirección de e-mail introducida no es válida. Por favor, introdúzcala de nuevo correctamente."
ro_*="Adresa de e-mail trebuie să conţină un singur caracter '@'."
pl_*="Adres email może zawierać tylko jeden znak '@'"
valueKeys=""

[MAILADDRESS_CONTAINS_TWO_FOLLOWING_DOTS]
default="The mail address can not contain two consecutive dots."
en_*="The mail address can not contain two consecutive dots."
de_*="Die E-Mail Adresse darf keine zwei aufeinanderfolgenden Punkte enthalten."
fr_*="L’adresse email ne doit pas comporter deux points à la suite."
es_*="La dirección de e-mail no deberá incluir dos puntos seguidos."
ro_*="Adresa de e-mail nu poate conţine două puncte consecutive."
pl_*="Adres email nie może zawierać dwóch kropek obok siebie."
valueKeys=""

[MAILADDRESS_INCORRECT]
default="The mail address is not correct."
en_*="The mail address is not correct."
de_*="Die E-Mail-Adresse ist nicht korrekt."
fr_*="Le format de l’adresse email est invalide. Veuillez modifier votre saisie selon le modèle [nom@domaine.fr]."
es_*="El formato del e-mail no es válido. Por favor, introduzca su e-mail de nuevo correctamente."
ro_*="Adresa de e-mail este incorectă."
pl_*="Podany adres email jest niepoprawny."
valueKeys=""

[URL_INCORRECT]
default="The URL is not a valid HTTP-URL."
en_*="The URL is not a valid HTTP-URL."
de_*="Der URL ist kein gültiger HTTP-URL."
ro_*="Adresa URL nu este o adresă HTTP-URL validă."
pl_*="Podany adres URL nie jest ważnym adresem HTTP-URL."
valueKeys=""

[URL_NOT_AVAILABLE]
default="The URL is not available."
en_*="The URL is not available."
de_*="Der URL ist nicht erreichbar."
ro_*="Adresa URL nu este disponibilă."
pl_*="Podany adres URL jest nieważny."
valueKeys=""
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:foo="http://stubbles.net/foo"
    xmlns:ixsl="http://www.w3.org/1999/XSL/TransformOutputAlias">
  <xsl:template match="foo:bar">
    <ixsl:value-of select="/document/Test/foo"/>
  </xsl:template>
</xsl:stylesheet><?xml version="1.0" encoding="utf-8"?>
<defines>
  <namespace uri="http://stubbles.net/php/string">
    <abstractTag name="encoder" abstractType="net::stubbles::php::string::stubStringEncoder" concreteTypeAttribute="type" keyAttribute="setterMethod"/>
    <tag name="base64" type="net::stubbles::php::string::stubBase64Encoder" keyAttribute="setterMethod"/>
    <tag name="md5" type="net::stubbles::php::string::stubMd5Encoder" keyAttribute="setterMethod"/>
    <tag name="url" type="net::stubbles::php::string::stubURLEncoder" keyAttribute="setterMethod"/>
    <tag name="utf8" type="net::stubbles::php::string::stubUTF8Encoder" keyAttribute="setterMethod"/>
  </namespace>
</defines><?xml version="1.0" encoding="utf-8"?>
<defines>
  <namespace uri="http://stubbles.net/streams">
    <abstractTag name="inputStream" abstractType="net::stubbles::streams::stubInputStream" concreteTypeAttribute="type" keyAttribute="setterMethod"/>
    <abstractTag name="outputStream" abstractType="net::stubbles::streams::stubOutputStream" concreteTypeAttribute="type" keyAttribute="setterMethod"/>
    <tag name="fileInputStream" type="net::stubbles::streams::file::stubFileInputStream" keyAttribute="setterMethod" extends="inputStream">
      <constructor>
        <attribute name="file" type="string"/>
        <attribute name="mode" type="string"/>
      </constructor>
    </tag>
    <tag name="fileOutputStream" type="net::stubbles::streams::file::stubFileOutputStream" keyAttribute="setterMethod" extends="outputStream">
      <constructor>
        <attribute name="file" type="string"/>
        <attribute name="mode" type="string"/>
      </constructor>
    </tag>
    <tag name="memoryInputStream" type="net::stubbles::streams::memory::stubMemoryInputStream" keyAttribute="setterMethod" extends="inputStream">
      <constructor>
        <attribute name="buffer" type="string"/>
      </constructor>
    </tag>
    <tag name="memoryOutputStream" type="net::stubbles::streams::memory::stubMemoryOutputStream" keyAttribute="setterMethod" extends="outputStream"/>
    <tag name="decodingInputStream" type="net::stubbles::streams::stubDecodingInputStream" keyAttribute="setterMethod" extends="inputStream">
      <constructor>
        <child name="inputStream"/>
        <attribute name="charset" type="string"/>
      </constructor>
    </tag>
    <tag name="encodingOutputStream" type="net::stubbles::streams::stubEncodingOutputStream" keyAttribute="setterMethod" extends="outputStream">
      <constructor>
        <child name="outputStream"/>
        <attribute name="charset" type="string"/>
      </constructor>
    </tag>
  </namespace>
</defines><?xml version="1.0" encoding="utf-8"?>
<defines>
  <namespace uri="http://stubbles.net/ipo/request/validator">
    <abstractTag name="validator" abstractType="net::stubbles::ipo::request::validator::stubValidator" concreteTypeAttribute="type" keyAttribute="setterMethod"/>
    <tag name="contains" type="net::stubbles::ipo::request::validator::stubContainsValidator" keyAttribute="setterMethod">
      <cdata type="xjconf:auto-primitive"/>
    </tag>
    <tag name="equal" type="net::stubbles::ipo::request::validator::stubEqualValidator" keyAttribute="setterMethod">
      <cdata type="xjconf:auto-primitive"/>
    </tag>
    <tag name="ip" type="net::stubbles::ipo::request::validator::stubIpValidator" keyAttribute="setterMethod"/>
    <tag name="mail" type="net::stubbles::ipo::request::validator::stubMailValidator" keyAttribute="setterMethod"/>
    <tag name="maxLength" type="net::stubbles::ipo::request::validator::stubMaxLengthValidator" keyAttribute="setterMethod">
      <cdata type="int"/>
    </tag>
    <tag name="maxNumber" type="net::stubbles::ipo::request::validator::stubMaxNumberValidator" keyAttribute="setterMethod">
      <cdata type="xjconf:auto-primitive"/>
    </tag>
    <tag name="minLength" type="net::stubbles::ipo::request::validator::stubMinLengthValidator" keyAttribute="setterMethod">
      <cdata type="int"/>
    </tag>
    <tag name="minNumber" type="net::stubbles::ipo::request::validator::stubMinNumberValidator" keyAttribute="setterMethod">
      <cdata type="xjconf:auto-primitive"/>
    </tag>
    <tag name="preSelect" type="net::stubbles::ipo::request::validator::stubPreSelectValidator" keyAttribute="setterMethod">
      <constructor>
        <child name="values"/>
      </constructor>
    </tag>
    <tag name="values" type="array"/>
    <tag name="value" type="xjconf:auto-primitive" key="__none"/>
    <tag name="regex" type="net::stubbles::ipo::request::validator::stubRegexValidator" keyAttribute="setterMethod">
      <cdata type="string"/>
    </tag>
    
    <abstractTag name="compositeValidator" abstractType="net::stubbles::ipo::request::validator::stubCompositeValidator" concreteTypeAttribute="type" keyAttribute="setterMethod"/>
    <tag name="and" type="net::stubbles::ipo::request::validator::stubAndValidator" keyAttribute="setterMethod"/>
    <tag name="or" type="net::stubbles::ipo::request::validator::stubOrValidator" keyAttribute="setterMethod"/>
    <tag name="xor" type="net::stubbles::ipo::request::validator::stubXorValidator" keyAttribute="setterMethod"/>
  </namespace>
</defines><?xml version="1.0" encoding="utf-8"?>
<defines>
  <!--
    Namespace definitions for the variants
  -->
  <namespace uri="http://stubbles.net/websites/variantmanager">
    <tag name="variants" type="net::stubbles::websites::variantmanager::stubVariantsMap">
      <attribute name="name" type="string" required="true"/>
      <attribute name="usePersistence" type="boolean" required="false"/>
    </tag>	
    
    <!-- Variant Types -->
    <abstractTag name="variant" abstractType="net::stubbles::websites::variantmanager::types::stubVariant" concreteTypeAttribute="type" setter="addChild">
      <attribute name="name" type="string" required="true"/>
      <attribute name="title" type="string" required="true"/>
      <attribute name="alias" type="string" required="false"/>
    </abstractTag>
    
    <tag name="lead" type="net::stubbles::websites::variantmanager::types::stubLeadVariant" extends="variant" />
    
    <tag name="random" type="net::stubbles::websites::variantmanager::types::stubRandomVariant" extends="variant">
      <attribute name="weight" type="int" required="true"/>
    </tag>
    
    <tag name="dummy" type="net::stubbles::websites::variantmanager::types::stubDummyVariant" extends="variant" />
    
    <tag name="requestParam" type="net::stubbles::websites::variantmanager::types::stubRequestParamVariant" extends="variant">
      <attribute name="paramName" type="string" required="true"/>
      <attribute name="paramValue" type="string" required="false"/>
    </tag>
    
  </namespace>
</defines><xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:php="http://php.net/xsl"
    xmlns:stub="http://stubbles.net/stub"
    exclude-result-prefixes="php stub">
  
  <xsl:template match="*|/">
    <xsl:copy>
      <xsl:copy-of select="./@*"/>
      <xsl:apply-templates select="node()"/>
    </xsl:copy>
  </xsl:template>
    
</xsl:stylesheet><xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:ixsl="http://www.w3.org/1999/XSL/TransformOutputAlias"
    xmlns:php="http://php.net/xsl"
    xmlns:stub="http://stubbles.net/stub"
    exclude-result-prefixes="php ixsl stub">
  <xsl:template match="stub:ingrid">
    <ul>
      <xsl:copy-of select="@*[name() !='prefix']"/>
      <xsl:apply-templates/>
    </ul>
  </xsl:template>

  <xsl:template match="stub:ingrid//row">
    <li class="clearfix">
      <xsl:copy-of select="@*"/>
      <xsl:apply-templates/>
    </li>
  </xsl:template>

  <xsl:template match="stub:ingrid//markup">
    <xsl:apply-templates/>
  </xsl:template>

  <xsl:template match="stub:ingrid//left">
    <xsl:call-template name="stub_ingrid_row_element">
      <xsl:with-param name="type">
        <xsl:text>left</xsl:text>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:template>

  <xsl:template match="stub:ingrid//right">
    <xsl:call-template name="stub_ingrid_row_element">
      <xsl:with-param name="type">
        <xsl:text>right</xsl:text>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:template>

  <xsl:template match="stub:ingrid//both">
    <xsl:call-template name="stub_ingrid_row_element">
      <xsl:with-param name="type">
        <xsl:text>both</xsl:text>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:template>

  <xsl:template name="stub_ingrid_row_element">
    <xsl:param name="type" select="@type"/>
    <div>
      <xsl:copy-of select="@*[name() !='class']"/>
        <xsl:attribute name="class">
        <xsl:value-of select="$type"/>
        <xsl:if test="@class">
          <xsl:text> </xsl:text>
          <xsl:value-of select="@class"/>
        </xsl:if>
      </xsl:attribute>
      <xsl:apply-templates/>
    </div>
  </xsl:template>

  <xsl:template match="stub:ingrid//label">
    <xsl:variable name="prefix">
      <xsl:value-of select="ancestor::stub:ingrid/@prefix"/>
    </xsl:variable>
    <label>
      <xsl:copy-of select="@*[name() !='for' and name() !='class' and name() !='colon' and name() !='mandatory']"/>
      <xsl:attribute name="for">
        <xsl:choose>
          <xsl:when test="starts-with(@for, concat($prefix, '_'))">
            <xsl:value-of select="@for"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="concat($prefix, '_', @for)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:attribute> 
      <ixsl:choose>
        <ixsl:when test="count(/document/request/value[@name = '{$prefix}_{@for}']/errors) &gt; 0">
          <ixsl:attribute name="class">
            <xsl:value-of select="@class"/>
            <xsl:text> text error</xsl:text>
          </ixsl:attribute>
        </ixsl:when>
        <ixsl:otherwise>
          <ixsl:attribute name="class">
            <xsl:value-of select="@class"/>
            <xsl:text> text</xsl:text>
          </ixsl:attribute>
        </ixsl:otherwise>
      </ixsl:choose>
      <xsl:variable name="labelpart">
        <xsl:text>label_</xsl:text>
        <xsl:value-of select="$prefix"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="@for"/>
      </xsl:variable>
      <xsl:call-template name="stub:include">
        <xsl:with-param name="part" select="$labelpart"/>
      </xsl:call-template>
      <xsl:if test="not(@colon = 'false' or @mandatory = 'true')">
        <xsl:text>:</xsl:text>
      </xsl:if>
      <xsl:if test="@mandatory = 'true'">
        <xsl:text>:*</xsl:text>
      </xsl:if>
    </label>
  </xsl:template>

  <xsl:template match="stub:ingrid//info">
    <xsl:variable name="prefix">
      <xsl:value-of select="ancestor::stub:ingrid/@prefix"/>
    </xsl:variable>
    <div class="info">
      <xsl:copy-of select="@*[name() !='class' and name() !='for']"/>
      <div class="{@class} infoBoxMagix">
        <xsl:attribute name="id">
          <xsl:value-of select="concat('info.', $prefix, '_', @for)"/>
        </xsl:attribute>
        <div class="header"/>
        <div class="content">
          <xsl:apply-templates/>
        </div>
        <div class="footer"/>
      </div>
    </div>
  </xsl:template>

  <xsl:template match="stub:ingrid//item">
    <xsl:variable name="prefix">
      <xsl:value-of select="ancestor::stub:ingrid/@prefix"/>
    </xsl:variable>
    <xsl:call-template name="stub_ingrid_field_object">
      <xsl:with-param name="prefix" select="$prefix"/>
    </xsl:call-template>
    <xsl:if test="not(ancestor::item[@type='multi']) and not(@type='hidden') and not(@type='submit') and not(@type='image')">
      <xsl:call-template name="stub_ingrid_field_error">
        <xsl:with-param name="prefix" select="$prefix"/>
        <xsl:with-param name="name" select="@name"/>
        <xsl:with-param name="type" select="@type"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:template>

  <xsl:template name="stub_ingrid_field_error">
    <xsl:param name="prefix" select="@prefix"/>
    <xsl:param name="name" select="@name"/>
    <xsl:param name="type" select="@type"/>
    <xsl:param name="nx" select="@nx"/>
    <ixsl:if>
      <xsl:attribute name="test">
        <xsl:choose>
          <xsl:when test="$type = 'multi'">
            <xsl:for-each select=".|.//item">
              <xsl:text>count(/document/request/value[@name='</xsl:text>
              <xsl:value-of select="$prefix"/>
              <xsl:text>_</xsl:text>
              <xsl:value-of select="@name"/>
              <xsl:text>']/errors) &gt; 0</xsl:text>
              <xsl:if test="position() != last()">
                <xsl:text> or </xsl:text>
              </xsl:if>
            </xsl:for-each>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>count(/document/request/value[@name='</xsl:text>
            <xsl:value-of select="$prefix"/>
            <xsl:text>_</xsl:text>
            <xsl:value-of select="$name"/>
            <xsl:text>']/errors) &gt; 0</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:attribute>
      <div>
        <xsl:copy-of select="@style"/>
        <xsl:attribute name="class">error</xsl:attribute>
        <xsl:choose>
          <xsl:when test="$type = 'multi'">
            <ul>
              <xsl:for-each select=".|.//item[not(@type = 'freetext')]">
                <xsl:if test="not(@name=preceding::item[ancestor::stub:ingrid[@prefix=$prefix]]/@name)">
                  <ixsl:if test="count(/document/request/value[@name='{$prefix}_{@name}']/errors/error) &gt; 0">
                    <ixsl:for-each select="/document/request/value[@name='{$prefix}_{@name}']/errors/error">
                      <li>
                        <xsl:choose>
                          <xsl:when test="not(../@uselabel = 'false') and not(../@uselabel = 'one') and not(@name = '')">
                            <span class="label">
                              <xsl:call-template name="stub:include">
                                <xsl:with-param name="part" select="concat('label_', $prefix, '_', @name)"/>
                              </xsl:call-template>
                            </span>
                          </xsl:when>
                          <xsl:otherwise>
                            <xsl:value-of select="concat(' ', position())"/>
                          </xsl:otherwise>
                        </xsl:choose>
                        <xsl:text>: </xsl:text>
                        <ixsl:choose>
                          <ixsl:when test="messages/string[@locale = '{$lang}']">
                            <ixsl:value-of select="messages/string[@locale = '{$lang}']/content"/>
                          </ixsl:when>
                          <ixsl:when test="messages/string[@locale = '{$lang_base}']">
                            <ixsl:value-of select="messages/string[@locale = '{$lang_base}']/content"/>
                          </ixsl:when>
                          <ixsl:otherwise>
                            <ixsl:value-of select="messages/string[@locale = 'default']/content"/>
                          </ixsl:otherwise>
                        </ixsl:choose>
                      </li>
                    </ixsl:for-each>
                  </ixsl:if>
                </xsl:if>
              </xsl:for-each>
            </ul>
          </xsl:when>
          <xsl:otherwise>
            <ixsl:if test="count(/document/request/value[@name='{$prefix}_{@name}']/errors/error) &gt; 0">
              <ixsl:for-each select="/document/request/value[@name='{$prefix}_{@name}']/errors/error">
                <ixsl:choose>
                  <ixsl:when test="messages/string[@locale = '{$lang}']">
                    <ixsl:value-of select="messages/string[@locale = '{$lang}']/content"/>
                  </ixsl:when>
                  <ixsl:when test="messages/string[@locale = '{$lang_base}']">
                    <ixsl:value-of select="messages/string[@locale = '{$lang_base}']/content"/>
                  </ixsl:when>
                  <ixsl:otherwise>
                    <ixsl:value-of select="messages/string[@locale = 'default']/content"/>
                  </ixsl:otherwise>
              </ixsl:choose>
             </ixsl:for-each>
           </ixsl:if>
          </xsl:otherwise>
        </xsl:choose>
      </div>
    </ixsl:if>
  </xsl:template>
  
  <xsl:template name="stub_ingrid_field_object">
    <xsl:param name="type" select="@type"/>
    <xsl:param name="prefix" select="@prefix"/>
    <xsl:param name="name" select="@name"/>
    <xsl:param name="fullname" select="@fullname"/>
    <xsl:param name="value" select="@value"/>
    <xsl:param name="valuePath" select="@valuePath"/>
    <xsl:param name="class" select="@class"/>
    <xsl:param name="style" select="@style"/>
    <xsl:param name="size" select="@size"/>
    <xsl:param name="path" select="@path"/>
    <xsl:param name="readonly" select="@readonly"/>
    <xsl:param name="disabled" select="@disabled"/>
    <xsl:param name="rows" select="@rows"/>
    <xsl:param name="cols" select="@cols"/>
    <xsl:param name="setdefault" select="@setdefault"/>
    <xsl:param name="default" select="@default"/>
    <xsl:param name="maxlength" select="@maxlength"/>
    <xsl:param name="optionlabel" select="@optionlabel"/>
    <xsl:param name="focus" select="@focus"/>
    <xsl:param name="tabindex" select="@tabindex"/>
    <xsl:param name="adddefaultoption" select="@adddefaultoption"/>
    <xsl:param name="omitoptioninclude" select="@omitoptioninclude"/>
    <xsl:param name="checked" select="@checked"/>
    <xsl:variable name="myid">
      <xsl:choose>
        <xsl:when test="@id">
          <xsl:value-of select="@id"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="concat($prefix, '_', $name)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="myname">
      <xsl:choose>
        <xsl:when test="@fullname">
          <xsl:value-of select="@fullname"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="concat($prefix, '_', $name)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$type = 'multi'">
        <div>
          <xsl:copy-of select="@style"/>
          <ixsl:attribute name="class"><xsl:value-of select="$class"/> multi clearfix</ixsl:attribute>
          <xsl:if test="$name != ''">
            <ixsl:attribute name="id"><xsl:value-of select="concat($prefix, '_', $name)"/></ixsl:attribute>
          </xsl:if>
          <xsl:apply-templates/>
        </div>
      </xsl:when>
      <xsl:when test="$type = 'freetext'">
        <div>
          <xsl:if test="not(@noid and @noid = 'true')">
            <ixsl:attribute name="id">
              <xsl:value-of select="$myid"/>
            </ixsl:attribute>
          </xsl:if>
          <xsl:copy-of select="@style"/>
          <ixsl:choose>
            <ixsl:when test="count(/document/request/value[@name = '{$prefix}_{$name}']/errors) &gt; 0">
              <ixsl:attribute name="class"><xsl:value-of select="$class"/> text error</ixsl:attribute>
            </ixsl:when>
            <ixsl:otherwise>
              <ixsl:attribute name="class"><xsl:value-of select="$class"/> text</ixsl:attribute>
            </ixsl:otherwise>
          </ixsl:choose>
          <xsl:apply-templates/>
        </div>
      </xsl:when>
      <xsl:when test="$type = 'image'">
        <span class="btn"><input type="{$type}" class="btn_submit" value="{$value}" name="{$prefix}_{$name}" /></span>
      </xsl:when>  
      <xsl:when test="$type = 'submit'">
        <input class="btn_submit" type="{$type}" value="{$value}" name="{$prefix}_{$name}"/>
      </xsl:when>
      <xsl:when test="$type = 'hidden'">
        <input type="{$type}" value="{$value}" name="{$prefix}_{$name}">
          <xsl:apply-templates/>
        </input>
      </xsl:when>
      <xsl:when test="$type = 'include'">
        <xsl:call-template name="stub:include">
          <xsl:with-param name="part" select="concat($prefix, '_', $name)"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$type = 'file'">
        <input type="file" name="{$prefix}_{$name}" id="{$myid}">
          <xsl:copy-of select="@style"/>
          <xsl:if test="$tabindex != ''">
            <xsl:attribute name="tabindex">
              <xsl:value-of select="$tabindex"/>
            </xsl:attribute>
          </xsl:if>
          <ixsl:if test="count(/document/request/value[@name = '{$prefix}_{$name}']/errors) &gt; 0">
            <ixsl:attribute name="class">error</ixsl:attribute>
          </ixsl:if>
        </input>
      </xsl:when>
      <xsl:when test="$type = 'dynamic'">
        <input type="select" name="{$prefix}_{$name}" id="{$myid}">
          <xsl:copy-of select="@style"/>
          <xsl:copy-of select="@onclick"/>
          <xsl:copy-of select="@onchange"/>
          <xsl:if test="$readonly = 'true'">
            <xsl:attribute name="readonly">true</xsl:attribute>
          </xsl:if>
          <xsl:if test="$tabindex != ''">
            <xsl:attribute name="tabindex">
              <xsl:value-of select="$tabindex"/>
            </xsl:attribute>
          </xsl:if>
          <xsl:if test="$default != ''">
            <xsl:attribute name="default">
              <xsl:value-of select="$default"/>
            </xsl:attribute>
          </xsl:if>
          <ixsl:choose>
            <ixsl:when test="count(/document/request/value[@name = '{$prefix}_{$name}']/errors) &gt; 0">
              <ixsl:attribute name="class"><xsl:value-of select="$class"/> select error</ixsl:attribute>
            </ixsl:when>
            <ixsl:otherwise>
              <ixsl:attribute name="class"><xsl:value-of select="$class"/> select</ixsl:attribute>
            </ixsl:otherwise>
          </ixsl:choose>
          <xsl:if test="$adddefaultoption = 'true'">
            <option value="">
              <xsl:call-template name="stub:include">
                <xsl:with-param name="part" select="concat('default_', $prefix, '_', $name)"/>
              </xsl:call-template>
            </option>
          </xsl:if>
          <ixsl:for-each select="{$path}">
            <ixsl:element name="{{name()}}">
              <ixsl:if test="/document/forms/{$prefix}/{$name} = @value">
                <ixsl:attribute name="selected">selected</ixsl:attribute>
              </ixsl:if>
              <ixsl:copy-of select="@*"/>
              <ixsl:apply-templates/>
            </ixsl:element>
          </ixsl:for-each>
        </input>
        <xsl:apply-templates/>
      </xsl:when>
      <xsl:when test="$type = 'radio' or $type = 'checkbox'">
        <xsl:choose>
          <xsl:when test="not(.//option) and $value != ''">
            <input type="{$type}" value="{$value}" name="{$prefix}_{$name}">
              <xsl:copy-of select="@style"/>
              <xsl:copy-of select="@onclick"/>
              <xsl:copy-of select="@onchange"/>
              <xsl:attribute name="id">
                <xsl:choose>
                  <xsl:when test="$type = 'radio' or ($type = 'checkbox' and $value != '')">
                    <xsl:value-of select="concat($prefix, '_', $name, '-', $value)"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="concat($prefix, '_', $name)"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:attribute>
              <ixsl:choose>
                <ixsl:when test="/document/forms/{$prefix}/{$name} = '{$value}'">
                  <ixsl:attribute name="checked">checked</ixsl:attribute>
                </ixsl:when>
                <ixsl:when test="string-length(/document/forms/{$prefix}/{$name}) = 0">
                  <xsl:if test="$default = 'true'">
                    <ixsl:attribute name="checked">checked</ixsl:attribute>
                  </xsl:if>
                </ixsl:when>
              </ixsl:choose>
              <ixsl:choose>
                <ixsl:when test="count(/document/request/value[@name = '{$prefix}_{$name}']/errors) &gt; 0">
                  <ixsl:attribute name="class"><xsl:value-of select="$class"/><xsl:text> </xsl:text><xsl:value-of select="$type"/> error</ixsl:attribute>
                </ixsl:when>
                <ixsl:otherwise>
                  <ixsl:attribute name="class"><xsl:value-of select="$class"/><xsl:text> </xsl:text><xsl:value-of select="$type"/></ixsl:attribute>
                </ixsl:otherwise>
              </ixsl:choose>
            </input>
          </xsl:when>
          <xsl:otherwise>
            <div>
              <xsl:if test="@display">
                <xsl:attribute name="style">display:<xsl:value-of select="@display"/>;</xsl:attribute>
              </xsl:if>
              <xsl:apply-templates select="option|ixsl:if|xsl:if|ixsl:choose|xsl:choose|ixsl:when|xsl:when|ixsl:otherwise|xsl:otherwise"/>
            </div>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:apply-templates select="./text()|./text/node()|./text/text()"/>
      </xsl:when>
      <xsl:when test="$type = 'select'">
        <select name="{$prefix}_{$name}" id="{$myid}">
          <xsl:copy-of select="@*[name()!='class' and name()!='omitoptioninclude' and name()!='name' and name()!='id' and name()!='type']"/>
          <xsl:if test="$disabled = 'true'">
            <xsl:attribute name="disabled">true</xsl:attribute>
          </xsl:if>
          <xsl:if test="$tabindex != ''">
            <xsl:attribute name="tabindex">
              <xsl:value-of select="$tabindex"/>
            </xsl:attribute>
          </xsl:if>
          <ixsl:choose>
            <ixsl:when test="count(/document/request/value[@name = '{$prefix}_{$name}']/errors) &gt; 0">
              <ixsl:attribute name="class"><xsl:value-of select="$class"/> select error</ixsl:attribute>
            </ixsl:when>
            <ixsl:otherwise>
              <ixsl:attribute name="class"><xsl:value-of select="$class"/> select</ixsl:attribute>
            </ixsl:otherwise>
          </ixsl:choose>
          <xsl:for-each select="option">
            <option value="{@value}">
              <ixsl:if test="/document/forms/{$prefix}/{$name} = '{@value}'">
                <ixsl:attribute name="selected">selected</ixsl:attribute>
              </ixsl:if>
              <xsl:if test="@default = 'true'">
                <xsl:copy-of select="./@default"/>
              </xsl:if>
              <xsl:choose>
                <xsl:when test="$omitoptioninclude = 'true'">
                  <xsl:apply-templates/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:call-template name="stub:include">
                    <xsl:with-param name="part" select="concat('option_', $prefix, '_', $name, '-', @value)"/>
                  </xsl:call-template>
                </xsl:otherwise>
              </xsl:choose>
            </option>
          </xsl:for-each>
          <xsl:for-each select="optioninclude">
            <xsl:call-template name="stub:include">
              <xsl:with-param name="href" select="@href"/>
              <xsl:with-param name="part" select="@part"/>
            </xsl:call-template>
          </xsl:for-each>
          <xsl:apply-templates select="*[name()!='option' and name()!='optioninclude']"/>
        </select>
      </xsl:when>
      <xsl:when test="$type = 'area'">
        <textarea name="{$prefix}_{$name}" id="{$myid}">
          <xsl:copy-of select="@style"/>
          <xsl:copy-of select="@onclick"/>
          <xsl:copy-of select="@onchange"/>
          <xsl:if test="$cols != ''">
            <xsl:attribute name="cols"><xsl:value-of select="$cols"/></xsl:attribute>
          </xsl:if>
          <xsl:if test="$rows != ''">
            <xsl:attribute name="rows"><xsl:value-of select="$rows"/></xsl:attribute>
          </xsl:if>
          <xsl:if test="$tabindex != ''">
            <xsl:attribute name="tabindex"><xsl:value-of select="$tabindex"/></xsl:attribute>
          </xsl:if>
          <ixsl:choose>
            <ixsl:when test="count(/document/request/value[@name = '{$prefix}_{$name}']/errors) &gt; 0">
              <ixsl:attribute name="class"><xsl:value-of select="$class"/> area error</ixsl:attribute>
            </ixsl:when>
            <ixsl:otherwise>
              <ixsl:attribute name="class"><xsl:value-of select="$class"/> area</ixsl:attribute>
            </ixsl:otherwise>
          </ixsl:choose>
          <xsl:for-each select="default">
            <xsl:apply-templates/>
          </xsl:for-each>
          <xsl:choose>
            <xsl:when test="$valuePath != ''">
              <ixsl:choose>
                <ixsl:when test="/document/forms/{$prefix}/{$name}">
                  <ixsl:value-of select="/document/forms/{$prefix}/{$name}"/>
                </ixsl:when>
                <ixsl:otherwise>
                  <ixsl:value-of select="{$valuePath}"/>
                </ixsl:otherwise>
              </ixsl:choose>
            </xsl:when>
            <xsl:otherwise>
              <ixsl:choose>
                <ixsl:when test="/document/forms/{$prefix}/{$name}">
                  <ixsl:value-of select="/document/forms/{$prefix}/{$name}"/>
                </ixsl:when>
                <ixsl:otherwise>
                  <xsl:if test="string-length(./text()) > 0">
                    <xsl:value-of select="./text()"/>
                  </xsl:if>
                </ixsl:otherwise>
              </ixsl:choose>
            </xsl:otherwise>
          </xsl:choose>
        </textarea>
        <xsl:apply-templates select="*[name()!='default']"/>
      </xsl:when>
      <xsl:otherwise>
        <input type="text" name="{$prefix}_{$name}" id="{$myid}">
          <xsl:copy-of select="@style"/>
          <xsl:copy-of select="@onclick"/>
          <xsl:copy-of select="@onchange"/>
          <xsl:copy-of select="@onkeypress"/>
          <xsl:copy-of select="@onkeydown"/>
          <xsl:copy-of select="@onkeyup"/>
          <xsl:if test="$type = 'password'">
            <xsl:attribute name="type"><xsl:value-of select="$type"/></xsl:attribute>
          </xsl:if>
          <xsl:if test="$size != ''">
            <xsl:attribute name="size"><xsl:value-of select="$size"/></xsl:attribute>
          </xsl:if>
          <xsl:if test="$maxlength != ''">
            <xsl:attribute name="maxlength"><xsl:value-of select="$maxlength"/></xsl:attribute>
          </xsl:if>
          <xsl:if test="$readonly = 'true'">
            <xsl:attribute name="readonly">true</xsl:attribute>
          </xsl:if>
          <xsl:if test="$tabindex != ''">
            <xsl:attribute name="tabindex">
              <xsl:value-of select="$tabindex"/>
            </xsl:attribute>
          </xsl:if>
          <xsl:if test="$default != ''">
            <xsl:attribute name="default">
              <xsl:value-of select="$default"/>
            </xsl:attribute>
          </xsl:if>
          <ixsl:choose>
            <ixsl:when test="count(/document/request/value[@name = '{$prefix}_{$name}']/errors) &gt; 0">
              <ixsl:attribute name="class"><xsl:value-of select="$class"/> text error</ixsl:attribute>
            </ixsl:when>
            <ixsl:otherwise>
              <ixsl:attribute name="class"><xsl:value-of select="$class"/> text</ixsl:attribute>
            </ixsl:otherwise>
          </ixsl:choose>
          <xsl:choose>
            <xsl:when test="$valuePath != ''">
              <ixsl:choose>
                <ixsl:when test="/document/forms/{$prefix}/{$name}">
                  <ixsl:attribute name="value"><ixsl:value-of select="/document/forms/{$prefix}/{$name}"/></ixsl:attribute>
                </ixsl:when>
                <ixsl:when test="{$valuePath} and string-length({$valuePath}) > 0">
                  <ixsl:attribute name="value"><ixsl:value-of select="{$valuePath}"/></ixsl:attribute>
                </ixsl:when>
                <ixsl:otherwise>
                  <ixsl:attribute name="value"><xsl:value-of select="@default"/></ixsl:attribute>
                </ixsl:otherwise>
              </ixsl:choose>
            </xsl:when>
            <xsl:otherwise>
              <ixsl:choose>
                <ixsl:when test="/document/forms/{$prefix}/{$name}">
                  <ixsl:attribute name="value"><ixsl:value-of select="/document/forms/{$prefix}/{$name}"/></ixsl:attribute>
                </ixsl:when>
                <ixsl:otherwise>
                  <ixsl:attribute name="value"><xsl:value-of select="@default"/></ixsl:attribute>
                </ixsl:otherwise>
              </ixsl:choose>
            </xsl:otherwise>
          </xsl:choose>
        </input>
        <xsl:apply-templates/>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:if test="$focus = 'true'">
      <script type="text/javascript">document.getElementById("<xsl:value-of select="concat($prefix, '_', $name)"/>").focus();</script>
    </xsl:if>
  </xsl:template>
  
<!-- older Version replaced by INGRID: stub:itemframe, stub:formerrors, stub:item, stub:option -->
</xsl:stylesheet><xsl:stylesheet version="1.1"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:ixsl="http://www.w3.org/1999/XSL/TransformOutputAlias"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:php="http://php.net/xsl"
    xmlns:stub="http://stubbles.net/stub"
    xmlns:variant="http://stubbles.net/variant"
    exclude-result-prefixes="php xi ixsl stub variant">

  <xsl:import href="xslimport://master.xsl"/>

  <xsl:namespace-alias stylesheet-prefix="ixsl" result-prefix="xsl"/>

  <xsl:param name="__path" select="@path"/>
  <xsl:param name="page" select="@page"/>
  <xsl:param name="lang" select="@lang"/>
  <xsl:param name="lang_base" select="@lang_base"/>
  <xsl:param name="__part" select="@__part"/>
  <xsl:param name="__file" select="@__file"/>

  <xsl:template match="/">
    <xsl:apply-templates select="node()"/>
  </xsl:template>

</xsl:stylesheet><xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:ixsl="http://www.w3.org/1999/XSL/TransformOutputAlias"
    xmlns:php="http://php.net/xsl"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:stub="http://stubbles.net/stub"
    exclude-result-prefixes="xi ixsl stub">

  <xsl:strip-space elements="stub:link"/>
  <xsl:strip-space elements="stub:argument"/>

  <xsl:template match="stub:document">
    <ixsl:stylesheet version="1.0" xmlns:php="http://php.net/xsl" exclude-result-prefixes="ixsl php">
      <ixsl:output>
        <xsl:copy-of select="@method"/>
        <xsl:copy-of select="@omit-xml-declaration"/>
        <xsl:copy-of select="@doctype-public"/>
        <xsl:copy-of select="@doctype-system"/>
      </ixsl:output>
      <ixsl:variable name="page" select="/document/@page"/>
      <ixsl:variable name="__acceptsCookies" select="/document/session/acceptsCookies/text()"/>
      <ixsl:variable name="__isUserAgentBot" select="/document/request/userAgent/@isBot"/>
      <ixsl:variable name="__sessid" select="/document/session/id"/>
      <ixsl:variable name="__sessname" select="/document/session/name"/>
      <ixsl:variable name="__lang"><xsl:value-of select="$lang"/></ixsl:variable>
      <ixsl:variable name="__lang_base"><xsl:value-of select="$lang_base"/></ixsl:variable>
      <ixsl:template match="/">
        <xsl:apply-templates select="node()"/>
      </ixsl:template>
      <ixsl:template match="@*|node()">
        <ixsl:copy>
          <ixsl:apply-templates select="@*|node()"/>
        </ixsl:copy>
      </ixsl:template>
      <ixsl:template name="generateVariantMenu">
        <ixsl:for-each select="variant">
          <ixsl:choose>
            <ixsl:when test="variant">
              <optgroup>
                <ixsl:attribute name="label"><ixsl:value-of select="@name"/></ixsl:attribute>
                <ixsl:call-template name="generateVariantMenuEntry"/>
              </optgroup>
            </ixsl:when>
            <ixsl:otherwise>
              <optgroup>
                <ixsl:attribute name="label"><ixsl:value-of select="@name"/></ixsl:attribute>
                <ixsl:call-template name="generateVariantMenuOption"/>
              </optgroup>
            </ixsl:otherwise>
          </ixsl:choose>
        </ixsl:for-each>
      </ixsl:template>
      <ixsl:template name="generateVariantMenuEntry">
        <ixsl:for-each select="variant">
          <ixsl:choose>
            <ixsl:when test="variant">
              <ixsl:call-template name="generateVariantMenuEntry"/>
            </ixsl:when>
            <ixsl:otherwise>
              <ixsl:call-template name="generateVariantMenuOption"/>
            </ixsl:otherwise>
          </ixsl:choose>
        </ixsl:for-each>
      </ixsl:template>
      <ixsl:template name="generateVariantMenuOption">
        <ixsl:choose>
          <ixsl:when test="/document/session/variant/name/text() = @name">
            <option selected="selected">
              <ixsl:attribute name="label">
                <ixsl:value-of select="@name"/>
              </ixsl:attribute>
              <ixsl:value-of select="@name"/>
            </option>
          </ixsl:when>
          <ixsl:otherwise>
            <option>
              <ixsl:attribute name="label">
                <ixsl:value-of select="@name"/>
              </ixsl:attribute>
              <ixsl:value-of select="@name"/>
            </option>
          </ixsl:otherwise>
        </ixsl:choose>
      </ixsl:template>
    </ixsl:stylesheet>
  </xsl:template>

  <xsl:template match="stub:comment">
    <ixsl:comment><xsl:copy-of select="node()"/></ixsl:comment>
  </xsl:template>

  <xsl:template match="stub:script">
    <script type="text/javascript"><xsl:copy-of select="@*"/>
      <ixsl:comment><xsl:copy-of select="node()"/>//</ixsl:comment>
    </script>
  </xsl:template>

  <xsl:template match="stub:error">
    <div class="stubTransformError">
      <xsl:copy-of select="node()"/>
    </div>
  </xsl:template>

  <xsl:template match="stub:argument"/>

  <xsl:template match="stub:link">
    <a>
    <xsl:copy-of select="@*[local-name() != 'processor' and local-name() != 'bot' and local-name() != 'page' and local-name() != 'querystring']"/>
    <ixsl:attribute name="href">
      <ixsl:variable name="bot"><xsl:value-of select="@bot"/></ixsl:variable>
      <ixsl:choose>
        <ixsl:when test="'true' = $__isUserAgentBot and string-length($bot) &gt; 0">
          <xsl:value-of select="@bot"/>
        </ixsl:when>
        <ixsl:otherwise>
          <xsl:choose>
            <xsl:when test="@processor">
              <xsl:text>/</xsl:text><xsl:value-of select="@processor"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:text>/xml</xsl:text>
            </xsl:otherwise>
          </xsl:choose>
          <xsl:text>/</xsl:text>
          <xsl:choose>
            <xsl:when test="@page">
              <xsl:value-of select="@page"/>
            </xsl:when>
          </xsl:choose>
          <ixsl:if test="'false' = $__acceptsCookies and 'false' = $__isUserAgentBot">
            <xsl:text>?</xsl:text>
            <ixsl:value-of select="$__sessname"/>
            <xsl:text>=</xsl:text>
            <ixsl:value-of select="$__sessid"/>
          </ixsl:if>
          <xsl:for-each select="./stub:argument">
            <xsl:choose>
              <xsl:when test="position() = 1">
                <ixsl:choose>
                  <ixsl:when test="'false' = $__acceptsCookies and 'false' = $__isUserAgentBot">
                    <xsl:text>&amp;</xsl:text>
                  </ixsl:when>
                  <ixsl:otherwise>
                    <xsl:text>?</xsl:text>
                  </ixsl:otherwise>
                </ixsl:choose>
              </xsl:when>
              <xsl:otherwise>
                <xsl:text>&amp;</xsl:text>
              </xsl:otherwise>
            </xsl:choose>
            <xsl:value-of select="@name"/>
            <xsl:text>=</xsl:text>
            <xsl:apply-templates/>
          </xsl:for-each>
          <xsl:if test="@querystring">
            <xsl:variable name="requestParams" select="php:function('stubXSLProcessor::invokeCallback', 'request', 'getQueryString')"/>
            <xsl:value-of select="$requestParams"/>
          </xsl:if>
        </ixsl:otherwise>
      </ixsl:choose>
    </ixsl:attribute>
    <xsl:apply-templates/>
    </a>
  </xsl:template>

  <xsl:template match="stub:maincontent">
    <xsl:variable name="path">
      <xsl:choose>
        <xsl:when test="@path">
          <xsl:value-of select="@path"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text />
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="prefix">
      <xsl:choose>
        <xsl:when test="@prefix">
          <xsl:value-of select="@prefix"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>main_</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="suffix">
      <xsl:choose>
        <xsl:when test="@suffix">
          <xsl:value-of select="@suffix"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>.xml</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="part">
      <xsl:choose>
        <xsl:when test="@part">
          <xsl:value-of select="@part"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>content</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:call-template name="stub:include">
      <xsl:with-param name="href">
        <xsl:value-of select="$path"/>
        <xsl:value-of select="$prefix"/>
        <xsl:value-of select="$page"/>
        <xsl:value-of select="$suffix"/>
      </xsl:with-param>
      <xsl:with-param name="part" select="$part"/>
    </xsl:call-template>
  </xsl:template>

  <xsl:template match="stub:include" name="stub:include">
    <xsl:param name="project" select="@project"/>
    <xsl:param name="href" select="@href"/>
    <xsl:param name="part" select="@part"/>
    <xsl:variable name="xihref">
      <xsl:choose>
        <xsl:when test="$href">
          <xsl:text>xinc://</xsl:text>
          <xsl:choose>
            <xsl:when test="$project">
              <xsl:value-of select="$project"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:text>default</xsl:text>
            </xsl:otherwise>
          </xsl:choose>
          <xsl:text>/</xsl:text>
          <xsl:value-of select="$href"/>
          <xsl:text>?part=</xsl:text>
          <xsl:value-of select="$part"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text></xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xi:include href="{$xihref}">
      <xsl:attribute name="xpointer">
        <xsl:text>xpointer(/parts/part[@name='</xsl:text>
        <xsl:value-of select="$part"/>
        <xsl:text>']/node())</xsl:text>
      </xsl:attribute>
      <xi:fallback>
        <ixsl:value-of>
          <xsl:attribute name="select">
            <xsl:text>php:function('stubXSLProcessor::invokeCallback', 'missingInclude', 'recordMissingInclude', "</xsl:text>
            <xsl:value-of select="$__file"/>
            <xsl:text>", "</xsl:text>
            <xsl:value-of select="$__part"/>
            <xsl:text>", "</xsl:text>
            <xsl:value-of select="$part"/>
            <xsl:text>", "</xsl:text>
            <xsl:value-of select="$href"/>
            <xsl:text>", "</xsl:text>
            <xsl:value-of select="$project"/>
            <xsl:text>")</xsl:text>
          </xsl:attribute>
        </ixsl:value-of>
      </xi:fallback>
    </xi:include>
  </xsl:template>

  <xsl:template match="stub:image">
    <xsl:variable name="dimensions" select="php:function('stubXSLProcessor::invokeCallback', 'image', 'getImageDimensions', @src)/child::*"/>
    <img>
      <xsl:copy-of select="@*[local-name() != 'width' and local-name() != 'height']"/>
      <xsl:attribute name="width"><xsl:value-of select="$dimensions/width"/></xsl:attribute>
      <xsl:attribute name="height"><xsl:value-of select="$dimensions/height"/></xsl:attribute>
    </img>
  </xsl:template>

  <xsl:template match="stub:form">
    <form>
      <xsl:attribute name="action">
        <xsl:text>/xml/</xsl:text>
        <xsl:choose>
          <xsl:when test="@send-to-page and not(@send-to-page = '')">
            <xsl:value-of select="@send-to-page"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$page"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:attribute>
      <xsl:attribute name="method">
        <xsl:choose>
          <xsl:when test="@method and not(@method = '')">
            <xsl:value-of select="@method"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>post</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:attribute>
      <xsl:copy-of select="@*[local-name() != 'send-to-page' and local-name() != 'method']"/>
      <ixsl:if test="'false' = $__acceptsCookies">
        <input type="hidden">
          <ixsl:attribute name="name">
            <ixsl:value-of select="$__sessname"/>
          </ixsl:attribute>
          <ixsl:attribute name="value">
            <ixsl:value-of select="$__sessid"/>
          </ixsl:attribute>
        </input>
      </ixsl:if>
      <xsl:apply-templates select="node()"/>
    </form>
  </xsl:template>

  <xsl:template match="stub:langselect" name="stub:langselect">
    <xsl:variable name="langnodes" select="./stub:lang[@name = $lang]"/>
    <xsl:variable name="langbasenodes" select="./stub:lang[@name = $lang_base]"/>
    <xsl:variable name="defaultnodes" select="./stub:lang[@name = 'default']"/>
    <xsl:choose>
      <xsl:when test="$langnodes">
        <xsl:apply-templates select="$langnodes/node()"/>
      </xsl:when>
      <xsl:when test="$langbasenodes">
        <xsl:apply-templates select="$langbasenodes/node()"/>
      </xsl:when>
      <xsl:when test="$defaultnodes">
        <xsl:apply-templates select="$defaultnodes/node()"/>
      </xsl:when>
      <xsl:otherwise>
        <small>
          <xsl:text>[ No content for </xsl:text>
          <xsl:value-of select="$lang"/>
          <xsl:text> or </xsl:text>
          <xsl:value-of select="$lang_base"/>
          <xsl:text> - specify at least language default ]</xsl:text>
        </small>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="stub:itemframe" name="stub:itemframe">
    <div>
      <xsl:attribute name="class">
        <xsl:choose>
          <xsl:when test="@class and not(@class = '')">
            <xsl:text>itemframe </xsl:text>
            <xsl:value-of select="@class"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>itemframe</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:attribute>
      <xsl:copy-of select="@*[local-name() != 'class']"/>
      <xsl:call-template name="stub:formerrors">
        <xsl:with-param name="itemid">
          <xsl:value-of select="@id"/>
          <xsl:text>_</xsl:text>
          <xsl:value-of select="@id"/>
        </xsl:with-param>
      </xsl:call-template>
      <ul>
      <xsl:apply-templates/>
      </ul>
    </div>
  </xsl:template>

  <xsl:template match="stub:formerrors" name="stub:formerrors">
    <xsl:param name="itemid" select="@itemid"/>
    <ixsl:if>
      <xsl:attribute name="test">
        <xsl:text>/document/request/value[@name = '</xsl:text>
        <xsl:value-of select="$itemid"/>
        <xsl:text>']/errors</xsl:text>
      </xsl:attribute>
      <ixsl:for-each>
        <xsl:attribute name="select">
          <xsl:text>/document/request/value[@name = '</xsl:text>
          <xsl:value-of select="$itemid"/>
          <xsl:text>']/errors/error</xsl:text>
        </xsl:attribute>
        <span class="form_error">
          <ixsl:choose>
            <ixsl:when>
              <xsl:attribute name="test">
                <xsl:text>messages/string[@locale = '</xsl:text>
                <xsl:value-of select="$lang"/>
                <xsl:text>']</xsl:text>
              </xsl:attribute>
              <ixsl:value-of>
                <xsl:attribute name="select">
                  <xsl:text>messages/string[@locale = '</xsl:text>
                  <xsl:value-of select="$lang"/>
                  <xsl:text>']/content</xsl:text>
                </xsl:attribute>
              </ixsl:value-of>
            </ixsl:when>
            <ixsl:when>
              <xsl:attribute name="test">
                <xsl:text>messages/string[@locale = '</xsl:text>
                <xsl:value-of select="$lang_base"/>
                <xsl:text>']</xsl:text>
              </xsl:attribute>
              <ixsl:value-of>
                <xsl:attribute name="select">
                  <xsl:text>messages/string[@locale = '</xsl:text>
                  <xsl:value-of select="$lang_base"/>
                  <xsl:text>']/content</xsl:text>
                </xsl:attribute>
              </ixsl:value-of>
            </ixsl:when>
            <ixsl:otherwise>
              <ixsl:value-of select="messages/string[@locale = 'default']/content"/>
            </ixsl:otherwise>
          </ixsl:choose>
        </span>
      </ixsl:for-each>
    </ixsl:if>
  </xsl:template>

  <xsl:template match="stub:item" name="stub:item">
    <xsl:param name="id" select="ancestor::stub:itemframe/@id"/>
    <li>
      <xsl:attribute name="id">
        <xsl:text>input_</xsl:text>
        <xsl:value-of select="$id"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="@name"/>
      </xsl:attribute>
      <xsl:if test="not(@type = 'submit')">
        <label>
          <xsl:attribute name="for">
            <xsl:value-of select="$id"/>
            <xsl:text>_</xsl:text>
            <xsl:value-of select="@name"/>
          </xsl:attribute>
          <xsl:call-template name="stub:include">
            <xsl:with-param name="part">
              <xsl:value-of select="$id"/>
              <xsl:text>.</xsl:text>
              <xsl:value-of select="@name"/>
            </xsl:with-param>
          </xsl:call-template>
          <xsl:if test="@mandatory = 'true'"><xsl:text>*</xsl:text></xsl:if>
        </label>
      </xsl:if>
      <xsl:choose>
        <xsl:when test="@type = 'text' or @type = 'password'">
          <input>
            <xsl:attribute name="id">
              <xsl:value-of select="$id"/>
              <xsl:text>_</xsl:text>
              <xsl:value-of select="@name"/>
            </xsl:attribute>
            <xsl:attribute name="name">
              <xsl:value-of select="$id"/>
              <xsl:text>_</xsl:text>
              <xsl:value-of select="@name"/>
            </xsl:attribute>
            <xsl:copy-of select="@*[local-name() != 'id' and local-name() != 'name' and local-name() != 'path' and local-name() != 'mandatory']"/>
            <ixsl:choose>
              <ixsl:when>
                <xsl:attribute name="test">
                  <xsl:text>/document/forms/</xsl:text>
                  <xsl:value-of select="$id"/>
                  <xsl:text>/</xsl:text>
                  <xsl:value-of select="@name"/>
                </xsl:attribute>
                <ixsl:attribute name="value">
                  <ixsl:value-of>
                    <xsl:attribute name="select">
                      <xsl:text>/document/forms/</xsl:text>
                      <xsl:value-of select="$id"/>
                      <xsl:text>/</xsl:text>
                      <xsl:value-of select="@name"/>
                    </xsl:attribute>
                  </ixsl:value-of>
                </ixsl:attribute>
              </ixsl:when>
              <ixsl:otherwise>
                <xsl:if test="@path and @path != ''">
                  <ixsl:attribute name="value">
                    <ixsl:value-of>
                      <xsl:attribute name="select">
                        <xsl:value-of select="@path"/>
                      </xsl:attribute>
                    </ixsl:value-of>
                  </ixsl:attribute>
                </xsl:if>
              </ixsl:otherwise>
            </ixsl:choose>
          </input>
        </xsl:when>
        <xsl:when test="@type = 'dynamic'">
          <ixsl:if>
            <xsl:attribute name="test">
              <xsl:value-of select="@path"/>
            </xsl:attribute>
            <input type="text">
              <xsl:attribute name="id">
                <xsl:value-of select="$id"/>
                <xsl:text>_</xsl:text>
                <xsl:value-of select="@name"/>
              </xsl:attribute>
              <xsl:attribute name="name">
                <xsl:value-of select="$id"/>
                <xsl:text>_</xsl:text>
                <xsl:value-of select="@name"/>
              </xsl:attribute>
              <xsl:copy-of select="@*[local-name() != 'id' and local-name() != 'name' and local-name() != 'type' and local-name() != 'path' and local-name() != 'mandatory']"/>
              <ixsl:attribute name="value">
                <ixsl:value-of>
                  <xsl:attribute name="select">
                    <xsl:value-of select="@path"/>
                  </xsl:attribute>
                </ixsl:value-of>
              </ixsl:attribute>
            </input>
          </ixsl:if>
        </xsl:when>
        <xsl:when test="@type = 'select'">
          <select>
            <xsl:attribute name="id">
              <xsl:value-of select="$id"/>
              <xsl:text>_</xsl:text>
              <xsl:value-of select="@name"/>
            </xsl:attribute>
            <xsl:attribute name="name">
              <xsl:value-of select="$id"/>
              <xsl:text>_</xsl:text>
              <xsl:value-of select="@name"/>
            </xsl:attribute>
            <xsl:copy-of select="@*[local-name() != 'id' and local-name() != 'name' and local-name() != 'mandatory' and local-name() != 'type']"/>
            <xsl:apply-templates select="node()">
              <xsl:with-param name="id" select="@id"/>
              <xsl:with-param name="name" select="@name"/>
            </xsl:apply-templates>
          </select>
        </xsl:when>
        <xsl:when test="@type = 'textarea'">
          <textarea>
            <xsl:attribute name="id">
              <xsl:value-of select="$id"/>
              <xsl:text>_</xsl:text>
              <xsl:value-of select="@name"/>
            </xsl:attribute>
            <xsl:attribute name="name">
              <xsl:value-of select="$id"/>
              <xsl:text>_</xsl:text>
              <xsl:value-of select="@name"/>
            </xsl:attribute>
            <xsl:copy-of select="@*[local-name() != 'id' and local-name() != 'name' and local-name() != 'mandatory' and local-name() != 'type']"/>
            <xsl:apply-templates select="text()"/>
            <ixsl:if>
              <xsl:attribute name="test">
                <xsl:text>/document/forms/</xsl:text>
                <xsl:value-of select="$id"/>
                <xsl:text>/</xsl:text>
                <xsl:value-of select="@name"/>
              </xsl:attribute>
              <ixsl:value-of>
                <xsl:attribute name="select">
                  <xsl:text>/document/forms/</xsl:text>
                  <xsl:value-of select="$id"/>
                  <xsl:text>/</xsl:text>
                  <xsl:value-of select="@name"/>
                </xsl:attribute>
              </ixsl:value-of>
            </ixsl:if>
          </textarea>
        </xsl:when>
        <xsl:when test="@type = 'submit'">
          <input>
            <xsl:attribute name="name">
              <xsl:value-of select="$id"/>
              <xsl:text>_</xsl:text>
              <xsl:value-of select="@name"/>
            </xsl:attribute>
            <xsl:copy-of select="@*[local-name() != 'name']"/>
          </input>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>[ Unknown Item-Type! ]</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:call-template name="stub:formerrors">
        <xsl:with-param name="itemid">
          <xsl:value-of select="$id"/>
          <xsl:text>_</xsl:text>
          <xsl:value-of select="@name"/>
        </xsl:with-param>
      </xsl:call-template>
    </li>
  </xsl:template>

  <xsl:template match="stub:option" name="stub:option">
    <xsl:param name="name" select="@name"/>
    <option>
      <xsl:copy-of select="@*"/>
      <ixsl:if>
        <xsl:attribute name="test">
          <xsl:text>/document/forms/</xsl:text>
          <xsl:value-of select="ancestor::stub:itemframe/@id"/>
          <xsl:text>/</xsl:text>
          <xsl:value-of select="$name"/>
          <xsl:text> = '</xsl:text>
          <xsl:value-of select="@value"/>
          <xsl:text>'</xsl:text>
        </xsl:attribute>
        <ixsl:attribute name="selected">
           <xsl:text>selected</xsl:text>
        </ixsl:attribute>
      </ixsl:if>
      <xsl:apply-templates select="text()"/>
    </option>
  </xsl:template>

  <xsl:template match="stub:date">
    <xsl:value-of select="php:function('stubXSLProcessor::invokeCallback', 'date', 'formatDate', @format, @timestamp)"/>
  </xsl:template>

  <xsl:template match="stub:localeDate">
    <xsl:value-of select="php:function('stubXSLProcessor::invokeCallback', 'date', 'formatLocaleDate', @format, @timestamp)"/>
  </xsl:template>

  <xsl:template match="stub:assistant" name="stub:assistant">
    <ixsl:if test="/document/mode">
      <ixsl:if test="/document/mode/name = 'DEV' or /document/mode/name = 'STAGE'">
        <div id="stageassistant">
          <a href="#" id="sa_close" onclick="stageAssistant.close(); return false;"><img src="/common/stageassistant/img/close.gif" width="15" height="15" alt="Close"/></a>
          <a href="#" id="sa_minimize" onclick="stageAssistant.minimize(); return false;"><img src="/common/stageassistant/img/minimize.gif" width="15" height="15" alt="Minimize"/></a>
          <div class="content">
            <div class="sa_variant_chooser">
              <ixsl:choose>
                <ixsl:when test="/document/variants/variantList//variant/variant">
                  <form action="?">
                    <div class="dropdown">
                      <select size="1" name="__variant">
                        <ixsl:for-each select="/document/variants/variantList">
                          <ixsl:call-template name="generateVariantMenu"/>
                        </ixsl:for-each>
                      </select>
                      <input type="submit" value="Go!" />
                    </div>
                  </form>
                </ixsl:when>
                <ixsl:otherwise>
                  <strong>No variants available</strong>
                </ixsl:otherwise>
              </ixsl:choose>
            </div>
            <div id="sa_ec">
              <div class="buttons">
                <a href="?showLastRequestXML=1" target="xmlSource"><img src="/common/stageassistant/img/b_domtree.gif" width="52" height="44" alt="View DOM tree"/></a>
              </div>
            </div>
            <div class="info">
              Page: <ixsl:value-of select="/document/@page"/><br/>
              Variant: <ixsl:value-of select="/document/session/variant/name/text()"/><br/>
              Variant-Alias: <ixsl:value-of select="/document/session/variant/alias/text()"/><br/>
            </div>
         </div>
        </div>
        <div id="stageassistant_min">
          <a href="#" id="sa_close_min" onclick="stageAssistant.close(); return false;"><img src="/common/stageassistant/img/close.gif" width="15" height="15" alt="Close"/></a>
          <a href="#" id="sa_open" onclick="stageAssistant.open(); return false;"><img src="/common/stageassistant/img/open.gif" width="15" height="15" alt="Open"/></a>
        </div>
        <script type="text/javascript">
            var stageAssistant;
            function onStageAssistantLoad()
            {
                stageAssistant = new stubbles.StageAssistant();
            }
        </script>
      </ixsl:if>
    </ixsl:if>
  </xsl:template>

</xsl:stylesheet>
<xsl:stylesheet version="1.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:variant="http://stubbles.net/variant"
    xmlns:ixsl="http://www.w3.org/1999/XSL/TransformOutputAlias"
    exclude-result-prefixes="variant">

  <!--
  Get the variant
  -->
  <xsl:template match="variant:get-current">
    <ixsl:value-of select="/document/session/variant/name/text()"/>
  </xsl:template>
  <xsl:template match="variant:get-current-base">
    <ixsl:value-of select="substring-before(/document/session/variant/name/text(), ':')"/>
  </xsl:template>

  <!--
  Restrict a block to a variant
  -->
  <xsl:template match="variant:restrict-to">
    <ixsl:if>
      <xsl:attribute name="test">
        <xsl:choose>
          <xsl:when test="@variant">
            /document/session/variant/name/text() = '<xsl:value-of select="@variant"/>'
          </xsl:when>
          <xsl:when test="@base">
            substring-before(/document/session/variant/name/text(), ':') = '<xsl:value-of select="@base"/>'
          </xsl:when>
          <xsl:when test="@end">
            contains(/document/session/variant/name/text(), '<xsl:value-of select="@end"/>')
          </xsl:when>
          <xsl:when test="@start">
            starts-with(/document/session/variant/name/text(), '<xsl:value-of select="@start"/>')
          </xsl:when>
          <xsl:when test="@alias">
            /document/session/variant/alias/text() = '<xsl:value-of select="@alias"/>'
          </xsl:when>
        </xsl:choose>
      </xsl:attribute>
      <xsl:apply-templates/>
    </ixsl:if>
  </xsl:template>

  <!--
  Display a block in all variants, except one
  -->
  <xsl:template match="variant:except">
    <ixsl:if>
      <xsl:attribute name="test">
        <xsl:choose>
          <xsl:when test="@variant">
            not(/document/session/variant/name/text() = '<xsl:value-of select="@variant"/>')
          </xsl:when>
          <xsl:when test="@base">
            not(substring-before(/document/session/variant/name/text(), ':') = '<xsl:value-of select="@base"/>')
          </xsl:when>
          <xsl:when test="@end">
            not(contains(/document/session/variant/name/text(), '<xsl:value-of select="@end"/>'))
          </xsl:when>
          <xsl:when test="@start">
            not(starts-with(/document/session/variant/name/text(), '<xsl:value-of select="@start"/>'))
          </xsl:when>
          <xsl:when test="@alias">
            not(/document/session/variant/alias/text() = '<xsl:value-of select="@alias"/>')
          </xsl:when>
        </xsl:choose>
      </xsl:attribute>
      <xsl:apply-templates/>
    </ixsl:if>
  </xsl:template>
  
  <!--
  Choose one item of a block, depending on a variant or the base variant
  -->
  <xsl:template match="variant:choose">
    <ixsl:choose>
      <xsl:for-each select="variant:when">
        <ixsl:when>
          <xsl:attribute name="test">
            <xsl:choose>
              <xsl:when test="@variant">
                /document/session/variant/name/text() = '<xsl:value-of select="@variant"/>'
              </xsl:when>
              <xsl:when test="@base">
                substring-before(/document/session/variant/name/text(), ':') = '<xsl:value-of select="@base"/>'
              </xsl:when>
              <xsl:when test="@end">
                contains(/document/session/variant/name/text(), '<xsl:value-of select="@end"/>')
              </xsl:when>
              <xsl:when test="@start">
                starts-with(/document/session/variant/name/text(), '<xsl:value-of select="@start"/>')
              </xsl:when>
              <xsl:when test="@alias">
                /document/session/variant/alias/text() = '<xsl:value-of select="@alias"/>'
              </xsl:when>
            </xsl:choose>
          </xsl:attribute>
          <xsl:apply-templates/>
        </ixsl:when>
      </xsl:for-each>
      <xsl:for-each select="variant:otherwise">
        <ixsl:otherwise>
          <xsl:apply-templates/>
        </ixsl:otherwise>
      </xsl:for-each>
    </ixsl:choose>
  </xsl:template>
  
</xsl:stylesheet>

title => Stubbles
package => net::stubbles
version => 1.5.0RC1
author => Stubbles Development Team <http://stubbles.net>
copyright => (c) 2007-2011 Stubbles Development Team
